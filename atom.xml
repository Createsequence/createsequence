<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Createsequence&#39;s Blog</title>
  
  <subtitle>一个努力前进的程序猿</subtitle>
  <link href="http://blog.xiajibagao.top/atom.xml" rel="self"/>
  
  <link href="http://blog.xiajibagao.top/"/>
  <updated>2020-12-22T08:50:10.381Z</updated>
  <id>http://blog.xiajibagao.top/</id>
  
  <author>
    <name>Createsequence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java集合源码分析（八）：Set与AbstractSet</title>
    <link href="http://blog.xiajibagao.top/2020/12/22/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9ASet%E4%B8%8EAbstracSet/"/>
    <id>http://blog.xiajibagao.top/2020/12/22/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9ASet%E4%B8%8EAbstracSet/</id>
    <published>2020-12-21T16:00:00.000Z</published>
    <updated>2020-12-22T08:50:10.381Z</updated>
    
    
    <summary type="html">概述
Set 接口是 Collection 接口下三大子接口之一。其下实现类都为元素不可重复的，不保证线程安全的集合。他有两个主要实现，即无序的 HashSet 与有序的 TreeSet。

Set 相对 List 集合与 Queue 集合不同之处在于，他的实现类需要依赖与 Map 集合的实现类密切相关。这体现在以下两点：

 * HashSet 实际依赖于 HashMap，他使用 HashMap 的 key 作为存储容器。TreeSet 同理，依赖于 TreeMap实现。
 * Map 集合中的 keySet 与 EntrySet 视图集合往往以实现了 Set 接口的内部类出现在 Map 的</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>next5主题自定义摘要</title>
    <link href="http://blog.xiajibagao.top/2020/12/21/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/next5%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%98%E8%A6%81/"/>
    <id>http://blog.xiajibagao.top/2020/12/21/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/next5%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%98%E8%A6%81/</id>
    <published>2020-12-20T16:00:00.000Z</published>
    <updated>2020-12-21T12:09:15.832Z</updated>
    
    
    <summary type="html">概述
最近 next6 折腾了一段时间，最后还是回到了 next5，但是添加阅读全文按钮以后，默认的摘要生成不太方便，于是就把注意打到了 js 上。

这里整理一下 next5 生成摘要的方法。

一、yaml
这个是 hexo 自带的，通过直接在 yaml 里面配置

1
2
3
4
5
6
7


---
title: next5主题自定义摘要
date: 2020-12-21
tags: [杂七乱八]
categories: [杂七乱八]
description: 这里是一段摘要
---


不过加完以后， next 会默认在文章详情页面的发布信息下也生成摘要，个人觉得不是很美观。

二</summary>
    
    
    
    <category term="杂七乱八" scheme="http://blog.xiajibagao.top/categories/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/"/>
    
    
    <category term="杂七乱八" scheme="http://blog.xiajibagao.top/tags/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>java集合源码分析（七）：LinkedHashMap</title>
    <link href="http://blog.xiajibagao.top/2020/12/21/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9ALinkedHashMap/"/>
    <id>http://blog.xiajibagao.top/2020/12/21/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9ALinkedHashMap/</id>
    <published>2020-12-20T16:00:00.000Z</published>
    <updated>2020-12-21T09:22:09.233Z</updated>
    
    
    <summary type="html">概述
LinkedHashMap 是 Map 接口下一个线程不安全的，允许 null 的，基于哈希表的实现。它是 HashMap 的子类， 由于引入了双向链表的数据结构，除了拥有 HashMap 的所有特征外，他还可以以双向链表的方式操作和访问，并且提供按插入顺序或访问顺序两种顺序访问方式。

由于结构的特殊性，通过 LinkedHashMap，我们可以非常便捷的实现一个基于 LRU 算法的缓存容器。

这是关于 java 集合类源码的第七篇文章。往期文章：

 1. java集合源码分析（一）：Collection 与 AbstractCollection
    
 2. java集合源码</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何解决next5主题目录无法跳转的问题</title>
    <link href="http://blog.xiajibagao.top/2020/12/17/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3next5%E4%B8%BB%E9%A2%98%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.xiajibagao.top/2020/12/17/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3next5%E4%B8%BB%E9%A2%98%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-16T16:00:00.000Z</published>
    <updated>2020-12-17T09:18:53.930Z</updated>
    
    
    <summary type="html">概述
目前使用的 next 版本是 5.1.4 ，文章左侧的目录一直不能跳转也不能展开，按网上的办法一直没法解决，今天自己琢磨了一阵总算搞定了。

由于发现遇到这个问题的人不少，特此总结一下。

一般分为两种情况：渲染错误和超链接乱码。

一、渲染错误
1.问题描述
最典型的特征就是目录上的超链接为 undefined，或者点击的时候报错： Cannot read property &#39;replace&#39; of null。

前一情况 GitHub 中已有相应的 Issues：根据 markdown 生成的 TOC 锚点的内容是 undefined

这个情况一般是 markdown-it 渲染出</summary>
    
    
    
    <category term="杂七乱八" scheme="http://blog.xiajibagao.top/categories/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/"/>
    
    
    <category term="杂七乱八" scheme="http://blog.xiajibagao.top/tags/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/"/>
    
    <category term="hexo" scheme="http://blog.xiajibagao.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>java集合源码分析（六）：HashMap</title>
    <link href="http://blog.xiajibagao.top/2020/12/16/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AHashMap/"/>
    <id>http://blog.xiajibagao.top/2020/12/16/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AHashMap/</id>
    <published>2020-12-15T16:00:00.000Z</published>
    <updated>2020-12-22T08:23:15.267Z</updated>
    
    
    <summary type="html">概述
HashMap 是 Map 接口下一个线程不安全的，基于哈希表的实现类。由于他解决哈希冲突的方式是分离链表法，也就是拉链法，因此他的数据结构是数组+链表，在 JDK8 以后，当哈希冲突严重时，HashMap 的链表会在一定条件下转为红黑树以优化查询性能，因此在 JDK8 以后，他的数据结构是数组+链表+红黑树。

对于 HashMap ，作为集合容器，我们需要关注其数据的存储结构，迭代方式，能否存放空值；作为使用了数组作为底层结构的集合，我们还需要关注其扩容的实现；同时，针对哈希表的特性，我们还需要关注它如何通过哈希算法取模快速定位下标。

这是关于 java 集合类源码的第六篇文章。往</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java集合源码分析（五）：Map与AbstractMap</title>
    <link href="http://blog.xiajibagao.top/2020/12/07/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AMap%E4%B8%8EAbstractMap/"/>
    <id>http://blog.xiajibagao.top/2020/12/07/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AMap%E4%B8%8EAbstractMap/</id>
    <published>2020-12-06T16:00:00.000Z</published>
    <updated>2020-12-17T06:37:59.244Z</updated>
    
    
    <summary type="html">概述
Map 接口是 java 中两大集合接口之一，相对于 Collection，Map 接口结构规定了所有键值对形式的集合容器。同时，它与 Collection 的子接口 Set 又密切相关，Map 一部分实现依赖于 Set 集合，而 Set 集合的一些实现也依赖于 Map。

Map 接口下有四个主要实现类 TreeMap，HashMap，LinkedMap，Hashtable。基于以上四大实现类，这是他们的类关系图：

Map 接口的类关系图与其相关的还有 Dictionary 类，这是一个已过时的早期键值对集合接口，后期的新集合都基于 Map 接口实现，唯一依赖与他的 Hashtabl</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList与LinkedList遍历操作问题</title>
    <link href="http://blog.xiajibagao.top/2020/12/04/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ArrayList%E4%B8%8ELinkedList%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.xiajibagao.top/2020/12/04/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ArrayList%E4%B8%8ELinkedList%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-03T16:00:00.000Z</published>
    <updated>2020-12-17T06:37:48.075Z</updated>
    
    
    <summary type="html">概述
一个 java 程序猿比较广为人知的小知识 ，是 ArrayList 和 LinkedList 最好使用迭代器删除，而不是遍历删除。

当我们尝试使用 for 循环或者 forEach 进行删除的时候，往往会出现一些意外的情况，导致集合全部删除失败。关于这点，我一直保持知其然不知其所以然的状态，刚好最近刚看完 ArrayList 和 LinkedList 的源码，今天这篇文章，就结合源码，总结一下 ArrayList 和 LinkedList 的几种错误删除。

一、List 集合的 fast-fail 机制
在开始前，我们需要了解一下集合的 fast-fail 机制。

List 接口</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="杂七乱八" scheme="http://blog.xiajibagao.top/tags/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java集合源码分析（四）：LinkedList</title>
    <link href="http://blog.xiajibagao.top/2020/12/03/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ALinkedList/"/>
    <id>http://blog.xiajibagao.top/2020/12/03/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ALinkedList/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2020-12-22T08:14:47.451Z</updated>
    
    
    <summary type="html">概述
LinkedList 是一个不保证线程安全的、基于双向的双端链表的实现的 List 集合。LinkedList 继承了 AbstractSequentialList 抽象类，在实现 List 接口的同时还实现了 Deque 接口，也正因如此，它也具有队列的特性与方法。

这是关于 java 集合类源码的第四篇文章。往期文章：

 1. java集合源码分析（一）：Collection 与 AbstractCollection
 2. java集合源码分析（二）：List与AbstractList
 3. java集合源码分析（三）：ArrayList

一、LinkedList 的类关系</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java集合源码分析（三）：ArrayList</title>
    <link href="http://blog.xiajibagao.top/2020/12/02/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AArrayList/"/>
    <id>http://blog.xiajibagao.top/2020/12/02/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AArrayList/</id>
    <published>2020-12-01T16:00:00.000Z</published>
    <updated>2020-12-22T08:13:58.344Z</updated>
    
    
    <summary type="html">概述
ArrayList 是 List 接口下一个基于可扩展数组的实现类，它和它的兄弟类 Vector 有着一样的继承关系，也都能随机访问，但是不同的是不能保证线程安全。

这是关于 java 集合类源码的第三篇文章。往期文章：

 1. java集合源码分析（一）：Collection 与 AbstractCollection
 2. java集合源码分析（二）：List与AbstractList

一、ArrayList 的类关系


ArrayList 实现了三个接口，继承了一个抽象类，其中 Serializable ，Cloneable 与 RandomAccess 接口都是用于标记的</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java集合源码分析（二）：List与AbstractList</title>
    <link href="http://blog.xiajibagao.top/2020/11/27/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AList%E4%B8%8EAbstractList/"/>
    <id>http://blog.xiajibagao.top/2020/11/27/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AList%E4%B8%8EAbstractList/</id>
    <published>2020-11-26T16:00:00.000Z</published>
    <updated>2020-12-22T08:12:09.108Z</updated>
    
    
    <summary type="html">概述
List 应该接口是 Collection 最常被使用的接口了。其下的实现类皆为有序列表，其中主要分为 Vector，ArrayList，LinkedList 三个实现类，其中 Vecotr 又拥有子类 Stack。

从线程安全来说，List 下拥有线程安全的集合类 Vector；从数据结构来说，List 下拥有基于数组实现的 Vector 与 ArrayList，和基于链表实现的 LinkedList。

本篇文章暂不讨论具体的实现类，而将基于 List 接口与其抽象类 AbstractList，了解 List 接口是如何承上启下，进一步从 Collection 抽象到具体的。

这</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java集合源码分析（一）：Collection 与 AbstractCollection</title>
    <link href="http://blog.xiajibagao.top/2020/11/25/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACollection%E4%B8%8EAbstractCollection/"/>
    <id>http://blog.xiajibagao.top/2020/11/25/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACollection%E4%B8%8EAbstractCollection/</id>
    <published>2020-11-24T16:00:00.000Z</published>
    <updated>2020-12-22T08:13:24.174Z</updated>
    
    
    <summary type="html">概述
我们知道，java 中容器分为 Map 集合和 Collection 集合，其中 Collection 中的又分为 Queue，List，Set 三大子接口。

其下实现类与相关的实现类子类数量繁多。我们仅以最常使用的 List 接口的关系为例，简单的画图了解一下 Collection 接口 List 部分的关系图。



根据上图的类关系图，我们研究一下源码中，类与类之间的关系，方法是如何从抽象到具体的。

一、Iterable 接口
Iterable 是最顶层的接口，继承这个接口的类可以被迭代。



 * iterator()：用于获取一个迭代器。
   
   
 * forEa</summary>
    
    
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/categories/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="java" scheme="http://blog.xiajibagao.top/tags/java/"/>
    
    <category term="java集合容器" scheme="http://blog.xiajibagao.top/tags/java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis在SpringBoot的基本使用</title>
    <link href="http://blog.xiajibagao.top/2020/11/24/spring/Redis%E5%9C%A8SpringBoot%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.xiajibagao.top/2020/11/24/spring/Redis%E5%9C%A8SpringBoot%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-11-23T16:00:00.000Z</published>
    <updated>2020-11-25T11:46:57.191Z</updated>
    
    
    <summary type="html">一、配置
1.添加依赖
在 springboot 启动器中直接添加依赖，或者创建后添加 Maven 依赖：

1
2
3
4
5
6
7
8
9
10
11
12


&lt;!--spring-boot-starter-data-redis--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!--jedis--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;red</summary>
    
    
    
    <category term="Redis" scheme="http://blog.xiajibagao.top/categories/Redis/"/>
    
    
    <category term="SpringBoot" scheme="http://blog.xiajibagao.top/tags/SpringBoot/"/>
    
    <category term="Redis" scheme="http://blog.xiajibagao.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>记一次使用策略模式优化代码的经历</title>
    <link href="http://blog.xiajibagao.top/2020/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://blog.xiajibagao.top/2020/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%8F%E5%8E%86/</id>
    <published>2020-11-20T16:00:00.000Z</published>
    <updated>2020-11-24T12:23:29.246Z</updated>
    
    
    <summary type="html">一、背景
之前接手了一个 springboot 项目。在我负责的模块中，有一块用户注册的功能，但是比较特别的是这个注册并不是重新注册，而是从以前的旧系统的数据库中同步旧数据到新系统的数据库中。由于这些用户角色来自于不同的系统，所以我需要在注册的时候先判断类型（这个类型由一个专门的枚举类提供），再去调用已经写好的同步方法同步数据。

伪代码大概是这样的：

1
2
3
4
5
6
7
8
9
10
11


public void register(String type, String userId, String projectId, String declareId){
    // 判断</summary>
    
    
    
    <category term="设计模式" scheme="http://blog.xiajibagao.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://blog.xiajibagao.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="工作见闻" scheme="http://blog.xiajibagao.top/tags/%E5%B7%A5%E4%BD%9C%E8%A7%81%E9%97%BB/"/>
    
    <category term="代码优化" scheme="http://blog.xiajibagao.top/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>设计模式（四）：模板方法模式</title>
    <link href="http://blog.xiajibagao.top/2020/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.xiajibagao.top/2020/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-20T16:00:00.000Z</published>
    <updated>2020-11-25T12:20:19.552Z</updated>
    
    
    <summary type="html">概述
在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。

模板方法模式旨在为一些方法的主体部分提供骨架，将具体细节上的一些实现延迟到他的实现类。

JDBC 运用了模板模式。JDK 在实现 List 接口的过程中， AbstractCollection 和 AbstractList 也使用了模板模式。

一、简单实现
举个我在做项目的时候遇到的例子：

假设我们有一个简单的针对 Demo 类的文件导出类，他提供了 Excel 文档的基本导出功能：
</summary>
    
    
    
    <category term="设计模式" scheme="http://blog.xiajibagao.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://blog.xiajibagao.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式（三）：代理模式</title>
    <link href="http://blog.xiajibagao.top/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.xiajibagao.top/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2020-11-20T07:47:28.585Z</updated>
    
    
    <summary type="html">概述
在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

策略模式旨在不改变被代理对象的基础上进行方法增强。

当我们一个原有的类不能满足功能，又处于职责或其他原因不便修改的时候，我们可以使用代理模式。通过代理类去调用被代理类的方法，在原方法的基础上进行各种加强，又不会改变原代码。

spring 中的 AOP 就运用了代理模式。

一、静态代理
为了简单的说明代理模式，我们举个例子：

首先有一个接口，叫做购房者，然后这个类地下有一个实现类，叫做小明:

1
2
3
</summary>
    
    
    
    <category term="设计模式" scheme="http://blog.xiajibagao.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://blog.xiajibagao.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式（二）：策略模式</title>
    <link href="http://blog.xiajibagao.top/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.xiajibagao.top/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2020-11-20T06:49:31.763Z</updated>
    
    
    <summary type="html">概述
在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

策略模式旨在解决不同逻辑下相同的对象执行不同策略的问题。

当我们遇到同一个方法，里面会根据需要多个逻辑的分支，分支里的行为都不同，但是都服务于同一个功能，这个时候就可以使用策略模式，将行为抽象为一个策略接口中的抽象方法，由接口的实现类——也就是策略类——去实现各中具体的行为。

策略模式也是一种比较常见且好用的设计模</summary>
    
    
    
    <category term="设计模式" scheme="http://blog.xiajibagao.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://blog.xiajibagao.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>资源推荐：数据库内核月报</title>
    <link href="http://blog.xiajibagao.top/2020/11/17/mysql/%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5/"/>
    <id>http://blog.xiajibagao.top/2020/11/17/mysql/%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5/</id>
    <published>2020-11-16T16:00:00.000Z</published>
    <updated>2020-11-17T09:31:08.165Z</updated>
    
    
    <summary type="html">今天在舍友的安利下发现了一个新的宝藏，阿里的数据库内核日报，内容之全面让小白我瞠目结舌，简单的爬了一下 mysql 相关的文章。

完整版可以直接点击链接下载。以下只是 Mysql 内容的整合：

 1.   MetadataLock子系统的优化 - 2014/11/05/
 2.   Recovery改进 - 2014/11/03/
 3.   高可用支持 - 2014/11/04/
 4.   在线Truncateundolog表空间 - 2014/11/06/
 5.   OptimizerCostModel - 2014/10/01/
 6.   Renametable死锁分析 - 2</summary>
    
    
    
    <category term="资源推荐" scheme="http://blog.xiajibagao.top/categories/%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="mysql" scheme="http://blog.xiajibagao.top/tags/mysql/"/>
    
    <category term="资源推荐" scheme="http://blog.xiajibagao.top/tags/%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>Mysql初探(十三)：自增主键，自增锁</title>
    <link href="http://blog.xiajibagao.top/2020/11/16/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%B8%89)%EF%BC%9A%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%8C%E8%87%AA%E5%A2%9E%E9%94%81/"/>
    <id>http://blog.xiajibagao.top/2020/11/16/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%B8%89)%EF%BC%9A%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%8C%E8%87%AA%E5%A2%9E%E9%94%81/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2020-11-16T13:06:33.086Z</updated>
    
    
    <summary type="html">此文为极客时间：MySQL实战45讲的39节的学习笔记

一、自增值的保存方式
我们前面提到过，自增主键的连续性使得表在空间上排列的更紧密，提高了空间利用率，避免了页分裂。实际上，自增主键大部分情况下可以保证连续性，但是也有例外的时候。

当我们创建表的时候，表结构会存储在 .frm 文件中，但是并不会一起保存自增值。MyISAM 引擎将自增值保存在数据文件，而 innodb 在 mysql8.0 之前只会将自增值保存在内存。

也就是说，对于 innodb 引擎来说，每次重启后，都需要寻找表中最大的自增值 X，将 X+1 作为新的自增值，如果当前最大值为 10，自增值就会是11，如果删除了自</summary>
    
    
    
    <category term="mysql" scheme="http://blog.xiajibagao.top/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://blog.xiajibagao.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql初探(十二)：order by</title>
    <link href="http://blog.xiajibagao.top/2020/11/15/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%BA%8C)%EF%BC%9Aorder%20by/"/>
    <id>http://blog.xiajibagao.top/2020/11/15/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%BA%8C)%EF%BC%9Aorder%20by/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2020-11-16T13:06:15.921Z</updated>
    
    
    <summary type="html">此文为极客时间：MySQL实战45讲的16节order by相关内容的笔记

一、order by 的执行流程
1.全字段排序
假如此时有这么一张表：

1
2
3
4
5
6
7
8
9


CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `city` varchar(16) NOT NULL,
  `name` varchar(16) NOT NULL,
  `age` int(11) NOT NULL,
  `addr` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `city` </summary>
    
    
    
    <category term="mysql" scheme="http://blog.xiajibagao.top/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://blog.xiajibagao.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql初探(十一)：join</title>
    <link href="http://blog.xiajibagao.top/2020/11/13/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%B8%80)%EF%BC%9Ajoin/"/>
    <id>http://blog.xiajibagao.top/2020/11/13/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%B8%80)%EF%BC%9Ajoin/</id>
    <published>2020-11-12T16:00:00.000Z</published>
    <updated>2020-11-16T13:00:52.799Z</updated>
    
    
    <summary type="html">此文为极客时间：MySQL实战45讲的 34、35节join相关内容的笔记

一、Join的查询流程
假设我们有表 t1 和表 t2，他们都有字段 a，b，其中 t1 有 100条数据，而 t2 有1000条数据。

我们要执行这么一条sql：

1


select * from t1 join t2 on t2.a = t1.a


执行流程就是会这样的：

 1. 先取出 t1 的一条数据 R；
 2. 然后根据 R 的 a 字段 去 t2 表里找复合条件的数据；
 3. 找到以后，就和 R 的数据拼起来作为结果集的一部分；
 4. 重复以上步骤，直到遍历完 t1 最后一条数据。

其中</summary>
    
    
    
    <category term="mysql" scheme="http://blog.xiajibagao.top/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://blog.xiajibagao.top/tags/mysql/"/>
    
  </entry>
  
</feed>
