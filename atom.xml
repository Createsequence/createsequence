<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Createsequence&#39;s Blog</title>
  
  <subtitle>一个努力前进的程序猿</subtitle>
  <link href="http://blog.xiajibagao.top/atom.xml" rel="self"/>
  
  <link href="http://blog.xiajibagao.top/"/>
  <updated>2022-09-26T02:51:40.129Z</updated>
  <id>http://blog.xiajibagao.top/</id>
  
  <author>
    <name>Createsequence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Spring事件机制（一）：广播器与监听器的初始化</title>
    <link href="http://blog.xiajibagao.top/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B9%BF%E6%92%AD%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://blog.xiajibagao.top/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B9%BF%E6%92%AD%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-09-26T02:51:40.129Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Spring 从 &lt;code&gt;3.x&lt;/code&gt; 开始支持事件机制。在 Spring 的事件机制中，我们可以令一个事件类继承 &lt;code&gt;ApplicationEvent&lt;/code&gt; 类，然后将实现了 &lt;code&gt;ApplicationListener&lt;/code&gt; 的 &lt;code&gt;Bean&lt;/code&gt; 注册到 spring 容器，最后向 &lt;code&gt;ApplicationEventPublisher&lt;/code&gt; 推送事件对象即可令所有订阅者收到事件。在 &lt;code&gt;4.2&lt;/code&gt; 以后，甚至不需要实现 &lt;code&gt;ApplicationListener&lt;/code&gt; 接口，仅需在 &lt;code&gt;Bean&lt;/code&gt; 中方法标记 &lt;code&gt;@EventListener&lt;/code&gt; 注解即可。&lt;/p&gt;
&lt;p&gt;笔者将基于 Spring 源码的 &lt;code&gt;5.2.x&lt;/code&gt; 分支，分析该功能是如何实现的。&lt;/p&gt;
&lt;p&gt;本文是其中的第一篇文章，将分析广播器与监听的是如何被初始化，并完成注解流程的。&lt;/p&gt;
&lt;p&gt;在开始前，推荐先阅读前文了解 Spring 容器的初始化过程与 &lt;code&gt;BeanFactory&lt;/code&gt; 中 &lt;code&gt;Bean&lt;/code&gt; 的创建，如果可能，还可以了解一点 Spring 的注解机制，这将更有利于流程与一些代码的理解。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16591407.html&quot;&gt;深入理解Spring事件机制（一）：广播器与监听器的初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16591418.html&quot;&gt;深入理解Spring事件机制（二）：事件的推送&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-广播器的创建&quot;&gt;一、广播器的创建&lt;/h2&gt;
&lt;p&gt;在前文，我们知道容器的初始化是通过 &lt;code&gt;AbstractApplicationContext.refresh()&lt;/code&gt; 方法完成的，事件机制的相关组件同样也离不开容器，因此事件系统的初始化也通过该方法完成。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractApplicationContext.initApplicationEventMulticaster()&lt;/code&gt; 是第一步，它的作用很简单：&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://blog.xiajibagao.top/categories/SpringBoot/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://blog.xiajibagao.top/tags/SpringBoot/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring事件机制（二）：事件的传播</title>
    <link href="http://blog.xiajibagao.top/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD/"/>
    <id>http://blog.xiajibagao.top/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-08-16T15:12:04.466Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Spring 从 &lt;code&gt;3.x&lt;/code&gt; 开始支持事件机制。在 Spring 的事件机制中，我们可以令一个事件类继承 &lt;code&gt;ApplicationEvent&lt;/code&gt; 类，然后将实现了 &lt;code&gt;ApplicationListener&lt;/code&gt; 的 &lt;code&gt;Bean&lt;/code&gt; 注册到 spring 容器，最后向 &lt;code&gt;ApplicationEventPublisher&lt;/code&gt; 推送事件对象即可令所有订阅者收到事件。在 &lt;code&gt;4.2&lt;/code&gt; 以后，甚至不需要实现 &lt;code&gt;ApplicationListener&lt;/code&gt; 接口，仅需在 &lt;code&gt;Bean&lt;/code&gt; 中方法标记 &lt;code&gt;@EventListener&lt;/code&gt; 注解即可。&lt;/p&gt;
&lt;p&gt;笔者将基于 Spring 源码的 &lt;code&gt;5.2.x&lt;/code&gt; 分支，分析该功能是如何实现的。&lt;/p&gt;
&lt;p&gt;本文是其中的第二篇文章，将分析事件是如何通过广播器推送，并被监听器接收并处理的。&lt;/p&gt;
&lt;p&gt;在开始前，推荐先阅读前文了解一点 Spring 的注解机制或者事务机制，这将更有利于流程与一些代码的理解。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16591407.html&quot;&gt;深入理解Spring事件机制（一）：广播器与监听器的初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16591418.html&quot;&gt;深入理解Spring事件机制（二）：事件的推送&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-事件的推送&quot;&gt;一、事件的推送&lt;/h2&gt;
&lt;h3 id=&quot;1-将事件推送到上下文&quot;&gt;1、将事件推送到上下文&lt;/h3&gt;
&lt;p&gt;当我们借助 Spring 发送一个事件对象的时候，一般都通过 &lt;code&gt;ApplicationEventPublisher&lt;/code&gt; 完成，在默认情况下，通过容器获得的 &lt;code&gt;ApplicationEventPublisher&lt;/code&gt; 单例实际上就是 &lt;code&gt;ApplicationContext&lt;/code&gt; 本身。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://blog.xiajibagao.top/categories/SpringBoot/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="http://blog.xiajibagao.top/tags/SpringBoot/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring注解机制（三）：合并注解的合成</title>
    <link href="http://blog.xiajibagao.top/2022/08/14/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%88%E5%B9%B6%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%88%E6%88%90/"/>
    <id>http://blog.xiajibagao.top/2022/08/14/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%88%E5%B9%B6%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%88%E6%88%90/</id>
    <published>2022-08-13T16:00:00.000Z</published>
    <updated>2022-08-15T14:22:54.291Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;众所周知，&lt;code&gt;spring&lt;/code&gt; 从 2.5 版本以后开始支持使用注解代替繁琐的 xml 配置，到了 &lt;code&gt;springboot&lt;/code&gt; 更是全面拥抱了注解式配置。平时在使用的时候，点开一些常见的等注解，会发现往往在一个注解上总会出现一些其他的注解，比如 &lt;code&gt;@Service&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Component&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// @Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; Service &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor(annotation = Component.class)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;quot;&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大部分情况下，我们可以将 &lt;code&gt;@Service&lt;/code&gt; 注解等同于 &lt;code&gt;@Component&lt;/code&gt; 注解使用，则是因为 spring 基于其 JDK 对&lt;a href=&quot;https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model&quot;&gt;元注解的机制&lt;/a&gt;进行了扩展。&lt;/p&gt;
&lt;p&gt;在 java 中，元注解是指可以注解在其他注解上的注解，spring 中通过对这个机制进行了扩展，实现了一些原生 JDK 不支持的功能，比如允许在注解中让两个属性互为别名，或者将一个带有元注解的子注解直接作为元注解看待，或者在这个基础上，通过 &lt;code&gt;@AliasFor&lt;/code&gt; 或者同名策略让子注解的值覆盖元注解的值。&lt;/p&gt;
&lt;p&gt;本文将基于 spring 源码 &lt;code&gt;5.2.x&lt;/code&gt; 分支，解析 spring 如何实现这套功能的。&lt;/p&gt;
&lt;p&gt;这是系列的第三篇文章，将详细介绍 Spring 是如何在经过搜索与属性映射后，将处理后的注解合成为合并注解的。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585516.html&quot;&gt;深入理解Spring注解机制（一）：注解的搜索与处理机制&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585518.html&quot;&gt;深入理解Spring注解机制（二）：元注解解析与属性映射&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585519.html&quot;&gt;深入理解Spring注解机制（三）：合并注解的合成&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-合并注解&quot;&gt;一、合并注解&lt;/h2&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring注解机制（二）：元注解解析与属性映射</title>
    <link href="http://blog.xiajibagao.top/2022/08/10/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%83%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84/"/>
    <id>http://blog.xiajibagao.top/2022/08/10/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%83%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84/</id>
    <published>2022-08-09T16:00:00.000Z</published>
    <updated>2022-08-15T14:22:48.533Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;众所周知，&lt;code&gt;spring&lt;/code&gt; 从 2.5 版本以后开始支持使用注解代替繁琐的 xml 配置，到了 &lt;code&gt;springboot&lt;/code&gt; 更是全面拥抱了注解式配置。平时在使用的时候，点开一些常见的等注解，会发现往往在一个注解上总会出现一些其他的注解，比如 &lt;code&gt;@Service&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Component&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// @Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; Service &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor(annotation = Component.class)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;quot;&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大部分情况下，我们可以将 &lt;code&gt;@Service&lt;/code&gt; 注解等同于 &lt;code&gt;@Component&lt;/code&gt; 注解使用，则是因为 spring 基于其 JDK 对&lt;a href=&quot;https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model&quot;&gt;元注解的机制&lt;/a&gt;进行了扩展。&lt;/p&gt;
&lt;p&gt;在 java 中，元注解是指可以注解在其他注解上的注解，spring 中通过对这个机制进行了扩展，实现了一些原生 JDK 不支持的功能，比如允许在注解中让两个属性互为别名，或者将一个带有元注解的子注解直接作为元注解看待，或者在这个基础上，通过 &lt;code&gt;@AliasFor&lt;/code&gt; 或者同名策略让子注解的值覆盖元注解的值。&lt;/p&gt;
&lt;p&gt;本文将基于 spring 源码 &lt;code&gt;5.2.x&lt;/code&gt; 分支，解析 spring 如何实现这套功能的。&lt;/p&gt;
&lt;p&gt;这是系列的第二篇文章，将详细介绍 Spring 是如何解析 &lt;code&gt;@AliasFor&lt;/code&gt;，实现各种别名功能。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585516.html&quot;&gt;深入理解Spring注解机制（一）：注解的搜索与处理机制&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585518.html&quot;&gt;深入理解Spring注解机制（二）：元注解解析与属性映射&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585519.html&quot;&gt;深入理解Spring注解机制（三）：合并注解的合成&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-创建合并注解聚合&quot;&gt;一、创建合并注解聚合&lt;/h2&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring注解机制（一）：注解的搜索与处理机制</title>
    <link href="http://blog.xiajibagao.top/2022/08/06/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.xiajibagao.top/2022/08/06/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2022-08-05T16:00:00.000Z</published>
    <updated>2022-08-15T14:22:59.883Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;众所周知，&lt;code&gt;spring&lt;/code&gt; 从 2.5 版本以后开始支持使用注解代替繁琐的 xml 配置，到了 &lt;code&gt;springboot&lt;/code&gt; 更是全面拥抱了注解式配置。平时在使用的时候，点开一些常见的等注解，会发现往往在一个注解上总会出现一些其他的注解，比如 &lt;code&gt;@Service&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Component&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// @Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; Service &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor(annotation = Component.class)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &amp;quot;&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大部分情况下，我们可以将 &lt;code&gt;@Service&lt;/code&gt; 注解等同于 &lt;code&gt;@Component&lt;/code&gt; 注解使用，则是因为 spring 基于其 JDK 对&lt;a href=&quot;https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model&quot;&gt;元注解的机制&lt;/a&gt;进行了扩展。&lt;/p&gt;
&lt;p&gt;在 java 中，元注解是指可以注解在其他注解上的注解，spring 中通过对这个机制进行了扩展，实现了一些原生 JDK 不支持的功能，比如允许在注解中让两个属性互为别名，或者将一个带有元注解的子注解直接作为元注解看待，或者在这个基础上，通过 &lt;code&gt;@AliasFor&lt;/code&gt; 或者同名策略让子注解的值覆盖元注解的值。&lt;/p&gt;
&lt;p&gt;本文将基于 spring 源码 &lt;code&gt;5.2.x&lt;/code&gt; 分支，解析 spring 如何实现这套功能的。&lt;/p&gt;
&lt;p&gt;这是系列的第一篇文章，将详细介绍 Spring 是如何从 &lt;code&gt;AnnotatedElement&lt;/code&gt; 的层级结构中完成对注解的搜索与处理的。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585516.html&quot;&gt;深入理解Spring注解机制（一）：注解的搜索与处理机制&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585518.html&quot;&gt;深入理解Spring注解机制（二）：元注解解析与属性映射&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Createsequence/p/16585519.html&quot;&gt;深入理解Spring注解机制（三）：合并注解的合成&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-层级结构&quot;&gt;一、层级结构&lt;/h2&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring别名机制</title>
    <link href="http://blog.xiajibagao.top/2022/07/26/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%88%AB%E5%90%8D%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.xiajibagao.top/2022/07/26/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%88%AB%E5%90%8D%E6%9C%BA%E5%88%B6/</id>
    <published>2022-07-25T16:00:00.000Z</published>
    <updated>2022-08-15T14:22:18.412Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 spring 容器中，允许通过名称或别名来获取 bean ，这个能力来自于顶层接口 &lt;code&gt;AliasRegistry&lt;/code&gt;，分析类下属的关系图，可以看到，几乎所有主要容器都直接或间接的实现了 &lt;code&gt;AliasRegistry&lt;/code&gt; 接口。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://img.xiajibagao.top/image-20220621134756391.png&quot; alt=&quot;image-20220621134756391&quot;&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220621134756391&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;AliasRegistry&lt;/code&gt; 的结构非常简单，主要的类就是 &lt;code&gt;AliasRegistry&lt;/code&gt; 接口与他的实现类 &lt;code&gt;SimpleAliasRegistry&lt;/code&gt;，后续的实现类基本都直接或间接的继承了 &lt;code&gt;SimpleAliasRegistry&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;本文将基于 spring 源码 &lt;code&gt;5.2.x&lt;/code&gt; 分支，围绕 &lt;code&gt;SimpleAliasRegistry&lt;/code&gt; 解析 spring 的别名机制是如何实现的。&lt;/p&gt;
&lt;h2 id=&quot;一-aliasregistry&quot;&gt;一、AliasRegistry&lt;/h2&gt;
&lt;p&gt;在 spring 的容器中，一个 bean 必须至少有一个名称，而一个名称可以有多个别名，别名亦可以有别名，若我们把这个最原始的名称称为 &lt;code&gt;id&lt;/code&gt;，则结构可以有：&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id -&amp;gt; id&amp;#x27;s alias1 -&amp;gt; alias of id&amp;#x27;s alias1 ... ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   -&amp;gt; id&amp;#x27;s alias2 -&amp;gt; alias of id&amp;#x27;s alias2 ... ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过 bean 的 &lt;code&gt;id&lt;/code&gt;，或与该 &lt;code&gt;id&lt;/code&gt; 直接、间接相关的别名，都可以从容器中获取到对应的 bean。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AliasRegistry&lt;/code&gt; 的作用就是定义这一套规则：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring容器初始化（三）：事件及其他配置的初始化</title>
    <link href="http://blog.xiajibagao.top/2022/07/05/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://blog.xiajibagao.top/2022/07/05/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-07-04T16:00:00.000Z</published>
    <updated>2022-09-26T02:50:44.431Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们知道，spring 的启动其实就是容器的启动，而一般情况下，容器指的其实就是上下文 &lt;code&gt;ApplicationContext&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractApplicationContext&lt;/code&gt; 作为整个 &lt;code&gt;ApplicationContext&lt;/code&gt; 体系中最高级的抽象类，为除了 &lt;code&gt;ComplexWebApplicationContext&lt;/code&gt; 和 &lt;code&gt;SimpleWebApplicationContext&lt;/code&gt; 这两个容器外的全部容器，规定好了 &lt;code&gt;refresh&lt;/code&gt; 的整体流程，所有的容器在完成一些自己的初始化配置后，都需要调用该 &lt;code&gt;refresh&lt;/code&gt; 方法，依次完成指定内容的初始化。&lt;/p&gt;
&lt;p&gt;也就是说，读懂了 &lt;code&gt;AbstractApplicationContext.refresh()&lt;/code&gt; 方法，其实就读懂了容器的启动流程：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;refresh&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException, IllegalStateException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.startupShutdownMonitor) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ================= 一、上下文的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 准备上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prepareRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通知子类刷新内部工厂&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 准备bean工厂以便在当前上下文中使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prepareBeanFactory(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ================= 二、BeanFactory的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 对工厂进行默认后置处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            postProcessBeanFactory(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 使用后置处理器对工厂进行处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            invokeBeanFactoryPostProcessors(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 注册Bean后置处理器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            registerBeanPostProcessors(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ================= 三、事件，Bean及其他配置的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 初始化此上下文的消息源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            initMessageSource();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 为此上下文初始化事件广播者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            initApplicationEventMulticaster();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 初始化特定上下文子类中的其他特殊bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            onRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 检查侦听器bean并注册&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            registerListeners();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 实例化所有非懒加载的剩余单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            finishBeanFactoryInitialization(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 完成刷新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            finishRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ================= 异常处理 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (BeansException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (logger.isWarnEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                logger.warn(&lt;span class=&quot;string&quot;&gt;&amp;quot;Exception encountered during context initialization - &amp;quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;string&quot;&gt;&amp;quot;cancelling refresh attempt: &amp;quot;&lt;/span&gt; + ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 销毁已创建的单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            destroyBeans();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 重置上下文的激活状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cancelRefresh(ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; ex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 重置内部的一些元数据缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            resetCommonCaches();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从总体来看，该方法描述的初始化过程大概分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] 上下文的初始化；&lt;/li&gt;
&lt;li&gt;[x] &lt;code&gt;BeanFactory&lt;/code&gt; 初始化；&lt;/li&gt;
&lt;li&gt;[x] 事件，Bean及其他配置的初始化；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;笔者将基于 spring 源码 &lt;code&gt;5.2.x&lt;/code&gt; 分支，分别通过五篇文章从源码分析 spring 容器的初始化过程。&lt;/p&gt;
&lt;p&gt;本文是其中的第三篇文章，将介绍上下文中事件，Bean及其他配置的初始化。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring容器初始化（二）：BeanFactory的初始化</title>
    <link href="http://blog.xiajibagao.top/2022/06/08/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ABeanFactory%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://blog.xiajibagao.top/2022/06/08/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ABeanFactory%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-06-07T16:00:00.000Z</published>
    <updated>2022-09-26T02:50:48.919Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们知道，spring 的启动其实就是容器的启动，而一般情况下，容器指的其实就是上下文 &lt;code&gt;ApplicationContext&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractApplicationContext&lt;/code&gt; 作为整个 &lt;code&gt;ApplicationContext&lt;/code&gt; 体系中最高级的抽象类，为除了 &lt;code&gt;ComplexWebApplicationContext&lt;/code&gt; 和 &lt;code&gt;SimpleWebApplicationContext&lt;/code&gt; 这两个容器外的全部容器，规定好了 &lt;code&gt;refresh&lt;/code&gt; 的整体流程，所有的容器在完成一些自己的初始化配置后，都需要调用该 &lt;code&gt;refresh&lt;/code&gt; 方法，依次完成指定内容的初始化。&lt;/p&gt;
&lt;p&gt;也就是说，读懂了 &lt;code&gt;AbstractApplicationContext.refresh()&lt;/code&gt; 方法，其实就读懂了容器的启动流程：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;refresh&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException, IllegalStateException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.startupShutdownMonitor) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ================= 一、上下文的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 准备上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prepareRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通知子类刷新内部工厂&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 准备bean工厂以便在当前上下文中使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prepareBeanFactory(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ================= 二、BeanFactory的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 对工厂进行默认后置处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            postProcessBeanFactory(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 使用后置处理器对工厂进行处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            invokeBeanFactoryPostProcessors(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 注册Bean后置处理器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            registerBeanPostProcessors(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ================= 三、事件，Bean及其他配置的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 初始化此上下文的消息源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            initMessageSource();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 为此上下文初始化事件广播者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            initApplicationEventMulticaster();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 初始化特定上下文子类中的其他特殊bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            onRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 检查侦听器bean并注册&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            registerListeners();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 实例化所有非懒加载的剩余单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            finishBeanFactoryInitialization(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 完成刷新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            finishRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ================= 异常处理 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (BeansException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (logger.isWarnEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                logger.warn(&lt;span class=&quot;string&quot;&gt;&amp;quot;Exception encountered during context initialization - &amp;quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;string&quot;&gt;&amp;quot;cancelling refresh attempt: &amp;quot;&lt;/span&gt; + ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 销毁已创建的单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            destroyBeans();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 重置上下文的激活状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cancelRefresh(ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; ex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 重置内部的一些元数据缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            resetCommonCaches();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从总体来看，该方法描述的初始化过程大概分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] 上下文的初始化；&lt;/li&gt;
&lt;li&gt;[x] &lt;code&gt;BeanFactory&lt;/code&gt; 初始化；&lt;/li&gt;
&lt;li&gt;[ ] 事件，Bean及其他配置的初始化；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;笔者将基于 spring 源码 &lt;code&gt;5.2.x&lt;/code&gt; 分支，分别通过五篇文章从源码分析 spring 容器的初始化过程。&lt;/p&gt;
&lt;p&gt;本文是其中的第二篇文章，将介绍 &lt;code&gt;BeanFactory&lt;/code&gt; 初始化。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring容器初始化（一）：上下文的初始化</title>
    <link href="http://blog.xiajibagao.top/2022/05/19/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://blog.xiajibagao.top/2022/05/19/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-05-18T16:00:00.000Z</published>
    <updated>2022-09-26T02:50:55.198Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们知道，spring 的启动其实就是容器的启动，而一般情况下，容器指的其实就是上下文 &lt;code&gt;ApplicationContext&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractApplicationContext&lt;/code&gt; 作为整个 &lt;code&gt;ApplicationContext&lt;/code&gt; 体系中最高级的抽象类，为除了 &lt;code&gt;ComplexWebApplicationContext&lt;/code&gt; 和 &lt;code&gt;SimpleWebApplicationContext&lt;/code&gt; 这两个容器外的全部容器，规定好了 &lt;code&gt;refresh&lt;/code&gt; 的整体流程，所有的容器在完成一些自己的初始化配置后，都需要调用该 &lt;code&gt;refresh&lt;/code&gt; 方法，依次完成指定内容的初始化。&lt;/p&gt;
&lt;p&gt;也就是说，读懂了 &lt;code&gt;AbstractApplicationContext.refresh()&lt;/code&gt; 方法，其实就读懂了容器的启动流程：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;refresh&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException, IllegalStateException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.startupShutdownMonitor) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ================= 一、上下文的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 准备上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prepareRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通知子类刷新内部工厂&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 准备bean工厂以便在当前上下文中使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        prepareBeanFactory(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ================= 二、BeanFactory的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 对工厂进行默认后置处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            postProcessBeanFactory(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 使用后置处理器对工厂进行处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            invokeBeanFactoryPostProcessors(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 注册Bean后置处理器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            registerBeanPostProcessors(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// ================= 三、事件，Bean及其他配置的初始化 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 初始化此上下文的消息源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            initMessageSource();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 为此上下文初始化事件广播者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            initApplicationEventMulticaster();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 初始化特定上下文子类中的其他特殊bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            onRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 检查侦听器bean并注册&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            registerListeners();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 实例化所有非懒加载的剩余单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            finishBeanFactoryInitialization(beanFactory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 完成刷新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            finishRefresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ================= 异常处理 =================&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (BeansException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (logger.isWarnEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                logger.warn(&lt;span class=&quot;string&quot;&gt;&amp;quot;Exception encountered during context initialization - &amp;quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;string&quot;&gt;&amp;quot;cancelling refresh attempt: &amp;quot;&lt;/span&gt; + ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 销毁已创建的单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            destroyBeans();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 重置上下文的激活状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cancelRefresh(ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; ex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 重置内部的一些元数据缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            resetCommonCaches();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从总体来看，该方法描述的初始化过程大概分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] 上下文的初始化；&lt;/li&gt;
&lt;li&gt;[ ] &lt;code&gt;BeanFactory&lt;/code&gt; 初始化；&lt;/li&gt;
&lt;li&gt;[ ] 事件，Bean及其他配置的初始化；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;笔者将基于 spring 源码 &lt;code&gt;5.2.x&lt;/code&gt; 分支，分别通过五篇文章从源码分析 spring 容器的初始化过程。&lt;/p&gt;
&lt;p&gt;本文是其中的第一篇文章，将介绍上下文的初始化过程。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring容器体系结构</title>
    <link href="http://blog.xiajibagao.top/2022/04/02/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%AE%B9%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.xiajibagao.top/2022/04/02/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%AE%B9%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2022-04-01T16:00:00.000Z</published>
    <updated>2022-08-15T14:22:42.035Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 spring 中，任何实现了 &lt;code&gt;BeanFactory&lt;/code&gt; 接口的类都可以视为容器，它是 &lt;code&gt;IOC&lt;/code&gt; 功能实现的核心，用于完成类实例从加载到销毁的整个生命周期的控制，这些被 spring 所管理的实例统称为 bean。&lt;/p&gt;
&lt;p&gt;根据抽象层级的不同，容器又分为 &lt;code&gt;BeanFactory&lt;/code&gt; 的直接实现，与基于 &lt;code&gt;BeanFactory&lt;/code&gt; 的扩展实现 &lt;code&gt;ApplicationContext&lt;/code&gt;，后者在前者的基础继承了 &lt;code&gt;ResourceLoader&lt;/code&gt;和&lt;code&gt;EnvironmentCapable&lt;/code&gt;接口，因而具备从某类运行环境的资源中直接加载 bean 的能力。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://img.xiajibagao.top/image-20220620142154578.png&quot; alt=&quot;image-20220620142154578&quot;&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220620142154578&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt; 最常用的两个实现 &lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt; 和 &lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt; ，前者用于从项目路径下根据 &lt;code&gt;xml&lt;/code&gt; 文件加载 bean，而后者通过扫描类注解完成 bean 的加载。这两者 &lt;code&gt;ApplicationContext&lt;/code&gt; 实际上就对应了我们所熟悉的两类配置方式，前者就是传统的 xml 配置，后者则是通过 &lt;code&gt;@Component&lt;/code&gt; 与 &lt;code&gt;@Bean&lt;/code&gt; 等注解对 bean 进行配置。&lt;/p&gt;
&lt;p&gt;本文将基于 spring 源码 &lt;code&gt;5.2.x&lt;/code&gt; 分支，基于 &lt;code&gt;BeanFactory&lt;/code&gt; 与 &lt;code&gt;ApplicationContext&lt;/code&gt; 两大接口，介绍 spring 的两类容器的结构体系。&lt;/p&gt;
&lt;h2 id=&quot;一-beanfactory-接口体系&quot;&gt;一、BeanFactory 接口体系&lt;/h2&gt;
&lt;p&gt;总览 &lt;code&gt;BeanFactory&lt;/code&gt; 体系，按照接口的抽象层次，大体可以分层四层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层：&lt;code&gt;BeanFactory&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;第二层：&lt;code&gt;HierarchicalBeanFactory&lt;/code&gt;，&lt;code&gt;ListableBeanFactory&lt;/code&gt;，&lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;第三层：&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;，此外还有一个关联性较强&lt;code&gt;SingletonBeanRegistry&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;第四层：&lt;code&gt;ConfigurableListableBeanFactory&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img src=&quot;https://img.xiajibagao.top/image-20220620151809732.png&quot; alt=&quot;image-20220620151809732&quot;&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220620151809732&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://blog.xiajibagao.top/tags/Spring/"/>
    
    <category term="源码分析" scheme="http://blog.xiajibagao.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>发布自己的jar包到Maven官方仓库</title>
    <link href="http://blog.xiajibagao.top/2022/02/18/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84jar%E5%8C%85%E5%88%B0Maven%E5%AE%98%E6%96%B9%E4%BB%93%E5%BA%93/"/>
    <id>http://blog.xiajibagao.top/2022/02/18/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84jar%E5%8C%85%E5%88%B0Maven%E5%AE%98%E6%96%B9%E4%BB%93%E5%BA%93/</id>
    <published>2022-02-17T16:00:00.000Z</published>
    <updated>2022-02-20T06:10:03.180Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;一-申请groupid&quot;&gt;一、申请GroupId&lt;/h2&gt;
&lt;p&gt;我们知道，一个maven坐标由&lt;code&gt;groupId&lt;/code&gt;，&lt;code&gt;artifactId&lt;/code&gt;和&lt;code&gt;version&lt;/code&gt;组成，后两者可以在pom中调整，而可以用在中央仓库的 &lt;code&gt;groupId&lt;/code&gt;需要申请。由于 Maven 中央仓库由 sonatype 公司进行运营，所以我们首先需要&lt;a href=&quot;https://issues.sonatype.org/secure/Signup!default.jspa&quot;&gt;注册一个sonatype账号&lt;/a&gt;，通过该账号去申请一个 &lt;code&gt;groupId&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-注册&quot;&gt;1、注册&lt;/h3&gt;
&lt;p&gt;注册没什么好说的，按顺序填就行，需要注意用户名最好不要用中文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.xiajibagao.top/image-20220215144939190.png&quot; alt=&quot;image-20220215144939190&quot; style=&quot;zoom: 50%;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-申请&quot;&gt;2、申请&lt;/h3&gt;
&lt;p&gt;这里的操作跟GitHub很像，新增相当于提出一个issues：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;https://img.xiajibagao.top/image-20220215150018531.png&quot; alt=&quot;image-20220215150018531&quot;&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20220215150018531&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;然后填写信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.xiajibagao.top/image-20220215150401093.png&quot; alt=&quot;image-20220215150401093&quot; style=&quot;zoom: 67%;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="杂七乱八" scheme="http://blog.xiajibagao.top/categories/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/"/>
    
    
    <category term="杂七乱八" scheme="http://blog.xiajibagao.top/tags/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码学习（三）：映射文件中sql的解析</title>
    <link href="http://blog.xiajibagao.top/2021/07/11/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%ADsql%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.xiajibagao.top/2021/07/11/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%ADsql%E7%9A%84%E8%A7%A3%E6%9E%90/</id>
    <published>2021-07-10T16:00:00.000Z</published>
    <updated>2021-07-11T02:10:35.267Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;根据上一篇文章，我们了解了 Mybatis 如何在加载配置文件后，根据指定配置方式寻找接口并且完成映射文件信息与接口的绑定的。在本篇文章，我们将延续上文，结合源码阐述映射文件中方法声明里的 sql 被解析为 java 对象的过程。&lt;/p&gt;
&lt;p&gt;这是关于 Mybatis 的第三篇文章，前文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.xiajibagao.top/2021/06/05/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/&quot;&gt;Mybatis源码学习（一）：配置文件的加载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.xiajibagao.top/2021/06/14/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AMapper%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%91%E5%AE%9A/&quot;&gt;Mybatis源码学习（二）：Mapper接口的绑定&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-sql解析&quot;&gt;一、sql解析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiajibagao.top/image-20210711012449848.png&quot; alt=&quot;image-20210711012449848&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1xmlmapperbuilder&quot;&gt;1.XMLMapperBuilder&lt;/h3&gt;
&lt;p&gt;Sql 解析与 &lt;code&gt;MappedStatement&lt;/code&gt;的生成都在 &lt;code&gt;XMLMapperBuilder&lt;/code&gt; 进行。根据上文可知，在 &lt;code&gt;XMLMapperBuilder&lt;/code&gt; 的 &lt;code&gt;parsePendingStatements()&lt;/code&gt;方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;parsePendingStatements&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取所有映射文件中的方法声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Collection&amp;lt;XMLStatementBuilder&amp;gt; incompleteStatements = configuration.getIncompleteStatements();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (incompleteStatements) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Iterator&amp;lt;XMLStatementBuilder&amp;gt; iter = incompleteStatements.iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (iter.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 遍历并转换为Statement对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                iter.next().parseStatementNode();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                iter.remove();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IncompleteElementException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Statement is still missing a resource...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;Configuration&lt;/code&gt;类中的&lt;code&gt;IncompleteStatements&lt;/code&gt;是在&lt;code&gt;XMLMapperBuilder.parse()&lt;/code&gt;时添加进去的，我们可以理解他是一个刚从配置文件中根据&lt;code&gt;&amp;lt;select&amp;gt;&amp;lt;delete&amp;gt;&amp;lt;update&amp;gt;&amp;lt;insert&amp;gt;&lt;/code&gt;标签名拿到的 XML 节点，还没有做任何解析。&lt;/p&gt;</summary>
    
    
    
    <category term="Mybatis" scheme="http://blog.xiajibagao.top/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="http://blog.xiajibagao.top/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码学习（二）：Mapper接口的绑定</title>
    <link href="http://blog.xiajibagao.top/2021/06/14/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AMapper%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%91%E5%AE%9A/"/>
    <id>http://blog.xiajibagao.top/2021/06/14/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AMapper%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%91%E5%AE%9A/</id>
    <published>2021-06-13T16:00:00.000Z</published>
    <updated>2021-06-21T15:35:35.583Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;根据上一篇文章，我们了解了 Mybatis 的配置文件是如何被加载的。在完成这一步之后，Mybatis 还需要根据配置文件中指定的路径去加载 Mapper 接口与写有 sql 的相应映射文件，最终完成两者的绑定。&lt;/p&gt;
&lt;p&gt;在本篇文章，我们将结合源码阐述这个过程。&lt;/p&gt;
&lt;p&gt;这是关于 Mybatis 的第二篇文章，前文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.xiajibagao.top/2021/06/05/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/&quot;&gt;Mybatis源码学习（一）：配置文件的加载&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-加载接口&quot;&gt;一、加载接口&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiajibagao.top/image-20210609000011106.png&quot; alt=&quot;image-20210609000011106&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1xmlconfigbuilder&quot;&gt;1.XMLConfigBuilder&lt;/h3&gt;
&lt;p&gt;见名知意，这个类的作用在于&lt;strong&gt;解析映射文件&lt;/strong&gt;，根据上文，我们会了解到他里面有各种 &lt;code&gt;标签名+Element&lt;/code&gt;为名的解析方法，其中，针对 Mapper 映射文件解析方法就是&lt;code&gt;mapperElement()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在开始之前，我们需要知道，在映射文件中有四种指定 Mybatis 接口的方式：&lt;/p&gt;</summary>
    
    
    
    <category term="Mybatis" scheme="http://blog.xiajibagao.top/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="http://blog.xiajibagao.top/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码学习（一）：配置文件的加载</title>
    <link href="http://blog.xiajibagao.top/2021/06/05/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://blog.xiajibagao.top/2021/06/05/mybatis/Mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-06-04T16:00:00.000Z</published>
    <updated>2021-06-21T14:44:39.088Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;我们知道，一个框架的运行，往往都从配置文件的加载开始，本篇文章作为 Mybatis 源码学习的第一篇文章，将结合源码，阐述 Mybatis 是如何加载 mybatis-config.xml 配置文件的。&lt;/p&gt;
&lt;p&gt;Mybatis 版本：3.5.8&lt;/p&gt;
&lt;p&gt;JDK 版本：1.8&lt;/p&gt;
&lt;p&gt;Mysql 版本：5.6.51&lt;/p&gt;
&lt;h2 id=&quot;一-输入流的读取&quot;&gt;一、输入流的读取&lt;/h2&gt;
&lt;p&gt;我们根据源码给的测试用例，可以知道 Mybatis 可以通过以下代码获取 Xml 配置文件并转为配置类：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String resource = &lt;span class=&quot;string&quot;&gt;&amp;quot;org/apache/ibatis/builder/MinimalMapperConfig.xml&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; (InputStream inputStream = Resources.getResourceAsStream(resource)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    XMLConfigBuilder builder = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XMLConfigBuilder(inputStream);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Configuration config = builder.parse();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;拿到全局配置类 &lt;code&gt;Configuration&lt;/code&gt; 以后就可以通过&lt;code&gt;SqlSessionFactoryBuilder().build()&lt;/code&gt;方法去创建&lt;code&gt;SqlSessionFactory&lt;/code&gt;了。当然，&lt;code&gt;SqlSessionFactoryBuilder().build()&lt;/code&gt;有多个重载方法，但是无外乎都要经过转换为 &lt;code&gt;Configuration&lt;/code&gt; 这一步。&lt;/p&gt;
&lt;p&gt;整个过程就分为三步：&lt;/p&gt;</summary>
    
    
    
    <category term="Mybatis" scheme="http://blog.xiajibagao.top/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="http://blog.xiajibagao.top/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析</title>
    <link href="http://blog.xiajibagao.top/2021/02/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.xiajibagao.top/2021/02/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-02-10T16:00:00.000Z</published>
    <updated>2021-02-12T08:47:50.784Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;当我们提到 juc 包下的锁，就不得不联系到 AbstractQueuedSynchronizer 这个类，这个类就是大名鼎鼎的 AQS，AQS 按字面意思翻译为抽象队列同步器，调用者可以通过继承该类快速的实现同步多线程下的同步容器。不管是我们熟悉的 ReadWriteLock 亦或是 ReentrantLock，或者 CountDownLatch 与 Semaphore，甚至是线程池类 ThreadPoolExecutor 都继承了 AQS。&lt;/p&gt;
&lt;p&gt;在本文，将深入源码，了解 AQS 的运行机制，了解通过 AQS 实现非公平锁，公平锁，可重入锁等的原理。&lt;/p&gt;
&lt;h2 id=&quot;一-aqs-中的数据结构&quot;&gt;一、AQS 中的数据结构&lt;/h2&gt;
&lt;p&gt;AQS 的底层数据结构其实是一条双向链表以及一个代表锁状态的变量 &lt;code&gt;state&lt;/code&gt;。当加锁后，&lt;code&gt;state&lt;/code&gt;会改变，而竞争锁的线程会被封装到节点中形成链表，并且尝试改变 &lt;code&gt;state&lt;/code&gt;以获取锁。&lt;/p&gt;
&lt;h3 id=&quot;1等待队列&quot;&gt;1.等待队列&lt;/h3&gt;
&lt;p&gt;在 AQS 中有一个 Node 内部类，该类即为链表的节点类。当通过 AQS 竞争锁的时候，线程会被封装到一个对应的节点中，多个竞争不到锁的线程最终会连成一条链表，&lt;strong&gt;这条链表上节点代表的线程处于等待状态，因此我们称之为等待队列，也就是 CLH&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;节点类中封装了竞争锁的线程的等待状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CANCELLED：1，表示&lt;strong&gt;当前结点已取消等待&lt;/strong&gt;。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。&lt;/li&gt;
&lt;li&gt;SIGNAL：-1，表示&lt;strong&gt;后继结点在等待当前结点唤醒&lt;/strong&gt;。后继结点入队时，会将前继结点的状态更新为SIGNAL。&lt;/li&gt;
&lt;li&gt;CONDITION：-2，表示&lt;strong&gt;结点等待在Condition上&lt;/strong&gt;，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将&lt;strong&gt;从等待队列转移到同步队列中&lt;/strong&gt;，等待获取同步锁。&lt;/li&gt;
&lt;li&gt;PROPAGATE：-3，&lt;strong&gt;共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;0&lt;/strong&gt;：新节点入队时的默认状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和线程池中的状态一样，&lt;strong&gt;Node 只有小于 0 的时候才处于正常的等待状态中，因此很多地方通过判断是否小于 0 来确定节点是否处于等待状态&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="http://blog.xiajibagao.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="http://blog.xiajibagao.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池源码分析</title>
    <link href="http://blog.xiajibagao.top/2021/02/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://blog.xiajibagao.top/2021/02/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-02-08T16:00:00.000Z</published>
    <updated>2021-02-11T09:44:36.807Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;在 java 中，线程池 ThreadPoolExecutor 是一个绕不过去的类，它是享元模式思想的体现，通过在容器中创建一定数量的线程加以重复利用，从而避免频繁创建线程带来的额外开销。一个设置合理的线程池可以提高任务响应的速度，并且避免线程数超过硬件能力带来的意外情况。&lt;/p&gt;
&lt;p&gt;在本文，将深入线程池源码，了解线程池的底层实现与运行机制。&lt;/p&gt;
&lt;h2 id=&quot;一-构造方法&quot;&gt;一、构造方法&lt;/h2&gt;
&lt;p&gt;ThreadPoolExecutor 类一共提供了四个构造方法，我们基于参数最完整构造方法了解一下线程池创建所需要的变量：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; corePoolSize, // 核心线程数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maximumPoolSize, // 最大线程数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; keepAliveTime, // 非核心线程闲置存活时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          TimeUnit unit, // 时间单位&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, // 工作队列&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          ThreadFactory threadFactory, // 创建线程使用的线程工厂&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          RejectedExecutionHandler handler // 拒绝策略)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;核心线程数：即长期存在的线程数，当线程池中运行线程未达到核心线程数时会优先创建新线程；&lt;/li&gt;
&lt;li&gt;最大线程数：当核心线程已满，工作队列已满，同时线程池中线程总数未超过最大线程数，会创建非核心线程；&lt;/li&gt;
&lt;li&gt;非核心线程闲置存活时间：当非核心线程闲置的时的最大存活时间；&lt;/li&gt;
&lt;li&gt;时间单位：非核心线程闲置存活时间的时间单位；&lt;/li&gt;
&lt;li&gt;任务队列：当核心线程满后，任务会优先加入工作队列，等等待核心线程消费；&lt;/li&gt;
&lt;li&gt;线程工厂：线程池创建新线程时使用的线程工厂；&lt;/li&gt;
&lt;li&gt;拒绝策略：当工作队列与线程池都满时，用于执行的策略；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二-线程池状态&quot;&gt;二、线程池状态&lt;/h2&gt;
&lt;h3 id=&quot;1线程池状态&quot;&gt;1.线程池状态&lt;/h3&gt;
&lt;p&gt;线程池拥有一个 AtomicInteger 类型的成员变量 ctl ，通过位运算分别使用 ctl 的高位低位以便在一个值中存储线程数量以及线程池状态。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="http://blog.xiajibagao.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="http://blog.xiajibagao.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized底层原理探究</title>
    <link href="http://blog.xiajibagao.top/2021/02/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://blog.xiajibagao.top/2021/02/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-02-10T12:57:34.049Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;说起多线程同步，一般的方案就是加锁，而在 java 中，提到加锁就想起 juc 包提供的 Lock 接口实现类与默认的关键字 synchronized 。我们常听到，juc 下的锁大多基于 AQS，而 AQS 的锁机制基于 CAS，相比起 CAS 使用的自旋锁，Synchronized 是一种重量级的锁实现。&lt;/p&gt;
&lt;p&gt;实际上，在 JDK6 之后，synchronized 逐渐引入了锁升级机制，它将会有一个从轻量级到重量级的逐步升级的过程。本文将简单的介绍 synchronized 的底层实现原理，并且介绍 synchronized 的锁升级机制。&lt;/p&gt;
&lt;h2 id=&quot;一-synchronized-的底层实现&quot;&gt;一、synchronized 的底层实现&lt;/h2&gt;
&lt;p&gt;synchronized 意为同步，它可以用于修饰静态方法，实例方法，或者一段代码块。&lt;/p&gt;
&lt;p&gt;它是一种可重入的对象锁。当修饰静态方法时，锁对象为类；当修饰实例方法时，锁对象为实例；当修饰代码块时，锁可以是任何非 null 的对象。&lt;/p&gt;
&lt;p&gt;由于其底层的实现机制，synchronized 的锁又称为监视器锁。&lt;/p&gt;
&lt;h3 id=&quot;1同步代码块&quot;&gt;1.同步代码块&lt;/h3&gt;
&lt;p&gt;当我们反编译一个含有被 synchronized &lt;strong&gt;修饰的代码块&lt;/strong&gt;的文件时，我们可以看到类似如下指令：&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;http://img.xiajibagao.top/image-20210210174821495.png&quot; alt=&quot;image-20210210174821495&quot;&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20210210174821495&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="多线程" scheme="http://blog.xiajibagao.top/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="http://blog.xiajibagao.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《趣谈网络协议》读书笔记（五）：TCP与UDP</title>
    <link href="http://blog.xiajibagao.top/2021/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ATCP%E4%B8%8EUDP/"/>
    <id>http://blog.xiajibagao.top/2021/01/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ATCP%E4%B8%8EUDP/</id>
    <published>2021-01-13T16:00:00.000Z</published>
    <updated>2021-02-09T05:36:47.660Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;此文为极客时间&lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot;&gt;趣谈网络协议&lt;/a&gt;第二模块第10讲至第12讲的的学习笔记。&lt;/p&gt;
&lt;p&gt;主要内容包括传输层的两个重要协议 TCP 与 UDP 协议，以及 TCP 是如何建立稳定连接。&lt;/p&gt;
&lt;h2 id=&quot;一-tcp与udp的区别&quot;&gt;一、TCP与UDP的区别&lt;/h2&gt;
&lt;h3 id=&quot;1定义&quot;&gt;1.定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;传输控制协议&lt;/strong&gt;：（TCP，Transmission Control Protocol）是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户数据报协议&lt;/strong&gt;：（UDP，User Datagram Protocol）是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。&lt;/p&gt;
&lt;h3 id=&quot;2区别&quot;&gt;2.区别&lt;/h3&gt;
&lt;p&gt;就其特性而言，TCP 是面向连接的，UDP 是面向无连接的，更直白的说，TCP 是有状态的，UDP 是无状态的。&lt;/p&gt;
&lt;p&gt;TCP 在连接之前，会进行三次握手以建立连接，这里的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://blog.xiajibagao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://blog.xiajibagao.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《趣谈网络协议》读书笔记（四）：网关与路由协议</title>
    <link href="http://blog.xiajibagao.top/2020/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BD%91%E5%85%B3%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.xiajibagao.top/2020/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BD%91%E5%85%B3%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-12-24T16:00:00.000Z</published>
    <updated>2021-02-09T05:36:46.936Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;此文为极客时间&lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot;&gt;趣谈网络协议&lt;/a&gt;第二模块“从第二层到第三层”中，第四节和第五节的学习笔记。&lt;/p&gt;
&lt;p&gt;主要内容包括网关，路由等，介绍了设备是如何在多个局域网间通过网关进行通信的。&lt;/p&gt;
&lt;h2 id=&quot;一-网关&quot;&gt;一、网关&lt;/h2&gt;
&lt;p&gt;在前文，我们了解到，局域网中的机器可以向另一局域网发出请求，在同一个局域网中的请求最后会抵达路由器或者交换机，最后再转发出去，而之所以请求都能到达一处，就在于他们所在的局域网中有一个统一的网关（Gateway）。&lt;/p&gt;
&lt;h3 id=&quot;1数据是如何到网关的&quot;&gt;1.数据是如何到网关的&lt;/h3&gt;
&lt;p&gt;首先我们需要了解数据包中 MAC 头与 IP 头的结构：&lt;/p&gt;
&lt;p&gt;我们知道，网络层总是一层套一层的，因此 MAC 包里包含 IP 包，MAC 头下会有 IP 头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAC 头的结构&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;http://img.xiajibagao.top/image-20201225140407048.png&quot; alt=&quot;image-20201225140407048&quot;&gt;&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20201225140407048&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://blog.xiajibagao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://blog.xiajibagao.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《趣谈网络协议》读书笔记（三）：ICMP协议与ping命令</title>
    <link href="http://blog.xiajibagao.top/2020/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AICMP%E5%8D%8F%E8%AE%AE%E4%B8%8Eping%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.xiajibagao.top/2020/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AICMP%E5%8D%8F%E8%AE%AE%E4%B8%8Eping%E5%91%BD%E4%BB%A4/</id>
    <published>2020-12-23T16:00:00.000Z</published>
    <updated>2020-12-25T05:26:20.039Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;此文为极客时间&lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot;&gt;趣谈网络协议&lt;/a&gt;第二模块“从第二层到第三层”中，第三节的学习笔记。&lt;/p&gt;
&lt;p&gt;主要内容包括 ICMP 协议中的查询报文与差错报文，ping 命令的整个执行过程，Linux 的&lt;code&gt;Traceroute&lt;/code&gt;命令是如何通过差错报文获取网络状态的。&lt;/p&gt;
&lt;h2 id=&quot;一-icmp协议&quot;&gt;一、ICMP协议&lt;/h2&gt;
&lt;p&gt;一般情况下，我们想要知道网络是否畅通，或者服务器是否正常运行，会使用 ping 命令，&lt;strong&gt;而 ping 命令依赖的协议就是 ICMP 协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;ICMP 协议全程为 Internet Control Message Protocol，即互联网控制报文协议。它是介于 IP 层与 TCP 层之间的协议，&lt;strong&gt;一般认为属于 IP 层协议，也就是网络层协议&lt;/strong&gt;。它被封装在 IP 包中，IP 协议用它来与其他主机交换错误报文或者一些其他的网络情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiajibagao.top/201589bb205c5b00ad42e0081aa46fe2.jpg&quot; alt=&quot;img&quot; style=&quot;zoom: 25%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;ICMP 报文有两种类型，一种是查询报文，比如 ping 命令；另一种是差错报文。&lt;/p&gt;
&lt;h3 id=&quot;1查询报文&quot;&gt;1.查询报文&lt;/h3&gt;
&lt;p&gt;ping 命令是查询报文一种，是一种主动请求，并且获得主动应答的 ICMP 协议，它在后面加了自己的格式。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://blog.xiajibagao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://blog.xiajibagao.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
