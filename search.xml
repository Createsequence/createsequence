<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java是值传递还是引用传递</title>
    <url>/2020/08/05/java/java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>以前一鳞半爪的了解过 java 的参数传递方式是什么样的，后面粗略的了解了一鳞半爪以后有了大概的印象：“传参数就是值传递，传对象就是引用传递”，今天同事说起这件事，他却说 java 只有值传递。抱着疑问，我专门查了相关资料和文章，发现我原来的理解确实有问题。</p>
<p>这里先放结论：</p>
<ul>
<li>java中参数的传递可以理解为<strong>都是值传递</strong></li>
<li>基础数据类型传递的是<strong>值的拷贝</strong></li>
<li>对象类型是共享对象传递，传递的是<strong>地址的拷贝</strong></li>
</ul>
<h2 id="一、形参和实参"><a href="#一、形参和实参" class="headerlink" title="一、形参和实参"></a>一、形参和实参</h2><p>要理解参数的传递就必须先理解形参和实参：</p>
<ul>
<li><p>形参：就是形式参数，用于<strong>定义方法的时候使用的参数</strong>，是用来接收调用者传递的参数的。 </p>
<p>形参只有在方法被调用的时候，虚拟机才会分配内存单元，在方法调用结束之后便会释放所分配的内存单元。</p>
<p>因此,<strong>形参只在方法内部有效</strong>，所以针对引用对象的改动也无法影响到方法外。</p>
</li>
<li><p>实参：就是实际参数，用于调用时<strong>传递给方法的参数</strong>。</p>
</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    String string = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">//string是实际参数</span></span><br><span class="line">    sout(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//str为形式参数</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、值传递和引用传递与共享对象传递"><a href="#二、值传递和引用传递与共享对象传递" class="headerlink" title="二、值传递和引用传递与共享对象传递"></a>二、值传递和引用传递与共享对象传递</h2><h3 id="1-值传递和引用传递"><a href="#1-值传递和引用传递" class="headerlink" title="1.值传递和引用传递"></a>1.值传递和引用传递</h3><p>理解了实参和形参，以及java对应的数据类型，我们就可以理解值传递和引用传递了。</p>
<ul>
<li><p>值传递：方法调用时，实际参数的<strong>值</strong>被传递给对应的形式参数，函数接收的是原始值的一个copy， 此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作<strong>都是对形参这个值的修改，不影响实际参数的值</strong>。</p>
</li>
<li><p>引用传递/址传递：方法调用时，实际参数的<strong>地址</strong>被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址。在方法执行中，<strong>形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象</strong>。</p>
</li>
</ul>
<p>对于这两种方式，网上有一个非常形象的图：</p>
<p><img src="http://img.xiajibagao.top/%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.gif"></p>
<h3 id="2-共享对象传递"><a href="#2-共享对象传递" class="headerlink" title="2.共享对象传递"></a>2.共享对象传递</h3><p>但是java的传值策略有点类似于两者的结合，是<strong>共享对象传递</strong>：</p>
<ul>
<li>共享对象传递：先获取到实际参数的地址，然后将其复制，并把<strong>该地址的拷贝</strong>传递给被调函数的形式参数。因为参数的地址都指向同一个对象，所以我们称也之为”传共享对象”，所以，如果在被调函数中改变了形式参数的值，调用者是可以看到这种变化的。</li>
</ul>
<p><strong>这也是之所以说java也是值传递的原因，共享对象传递实际上也是对实参进行拷贝然后赋给形参，但是操作针对的对象不是值而是地址</strong>！</p>
<p>由于传递的是地址的拷贝，所以如果你在方法中将这个地址指向了新的对象，实际上是没有任何对方法外是没有任何作用的，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">&quot;main中：&quot;</span> + p.hashCode());</span><br><span class="line">    change(p);</span><br><span class="line">    System.out.println(<span class="string">&quot;main中：&quot;</span> + p.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">&quot;change中：&quot;</span> + person.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">main中：<span class="number">692404036</span></span><br><span class="line">change中：<span class="number">1554874502</span></span><br><span class="line">main中：<span class="number">692404036</span></span><br></pre></td></tr></table></figure>

<p>可以看到在<code>main</code>方法中输出的hashCode指向的都是同一个对象，而<code>change</code>中指向了另一个，可以这么理解：</p>
<ul>
<li>p为指向了第一个Person对象的地址</li>
<li>把p拷贝了一份得到p‘，这里的p’就是<code>change</code>方法中的形参p</li>
<li><code>change</code>中p指向了一个新的Person对象，在<code>change</code>这个函数范围里p指向的就是new出来的第二个Person对象的地址</li>
<li>由于<code>change</code>中的p实际上是<code>main</code>中p的拷贝p‘，所以在<code>change</code>里p’指向的改变对<code>main</code>中的p不会有任何影响</li>
</ul>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><blockquote>
<p>你在福建有座仓库，给自己配了一把钥匙</p>
</blockquote>
<p>1.三种传递：</p>
<ul>
<li>值传递：你建了一座一模一样的仓库给别人</li>
<li>引用传递：把你家仓库的钥匙给了别人</li>
<li>共享对象传递：把你家仓库钥匙复刻了一把给别人</li>
</ul>
<p>2.共享对象传递的特点：</p>
<ul>
<li>拷贝的地址与原地址指向同一个内存对象：别人用你复刻的钥匙一样能进出你的仓库</li>
<li>拷贝地址引用对象的改变不影响原地址的引用对象：老王在福建泉州也盖了个一模一样仓库，钥匙和你的一模一样，虽然你的仓库比较有名，但是唯独在泉州提到仓库大家都想到的是老王的仓库。你说这把钥匙能开仓库，在泉州大家想到是这把钥匙能开老王的仓库，在其他城市大家想到是能开你的仓库</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis通用底层实现</title>
    <url>/2020/10/16/java/%E9%80%9A%E7%94%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近接触了一些项目，发现很多项目最开始的时候Service接口和实现类一个方法都没有，通过继承通用底层能够使用基本的增删改查操作了。这种骚操作以前听过但是着实没有亲手实现过，今天参考着自己实现一下。</p>
<p><img src="http://img.xiajibagao.top/image-20200922091422581.png" alt="依赖关系图"></p>
<p>以最终我想要获得的自定义接口实现类DemoRStudentClassServicelImpl为例，以下是相关类之间的依赖关系图，不难看出，大体是分成通用的DAO层和建立在前者之上的通用的Service层两部分实现。</p>
<h2 id="一、通用DAO实现"><a href="#一、通用DAO实现" class="headerlink" title="一、通用DAO实现"></a>一、通用DAO实现</h2><h3 id="1-通用底层对象BaseDO"><a href="#1-通用底层对象BaseDO" class="headerlink" title="1.通用底层对象BaseDO"></a>1.通用底层对象BaseDO</h3><p>框架定义了一个基础对象BaseDO，提供一些通用属性，和通用方法，比如创建时间，修改时间等。</p>
<p>所有的对象都需要继承此类，以便在后续操作中使得定义的方法通过泛型接收对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String createBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date createDate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String updateBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date updateDate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRStudentDO</span> <span class="title">extend</span> <span class="title">BaseDO</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-通用底层IBaseDao与自定义Dao"><a href="#2-通用底层IBaseDao与自定义Dao" class="headerlink" title="2.通用底层IBaseDao与自定义Dao"></a>2.通用底层IBaseDao与自定义Dao</h3><p>定义一个<strong>统一的通用底层IBaseDao接口</strong>，里面规定了一些基本的增删改查方法，通过接口泛型去规定接口下方法的返回值，这些自定义的业务对象类同样需要继承BaseDO类。</p>
<p>当我们创建了一个自定义底层DemoRStudentDao的时候，我们只需要让DemoRStudentDao接口直接继承IBaseDao接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用Dao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDO</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(String id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(T bpmClass)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(T bpmClass)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Dao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoRStudentDao</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">DemoRStudentDO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//直接获得IBaseDao中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就能直接获得基本的增删改查方法，其中XML文件的namespace依然直接映射到DemoRStudentDao，当有其他业务需求的时候，直接重写基本方法，或者在DemoRStudentDao中新增方法即可。</p>
<h2 id="二、通用Service实现"><a href="#二、通用Service实现" class="headerlink" title="二、通用Service实现"></a>二、通用Service实现</h2><h3 id="1-通用服务接口IBaseService"><a href="#1-通用服务接口IBaseService" class="headerlink" title="1.通用服务接口IBaseService"></a>1.通用服务接口IBaseService</h3><p>跟IBaseDao一样，我们为通用的服务接口规定出一些基本的增删改查方法，这些方法的返回值同样通过接口泛型指定为任意一个继承了BaseDO的对象类。</p>
<p>然后自定义的service接口直接继承IBaseService，即可获得基本的增删改查方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseService</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDO</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(String id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(T entity)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoRStudentClassService</span> <span class="keyword">extends</span> <span class="title">IBaseService</span>&lt;<span class="title">DemoRStudentClassDO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//直接获得IBaseService中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-通用实现类BaseService"><a href="#2-通用实现类BaseService" class="headerlink" title="2.通用实现类BaseService"></a>2.通用实现类BaseService</h3><p>为了避免还要重复实现基本的增删改查方法，我们需要一个BaseService类去实现IBaseService中的基本方法，自定义的Service通过继承它来获得实现好的基本方法。</p>
<p>因为无论如何，要操作数据就必须得有某个DAO实例，所以在BaseService接口中有一个抽象方法<code>getDao()</code>，这个抽象方法需要我们实现以后返回一个DAO实例，其他的方法都基于这个<code>getDao()</code>来获取DAO实例，有点像代理模式。</p>
<p>所以BaseService是一个抽象类，接口泛型既需要指定继承了BaseDO的对象类，又需要指定继承了IBaseDAO接口的DAO实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDO</span>, <span class="title">K</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">IBaseService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由具体的自定义接口实现类去继承并且实现，注入操作依然放在具体的自定义实现类里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> K 返回一个IbaseDao的子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> K <span class="title">getDao</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDao().get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">list</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDao().list(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        entity.preInsert(String.valueOf(getUserId()));</span><br><span class="line">        <span class="keyword">return</span> getDao().save(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        entity.preUpdate(String.valueOf(getUserId()));</span><br><span class="line">        <span class="keyword">return</span> getDao().update(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDao().remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用自定义的XXXServiceImpl"><a href="#3-使用自定义的XXXServiceImpl" class="headerlink" title="3.使用自定义的XXXServiceImpl"></a>3.使用自定义的XXXServiceImpl</h3><p>我们现在有了通用的底层，该去自己实现一个DemoRStudentClassService去使用它们了。</p>
<ul>
<li><p>首先，我们新建一个Service接口，叫做DemoRStudentClassService，接口继承IBaseService，获取基本的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoRStudentClassServiceService</span> <span class="keyword">extends</span> <span class="title">IBaseService</span>&lt;<span class="title">DemoRStudentClassDO</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，我们新建一个实现类DemoRStudentClassServiceImpl，这个类需要实现DemoRStudentClassService，然后继承BaseService</p>
<p><img src="http://img.xiajibagao.top/image-20201016124611497.png" alt="接口与实现类的关系"></p>
<p>如图所示，DemoRStudentClassService继承了IBaseService接口中的方法，DemoRStudentClassServiceImpl继承了BaseService类，而BaseService类又实现了IBaseService的方法，所以DemoRStudentClassServiceImpl只要继承BaseService就可以自动获得IBaseService的实现方法。</p>
</li>
<li><p>最后，实现BaseService中的<code>getDao()</code>抽象方法，返回注入的DAO实例，让BaseService中的方法有dao可用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRStudentClassServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">DemoRStudentClassDO</span>, <span class="title">DemoRStudentClassDao</span>&gt; <span class="keyword">implements</span> <span class="title">XXXService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoRStudentClassDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DemoRStudentClassDao <span class="title">getDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>到目前为止，在IBaseService中规定的方法都可以直接使用了。如果有必要，可以在自己的Dao或者ServiceImpl类中去重写原方法，或者直接添加新方法。</p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>杂七乱八</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>进程线程，并行并发，同步异步，阻塞费阻塞</title>
    <url>/2020/06/27/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E8%B4%B9%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近接触了 java 并发编程，其中接触到了挺多的新名词：进程，线程，并行，并发，同步，异步，阻塞，非阻塞。其中大部分是其实是操作系统的概念，在这里先简单的提前了解一下，做一下区分。算是为操作系统做个预习。</p>
<h2 id="一、串行，并行，并发"><a href="#一、串行，并行，并发" class="headerlink" title="一、串行，并行，并发"></a>一、串行，并行，并发</h2><h3 id="1-名称解释"><a href="#1-名称解释" class="headerlink" title="1.名称解释"></a>1.名称解释</h3><ul>
<li><p>串行：程序<strong>按顺序</strong>执行，同一时间只能执行一个程序，前一个执行完毕后才轮到后一个</p>
</li>
<li><p>并行：多个程序可以<strong>同时</strong>执行，宏观和微观上看程序都是同时执行</p>
</li>
<li><p>并发：同一时刻只有一条程序执行，但是多<strong>个进程被快速轮换</strong>执行，宏观上看是同时执行，微观上看只是把时间分成若干段，使多个进程快速交替的执行</p>
</li>
</ul>
<p><strong>并发与并行关注的是程序是否在同一时间内同时被执行</strong></p>
<p><img src="http://img.xiajibagao.top/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.png"></p>
<h3 id="2-举个例子"><a href="#2-举个例子" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><ul>
<li>串行：你吃饭吃到一半，电话来了，你一直到吃完了以后才去接</li>
<li>并发：你吃饭吃到一半，电话来了，你接了电话聊了两句，停下来吃了两口饭，又拿起电话聊了两句</li>
<li>并行：你吃饭吃到一半，电话来了，你一边打电话一边吃饭</li>
</ul>
<p>另外：</p>
<blockquote>
<p>当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发（Concurrent）。</p>
<p>当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行（Parallel）。</p>
</blockquote>
<h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-名称解释-1"><a href="#1-名称解释-1" class="headerlink" title="1.名称解释"></a>1.名称解释</h3><ul>
<li>进程：程序程序的一次执行，<strong>是系统进行资源分配</strong>的基本单位，是操作系统结构的基础</li>
<li>线程：有时被称为轻量级进程，是程序执行流的最小单元。线程是进程中的一个实体，<strong>是被系统独立调度和分派的基本单位</strong></li>
</ul>
<p><strong>进程之间资源不共享，而线程之间资源共享（故引入锁以处理资源分配问题）</strong></p>
<h3 id="2-举个例子-1"><a href="#2-举个例子-1" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><ul>
<li>进程：你开了一个迅雷，又开了一个QQ，这分别是两个进程</li>
<li>线程：你在QQ分别和好友a还有好友b聊天，这是QQ这个进程里的两个线程</li>
</ul>
<h2 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h2><h3 id="1-名称解释-2"><a href="#1-名称解释-2" class="headerlink" title="1.名称解释"></a>1.名称解释</h3><ul>
<li><p>同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p>
</li>
<li><p>异步，当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
</li>
</ul>
<p><strong>同步和异步关注的是消息通信机制</strong></p>
<h3 id="2-举个例子-2"><a href="#2-举个例子-2" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><ul>
<li>同步：你去书店买本书，老板说帮你找一下，然后开始找，等到找到了再告诉你结果为止（返回结果）</li>
<li>异步：你去书店买本书，老板说帮你找一下找到再给你打电话（不返回结果），等他找到的就打电话给你（回调）</li>
</ul>
<h2 id="四、阻塞和非阻塞"><a href="#四、阻塞和非阻塞" class="headerlink" title="四、阻塞和非阻塞"></a>四、阻塞和非阻塞</h2><h3 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1.名词解释"></a>1.名词解释</h3><ul>
<li>阻塞：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</li>
<li>非阻塞：调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</li>
</ul>
<p><strong>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态</strong></p>
<h3 id="2-举个例子-3"><a href="#2-举个例子-3" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><ul>
<li>阻塞：你去书店买书，立即买到了，或者没有立刻就走了，这就是非阻塞</li>
<li>非阻塞：你去书店买书，如果恰好书店没有，你就等一直等到书店有了这本书买到了才走，然后后排的人必须等你走了以后才能买书</li>
</ul>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>String类小结</title>
    <url>/2020/08/11/java/String%E7%B1%BB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>java 的 String 类可以说是日常中使用的最多的类，但是大多数时候都只是简单的拼接或者调用 API，只知其然不知其所以然。为了改变这个情况，我决定结合网上的资料，参考源码，深入一点去了解 String 这个熟悉的陌生人。</p>
<p>要第一时间了解一个类，没有什么比官方的javaDoc文档更直观的了：</p>
<blockquote>
<p>String类表示字符串。Java程序中的所有字符串文本（如“abc”）都作为此类的实例实现。</p>
<p><strong>字符串是常量；它们的值在创建后不能更改</strong>。字符串缓冲区支持可变字符串。<strong>因为字符串对象是不可变的，所以可以共享它们</strong>。</p>
<p>类字符串包括用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串以及创建字符串副本的方法，其中所有字符都转换为大写或小写。大小写映射基于Character类指定的Unicode标准版本。</p>
<p><strong>Java语言提供了对字符串连接运算符（+）以及将其他对象转换为字符串的特殊支持。字符串连接是通过<code>StringBuilder</code>（或<code>StringBuffer</code>）类及其<code>append</code>方法实现的。字符串转换是通过<code>toString</code>方法实现的</strong>，由Object定义并由Java中的所有类继承。有关字符串连接和转换的更多信息，请参阅Gosling、Joy和Steele，Java语言规范。</p>
<p>除非另有说明，否则向此类中的构造函数或方法传递null参数将导致引发<code>NullPointerException</code>。<br>字符串表示UTF-16格式的字符串，其中补充字符由代理项对表示（有关详细信息，请参阅<code>Character</code>类中的Unicode字符表示部分）。索引值引用字符代码单位，因此补充字符在字符串中使用两个位置。</p>
<p>除了处理Unicode代码单元（即字符值）的方法外，String类还提供了处理Unicode代码点（即字符）的方法。</p>
</blockquote>
<p>根据文档，对于String类，我们关注三个问题：</p>
<ul>
<li>String对象的不可变性（为什么是不可变的，这么设计的必要性）</li>
<li>String对象的创建方式（两种创建方式，字符串常量池）</li>
<li>String对象的拼接（StringBuffer，StringBuilder，加号拼接的本质）</li>
</ul>
<h2 id="一、String对象的不可变性"><a href="#一、String对象的不可变性" class="headerlink" title="一、String对象的不可变性"></a>一、String对象的不可变性</h2><h3 id="1-String为什么是不可变的"><a href="#1-String为什么是不可变的" class="headerlink" title="1.String为什么是不可变的"></a>1.String为什么是不可变的</h3><p>文档中提到：</p>
<blockquote>
<p>字符串是常量；它们的值在创建后不能更改。</p>
</blockquote>
<p>对于这段话我们结合源码来看;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，String类字符其实就是char数组对象的二次封装，存储变量<code>value[]</code>是被final修饰的，所以一个String对象创建以后是无法被改变值的，这点跟包装类是一样的。</p>
<p>我们常见的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;BBB&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>实际上创建了两个String对象，我们使用 = 只是把s指从AAA的内存地址指向了BBB的内存地址。</p>
<p>我们再看看熟悉的<code>substring()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">        : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在最后也是返回了一个新的String对象，同理，<code>toLowerCase()</code>,<code>trim()</code>等返回字符串的方法也都是在最后返回了一个新对象。</p>
<h3 id="2-String不可变的必要性"><a href="#2-String不可变的必要性" class="headerlink" title="2.String不可变的必要性"></a>2.String不可变的必要性</h3><p>String之所以被设计为不可变的，目的是为了<strong>效率和安全性</strong>：</p>
<ul>
<li>效率：<ol>
<li>String不可变是字符串常量池实现的必要条件，通过常量池可以避免了过多的创建String对象，节省堆空间。</li>
<li>String的包含了自身的HashCode，不可变保证了对象HashCode的唯一性，避免了反复计算。</li>
</ol>
</li>
<li>安全性：<ol>
<li>String被许多Java类用来当参数，如果字符串可变，那么会引起各种严重错误和安全漏洞。</li>
<li>再者String作为核心类，很多的内部方法的实现都是本地调用的，即调用操作系统本地API，其和操作系统交流频繁，假如这个类被继承重写的话，难免会是操作系统造成巨大的隐患。</li>
<li>最后字符串的不可变性使得同一字符串实例被多个线程共享，所以保障了多线程的安全性。而且类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。</li>
</ol>
</li>
</ul>
<h2 id="二、字符串常量池"><a href="#二、字符串常量池" class="headerlink" title="二、字符串常量池"></a>二、字符串常量池</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>文档中有提到：</p>
<blockquote>
<p>因为字符串对象是不可变的，所以可以共享它们</p>
</blockquote>
<p>字符串常量池是一块用于记录字符串常量的特殊区域（具体可以参考我在关于<a href="https://www.cnblogs.com/Createsequence/p/13447923.html">jvm内存结构的文章</a>），JDK8之前字符串常量池在方法区的运行时常量池中，JDK8之后分离到了堆中。“共享”操作就依赖于字符串常量池。</p>
<p>我们知道String是一个对象，而<code>value[]</code>是一个不可变值，所以当我们日常中使用String的时候就会频繁的创建新的String对象。JVM为了提高性能减少内存开销，在通过类似<code>String S = “aaa”</code>这样的操作的时候，<strong>JVM会先检查常量池是否是存在相同的字符串，如果已存在就直接返回字符串实例地址，否则就会先实例一个String对象放到池中，再返回地址</strong>。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;aaa&quot;</span>;  </span><br><span class="line">String s2 = <span class="string">&quot;aaa&quot;</span>; </span><br><span class="line">System.out.print(s1 == s2);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们知道“==”比较对象的时候比较的是内存地址是否相等，当s1创建的时候，一个“aaa”String对象被创建并放入池中，s1指向的是该对象地址；当第二个s2赋值的时候，JVM从常量池中找到了值为“aaa”的字符串对象，于是跳过了创建过程，直接将s1指向的对象地址也赋给了s2.</p>
<h3 id="2-入池方法intern"><a href="#2-入池方法intern" class="headerlink" title="2.入池方法intern()"></a>2.入池方法<code>intern()</code></h3><p>这里要提一下String对象的手动入池方法 <code>intern()</code>。</p>
<p>这个方法的注释是这样的：</p>
<blockquote>
<p>最初为空的字符串池由String类私有维护。</p>
<p>调用intern方法时，如果池已经包含等于<code>equal()</code>方法确定的此String对象的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。</p>
</blockquote>
<p>举个例子说明作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;aabb&quot;</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aabb&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>最开始s1创建了“aabb”对象A，并且加入了字符串常量池，接着s2创建了新的”aabb”对象B，这个对象在堆中并且独立于常量池，此时s1指向常量池中的A，s2指向常量池外的B，所以==返回是false。</p>
<p>我们使用<code>intern()</code>方法手动入池，字符串常量池中已经有了值等于“aabb”的对象A，于是直接返回了对象A的地址，此时s1和s2指向的都是内存中的对象A，所以==返回了true。</p>
<h2 id="三、String对象的创建方式"><a href="#三、String对象的创建方式" class="headerlink" title="三、String对象的创建方式"></a>三、String对象的创建方式</h2><p>从上文我们知道String对象的创建和字符串常量池是密切相关的，而创建一个新String对象有两种方式：</p>
<ul>
<li>使用字面值形式创建。类似 <code>String s = &quot;aaa&quot;</code></li>
<li>使用new关键字创建。类似 <code>String s = new String(&quot;aaa&quot;)</code></li>
</ul>
<h3 id="1-使用字面值形式创建"><a href="#1-使用字面值形式创建" class="headerlink" title="1.使用字面值形式创建"></a>1.使用字面值形式创建</h3><p><img src="http://img.xiajibagao.top/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BAString.png" alt="字面值形式创建String"></p>
<p><strong>当使用字面值创建String对象的时候，会根据该字符串是否已存在于字符串常量池里来决定是否创建新的String对象。</strong></p>
<p>当我们使用类似<code>String s = &quot;a&quot;</code>这样的代码创建字符串常量的时候，JVM会先检查“a”这个字符串是否在常量池中：</p>
<ul>
<li><p><strong>如果存在，就直接将此String对象地址赋给引用s（引用s是个成员变量，它在虚拟机栈中）</strong>；</p>
</li>
<li><p><strong>如果不存在，就会先在堆中创建一个String对象，然后将对象移入字符串常量池，最后将地址赋给s</strong>。 </p>
</li>
</ul>
<h3 id="2-使用new关键字创建"><a href="#2-使用new关键字创建" class="headerlink" title="2.使用new关键字创建"></a>2.使用new关键字创建</h3><p><img src="http://img.xiajibagao.top/new%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%9B%E5%BB%BAString.png" alt="new关键字创建String"></p>
<p><strong>当使用String关键字创建String对象的时候，无论字符串常量池中是否有同值对象，都会创建一个新实例。</strong></p>
<p>看看new调用的的构造函数的注释：</p>
<blockquote>
<p>初始化新创建的字符串对象，使其表示与参数相同的字符序列；换句话说，<strong>新创建的字符串是参数字符串的副本</strong>。除非需要original的显式副本，否则没有必要使用此构造函数，因为字符串是不可变的。</p>
</blockquote>
<p>当我们使用new关键字创建String对象时，和字面值形式创建一样，JVM会检查字符串常量池是否存在同值对象：</p>
<ul>
<li><strong>如果存在，则就在堆中创建一个对象，然后返回该堆中对象的地址</strong>；</li>
<li><strong>否则就先在字符串常量池中创建一个String对象，然后再在堆中创建一个一模一样的对象，然后返回堆中对象的地址</strong>。</li>
</ul>
<p>也就是说，使用字面值创建后产生的对象只会有一个，但是用new创建对象后产生的对象可能会有两个（只有堆中一个，或者堆中一个和常量池中一个）。</p>
<p>我们举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;aabb&quot;</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aabb&quot;</span>);</span><br><span class="line">String s3 = <span class="string">&quot;aa&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;aa&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s4); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，四个String对象是都是相互独立的。</p>
<p>实际上，执行完以后对象在内存中的情况是这样的：</p>
<p><img src="http://img.xiajibagao.top/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%E5%A0%86%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84String%E5%AF%B9%E8%B1%A1.png" alt="代码执行后堆和常量池中的String对象"></p>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h3><ul>
<li>使用new或者字面值形式创建String时都会根据常量池是否存在同值对象而决定是否在常量池中创建对象</li>
<li>使用字面值创建的String，引用直接指向常量池中的对象</li>
<li>使用new创建的String，还会在堆中常量池外再创建一个对象，引用指向常量池外的对象</li>
</ul>
<h2 id="四、String的拼接"><a href="#四、String的拼接" class="headerlink" title="四、String的拼接"></a>四、String的拼接</h2><p>我们知道，String经常会用拼接操作，而这依赖于StringBuilder类。实际上，<strong>字符串类不止有String，还有StringBuilder和StringBuffer</strong>。</p>
<p>简单的来说，StringBuilder和StringBuffer与String的主要区别在于后两者是<strong>可变的字符序列</strong>，每次改变都是针对对象本身，而不是像String那样直接创建新的对象，然后再改变引用。</p>
<h3 id="1-StringBuilder"><a href="#1-StringBuilder" class="headerlink" title="1.StringBuilder"></a>1.StringBuilder</h3><p>我们先看看它的javaDoc是怎么介绍的：</p>
<blockquote>
<p><strong>可变的字符序列</strong>。</p>
<p><strong>此类提供与StringBuffer兼容的API，但不保证同步</strong>。</p>
<p>此类设计为在单线程正在使用StringBuilder的地方来代替StringBuffer。在可能的情况下，建议优先使用此类而不是StringBuffer，因为在大多数实现中它会更快。 </p>
<p>StringBuilder上的主要操作是<code>append()</code>和<code>insert()</code>方法，它们会被重载以接受任何类型的数据。每个有效地将给定的基准转换为字符串，然后将该字符串的字符追加或插入到字符串生成器中。 a<strong>ppend方法始终将这些字符添加到生成器的末尾。 insert方法在指定点添加字符</strong>。</p>
<p>例如:</p>
<p>如果z指向当前内容为“ start”的字符串生成器对象，则方法调用z.append（“ le”）会使字符串生成器包含“ startle”，而z.insert（4，“ le”）将更改字符串生成器以包含“ starlet”。</p>
<p>通常，如果sb引用StringBuilder的实例，则sb.append（x）与sb.insert（sb.length（），x）具有相同的效果。每个字符串生成器都有能力。只要字符串构建器中包含的字符序列的长度不超过容量，就不必分配新的内部缓冲区。如果内部缓冲区溢出，则会自动变大。</p>
<p> StringBuilder实例不能安全地用于多个线程。如果需要这样的同步，则建议使用StringBuffer。除非另有说明，否则将null参数传递给此类中的构造函数或方法将导致引发NullPointerException。</p>
</blockquote>
<p>我们知道这个类的主要作用在于能够动态的扩展（<code>append()</code>）和改变字符串对象（<code>insert()</code>）的值。</p>
<p>我们对比一下String和StringBuilder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，两者的区别在于String实现了Comparable接口而StringBulier继承了抽象类AbstractStringBuilder。后者的扩展性就来自于AbstractStringBuilder。</p>
<p>AbstractStringBuilder中和String一样采用一个<strong>char数组</strong>来保存字符串值，但是这个char数组是未经final修饰，是可变的。</p>
<p>char数组有一个初始大小，跟集合容器类似，当append的字符串长度超过当前char数组容量时，则对char数组进行动态扩展，即重新申请一段更大的内存空间，然后将当前char数组拷贝到新的位置；反之就会适当缩容。</p>
<p>一般是新数组长度默认为：<code>(旧数组长度+新增字符长度) * 2 + 2</code>。(不太准确，想要了解更多的同学可以参考AbstractStringBuilder类源码中的<code>newCapacity()</code>方法)</p>
<h3 id="2-加号拼接与append方法拼接"><a href="#2-加号拼接与append方法拼接" class="headerlink" title="2.加号拼接与append方法拼接"></a>2.加号拼接与append方法拼接</h3><p>我们平时一般都直接对String使用加号拼接，实际上这仍然还是依赖于StringBuilder的<code>append()</code>方法。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这写法实际上编译以后会变成类似这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s = (<span class="keyword">new</span> StringBuilder(String.valueOf(s))).append(<span class="string">&quot;a&quot;</span>).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看见<strong>每一次循环都会生成一个新的StringBuilder对象，这样无疑是很低效的</strong>，也是为什么网上很多文章会说循环中拼接字符串不要使用String而是StringBuilder的原因。因为如果我们自己写就可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显比编译器转换后的写法要高效。</p>
<p>理解了加号拼接的原理，我们也就知道了为什么字符串对象使用加号凭借==返回的是false：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">String s4 = s1 + s2;</span><br><span class="line">String s5 = <span class="string">&quot;ab&quot;</span> + s3;</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s5); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>分析一下上面的过程，<strong>无论 <code>s1 + s2</code>还是 <code>&quot;ab&quot; + s3</code>实际上都调用了StringBuilder在字符串常量池外创建了一个新的对象</strong>，所以==判断返回了false。</p>
<p>值得一提的是，如果我们遇到了“常量+字面值”的组合，是可以看成单纯的字面值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String s3 = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">String s5 = <span class="string">&quot;ab&quot;</span> + s3;</span><br><span class="line">System.out.println(s1 == s5); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>总结一下就是：</p>
<ul>
<li><strong>对于“常量+字面值”的组合，可以等价于纯字面值创建对象</strong></li>
<li><strong>对于包含字符串对象引用的写法，由于会调用StringBuilder类的toString方法生成新对象，所以等价于new的方式创建对象</strong></li>
</ul>
<h3 id="3-StringBuffer"><a href="#3-StringBuffer" class="headerlink" title="3.StringBuffer"></a>3.StringBuffer</h3><p>同样看看它的javaDoc，与StringBuilder基本相同的内容我们跳过：</p>
<blockquote>
<p><strong>线程安全的可变字符序列</strong>。StringBuffer类似于字符串，但是可以修改。</p>
<p>对于**。字符串缓冲区可安全用于多个线程。这些方法在必要时进行同步，以使任何特定实例上的所有操作都表现为好像以某种串行顺序发生，该顺序与所涉及的每个单独线程进行的方法调用的顺序一致。 </p>
<p>… …</p>
<p>请注意，虽然StringBuffer被设计为可以安全地从多个线程中并发使用，但是如果将构造函数或append或insert操作传递给在线程之间共享的源序列，则调用代码必须确保该操作具有一致且不变的视图操作期间源序列的长度。这可以通过调用方在操作调用期间保持锁定，使用不可变的源序列或不跨线程共享源序列来满足。</p>
<p>… …</p>
<p><strong>从JDK 5版本开始，该类已经添加了一个等效类StringBuilder，该类旨在供单线程使用。</strong>通常应优先使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步，因此它比所有此类都优先使用。</p>
</blockquote>
<p>可以知道，StringBuilder是与JDK5之后添加的StringBuffer是“等效类”，两个类功能基本一致，唯一的区别在于<strong>StringBuffer是线程安全的</strong>。</p>
<p>我们查看源码，可以看到<strong>StringBuffer实现线程安全的方式是为成员方法添加<code>synchronized</code>关键字进行修饰</strong>，比如<code>append()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，StringBuffer几乎所有的方法都加了<code>synchronized</code>。这也就不难理解为什么一般情况下StringBuffer效率不如StringBuilder了，因为StringBuffer的所有方法都加了锁。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot使用swagger2生成Api文档</title>
    <url>/2020/02/23/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/Springboot%E4%BD%BF%E7%94%A8swagger2%E7%94%9F%E6%88%90Api%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前开发项目的时候，需要写API文档，项目小接口少的时候一份word就能简单应付，但是随着项目的API的增加，对API文档的维护工作就会越来越繁琐，为此引入能自动生成RESTful接口文档的Swagger2框架就变得理所当然。</p>
<p>作为一个能够自动生成API文档的框架，其最大的优点有两个：</p>
<ol>
<li>接口文档在线能够自动生成，文档随接口变动实时更新，节省维护成本 </li>
<li> 支持类似spring RESTful插件那样的在线接口测试，不依赖第三方工具</li>
</ol>
<h2 id="一、举个例子？"><a href="#一、举个例子？" class="headerlink" title="一、举个例子？"></a>一、举个例子？</h2><p>假设现在有一个TestController接口，里面有几个简单的API，通过swagger的注解添加接口描述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;Api-test&quot;, description = &quot;测试接口&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test/&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiOperation(&quot;获取回复&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;aiTalk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        str.replace(<span class="string">&quot;吗？&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ... ... <span class="comment">//下同，不再赘述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目后访问特定页面即可看到以Controller分类的API文档，点击展开以，根据注解的详细程度，会有传入参数，返回类型等详细说明，除此之外，还会有类似springREST插件那样的在线测试功能</p>
<p><img src="http://img.xiajibagao.top/swagger2.jpg"></p>
<h2 id="二、如何在项目中引入swagger2？"><a href="#二、如何在项目中引入swagger2？" class="headerlink" title="二、如何在项目中引入swagger2？"></a>二、如何在项目中引入swagger2？</h2><h3 id="1-引入Maven依赖"><a href="#1-引入Maven依赖" class="headerlink" title="1.引入Maven依赖"></a>1.引入Maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-在springboot配置使用Swagger"><a href="#2-在springboot配置使用Swagger" class="headerlink" title="2.在springboot配置使用Swagger"></a>2.在springboot配置使用Swagger</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-02-23 13:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：配置swagger2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">adminApiConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .groupName(<span class="string">&quot;huangApi&quot;</span>)</span><br><span class="line">            .apiInfo(adminApiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            .paths(Predicates.and(PathSelectors.regex(<span class="string">&quot;/.*&quot;</span>)))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">adminApiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">            .title(<span class="string">&quot;简单课程表-API文档&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;本文档描述了简单课程表系统的接口定义&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-访问页面"><a href="#3-访问页面" class="headerlink" title="3.访问页面"></a>3.访问页面</h3><p>启动项目，访问 <a href="http://localhost:8080/swagger-ui.html#/">http://localhost:8080/swagger-ui.html#/</a> 即可</p>
<h2 id="三、swagger2注解"><a href="#三、swagger2注解" class="headerlink" title="三、swagger2注解"></a>三、swagger2注解</h2><h3 id="1-Api注解"><a href="#1-Api注解" class="headerlink" title="1.@Api注解"></a>1.@Api注解</h3><p> <strong>用在请求的类上，表示对类的说明</strong> </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>描述类的作用</td>
</tr>
<tr>
<td>tags</td>
<td>说明该类的作用，非空时将覆盖value的值</td>
</tr>
<tr>
<td>protocols</td>
<td>设置特定协议，例：http， https， ws， wss</td>
</tr>
<tr>
<td>hidden</td>
<td>默认为false， 配置为true 将在文档中隐藏</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;Api-test&quot;, tags = &quot;测试接口&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test/&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-ApiOperation注解"><a href="#2-ApiOperation注解" class="headerlink" title="2.  @ApiOperation注解"></a>2.  @ApiOperation注解</h3><p> <strong>用在请求的方法上，说明方法的用途、作用</strong>  </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>描述方法的作用</td>
</tr>
<tr>
<td>tags</td>
<td>说明该方法的作用，非空时将覆盖value的值</td>
</tr>
<tr>
<td>response</td>
<td>返回对象类型（如果该对象类有@ApiModel属性会在文档的Model中列出）</td>
</tr>
<tr>
<td>httpMethod</td>
<td>指定HTTP方法，”GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH”</td>
</tr>
<tr>
<td>hidden</td>
<td>默认为false， 配置为true 将在文档中隐藏</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;获取课程表&quot;,response = CourseSchedule.class, httpMethod = &quot;GET&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.GET, path =  &quot;getCourseSchedule&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CourseSchedule <span class="title">getCourseSchedule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CourseSchedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-ApiImplicitParams注解"><a href="#3-ApiImplicitParams注解" class="headerlink" title="3.  @ApiImplicitParams注解"></a>3.  @ApiImplicitParams注解</h3><p>@ApiImplicitParam注解，用在@ApiImplicitParams注解中，表示一组参数的说明</p>
<p>@ApiParam注解，用在单个参数上，是对单个参数的说明</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>参数的说明</td>
</tr>
<tr>
<td>name</td>
<td>参数名，参数名称可以覆盖方法参数名称，路径参数必须与方法参数一致</td>
</tr>
<tr>
<td>required</td>
<td>参数是否必须传，默认为false(路径参数必填)</td>
</tr>
<tr>
<td>defaultValue</td>
<td>参数的默认值</td>
</tr>
<tr>
<td>paramType</td>
<td>参数应该怎么传给接口：<br>1.“header”对应spring@RequestHeader注解标记的参数；<br>2.“query”对应spring@RequestParam注解标记的参数；<br>3.“path”对应spring@PathVariable注解标记的参数；<br></td>
</tr>
<tr>
<td>dataType</td>
<td>参数类型</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;str&quot;, value = &quot;字符串&quot;, required = false, dataType = &quot;String&quot;, paramType = &quot;query&quot;),</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;id&quot;, required = true, dataType = &quot;Integer&quot;, paramType = &quot;query&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@GetMapping(path =  &quot;call&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@ApiParam(name = &quot;str&quot;, value = &quot;字符串&quot;, required = false)</span> String str,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@ApiParam(name = &quot;id&quot;, value = &quot;id&quot;, required = true)</span> Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;吱一声以表示项目运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-ApiModel注解"><a href="#4-ApiModel注解" class="headerlink" title="4.  @ApiModel注解"></a>4.  @ApiModel注解</h3><p>  <strong>用在请求的类上，表示对类的说明</strong> </p>
<p> <strong>@ApiModelProperty注解</strong></p>
<p><strong>用在被@ApiModel标记了的类的属性上，用于描述类的属性</strong></p>
<p> 注：此注解一般用于响应类上，比如使用@RequestBody注解直接接收对象作为参数的时候，多用于创建或更新</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>此属性的简要说明</td>
</tr>
<tr>
<td>name</td>
<td>允许覆盖属性名称</td>
</tr>
<tr>
<td>allowableValues</td>
<td>限制参数的可接受值，有以下几种：<br>1.以逗号分隔的列表<br/>2.范围值<br/>3.设置最小值/最大值</td>
</tr>
<tr>
<td>example</td>
<td>属性的示例</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2019-12-11 12:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：考试安排实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiModel(&quot;考试安排实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamSchedule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;课程名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;考场&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String examClassroom;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;考试时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String examDate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;当前时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;当前学期&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nowDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果被标记的类有被 @ApiOperation注解的response属性引用的话，在文档页面的Model可以看到</p>
<p><img src="http://img.xiajibagao.top/model.jpg"></p>
<h2 id="四、使用knife4j对swagger进行增强"><a href="#四、使用knife4j对swagger进行增强" class="headerlink" title="四、使用knife4j对swagger进行增强"></a>四、使用knife4j对swagger进行增强</h2><h3 id="1-什么是knife4？"><a href="#1-什么是knife4？" class="headerlink" title="1.什么是knife4？"></a>1.什么是knife4？</h3><p>knife4j是为JavaMVC框架集成Swagger生成Api文档的增强解决方案 ，在Swagger的基础上进行了各方面的增强，比如接口排序，一键导出markdown，word，pdf等功能，以及一个逻辑更加清晰而美观的功能，最重要的是，这些实用功能不需要改动任何原有的注释或者代码，只需要加一个依赖！tql！！！</p>
<p>地址： <a href="https://doc.xiaominfo.com/">https://doc.xiaominfo.com/</a> </p>
<h3 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2.简单使用"></a>2.简单使用</h3><p>在原有swagger2依赖下引入knife4j依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用knife4j对swagger进行增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后就可以用了！</p>
<p>没错，原本的 <a href="http://localhost:8080/swagger-ui.html#/">http://localhost:8080/swagger-ui.html#/</a> 页面访问完全不受影响，但是通过<a href="http://localhost:8080/doc.html%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AEknife4j%E5%8A%A0%E5%BC%BA%E5%90%8E%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8080/doc.html即可访问knife4j加强后的页面，效果如下：</a></p>
<p><img src="http://img.xiajibagao.top/knife.jpg"></p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>算法时间复杂度</title>
    <url>/2020/06/27/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>衡量一个算法的好坏，最简单的标准就是他的时间复杂度。</p>
<blockquote>
<p>算法的<strong>时间复杂度</strong>（Time complexity）是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。</p>
<p>时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。</p>
<p>例如，如果一个算法对于任何大小为 <em>n</em> （必须比 <em>n0</em> 大）的输入，它至多需要 5<em>n</em>3 + 3<em>n</em> 的时间运行完毕，那么它的渐近时间复杂度是 O(<em>n</em>3).</p>
</blockquote>
<h2 id="一、时间频度"><a href="#一、时间频度" class="headerlink" title="一、时间频度"></a>一、时间频度</h2><p>要理解时间复杂度，需要先理解时间频度，而时间频度简单的说，就是<strong>算法中语句的执行次数</strong>。</p>
<p>举个例子：</p>
<p>要计算1+2+…+100，现在有两种算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        total+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = (<span class="number">1</span> + n)*n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看见，对于<code>fun1()</code>这个方法，不管n多大，永远需要执行n+1次，也就是说他的时间频度是T(n)=n+1,</p>
<p>而对与<code>fun2()</code>来说，不管n多大都只需要执行1次，所以他的时间频度T(n)=1。</p>
<p><strong>当n趋向无穷大时，有三个忽略</strong>：</p>
<h3 id="1-忽略常数项"><a href="#1-忽略常数项" class="headerlink" title="1.忽略常数项"></a>1.忽略常数项</h3><p>比如T(n)=2n+1，当n趋向无穷大时，可以忽略常数项1；</p>
<p>参见下图：</p>
<ul>
<li>2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略 </li>
<li>3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略</li>
</ul>
<p><img src="http://img.xiajibagao.top/20200627133030.png"></p>
<h3 id="2-忽略低次项"><a href="#2-忽略低次项" class="headerlink" title="2.忽略低次项"></a>2.忽略低次项</h3><p>比如T(n)=2n+3n^8，当n趋向无穷大时，可以忽略低次项及其系数2n；</p>
<p>参见下图：</p>
<ul>
<li>2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10     </li>
<li>n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20</li>
</ul>
<p><img src="http://img.xiajibagao.top/20200627133038.png"></p>
<h3 id="3-忽略系数"><a href="#3-忽略系数" class="headerlink" title="3.忽略系数"></a>3.忽略系数</h3><p>比如T(n)=2n^8，当n趋向无穷大时，可以忽略系数2。</p>
<p>参见下图：</p>
<ul>
<li>随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。 </li>
<li>而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键</li>
</ul>
<p><img src="http://img.xiajibagao.top/20200627133027.png"></p>
<h2 id="二、时间复杂度"><a href="#二、时间复杂度" class="headerlink" title="二、时间复杂度"></a>二、时间复杂度</h2><p>我们现在理解了时间频度的T(n)的含义，假设当有一个辅助函数f(n)，使得<strong>当n趋近无穷大时</strong>，T(n)/f(n)的极限值为不等于0的常数，就叫f(n)为T(n)的同量级函数，记作T(n)=O(f(n))，</p>
<p>称O(f(n))为算法的<strong>时间渐进复杂度</strong>，也就是<strong>时间复杂度</strong>。</p>
<p>又根据时间频度T(n)的“三个忽略”原则，我们可以知道时间复杂度是这样得到的：</p>
<ol>
<li>忽略所有常数</li>
<li>只保留函数中的最高阶项</li>
<li>去掉最高阶项的系数</li>
</ol>
<p>举个例子：</p>
<p>某算法T(n)=2n^3+4n-5，按步骤走：</p>
<ol>
<li>T(n)=2n^3+4n</li>
<li>T(n)=2n^3</li>
<li>T(n)=n^3</li>
</ol>
<p>即可得该算法时间复杂度为O(n^3)</p>
<h2 id="三、常见时间复杂度"><a href="#三、常见时间复杂度" class="headerlink" title="三、常见时间复杂度"></a>三、常见时间复杂度</h2><p>这里按复杂度从低到高列举常见的时间复杂度：</p>
<ol>
<li><p>常数阶O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对数阶O(log2n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据公式有 n = 2^x，也就是 x = log2n，x即为循环代码执行次数，所以时间复杂度为O(log2n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        i = i *<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线性阶O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般来说，只要代码里只有一个循环结构，即输入规模和执行次数呈线性相关，那这个代码的时间复杂度就都是O(n) 。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        n+=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线性对数阶O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以简单理解为对数阶的程序被放入了循环结构中，也就是n*O(logn)，下面的代码的复杂度就是O(nlog2n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            j = j *<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>平方阶O(n²)，立方阶O(n^3)，K次方阶O(n^k)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平方阶可以简单理解为线性阶中嵌套一个线性阶，也就是O(logn)*O(logn)，下面的代码复杂度就是O(n^2)</span></span><br><span class="line"><span class="comment">// 立方阶同理，就是三个线性阶的嵌套，K次方阶同理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; i++)&#123;</span><br><span class="line">			i=i+j;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="四、复杂度的四个概念"><a href="#四、复杂度的四个概念" class="headerlink" title="四、复杂度的四个概念"></a>四、复杂度的四个概念</h2><ol>
<li>最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。</li>
<li>最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。</li>
<li>平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示</li>
<li>均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</li>
</ol>
<p>举个例子：</p>
<p>长度为n的数组查找一个给定元素k</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == k)&#123;</span><br><span class="line">            <span class="comment">//找到了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个方法，最好的情况下元素k就在数组第一位，复杂度为O(1)，但是最坏的情况下，元素k在数组最后一位，复杂度为O(n)。</p>
<p>同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，我们引入这4个概念，当然，在大多数时候我们是不用特意区分这四种情况的。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>总结一下如何快速判断程序的时间复杂度：</p>
<ul>
<li>只关注循环最多的那部分代码</li>
<li>总复杂度等于量级最大的那段代码的复杂度</li>
<li>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ul>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（一）：工厂模式</title>
    <url>/2020/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>工厂模式（Factory Pattern）属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<p>工厂模式旨在与解决接口实现类选择这一类问题，让实例创建的代码使用实例的方法解耦。</p>
<p>当我们需要根据不同的明确条件下创建不同的实例的时候，就可以使用工厂模式。</p>
<p>工厂模式分为三类：</p>
<ul>
<li>工厂方法模式：一个工厂生产固定的一个类。</li>
<li>简单/静态工厂模式：一个工厂生产固定种类的多个类。</li>
<li>抽象工厂模式：一个抽象工厂生产一</li>
</ul>
<h2 id="一、工厂方法模式"><a href="#一、工厂方法模式" class="headerlink" title="一、工厂方法模式"></a>一、工厂方法模式</h2><p>假设我们有一个导出报表的抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件导出接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Exporter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">export</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他现在有一个Excel导出实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Excel导出实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelExporter</span> <span class="title">extend</span> <span class="title">Exporter</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String modelPath;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出Excel:&quot;</span>+<span class="string">&quot;模板路径：&quot;</span>+ modelPath +<span class="string">&quot;文件名：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExcelExporter</span><span class="params">(String modelPath, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelPath = modelPath;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要在一个方法里去调用它，让客户可以导出报表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从配置中读取模板路径</span></span><br><span class="line">String modelPath = Config.getExcelModelPath();</span><br><span class="line"><span class="comment">//获取文件名</span></span><br><span class="line">String fileName = name + Config.getExcelLastName(); </span><br><span class="line">ExcelExporter ee = <span class="keyword">new</span> ExcelExporter(modelPath, fileName);</span><br><span class="line"><span class="comment">//一些其他业务逻辑</span></span><br><span class="line">... ...</span><br><span class="line">ee.export();</span><br></pre></td></tr></table></figure>

<p>我们在很多方法都需要调用这个类，但是每次使用都要写那么多行代码，实在太麻烦，而且万一忽然modelPath或者fileName这些参数要改，那工程量也很让人头痛。</p>
<p>所以我们可以把获取对象的操作提出来，把读取配置路径等方法都单独提出来，最后统一放到一个工厂类里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Excel文件导出实现类的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelExporterFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExcelLastName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Config.getExcelLastName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModePath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Config.getExcelModelPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExcelExporter <span class="title">getExporter</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExcelExporter(getModePath(),getExcelLastName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后使用的时候不需要在意实例化的过程，只需要调用方法获取新对象就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExcelExporterFactory factory = <span class="keyword">new</span> ExcelExporterFactory();</span><br><span class="line">factory.getExcelExporter().export();</span><br></pre></td></tr></table></figure>

<p>值得一提的是，由于工厂的特殊性，它大多数情况下都是单例的。</p>
<p>不难发现，工厂方法模式有以下优点：</p>
<ul>
<li>1:客户端不需要在负责对象的创建,<strong>明确了各个类的职责</strong>；</li>
<li>2:如果有<strong>新的对象增加</strong>,只需要<strong>增加一个具体的类和具体的工厂类</strong>即可；</li>
<li>3:<strong>不会影响已有的代码</strong>,后期维护容易,增强系统的扩展性。</li>
</ul>
<h2 id="二、简单-静态工厂"><a href="#二、简单-静态工厂" class="headerlink" title="二、简单/静态工厂"></a>二、简单/静态工厂</h2><p>工厂方法模式确实好，但是有时候我们需要用工厂生产的往往只有特定的几个类，其他的直接new就可以了。这种情况下在<strong>为每一个类单独创建一个工厂类太过麻烦，为此我们让一个工厂去生产固定的那几种类</strong>，这就是简单/静态工厂。</p>
<p>假设我们目前只需要导出Excel和word类型的报表，我们在上一个例子的基础上再加一WordExporter实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Excel导出实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordExporter</span> <span class="title">extend</span> <span class="title">Exporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String modelPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出Word！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordExporter</span><span class="params">(String modelPath, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelPath = modelPath;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们改造一下原本的ExcelExporterFactory，让他也能生产WordExporter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件导出实现类的简单工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExporterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExcelLastName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Config.getExcelLastName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModePath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Config.getExcelModelPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exporter <span class="title">getExporter</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据条件返回对应的实例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;word&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WordExporter(getModePath(),getExcelLastName());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;excel&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExcelExporter(getModePath(),getExcelLastName());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;导出类型不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们要调用的时候，直接通过工厂调用就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExporterFactory factory = <span class="keyword">new</span> ExporterFactory();</span><br><span class="line">factory.getExcelExporter(type).export();</span><br></pre></td></tr></table></figure>

<p>这个就是<strong>简单工厂</strong>。</p>
<p>在简单工厂的基础上，我们不难看出，现在的ExporterFactory总是只能生产固定的那几种类，那么其实调用<code>getExporter()</code>去获取实现类的时候根本没必要new一个新工厂。</p>
<p>于是我们将这个工程里的所有方法都变成静态方法，调用的时候就很方便了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExportService es = ExporterFactory.getExporter(type);</span><br></pre></td></tr></table></figure>

<p>这个就是<strong>静态工厂</strong>。</p>
<h2 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h2><p>简单工厂对工厂方法做了减法，简化了代码结构，但是简单工厂违背了开闭原则，如果要添加新的产品，就需要修改工厂类代码。而传统的工厂方法模式，如果有很多产品的情况下又会创建过多的工厂类。</p>
<p>为此，我们对工厂方法模式做加法，就有了抽象工厂模式：由顶层的抽象工厂提供生产产品的接口，具体的生产过程由继承了抽象工厂的子工厂去实现。</p>
<p>举个例子：</p>
<p>根据上文，我们现在有了Exporter接口，和两个实现类ExcelExporter和WordExporter，现在我们有了新的需求：</p>
<p>导出的报表要分成两种类型：有数据的表格和没有数据的表格。（empty）</p>
<h3 id="1-产品的抽象"><a href="#1-产品的抽象" class="headerlink" title="1.产品的抽象"></a>1.产品的抽象</h3><p>我们先对产品进行抽象：</p>
<p>Exporter这个类不管是否有数据，都需要导出方法 <code>export()</code>，然后根据表格是否有数据，还需要一个方法 <code>empty()</code>。</p>
<p>我们将其分为由原本的ExcelExporter和WordExporter也变成抽象类，只实现各种的<code>export()</code>方法，然后再针对ExcelExporter和WordExporter再拆分，得到无数据表格类EmptyExcelExporter，EmptyWordExporter，有数据表格类FullExcelExporter，FullWordExporter。</p>
<p><img src="http://img.xiajibagao.top/image-20200926191804858.png" alt="抽象工厂生产产品的抽象"></p>
<h3 id="2-工厂的抽象"><a href="#2-工厂的抽象" class="headerlink" title="2.工厂的抽象"></a>2.工厂的抽象</h3><p>由于产品的层级变成了三层，原本用于生产WordExporter和ExcelExporter的工厂ExporterFactory也要进行拆分。</p>
<p>将ExporterFactory变为接口，里面规定了<code>getExcelExporter()</code>和<code>getWordExporter()</code>两个接口方法，然后由EmptyExporterFactory还有FullExporterFactory工厂去</p>
<p><img src="http://img.xiajibagao.top/image-20200926192545919.png" alt="工厂类的抽象"></p>
<p>不难看出，抽象工厂通过多了一层抽象，减少了工厂类的数量，但是当要添加一类产品，比如加一个导出PDF类，同样要修改ExporterFactory及其实现类。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用七牛云图床</title>
    <url>/2020/06/04/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/Typora%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最早之前博客一直是用有道云笔记写的，后面接触了 markdown 后改用 Typora 方便了不少，但是上传的时候图片仍然还要另外上传，着实麻烦。于是决定用七牛云自己搭一个图床。</p>
<h2 id="一、创建并上传文件到存储空间"><a href="#一、创建并上传文件到存储空间" class="headerlink" title="一、创建并上传文件到存储空间"></a>一、创建并上传文件到存储空间</h2><h3 id="1-注册七牛账号，并且实名认证"><a href="#1-注册七牛账号，并且实名认证" class="headerlink" title="1.注册七牛账号，并且实名认证"></a>1.注册七牛账号，并且实名认证</h3><h3 id="2-创建储存空间"><a href="#2-创建储存空间" class="headerlink" title="2.创建储存空间"></a>2.创建储存空间</h3><p>打开侧边栏，选择对象存储</p>
<p><img src="http://img.xiajibagao.top/20200604140435.png"></p>
<p>选择新建空间</p>
<p><img src="http://img.xiajibagao.top/20200604141608.png"></p>
<ul>
<li>存储空间名称：按规则随便取</li>
<li>存储区域：选择离靠近的地区</li>
<li>访问控制：选择<strong>公开</strong>，否则<strong>外网无法访问，没法作为图床</strong></li>
</ul>
<h3 id="3-上传文件"><a href="#3-上传文件" class="headerlink" title="3.上传文件"></a>3.上传文件</h3><p><img src="http://img.xiajibagao.top/20200604141529.png" alt="image-20200604115247758"></p>
<ul>
<li><p>选择文件管理，点击上传文件即可上传</p>
</li>
<li><p>不绑定私有域名时默认外链域名即为官方分配的30天有效临时域名，</p>
<p>如果绑定私有域名可以选择私有域名</p>
</li>
<li><p>点击详情即可预览图片</p>
</li>
<li><p>点击更多，选中复制外链即可获得图片外链</p>
<p><img src="http://img.xiajibagao.top/20200604140440.png"></p>
</li>
</ul>
<p>获取外链之后直接输入浏览器网址栏，或者在代码里引用就行了！</p>
<h2 id="二、创建二级域名并解析到七牛云CNAME"><a href="#二、创建二级域名并解析到七牛云CNAME" class="headerlink" title="二、创建二级域名并解析到七牛云CNAME"></a>二、创建二级域名并解析到七牛云CNAME</h2><p>七牛云默认会每隔30天重新分配一个临时的测试域名，也就是说，过了30天域名重置以后，之前的外链就全部失效，为了预防这种情况，我们需要绑定一个自己的私人域名。</p>
<p>如果没有私人域名的话参考这个方案：</p>
<p><a href="https://blog.csdn.net/qinglianchen0851/article/details/84257005">七牛：测试域名过期？自己域名又没备案？这里有一招完美解决你烦恼</a></p>
<p>如果有的话可以继续往下看</p>
<h3 id="1-设置存储空间域名绑定"><a href="#1-设置存储空间域名绑定" class="headerlink" title="1.设置存储空间域名绑定"></a>1.设置存储空间域名绑定</h3><p><img src="http://img.xiajibagao.top/20200604141616.png"></p>
<ul>
<li><p>选择自定义域名，添加一条你要绑定的子域名，其他设置不需要动，添加完保存即可</p>
<p>子域名格式需要为：主机记录.域名，比如<code>img.xxxxx.com</code>这样</p>
</li>
<li><p>配置完成后鼠标移至CNAME按钮上，复制<code>CNAME</code></p>
<p>比如我的配置就是<code>img-xxxxx-top-idvc2rp.qiniudns.com</code></p>
</li>
</ul>
<h3 id="2-前往域名服务商创建二级域名"><a href="#2-前往域名服务商创建二级域名" class="headerlink" title="2.前往域名服务商创建二级域名"></a>2.前往域名服务商创建二级域名</h3><p>以阿里云为例：</p>
<p>进入控制台打开侧边栏 –》选择域名解析 –》选择要创建二级域名的根域名 –》 解析设置</p>
<p><img src="http://img.xiajibagao.top/20200604141622.png" alt="image-20200604133425532"></p>
<p>进入解析设置后选择添加记录以创建二级域名</p>
<p><img src="http://img.xiajibagao.top/20200604140441.png"></p>
<ul>
<li><p>记录类型，创建子域名，类型选择<code>CNAME</code>，</p>
<p>因为之后图床会绑定子域名，需要直接将子域名解析到图床去</p>
</li>
<li><p>主机记录：即二级域名，之前存储仓库填什么这里就填什么</p>
<p>比如之前如果填的<code>img.xxxx.com</code>，这里主机记录就填<code>img</code></p>
</li>
<li><p>记录值：这里直接黏贴之前存储仓库复制的CNAME</p>
</li>
</ul>
<h3 id="3-使用二级域名代替默认测试域名"><a href="#3-使用二级域名代替默认测试域名" class="headerlink" title="3.使用二级域名代替默认测试域名"></a>3.使用二级域名代替默认测试域名</h3><p>先测试看看是否已经解析成功：</p>
<p>打开cmd，然后输入<code>nslookup 二级域名</code>，看看第一条是否解析到配置的CNAME值</p>
<p><img src="http://img.xiajibagao.top/20200604141627.png"></p>
<p>如果有说明解析已经成功了。</p>
<p><img src="http://img.xiajibagao.top/20200604141630.png" alt="image-20200604132815077"></p>
<p>回到存储仓库，此时外链域名可以选自己添加的二级域名了，切换到二级域名，然后保存为默认域名，之后引用的图片外链就会变成<code>二级域名/图片文件名</code>的格式了</p>
<h2 id="三、下载并安装PicGo"><a href="#三、下载并安装PicGo" class="headerlink" title="三、下载并安装PicGo"></a>三、下载并安装PicGo</h2><p>现在图床基本可以使用了，但是为了能更方便的管理，最重要的是能跟Typora无缝衔接，我们还需要PicGo辅助，</p>
<p>PicGo<a href="https://github.com/Molunerfinn/PicGo/tags">下载地址</a>，选择版本并且根据自己的操作系统选择对应的安装包即可。</p>
<p>安装好后打开界面是这样的：</p>
<p><img src="http://img.xiajibagao.top/20200604141634.png" alt="image-20200604134354105"></p>
<p>选择图床设置里的七牛图床：</p>
<p><img src="http://img.xiajibagao.top/20200604141636.png" alt="image-20200604132153288"></p>
<ul>
<li>设定AK和SK：前往七牛云个人中心 –》密匙管理复制黏贴即可</li>
<li>设定储存空间名：和七牛存储空间名称一致</li>
<li>设定访问网站：即你的二级域名，这里<strong>需要在域名之前加上http://</strong></li>
</ul>
<p>然后点确认保存设置，回到上传区选项即可上传图片到图床。</p>
<ul>
<li>上传图片成功后剪贴板会自动获取图片引用的外链</li>
<li>在相册可以查看通过PicGo上传过的图片</li>
</ul>
<p>然后我们需要打开Server：</p>
<p><img src="http://img.xiajibagao.top/20200604141547.png" alt="image-20200604132637321"></p>
<p><img src="http://img.xiajibagao.top/20200604140447.png" alt="image-20200604134431620"></p>
<p>开启端口监听后确认即可。</p>
<h2 id="四、Typora配置图片上传"><a href="#四、Typora配置图片上传" class="headerlink" title="四、Typora配置图片上传"></a>四、Typora配置图片上传</h2><h3 id="1-配置上传服务设定"><a href="#1-配置上传服务设定" class="headerlink" title="1.配置上传服务设定"></a>1.配置上传服务设定</h3><p>设置好PicGo后来到Typora进行配置：</p>
<p><img src="http://img.xiajibagao.top/20200604140448.png" alt="image-20200604134151633"></p>
<p>打开偏好设置 –》图像 –》 上传服务设定</p>
<ul>
<li>上传服务：选择PicGo</li>
<li>PicGo路径：选择PicGo安装根目录的.exe文件</li>
</ul>
<h3 id="2-上传图片"><a href="#2-上传图片" class="headerlink" title="2.上传图片"></a>2.上传图片</h3><p>上传图片有三种方式：</p>
<ul>
<li><p>加入图片时直接上传</p>
<p>在偏好设置 –》图像 –》插入图片时 设置</p>
</li>
<li><p>对图片右键上传</p>
</li>
<li><p>在格式 –》图像 –》 上传所有本地图片</p>
</li>
</ul>
<p>如果出现报错，一般是端口被占用，可以打开PicGo的server看看端口是否还是36677，改变了的话改回来就好了。</p>
<p>如果还出现其他报错，可以参考这篇文章：</p>
<p><a href="https://www.jianshu.com/p/4cd14d4ceb1d">手把手教你用Typora自动上传到picgo图床【教程与排坑】</a></p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP知识小结</title>
    <url>/2020/08/19/Spring/SpringAOP%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>提起Spring，必然就会联想到AOP（面向切面编程）和IOC（控制反转）这两个词，众所周知，Spring框架对这两种思想进行了很好的实现。</p>
<p>在这篇文章，我将大致的介绍Spring对AOP这思想的实现流程。</p>
<p>对于AOP，关注的两个问题：</p>
<ul>
<li>什么是是AOP/IOC？</li>
<li>AOP/IOC解决了什么问题？</li>
</ul>
<h2><span id="一-什么是aop">一、什么是AOP</span></h2><blockquote>
<p>Aspect oriented programming 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续。</p>
</blockquote>
<p>我们知道，根据面向对象编程的思想，对于一些具有相同属性和方法的类，我们可以抽象出他们共同部分作为一个父类，然后这些子类通过继承来获得他们共同的属性。比如<code>Cat</code>类和<code>Dog</code>都有<code>eat()</code>方法，那么我们可以将<code>eat()</code>方法抽象到他们的父类<code>Animal</code>，让他们去继承父类。</p>
<p>我们管这个抽取成类的方法叫做<strong>纵向抽取</strong>。</p>
<p>而如果他们的父类的方法中有相同方法，那么就直接抽取成公共方法。，但是有一些一开始就耦合到业务逻辑里的重复代码，比如下面统计方法执行时间的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//计时</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;eat.....&quot;</span>);</span><br><span class="line">    <span class="comment">//结束计时</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行时长：&quot;</span> + (System.currentTimeMillis() - start)/<span class="number">1000f</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这些方法实际上是难以抽离的，因为他们实际上已经耦合到了业务逻辑里。这部分代码，又叫做<strong>横切逻辑代码</strong>。</p>
<p><img src="http://img.xiajibagao.top/%E6%A8%AA%E5%90%91%E5%88%87%E5%89%B2.png" alt="横向切割"></p>
<p>我们可以看到，通过对方法增加一个进行一个<strong>横向抽取</strong>来抽取重复的方法。这个方式<strong>不会改变原有的业务逻辑代码</strong>。</p>
<p>现在就不难理解AOP为啥叫面向切面编程了：</p>
<ul>
<li>切指横切逻辑：原有业务代码不动，只操作横切逻辑代码；</li>
<li>以方法为线，横切逻辑代码为点，很多点构成了一个横切面。</li>
</ul>
<h2><span id="二-aop的实现原理">二、AOP的实现原理</span></h2><h3><span id="1静态代理">1.静态代理</span></h3><p>说到AOP，就得先理解一下什么叫代理模式：</p>
<blockquote>
<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>
</blockquote>
<p>我们举个例子，首先有一个接口，叫做购房者，然后这个类地下有一个实现类，叫做小明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//购房者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 买房</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小明实现了购房者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> <span class="keyword">implements</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小明买了一套房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>买房子还要货比三家，小明没时间，于是就把买房子这件事情委托给中介</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intermediary</span> <span class="keyword">implements</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XiaoMing xiaoMing ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明把权限委托给了中介</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Intermediary</span><span class="params">(XiaoMing xiaoMing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.xiaoMing = xiaoMing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这基础上又添加了挑选方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;房中介先帮吗挑了最合适的房&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中介让XiaoMing这个类执行了购房的动作</span></span><br><span class="line">        xiaoMing.buy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这基础上又添加了抽成方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;买完房中介要那点抽成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://img.xiajibagao.top/%E5%B0%8F%E6%98%8E%E4%B9%B0%E6%88%BF%EF%BC%88%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89.png" alt="小明买房（静态代理）"></p>
<p>在这个例子里：</p>
<ul>
<li>被代理对象是小明这个类，是我们最终要访问的；</li>
<li>代理对象就是中介这个类，他是被代理对象的加强，我们通过代理对象去访问目标对象，在这基础上对其进行加强。</li>
</ul>
<p>为了做到代理的效果，代理对象和目标对象<strong>需要实现同一个接口或者继承同一个类</strong>，以达到通过代理对象的方法去调用被代理对象的方法。这种方法叫做<strong>静态代理</strong>。</p>
<p>通过静态代理，我们可以在不改变代理类代码的基础上进行方法增强，但是如果有很多这样的代理行为，那么就需要很多代理类或者代理类去实现很多接口的方法，这样做显然会来带麻烦，为此，我们可以选择只在需要的时候才生产代理对象，这就是动态代理。</p>
<p>针对动态代理，有两种实现方法：</p>
<ul>
<li>JDK 代理，通过 JDK 的 API 实现；</li>
<li>CGLib 代理，通过 CGLib 包实现。</li>
</ul>
<h3><span id="2jdk代理">2.JDK代理</span></h3><p>JDK 代理仍然需要被代理去实现某个接口，因为 JDK 代理的方式本质仍然还是生成一个与被代理类继承同一个接口的类，去代替被代理类的方法提供调用，但是和静态代理不同，这个代理对象由代码在调用的时候动态生成。</p>
<p>我们可以先看看实现代理效果的核心方法<code>Proxy.newProxyInstance()</code>的注释：</p>
<blockquote>
<p>返回指定接口的代理类的实例，该实例将方法调用分派到指定的调用处理程序。 </p>
<p>参数：</p>
<p><code>ClassLoader loader</code>：指定加载被代理对象的类加载器</p>
<p><code>Class&lt;?&gt;[] interfaces</code>：被代理对象实现的接口的类型,使用泛型方式确认类型</p>
<p><code>InvocationHandler h</code>：事件处理,执行被代理对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
</blockquote>
<p>我们需要提供三个参数，被代理类的类的加载器，被代理类实现的结构，一个代理方法要实现的函数式接口。</p>
<p>对于函数式接口 <code>InvocationHandler</code>，我们不妨再看看他的参数：</p>
<blockquote>
<p><code>proxy</code>：在方法上调用方法的代理实例method-与在代理实例上调用的接口方法相对应的Method实例。 </p>
<p><code>Method</code>：对象的声明类将是在其中声明该方法的接口，它可能是代理类通过其继承该方法的代理接口的超接口。</p>
<p> <code>args</code> ：包含在代理实例的方法调用中传递的参数值的对象数组；如果接口方法不带参数，则为null。基本类型的参数包装在适当的基本包装器类的实例中，例如java.lang.Integer或java.lang.Boolean。</p>
</blockquote>
<p>可以说非常直观了，下面我们来简单实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    XiaoMing xiaoMing = <span class="keyword">new</span> XiaoMing();</span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    Buyers proxyBuyers = (Buyers) Proxy.newProxyInstance(</span><br><span class="line">        <span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">        xiaoMing.getClass().getClassLoader(),</span><br><span class="line">        <span class="comment">//获取被代理对象实现的接口</span></span><br><span class="line">        xiaoMing.getClass().getInterfaces(),</span><br><span class="line">        <span class="comment">//让代理对象实现被代理对象实现的接口</span></span><br><span class="line">        (proxy, method, params) -&gt; &#123;</span><br><span class="line">            <span class="comment">//只有对buy方法进行加强，如果不是buy方法就直接执行被代理对象的方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.getName() != <span class="string">&quot;buy&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(xiaoMing, params);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;中介帮小明找到了最合适的房源&quot;</span>);</span><br><span class="line">            method.invoke(xiaoMing, params);</span><br><span class="line">            System.out.println(<span class="string">&quot;中介抽了一笔中介费&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//通过代理对象买房</span></span><br><span class="line">    proxyBuyers.buy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">中介帮小明找到了最合适的房源</span><br><span class="line">小明买了一套房</span><br><span class="line">中介抽了一笔中介费</span><br></pre></td></tr></table></figure>

<p>我们可以看看实现代理效果的核心方法<code>Proxy.newProxyInstance()</code>的注释：</p>
<blockquote>
<p>返回指定接口的代理类的实例，该实例将方法调用分派到指定的调用处理程序。 </p>
<p>参数：</p>
<p><code>ClassLoader loader</code>：指定加载被代理对象的类加载器</p>
<p><code>Class&lt;?&gt;[] interfaces</code>：被代理对象实现的接口的类型,使用泛型方式确认类型</p>
<p><code>InvocationHandler h</code>：事件处理,执行被代理对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
</blockquote>
<h3><span id="3cglib代理">3.CGLib代理</span></h3><p>对于动态代理，我们可以通过JDK的<code>Proxy.newProxyInstance()</code>方法动态的生成一个实现了被代理类指定接口的代理类，那么，如果<strong>被代理类没有实现任何接口</strong>，那我们该怎么办呢？答案就是使用 CGLib 代理。</p>
<p>CGLib 代理的原理就是在内存里创建一个被代理类的对象的子类，然后重写父类要加强的方法，而无需加强的方法就直接使用父类方法。</p>
<p>要使用 CGLib 代理，需要引入 CGLib 包（Spring的动态代理就是基于Cglib实现的，所以Spring的依赖里会有这个）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XiaoMing xiaoMing = <span class="keyword">new</span> XiaoMing();</span><br><span class="line"><span class="comment">//获取代理对象</span></span><br><span class="line">Buyers proxyBuyers = (Buyers) Enhancer.create(</span><br><span class="line">    <span class="comment">//获取被代理对象的类</span></span><br><span class="line">    xiaoMing.getClass(),</span><br><span class="line">    <span class="comment">//实现代理逻辑切入类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o 代理类对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> method 要拦截的被代理类的方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> objects 被代理类的方法参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodProxy 要触发父类的方法对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName() != <span class="string">&quot;buy&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">//注意，这里参数是o，调用的是invokeSuper</span></span><br><span class="line">                <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;中介帮小明找到了最合适的房源&quot;</span>);</span><br><span class="line">            <span class="comment">//注意，这里参数是xiaoMing，调用的是invoke</span></span><br><span class="line">            methodProxy.invoke(xiaoMing, objects);</span><br><span class="line">            System.out.println(<span class="string">&quot;中介抽了一笔中介费&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">proxyBuyers.buy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般为了方便使用，我们会将代理过程整合到一个代理工厂类中。</p>
<p><strong>由于需要生成子类，所以要被代理的类最好不能用 final 修饰</strong></p>
<h3><span id="4如何选择代理模式">4.如何选择代理模式</span></h3><ul>
<li>JDK在创建代理对象时的性能要高于 CGLib 代理，而生成代理对象的运行性能却比 CGLib 的低。</li>
<li>如果是单例的代理，推荐使用 CGLib</li>
</ul>
<p>也就是说，<strong>如果需要频繁的创建代理对象（多例），那么就该选择JDK代理，否则（单例）使用CGLib代理</strong></p>
<h3><span id="5其他aop实现">5.其他AOP实现</span></h3><p>除了代理模式以外，还有其他的实现：AspectJ，以及 JBoss API 等，其中 AspectJ 应该是知名度最高的，它常常以注解的形式出现在我们的代码中。</p>
<blockquote>
<p>AspectJ是<strong>语言级别</strong>的 AOP 实现，扩展了 Java 语言，定义了 AOP 语法，能够在<strong>编译期</strong>提供横切代码的织入，所以它有<strong>专门的编译器</strong>用来生成遵守Java字节码规范的 Class 文件。</p>
</blockquote>
<h2><span id="三-aop">三、AOP</span></h2><h3><span id="1aop的术语">1.AOP的术语</span></h3><ul>
<li><p>连接点（Join point）：SpringAOP基于动态代理实现，是方法拦截，也就是每一个成员方法都是连接点</p>
</li>
<li><p>切点（Poincut）：具体定位的连接点</p>
</li>
<li><p>增强/通知（Advice）：添加到切点的一段代码，并且定位切点的方位信息。</p>
<p>SpringAOP提供了<strong>前置，后置，返回，异常，环绕</strong>五种。</p>
</li>
<li><p>织入（weaving）：将增强/通知添加到连接点上的过程</p>
</li>
<li><p>引入/引介（Introduction）：允许我们向当前类<strong>添加新方法或者属性</strong>，是一种特色增强。</p>
</li>
<li><p>切面（Aspect）：切面由切点和增强/通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义。</p>
</li>
</ul>
<blockquote>
<p>通知/增强包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知/增强被应用的具体位置。其中关键的是切点定义了哪些连接点会得到通知/增强。</p>
</blockquote>
<h3><span id="2aop的使用方式">2.AOP的使用方式</span></h3><p>有三种：</p>
<ul>
<li>基于代理实现的AOP：需要实现接口手动创建</li>
<li>纯粹POJOO切面：使用XML配置AOP命名空间</li>
<li>@AspectJ驱动的切面：使用注解</li>
</ul>
<h3><span id="3spring提供的增强方式">3.Spring提供的增强方式</span></h3><p>总共有五种：</p>
<p><img src="http://img.xiajibagao.top/Spring%E4%BA%94%E7%A7%8D%E5%A2%9E%E5%BC%BA%E7%B1%BB%E5%9E%8B.png" alt="Spring五种增强类型"></p>
<h3><span id="4切点类型">4.切点类型</span></h3><p>总共有六种：</p>
<p><img src="http://img.xiajibagao.top/Spring%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%AD%E7%A7%8D%E5%88%87%E7%82%B9%E7%B1%BB%E5%9E%8B.png" alt="Spring提供的六种切点类型"></p>
<h3><span id="5切面类型">5.切面类型</span></h3><p>三种：</p>
<ul>
<li>一般切面</li>
<li>切点切面</li>
<li>引介/引入切面</li>
</ul>
<p><img src="http://img.xiajibagao.top/%E5%88%87%E9%9D%A2%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="切面类继承关系"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基本操作</title>
    <url>/2019/09/02/Docker/Docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2><span id="一-docker常用命令">一、Docker常用命令</span></h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#镜像名			版本标签			镜像id			 创建时间			镜像大小</span></span><br><span class="line"><span class="string">REPOSITORY</span>          <span class="string">TAG</span>                 <span class="string">IMAGE</span> <span class="string">ID</span>            <span class="string">CREATED</span>             <span class="string">SIZE</span></span><br><span class="line"><span class="string">hello-world</span>         <span class="string">latest</span>              <span class="string">fce289e99eb9</span>        <span class="number">6</span> <span class="string">months</span> <span class="string">ago</span>        <span class="number">1.</span><span class="string">84kB</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">version/info</span> <span class="comment">#查看版本/信息</span></span><br><span class="line"><span class="string">docker</span> <span class="string">--help</span> <span class="comment">#查看说明文档</span></span><br><span class="line"><span class="string">docker</span> <span class="string">logs</span> <span class="string">-f</span> <span class="string">-t</span> <span class="string">--tail</span> <span class="string">日志条数</span> <span class="string">容器ID</span> <span class="comment">#查看容器日志</span></span><br><span class="line"><span class="string">docker</span> <span class="string">inspect</span> <span class="comment">#获取容器/镜像的元数据</span></span><br></pre></td></tr></table></figure>



<h2><span id="二-镜像基本操作">二、镜像基本操作</span></h2><h3><span id="1-拉取">1. 拉取</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">search</span> [<span class="string">xxx</span>] <span class="comment">#查找名为xxx的镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">pull</span> [<span class="string">xxx</span>]<span class="string">：版本号</span> <span class="comment"># 拉取xxx镜像，不加版本号则默认拉取最新版本</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-查看">2. 查看</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">images</span> <span class="string">-a/-qa</span> <span class="comment">#列出本地全部镜像/全部镜像的ID</span></span><br></pre></td></tr></table></figure>

<p><img src="http://img.xiajibagao.top/docker%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F.PNG"></p>
<h3><span id="3-删除">3. 删除</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">rmi</span> <span class="string">-f</span> [<span class="string">xxx</span>] <span class="comment">#删除名为xxx的镜像，加-f为强制删除（不论现在正在运行）</span></span><br><span class="line"><span class="string">docker</span> <span class="string">rmi</span> <span class="string">$(docker</span> <span class="string">images</span> <span class="string">-q)</span> <span class="comment">#删除所有镜像</span></span><br></pre></td></tr></table></figure>

<p>注意：要拉取的镜像名确认不要写错，否则会报错（repository does not exist or may require ‘docker login’）</p>
<h3><span id="4-导出镜像">4. 导出镜像</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存镜像到指定目录</span></span><br><span class="line"><span class="comment">#这里的原image名和版本号需要与要保存的镜像一致</span></span><br><span class="line"><span class="string">docker</span> <span class="string">save</span>  <span class="string">镜像ID</span> <span class="string">-o</span> <span class="string">d:\dockerimages\新image名.tar</span> <span class="string">原image名:版本号</span></span><br></pre></td></tr></table></figure>

<h3><span id="5-导入镜像">5. 导入镜像</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从指定目录加载镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">load</span> <span class="string">-i</span> <span class="string">\dockerimages\新image名.tar</span></span><br></pre></td></tr></table></figure>



<h2><span id="三-容器基本操作">三、容器基本操作</span></h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-i为以交互模式启动容器</span></span><br><span class="line"><span class="comment">#-t为容器重新分配一个伪输入终端（两者合写为-it）</span></span><br><span class="line"><span class="comment">#--name为容器命名，不加则默认自动分配</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">--name</span> <span class="string">mycentos</span> <span class="string">centos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建守护式容器</span></span><br><span class="line"><span class="comment">#直接在后台创建一个容器，但是如果容器里没有活动则会在创建后立刻自动停止</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-d</span> <span class="string">centos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8080为docker服务对外暴露的端口，8080指docker内的tomcat端口</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-p</span> <span class="number">8080</span><span class="string">:8080</span> <span class="string">tomcat</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-查看">1. 查看</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="comment">#查看当前运行的容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="string">-l</span> <span class="comment">#列出最近创建的容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="string">-a</span> <span class="comment">#列出当前和曾经运行的容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="string">-n</span> <span class="string">x</span> <span class="comment">#显示最近运行过的n个容器</span></span><br><span class="line"><span class="comment">#在以上基础上变为 -xq 可以只显示容器编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果找不到命令，则可能为该镜像没有包含procps工具</span></span><br><span class="line"><span class="string">apt-get</span> <span class="string">update</span> <span class="string">&amp;&amp;</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">procps</span></span><br></pre></td></tr></table></figure>

<p><img src="http://img.xiajibagao.top/docker%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8.PNG"></p>
<h3><span id="2-进入">2.  进入</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在已运行的容器中，执行命令，操作对象是容器，如果你要进入已运行的容器，并且执行命令，用exec；</span></span><br><span class="line"><span class="string">docker</span> <span class="string">exec</span> <span class="string">-it</span> <span class="string">容器名/容器ID</span> <span class="string">/bin/bash</span></span><br><span class="line"><span class="comment">#同样操作的是已运行的容器，可以将本机标准输入（键盘输入）输到容器中，也可以将容器的输出显示在本机的屏幕上，如果你想查看容器运行过程中产生的标准输入输出，用attach；</span></span><br><span class="line"><span class="string">docker</span> <span class="string">attach</span> <span class="string">容器名/容器ID</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-停止">3. 停止</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">stop</span> <span class="string">容器名/容器ID</span> <span class="comment">#停止单个</span></span><br><span class="line"><span class="string">docker</span> <span class="string">stop</span> <span class="string">$(docker</span> <span class="string">ps</span> <span class="string">-a</span> <span class="string">-q)</span> <span class="comment">#停止全部</span></span><br><span class="line"><span class="string">docker</span> <span class="string">kill</span> <span class="string">容器名/容器ID</span> <span class="comment">#强制停止</span></span><br></pre></td></tr></table></figure>

<h3><span id="4-退出">4. 退出</span></h3><p>需要注意的是，容器停止后里面的数据就直接销毁了，所有如果没有提交镜像还没有备份，最好不要直接使用exit退出容器</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">exit</span> <span class="comment">#容器停止并退出</span></span><br><span class="line"><span class="string">ctrl+P+Q</span> <span class="comment">#容器不停止退出（非常重要！！！！！！！）</span></span><br></pre></td></tr></table></figure>

<h3><span id="5-删除">5. 删除</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">rm</span> <span class="string">容器名/容器ID</span> <span class="comment">#删除单个</span></span><br><span class="line"><span class="string">docker</span> <span class="string">rm</span> <span class="string">$(docker</span> <span class="string">ps</span> <span class="string">-a</span> <span class="string">-q)</span> <span class="comment">#删除全部</span></span><br></pre></td></tr></table></figure>

<p>注意：rm为删除容器，rmi为删除镜像</p>
<h3><span id="6-提交容器">6. 提交容器</span></h3><p>如果想要重复使用当前容器，可以将容器提交成镜像，那样下次使用时就可以直接拉取镜像并启动容器即可</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker commit <span class="attribute">-m</span>=<span class="string">&quot;描述信息&quot;</span> <span class="attribute">-a</span>=<span class="string">&quot;作者&quot;</span> 容器ID 要创建的新镜像名:版本号</span><br></pre></td></tr></table></figure>

<h3><span id="7-从容器中拷贝文件到主机中">7. 从容器中拷贝文件到主机中</span></h3><p>顾名思义，将容器中的文件拷贝到主机，如日志或者sql文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">cp</span> <span class="string">容器名/容器ID:文件位置</span> <span class="string">/root</span></span><br></pre></td></tr></table></figure>

<h3><span id="8-docker安装mysql">8. docker安装mysql</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-p</span> <span class="number">3306</span><span class="string">:3306</span> <span class="string">--name</span> <span class="string">mymysql</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/mysqlfile/conf:/etc/mysql/conf.d</span> <span class="comment">#挂载容器数据卷（可不带）</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/mysqlfile/logs:/logs</span> <span class="comment">#挂载容器数据卷（可不带）</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/mysqlfile/data:/var/lib/mysql</span> <span class="comment">#挂载容器数据卷（可不带）</span></span><br><span class="line"><span class="string">-e</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span> <span class="comment">#设置默认用户名</span></span><br><span class="line"><span class="string">-d</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">exec</span> <span class="string">-it</span> <span class="string">mymysql</span> <span class="string">/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以root身份登录</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-uroot</span> <span class="string">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选择mysql</span></span><br><span class="line"><span class="string">use</span> <span class="string">mysql;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果navicat远程连接报1521错误</span></span><br><span class="line"><span class="string">GRANT</span> <span class="string">ALL</span> <span class="string">ON</span> <span class="string">*.*</span> <span class="string">TO</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;;</span> <span class="comment">#远程连接授权</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">BY</span> <span class="string">&#x27;password&#x27;</span> <span class="string">PASSWORD</span> <span class="string">EXPIRE</span> <span class="string">NEVER;</span> <span class="comment">#更改加密规则</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">WITH</span> <span class="string">mysql_native_password</span> <span class="string">BY</span> <span class="string">&#x27;123456&#x27;</span><span class="string">;</span> <span class="comment">#更改密码</span></span><br><span class="line"><span class="string">FLUSH</span> <span class="string">PRIVILEGES;</span> <span class="comment">#刷新权限</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2><span id="四-容器数据卷">四、容器数据卷</span></h2><p>用于数据保存和持久化,简单的理解，就是容器和主机共享的一个公共硬盘，举个例子，原本tomcat部署应用，或者查看日志还需要进入容器，现在将日志文件夹和部署文件夹拿出来挂载到主机，就可以在不进入容器的情况下查看日志或者部署项目</p>
<h3><span id="1-直接构建容器数据卷">1.  直接构建容器数据卷</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接把容器内文件夹挂在到主机文件夹上</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/宿主机绝对路径:/容器内目录</span> <span class="string">镜像名</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在主机根目录下创建MyDockerCentos文件夹，在centos容器中创建MyDockerCentos01文件夹</span></span><br><span class="line"><span class="comment">#挂载成功后，MyDockerCentos01文件夹内容即可共享在MyDockerCentos文件夹内的内容</span></span><br><span class="line"><span class="comment">#添加ro则该文件夹为只读</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/MyDockerCentos:/MyDockerCentos01</span> <span class="string">or</span> <span class="string">centos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过容器元数据查看挂载情况</span></span><br><span class="line"><span class="string">docker</span> <span class="string">inspect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在json中可以看到此段文字</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">&quot;Mounts&quot;:</span> [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;Type&quot;:</span> <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Source&quot;:</span> <span class="string">&quot;/MyDockerCentos&quot;</span>, <span class="comment">#此为主机挂载文件夹路径</span></span><br><span class="line">                <span class="attr">&quot;Destination&quot;:</span> <span class="string">&quot;/MyDockerCentos01&quot;</span>, <span class="comment">#此为容器挂载文件夹路径</span></span><br><span class="line">                <span class="attr">&quot;Mode&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;RW&quot;:</span> <span class="literal">true</span>, <span class="comment">#若为只读，则&quot;RW&quot;为false</span></span><br><span class="line">                <span class="attr">&quot;Propagation&quot;:</span> <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]<span class="string">,</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h3><span id="2通过dockerfile构建容器数据卷">2.通过DockerFile构建容器数据卷</span></h3><p>关于DockerFile，具体介绍见下文</p>
<h4><span id="21-编写一个构建docker镜像的脚本">2.1 编写一个构建docker镜像的脚本</span></h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在当前跟根目录新建mydockerfile</span></span><br><span class="line"><span class="string">vim</span> <span class="string">mydockerfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写入以下命令</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">centos</span></span><br><span class="line"><span class="string">VOLUME</span> [<span class="string">&quot;/dataVolumeContainer1&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>]</span><br><span class="line"><span class="string">CMD</span> <span class="string">echo</span> <span class="string">&quot;create success!&quot;</span></span><br><span class="line"><span class="string">CMD</span> <span class="string">/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：可以理解为</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/host1:/dataVolumeContainer1</span> <span class="string">-v</span> <span class="string">/host2:/dataVolumeContainer1</span> <span class="string">centeros</span> <span class="string">/bin/bash</span></span><br></pre></td></tr></table></figure>

<h5><span id="22-执行dockerfile">2.2 执行dockerfile</span></h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意：命令最后有一个“ . ”，请务必带不要忘记</span></span><br><span class="line"><span class="string">docker</span> <span class="string">build</span> <span class="string">-f</span> <span class="string">/mydocker/mydockerfile</span> <span class="string">-t</span> [<span class="string">新镜像名字</span>] <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行完后打印信息</span></span><br><span class="line">[<span class="string">root@iZwz9ev02los7q1d71e7muZ</span> <span class="string">mydocker</span>]<span class="comment"># docker build -f /mydocker/mydockerfile -t centos .</span></span><br><span class="line"><span class="string">Sending</span> <span class="string">build</span> <span class="string">context</span> <span class="string">to</span> <span class="string">Docker</span> <span class="string">daemon</span>  <span class="number">2.</span><span class="string">048kB</span></span><br><span class="line"><span class="attr">Step 1/4 :</span> <span class="string">FROM</span> <span class="string">centos</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">9f38484d220f</span> <span class="comment">#此为文件中指定的镜像模板ID</span></span><br><span class="line"><span class="attr">Step 2/4 :</span> <span class="string">VOLUME</span> [<span class="string">&quot;/dataVolumeContainer1&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>]</span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">Running</span> <span class="string">in</span> <span class="string">2b7657366a63</span></span><br><span class="line"><span class="string">Removing</span> <span class="string">intermediate</span> <span class="string">container</span> <span class="string">2b7657366a63</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">abec456be739</span></span><br><span class="line"><span class="attr">Step 3/4 :</span> <span class="string">CMD</span> <span class="string">echo</span> <span class="string">&quot;create success!&quot;</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">Running</span> <span class="string">in</span> <span class="string">9e043eaa69dd</span></span><br><span class="line"><span class="string">Removing</span> <span class="string">intermediate</span> <span class="string">container</span> <span class="string">9e043eaa69dd</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">ff5086933e91</span></span><br><span class="line"><span class="attr">Step 4/4 :</span> <span class="string">CMD</span> <span class="string">/bin/bash</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">Running</span> <span class="string">in</span> <span class="string">046617fa2f7a</span></span><br><span class="line"><span class="string">Removing</span> <span class="string">intermediate</span> <span class="string">container</span> <span class="string">046617fa2f7a</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">0245ba1fc082</span> <span class="comment">#根据此id新运行一个容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新运行一个容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">0245ba1fc082</span> <span class="string">/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看根目录所有文件后可见</span></span><br><span class="line">[<span class="string">root@2ca987ed7f70</span> <span class="string">/</span>]<span class="comment"># ll</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">drwxr-xr-x</span>  <span class="number">2</span> <span class="string">root</span> <span class="string">root</span>  <span class="number">4096 </span><span class="string">Jul</span> <span class="number">31</span> <span class="number">15</span><span class="string">:06</span> <span class="string">dataVolumeContainer1</span> <span class="comment">#dataVolumeContainer1</span></span><br><span class="line"><span class="string">drwxr-xr-x</span>  <span class="number">2</span> <span class="string">root</span> <span class="string">root</span>  <span class="number">4096 </span><span class="string">Jul</span> <span class="number">31</span> <span class="number">15</span><span class="string">:06</span> <span class="string">dataVolumeContainer2</span> <span class="comment">#dataVolumeContainer2</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5><span id="23-查看数据卷情况">2.3 查看数据卷情况</span></h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看该容器元信息</span></span><br><span class="line"><span class="string">docker</span> <span class="string">inspect</span> <span class="string">2ca987ed7f70</span></span><br><span class="line"><span class="comment">#可知当未指定文件夹在主机的路径时，则默认创建在/var/lib/docker/volumes目录下</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">&quot;Mounts&quot;:</span> [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;Type&quot;:</span> <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Name&quot;:</span> <span class="string">&quot;008c479311eb38775908647c6f89cebbed368107a418a385ee58b5461341db0b&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Source&quot;:</span> <span class="string">&quot;/var/lib/docker/volumes/008c479311eb38775908647c6f89cebbed368107a418a385ee58b5461341db0b/_data&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Destination&quot;:</span> <span class="string">&quot;/dataVolumeContainer2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Driver&quot;:</span> <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Mode&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;RW&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">&quot;Propagation&quot;:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;Type&quot;:</span> <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Name&quot;:</span> <span class="string">&quot;fdbf4a0b6921b7950a214f8bf028cf00edad091870e523bd694a984cc87fac30&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Source&quot;:</span> <span class="string">&quot;/var/lib/docker/volumes/fdbf4a0b6921b7950a214f8bf028cf00edad091870e523bd694a984cc87fac30/_data&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Destination&quot;:</span> <span class="string">&quot;/dataVolumeContainer1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Driver&quot;:</span> <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Mode&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;RW&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">&quot;Propagation&quot;:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]<span class="string">,</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h2><span id="五-dockerfile脚本">五、DockerFile脚本</span></h2><h3><span id="1-dockerfile简介">1. DockerFile简介</span></h3><p>生成docker镜像的脚本,类似于.bat批处理文件，构建容器的时候会按脚本执行构建，如果在里面写好预先写好环境配置的相关命令，那么执行完脚本以后，就能直接得到一个已经配置好环境的容器</p>
<h3><span id="2-dockerfile指令">2. DockerFile指令</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="comment">#基础镜像，指定</span></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="comment">#镜像维护者信息</span></span><br><span class="line"><span class="string">RUN</span> <span class="comment">#容器构建时需要运行的命令</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="comment">#当前容器对外暴露的端口</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="comment">#主机进入容器后的所在的默认路径位置</span></span><br><span class="line"><span class="string">ENV</span> <span class="comment">#用于在构建镜像的过程中设置环境变量</span></span><br><span class="line"><span class="string">COPY/ADD</span> <span class="comment">#将主机文件拷贝至镜像，若ADD则还会自动解压压缩包和出来URL</span></span><br><span class="line"><span class="string">VOLUME</span> <span class="comment">#容器数据卷，用于数据保存和持久化</span></span><br><span class="line"><span class="string">CMD</span> <span class="comment">#指定容器启动时要运行的命令（脚本中可以有多个，但是只有最后一个生效）</span></span><br><span class="line"><span class="string">ENTRYPOINT</span> <span class="comment">#同CMD，但是不会被docker run之后的参数覆盖</span></span><br><span class="line"><span class="string">ONBUILD</span> <span class="comment">#父镜像被子镜像继承后触发</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-dockerignore">3. dockerignore</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代表根目录（上下文环境目录中）中以abc开头的任意直接子目录或者直接子文件将被忽略</span></span><br><span class="line"><span class="comment">#如/abc  abc.txt</span></span><br><span class="line"><span class="string">/abc*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代表根目录（上下文环境目录中）中任意直接子目录中以abc开头的任意直接子目录或者直接子文件将被忽略</span></span><br><span class="line"><span class="comment">#如 /file/abc  /file/abc.txt</span></span><br><span class="line"><span class="string">*/abc*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代表根目录（上下文环境目录中）中任意两级目录下以abc开头的任意直接子目录或者直接子文件将被忽略</span></span><br><span class="line"><span class="comment">#如 /file1/file2/abc  /file1/file2/abc.txt</span></span><br><span class="line"><span class="string">*/*/abc*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#排除根目录中的文件和目录，其名称是单字符扩展名temp。例如，/tempa与/tempb被排除在外。</span></span><br><span class="line"><span class="string">temp?</span>	</span><br><span class="line"></span><br><span class="line"><span class="comment">#Docker还支持一个**匹配任意数量目录（包括零）的特殊通配符字符串</span></span><br><span class="line"><span class="string">**/abc*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以!（感叹号）开头的行可用于对排除项进行例外处理,比如原本包含了README.md这个文件的过滤，但是加了如下一行后</span></span><br><span class="line"><span class="comment">#就不会再过滤README.md，依然会将其提交到守护进程。</span></span><br><span class="line"><span class="type">!README.md</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#异常规则的放置位置会影响行为</span></span><br><span class="line"><span class="string">*.md</span></span><br><span class="line"><span class="type">!README*.md</span></span><br><span class="line"><span class="string">README-secret.md</span></span><br><span class="line"><span class="comment">#README-secret.md 仍然会被忽略</span></span><br><span class="line">	</span><br><span class="line"><span class="string">*.md</span></span><br><span class="line"><span class="string">README-secret.md</span></span><br><span class="line"><span class="type">!README*.md</span></span><br><span class="line"><span class="comment">#README-secret.md 不会被忽略</span></span><br><span class="line"></span><br><span class="line"><span class="string">您甚至可以使用该.dockerignore文件来排除Dockerfile和.dockerignore文件。这些文件仍然发送到守护程序，因为它需要它们来完成它的工作。但是ADD和COPY命令不会将它们复制到图像中。</span></span><br></pre></td></tr></table></figure>



<h2><span id="六-dockerfile实战">六、DockerFile实战</span></h2><h3><span id="1使用dockerfile自定义一个centos镜像">1.使用DockerFile自定义一个centos镜像</span></h3><p><strong>第一步，编写脚本</strong>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FORM</span> <span class="string">centos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ENV mypath /temp #设置一个环境变量</span></span><br><span class="line"><span class="comment">#WORKDIR $mypath #设置默认进入容器的路径，指向环境变量所规定的路径</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">vim</span> <span class="string">-y</span> <span class="comment">#安装vim</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">tree</span> <span class="string">-y</span> <span class="comment">#安装tree</span></span><br><span class="line"></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">80</span> <span class="comment">#暴露出80端口</span></span><br><span class="line"></span><br><span class="line"><span class="string">CMD</span> <span class="string">echo</span> <span class="string">&quot;success!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">CMD</span> <span class="string">/bin/bash</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步，运行脚本</strong>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">build</span> <span class="string">-f</span> <span class="string">/mydocker/dockerfile/mydockerfile2</span> <span class="string">-t</span> <span class="string">mycentos</span> <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用命令查看容器历史可见</span></span><br><span class="line"><span class="string">docker</span> <span class="string">history</span> <span class="string">22d8bbae3a6f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#顺序加载，倒序执行</span></span><br><span class="line"><span class="string">IMAGE</span>               <span class="string">CREATED</span>             <span class="string">CREATED</span> <span class="string">BY</span>                              		<span class="string">SIZE</span>   </span><br><span class="line"><span class="string">22d8bbae3a6f</span>        <span class="number">3</span> <span class="string">hours</span> <span class="string">ago</span>         <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">tree</span> <span class="string">-y</span> <span class="comment">#安装tree          23MB         </span></span><br><span class="line"><span class="string">b77e4249fba5</span>        <span class="number">3</span> <span class="string">hours</span> <span class="string">ago</span>         <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">vim</span> <span class="string">-y</span> <span class="comment">#安装vim            167MB       </span></span><br><span class="line"><span class="string">9f38484d220f</span>        <span class="number">4</span> <span class="string">months</span> <span class="string">ago</span>        <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]              0B         </span></span><br><span class="line"><span class="string">&lt;missing&gt;</span>           <span class="number">4</span> <span class="string">months</span> <span class="string">ago</span>        <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="comment">#(nop)  LABEL org.label-schema.sc…     0B         </span></span><br><span class="line"><span class="string">&lt;missing&gt;</span>           <span class="number">4</span> <span class="string">months</span> <span class="string">ago</span>        <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="comment">#(nop) ADD file:074f2c974463ab38c…     202MB </span></span><br></pre></td></tr></table></figure>

<p>注意：如果无法解决权限问题报错，可以进入dockerfile文件夹后运行程序</p>
<h3><span id="2自定义一个带jdk和tomcat的centos">2.自定义一个带jdk和tomcat的centos</span></h3><p><strong>第一步，编写脚本</strong>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">centos</span></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="string">huang&lt;841396397@qq.com&gt;</span></span><br><span class="line"><span class="comment">#把主机下的目录tomcat和jdk添加至容器，这里脚本与安装包在同一路径下</span></span><br><span class="line"><span class="string">ADD</span> <span class="string">apache-tomcat-8.5.43.tar.gz</span> <span class="string">/usr/local</span></span><br><span class="line"><span class="string">ADD</span> <span class="string">jdk-8u221-linux-i586.tar.gz</span> <span class="string">/usr/local</span></span><br><span class="line"><span class="comment">#安装插件</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">vim</span> <span class="string">-y</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">wget</span> <span class="string">-y</span> </span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">tree</span> <span class="string">-y</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">bash-completion</span> <span class="string">-y</span></span><br><span class="line"><span class="comment">#设置访问时的容器路径</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">MYPATH</span> <span class="string">/usr/local</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">$MYPATH</span></span><br><span class="line"><span class="comment">#配置JDK和tomcat环境 </span></span><br><span class="line"><span class="string">ENV</span> <span class="string">JAVA_HOME</span> <span class="string">/usr/local/jdk1.8.0_221</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">CLASSPATH</span> <span class="string">$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">CATALINA_HOME</span> <span class="string">/usr/local/apache-tomcat-8.5.43</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">CATALINA_BASE</span> <span class="string">/usr/local/apache-tomcat-8.5.43</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">PATH</span> <span class="string">$PATH:$JAVA_HOME/lib:$CATALINA_HOME/lib:$$CATALINA_HOME/bin</span></span><br><span class="line"><span class="comment">#容器运行时监听的端口</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line"><span class="string">CMD</span> <span class="string">/usr/local/apache-tomcat-8.5.43/bin/startup.sh</span> <span class="string">&amp;&amp;</span> <span class="string">tail</span> <span class="string">-F</span> <span class="string">/usr/local/apache-tomcat-8.5.43/bin/logs/catalina.out</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步，运行脚本</strong>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">build</span> <span class="string">-f</span> <span class="string">/mydocker/dockerfile/tomcat</span> <span class="string">-t</span> <span class="string">mytomcat</span> <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行成功</span></span><br><span class="line"><span class="string">REPOSITORY</span>          <span class="string">TAG</span>                 <span class="string">IMAGE</span> <span class="string">ID</span>            <span class="string">CREATED</span>             <span class="string">SIZE</span></span><br><span class="line"><span class="string">mytomcat</span>            <span class="string">latest</span>              <span class="string">71e04bed14cd</span>        <span class="number">9</span> <span class="string">seconds</span> <span class="string">ago</span>       <span class="string">859MB</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步，启动容器</strong>：</p>
<p>注意：配置tomcat和jdk参考 ” linux常用操作 “</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器暴露端口，名称</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-p</span> <span class="number">8001</span><span class="string">:8080</span> <span class="string">--name</span> <span class="string">mycat</span></span><br><span class="line"><span class="comment">#创建两个容器数据卷</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/tomcatfile/webapp:/usr/local/apache-tomcat-8.5.43/webapp</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/tomcatfile/logs:/usr/local/apache-tomcat-8.5.43/logs</span></span><br><span class="line"><span class="string">--privileged=true</span></span><br><span class="line"><span class="comment">#镜像模板</span></span><br><span class="line"><span class="string">mytomcat</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#容器启动</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS           </span><br><span class="line">edd612a7f92f        mytomcat            &quot;/bin/sh -c &#x27;/usr/lo…&quot;   <span class="number">24</span> seconds ago      Up <span class="number">23</span> seconds  </span><br><span class="line"></span><br><span class="line">PORTS                    NAMES</span><br><span class="line"><span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">8001</span>-&gt;<span class="number">8080</span>/tcp   mycat</span><br></pre></td></tr></table></figure>

<h2><span id="七-使用阿里云镜像仓库管理镜像">七、使用阿里云镜像仓库管理镜像</span></h2><p>选中镜像仓库管理首页的镜像仓库选项，根据提示创建命名空间和镜像仓库，并绑定github或其他代码托管平台账号</p>
<h3><span id="1-打包镜像">1. 打包镜像</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把成功运行的容器打包成镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">commit</span> <span class="string">-m=&quot;jdk+tomcat+centos&quot;</span> <span class="string">-a=&quot;huang&quot;</span> <span class="string">c0733d9e5807</span> <span class="string">mycentos:1.0</span></span><br><span class="line"><span class="comment">#查看镜像</span></span><br><span class="line"><span class="string">Docker</span> <span class="string">Registry</span></span><br><span class="line"><span class="comment">#可见新镜像</span></span><br><span class="line"><span class="string">REPOSITORY</span>          <span class="string">TAG</span>                 <span class="string">IMAGE</span> <span class="string">ID</span>            <span class="string">CREATED</span>             <span class="string">SIZE</span></span><br><span class="line"><span class="string">mycentos</span>            <span class="number">1.0</span>                 <span class="string">fe6434ec860e</span>        <span class="number">6</span> <span class="string">seconds</span> <span class="string">ago</span>       <span class="string">923MB</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-登录阿里云docker-registry">2. 登录阿里云Docker Registry</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">login</span> <span class="string">--username=xxxxxxxx</span> <span class="string">registry.cn-shenzhen.aliyuncs.com</span></span><br><span class="line"><span class="string">xxxpasswordxxx</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-从registry拉取推送镜像">3.  从Registry拉取/推送镜像</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">pull</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/xxxx/depository01:[镜像版本号]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#推送镜像</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">tag</span> [<span class="string">ImageId</span>] <span class="string">registry.cn-shenzhen.aliyuncs.com/xxxxxx/depository01:[镜像版本号]</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/xxxxxx/depository01:[镜像版本号]</span></span><br></pre></td></tr></table></figure>

<h3><span id="4-在阿里云查看镜像">4. 在阿里云查看镜像</span></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看公有镜像</span></span><br><span class="line"><span class="string">进入阿里云镜像容器管理主界面，选择镜像中心的镜像搜索选项，搜索仓库</span></span><br><span class="line"><span class="string">eg：xxxxxx/depository01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看私有镜像</span></span><br><span class="line"><span class="string">进入阿里云镜像容器管理主界面，选中自己的仓库，点击镜像版本管理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装</title>
    <url>/2019/08/28/Docker/Docker%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一-安装docker"><a href="#一-安装docker" class="headerlink" title="一. 安装docker"></a>一. 安装docker</h2><h3 id="1-删除已安装的docker"><a href="#1-删除已安装的docker" class="headerlink" title="1.  删除已安装的docker"></a>1.  删除已安装的docker</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">yum</span> <span class="string">remove docker \</span></span><br><span class="line">    <span class="meta">docker-client</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-client-latest</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-common</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-latest</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-latest-logrotate</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-logrotate</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-selinux</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-engine-selinux</span> <span class="string">\</span></span><br><span class="line">    <span class="attr">docker-engine</span></span><br></pre></td></tr></table></figure>

<h3 id="2-确定yum更新到最新版本"><a href="#2-确定yum更新到最新版本" class="headerlink" title="2. 确定yum更新到最新版本"></a>2. 确定yum更新到最新版本</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo yum update -y</span></span><br></pre></td></tr></table></figure>

<h3 id="3-安装需要的软件包"><a href="#3-安装需要的软件包" class="headerlink" title="3.  安装需要的软件包"></a>3.  安装需要的软件包</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">sudo yum install -<span class="symbol">y</span> yum-utils device-mapper-<span class="symbol">persistent</span>-data lvm2 -<span class="symbol">y</span></span><br></pre></td></tr></table></figure>

<h3 id="4-设置yum源"><a href="#4-设置yum源" class="headerlink" title="4. 设置yum源"></a>4. 设置yum源</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">yum-config-manager</span> <span class="string">--add-repo</span> <span class="string">https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line"><span class="comment">#若出现错误则改为阿里云yum源</span></span><br><span class="line"><span class="string">yum-config-manager</span>  <span class="string">--add-repo</span>  <span class="string">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span> </span><br></pre></td></tr></table></figure>

<h3 id="5-安装docker"><a href="#5-安装docker" class="headerlink" title="5.安装docker"></a>5.安装docker</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以查看所有仓库中所有docker版本，并选择特定版本安装</span></span><br><span class="line"><span class="string">yum</span> <span class="string">list</span> <span class="string">docker-ce</span> <span class="string">--showduplicates</span> <span class="string">|</span> <span class="string">sort</span> <span class="string">-r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">docker-ce-17.12.0.ce</span> <span class="string">-y</span></span><br></pre></td></tr></table></figure>

<h3 id="6-查看安装是否成功"><a href="#6-查看安装是否成功" class="headerlink" title="6. 查看安装是否成功"></a>6. 查看安装是否成功</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> version</span><br><span class="line">docker <span class="literal">info</span></span><br></pre></td></tr></table></figure>

<h3 id="7-启动并加入开机启动"><a href="#7-启动并加入开机启动" class="headerlink" title="7. 启动并加入开机启动"></a>7. 启动并加入开机启动</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">start</span> docker</span><br><span class="line">sudo systemctl <span class="keyword">enable</span> docker</span><br></pre></td></tr></table></figure>



<h2 id="二-设置阿里云镜像加速"><a href="#二-设置阿里云镜像加速" class="headerlink" title="二. 设置阿里云镜像加速"></a>二. 设置阿里云镜像加速</h2><p>由于国内访问DockerHub速度堪忧，所以需要使用国内的镜像，比如网易或者阿里云。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">阿里云：https://promotion.aliyun.com/ntms/act/kubernetes.html#application</span></span><br><span class="line"></span><br><span class="line"><span class="string">网易云：https://www.163yun.com/product/repo</span></span><br></pre></td></tr></table></figure>

<p>这里使用阿里云容器镜像服务，注册后开通服务，在主界面选择“镜像加速器”，再选择CenterOS即可。</p>
<h3 id="1-根据提示，在配置文件中添加专属加速器地址配置"><a href="#1-根据提示，在配置文件中添加专属加速器地址配置" class="headerlink" title="1 . 根据提示，在配置文件中添加专属加速器地址配置"></a>1 . 根据提示，在配置文件中添加专属加速器地址配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果是CenterOS7+，则需要在/etc/docker/下手动建daemon.json文件</span></span><br><span class="line"><span class="string">vim</span> <span class="string">/etc/docker/daemon.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在里面配置加速器地址</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;:</span> [<span class="string">&quot;https://xxxqxz6.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-重新加载配置文件，重启docker"><a href="#2-重新加载配置文件，重启docker" class="headerlink" title="2. 重新加载配置文件，重启docker"></a>2. 重新加载配置文件，重启docker</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重新加载配置文件</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="string">daemon-reload</span></span><br><span class="line"><span class="comment">#重启docker</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="string">restart</span> <span class="string">docker</span></span><br></pre></td></tr></table></figure>

<p>注：网易云和阿里云操作基本相同，相对推荐使用阿里云</p>
<h3 id="3-确认配置生效"><a href="#3-确认配置生效" class="headerlink" title="3. 确认配置生效"></a>3. 确认配置生效</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#确认配置生效时docker info显示信息中会含有以下内容</span></span><br><span class="line"><span class="comment">#Registry Mirrors:</span></span><br><span class="line"><span class="comment">#https://xxxxx.mirror.aliyuncs.com/</span></span><br></pre></td></tr></table></figure>

<p>==========================</p>
<p>参考：1.<a href="https://blog.csdn.net/deng624796905/article/details/86493330">https://blog.csdn.net/deng624796905/article/details/86493330</a><br>​参考：2.<a href="https://www.cnblogs.com/yufeng218/p/8370670.html">https://www.cnblogs.com/yufeng218/p/8370670.html</a></p>
<p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>===========================</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（二）：垃圾回收机制</title>
    <url>/2020/08/10/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道自动的垃圾回收机制是Java语言一个特点，它让我们在写程序的时候不再需要考虑内存管理问题。内存管理实际上就是<strong>分配内存</strong>和<strong>回收内存</strong>这两个问题，在<a href="https://www.cnblogs.com/Createsequence/p/13447923.html">上一篇文章</a>我大概介绍了jvm是如何划分内存空间以合理的分配内存的，而这篇文章就介绍一下jvm是如何回收内存的。</p>
<p>对于线程私有的程序计数器，虚拟机栈和本地方法栈三块数据区域而言，生命周期是和线程绑定的，线程结束时自然就回收内存了；而对于栈，每一个方法代表每一个栈帧，方法结束的时候就出栈，这时内存也跟着回收了。这些区域的内存回收都是具有确定性的，而堆就不同。</p>
<p>我们知道，堆主要用与存放对象实例，而只有运行时才知道要创建那些对象，而只有对象完全不被使用时才能回收其占用的内存空间。对于这块内容，我们需要明确三个问题：</p>
<ul>
<li><strong>哪些对象可以回收？</strong>（引用计数法、可达性算法）</li>
<li><strong>这些内存什么时候回收？</strong>（新生代、老年代、永久代，MinorGC和FullGC）</li>
<li><strong>这些内存怎么回收？</strong>（三种垃圾收集算法和分代收集算法，七种垃圾收集器）</li>
</ul>
<h2 id="一、判断对象是否可回收"><a href="#一、判断对象是否可回收" class="headerlink" title="一、判断对象是否可回收"></a>一、判断对象是否可回收</h2><p>我们要判断对象是否可以回收，最有效的方式就是判断这个对象是否正在被别的对象引用。针对这个问题，有两种算法：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p>
<h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p><strong>引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收</strong>。</p>
<p>简单的来说，就是为每一个对象实例配置一个计数器：</p>
<ul>
<li>当一个实例被创建并分配一个对象引用的时候，计数器为1；</li>
<li>每当该对象被分配给一个对象实例的时候计数器就加一；</li>
<li>当对象实例的某个引用超过了生命周期或者被设置为别的实例时，计数器就减一</li>
<li>当计数器为0时实例就会被回收</li>
</ul>
<p>引用计数器实现简单而且效率高，但是<strong>无法解决循环引用问题</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    a.b = b;</span><br><span class="line">    b.a = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当A实例中引用了B实例，而B实例中又引用了A实例，他们的极速器就永远不能为0，也就无法回收。</p>
<h3 id="2-可达性算法"><a href="#2-可达性算法" class="headerlink" title="2.可达性算法"></a>2.可达性算法</h3><p><strong>可达性算法通过判断对象的引用链是否可达来判断对象是否可以被回收。</strong></p>
<p>通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>在java中，可以作为GC Roots的对象包括：</p>
<ul>
<li>虚拟机栈汇总引用的对象</li>
<li>方法区汇总静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中方法引用的对象</li>
</ul>
<p><img src="http://img.xiajibagao.top/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="可达性分析算法"></p>
<h3 id="3-强引用、软引用、弱引用、虚引用"><a href="#3-强引用、软引用、弱引用、虚引用" class="headerlink" title="3.强引用、软引用、弱引用、虚引用"></a>3.强引用、软引用、弱引用、虚引用</h3><p>我们知道以上两种算法都需要判断对象是否被引用，实际上，如果reference类型的数据中<strong>存储的数值代表的是另外一块内存的起始地址</strong>，就称这块内存代表着一个引用，因此对象往往只有两种状态：被引用或者未被引用。</p>
<p>如果我们希望有这样一类对象：当内存空间足够时，能保留在内存中；如果内存空间在进行垃圾回收后还是非常紧张，就抛弃这些对象。比如一些系统缓存。</p>
<p>因此为了做出区分，JDK1.2之后Java的引用被分为强引用、软引用、弱引用、虚引用4种。这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用指类似<code>Object obj=new Object()</code>这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</li>
<li>软引用用来描述一些还有用但并非必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围中进行第二次回收。用SoftReference类实现。</li>
<li>弱引用也描述非必需对象，只能存活到下一次垃圾回收之前。用WeakReference类实现。</li>
<li>虚引用也被称为幽灵引用，为一个对象设置虚引用的唯一目的就是能在这个对象被垃圾回收时收到一个系统通知。用PhantomReference类实现。</li>
</ul>
<p>这块内容具体可以参考：<a href="https://www.cnblogs.com/gudi/p/6403953.html">Java 的强引用、弱引用、软引用、虚引用</a></p>
<h2 id="二、垃圾收集算法"><a href="#二、垃圾收集算法" class="headerlink" title="二、垃圾收集算法"></a>二、垃圾收集算法</h2><p>要理解垃圾回收时机，我们需要理解分代算法，在这之前我们需要对四种垃圾收集算法有大概的印象：</p>
<h3 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1.标记清除算法"></a>1.标记清除算法</h3><blockquote>
<p>首先标记出所有需要回收的对象，在标记完成之后统一回收所有比标记的对象。</p>
</blockquote>
<p>标记清除算法有两个问题：</p>
<ul>
<li>效率问题：标记和清除两个过程的效率都不高；</li>
<li>空间问题：标记清除之后会产生大量不连续的内存碎片</li>
</ul>
<h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h3><blockquote>
<p>把内存分为大小相等的两块，每次只用其中一块。当这一块的用完了，就把还存活的对象复制到另一块，然后再把已经用过的内存空间一次清理掉。</p>
</blockquote>
<p><strong>复制算法常用于回收新生代</strong>。</p>
<p>如我们之前在介绍堆的内存结构的时候，jvm会将堆分外新生代和老年代。</p>
<p>而将新生代内存又分为一块较大的<code>eden</code>空间和两块较小的<code>survivor</code>空间，每次使用<code>eden</code>和其中一块<code>survivor</code>。当回收时，将<code>eden</code>和<code>survivor</code>中还存活着的对象一次地复制到另外一块<code>survivor</code>空间上，最后清理掉<code>eden</code>和刚才用过的<code>survivor</code>空间。</p>
<h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h3><blockquote>
<p>与标记清除类似，但是不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
</blockquote>
<p><strong>标记-整理算法常用于老年代。</strong></p>
<p>复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h3><blockquote>
<p>根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
</blockquote>
<p>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率：</p>
<ul>
<li>在新生代每次垃圾收集时都有大批对象死去，只有少量存活，所以使用复制算法；</li>
<li>在老生代中代中存活率高，使用标记清理或者标记整理算法来回收。</li>
</ul>
<h2 id="三、分代收集算法的内存回收策略"><a href="#三、分代收集算法的内存回收策略" class="headerlink" title="三、分代收集算法的内存回收策略"></a>三、分代收集算法的内存回收策略</h2><p><img src="http://img.xiajibagao.top/java%E5%A0%86.png" alt="java堆"></p>
<p>正如之前所说，由于java对象实例存储于堆中，所以堆就是GC的主要场所。</p>
<p>根据分代收集算法，堆会分为新生代和老年代。</p>
<h3 id="1-新生代和老年代"><a href="#1-新生代和老年代" class="headerlink" title="1.新生代和老年代"></a>1.新生代和老年代</h3><blockquote>
<p><strong>新生代</strong>的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代发生的GC叫<strong>MinorGC</strong>。</p>
<p><strong>老年代</strong>存放的都是一些生命周期较长的对象，就在新生代中经历了N次垃圾回收后仍然存活的对象会被放到老年代中。老年代发生的GC叫<strong>FullGC</strong>。</p>
</blockquote>
<p>新生代内存按照 <code>8:1:1</code> 的比例分为一个<code>eden</code>区和两个<code>survivor(survivor0，survivor1)</code>区，大部分对象在<code>eden</code>区中生成。</p>
<p>在进行垃圾回收时：</p>
<ul>
<li>一般先将<code>eden</code>区存活对象复制到<code>survivor0</code>区，然后清空<code>eden</code>区；</li>
<li>当<code>survivor0</code>区也满了时，则将<code>eden</code>区和<code>survivor0</code>区存活对象复制到<code>survivor1</code>区，然后清空<code>eden</code>和这个<code>survivor0</code>区，此时<code>survivor0</code>区是空的，然后交换<code>survivor0</code>区和<code>survivor1</code>区的角色。下次垃圾回收时扫描<code>eden</code>区和<code>survivor1</code>区，然后再交换<code>survivor0</code>区和<code>survivor1</code>，如此反复；</li>
<li>当<code>survivor1</code>区也不足以存放<code>eden</code>区和<code>survivor0</code>区的存活对象时，就将存活对象直接存放到老年代。</li>
</ul>
<h3 id="2-分代收集算法的内存分配策略"><a href="#2-分代收集算法的内存分配策略" class="headerlink" title="2.分代收集算法的内存分配策略"></a>2.分代收集算法的内存分配策略</h3><p>这里再提一下内存分配策略：</p>
<ul>
<li><strong>对象优先分配给<code>eden</code>区域</strong>。当eden区域没有足够空间时，发起一次MinorGC。</li>
<li><strong>需要大量连续内存空间的大对象直接进入老年代</strong>。比如巨长的数组或者字符串，还有非常高的树之类的。</li>
<li><strong>长期存活的对象会进入老年代</strong>。对象在新生代活过一定次数GC（一般是15次）后会移入老年代。</li>
<li><strong>动态对象年龄判定</strong>。如果在<code>survivor</code>空间中相同年龄所有对象大小的总和大小大于<code>survivor</code>空间的一半，年龄大于或等于该年龄的对象直接进入老年代</li>
</ul>
<h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h3><p>新生代收集器，单线程。</p>
<h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h3><p>Serial收集器的多线程版本.</p>
<h3 id="3-Serial-Old收集器"><a href="#3-Serial-Old收集器" class="headerlink" title="3. Serial Old收集器"></a>3. Serial Old收集器</h3><p>Serial收集器用于老年代的多线程版本。</p>
<h3 id="4-Parallel-Scavenge收集器"><a href="#4-Parallel-Scavenge收集器" class="headerlink" title="4.Parallel Scavenge收集器"></a>4.Parallel Scavenge收集器</h3><p>新生代收集器，多线程。它的关注点与其他收集器不同，其他的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标则是达到一个高吞吐量。</p>
<h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5.Parallel Old收集器"></a>5.Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本。</p>
<h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6.CMS收集器"></a>6.CMS收集器</h3><p>老年代并行，以获取最短回收停顿时间为特点的收集器。<strong>只有他用标记-清除算法</strong>。<strong>顶不住了就用Serial Old</strong>帮忙。</p>
<h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h3><p>G1收集器是JDK7提供的一个新收集器。</p>
<p>G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是<strong>整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代</strong>。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（三）：类加载机制</title>
    <url>/2020/08/11/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道java代码会被编译为.class文件，这里class文件中的类信息最终还是需要jvm加载以后才能使用。</p>
<p>事实上，虚拟机把描述类的数据<strong>从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制</strong>。</p>
<p>对于jvm类的加载机制，我们主要关注两个问题：</p>
<ul>
<li>类的加载时机？(初始化的五种情况)</li>
<li>类的加载过程？（类的五个加载过程）</li>
</ul>
<h2 id="一、类的加载时机"><a href="#一、类的加载时机" class="headerlink" title="一、类的加载时机"></a>一、类的加载时机</h2><h3 id="1-类的生命周期"><a href="#1-类的生命周期" class="headerlink" title="1.类的生命周期"></a>1.类的生命周期</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>。其中验证、准备、解析统称为<strong>连接</strong>。</p>
<p><img src="http://img.xiajibagao.top/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA.png" alt="类加载的时机"></p>
<p>值得一提的是，加载，验证，准备，初始化和卸载是固定的，<strong>但是解析阶段不是：它在一定情况下可以在初始化后再开始，以支持java语言的动态绑定</strong>。</p>
<p>这里解释一下动态绑定和静态绑定：</p>
<blockquote>
<p>静态绑定：<br>在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。</p>
<p>动态绑定：<br>后期绑定：在运行时根据具体对象的类型进行绑定。</p>
</blockquote>
<p>另外，类的加载过程必须按步骤“开始”，但是并不等前一个步骤完成后才进行下一个步骤，而是在前一个步骤进行时就开始下一个步骤。</p>
<h3 id="2-类的加载时机"><a href="#2-类的加载时机" class="headerlink" title="2.类的加载时机"></a>2.类的加载时机</h3><p><strong>这里的“加载”只是类加载过程的一个阶段</strong>，代表这“类的加载”的这一过程的开始，<strong>jvm并没有强制性约束在什么时候开始类加载过程</strong>。</p>
<p>一般我们说类的加载，指的是整个加载过程。过程完成后，代表jvm将java文件编译成class文件后，以二进制流的方式存放到运行时数据的方法区中，并在java的堆中创建一个java.lang.Class对象，用来指向存放在方法堆中的数据结构。</p>
<h3 id="3-类的初始化时机"><a href="#3-类的初始化时机" class="headerlink" title="3.类的初始化时机"></a>3.类的初始化时机</h3><p>首先我们得明确一下初始化和实例化的区别：</p>
<blockquote>
<p><strong>类的实例化</strong>是指创建一个类的实例(对象)的过程；</p>
<p><strong>类的初始化</strong>是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。</p>
</blockquote>
<p>初始化一般是类使用前的最后一个阶段，所以类初始化时机可以看成类的加载时机。</p>
<p>凡是有以下四种行为的成为对一个类进行<strong>主动引用</strong>，<strong>只有主动引用会触发类的初始化</strong>：</p>
<ul>
<li><strong>遇到四条字节码指令</strong>：<ol>
<li>new：使用new关键字实例化对象;</li>
<li>getstatic：获取一个不被final修饰的类的静态字段;</li>
<li>putstatic：设置一个不被final修饰的类的静态字段;</li>
<li>invokestatic：调用一个类的静态方法;</li>
</ol>
</li>
<li><strong>使用java.lang.reflect包中的方法对类进行反射调用时，如果类还没有初始化，则必须首先对其初始化;</strong></li>
<li><strong>当初始化一个类时，如果其父类还没有初始化，则必须首先初始化其父类;</strong></li>
<li><strong>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</strong></li>
<li><strong>当使用JDK7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。</strong></li>
</ul>
<p>除了以上五种方式以外引用类的方式成为<strong>被动引用</strong>，并不会触发初始化。</p>
<p>被动引用有以下几种代表性的例子：</p>
<p>假设我们有以下两种类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-08-08 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：Parent类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ParentAge = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Parent,我被初始化了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-08-08 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：Child类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> cons = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Child，我被初始化了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    System.out.println(Child.ParentAge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">我是Parent,我被初始化了！</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>通过数组定义引用类不会初始化；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Parent[] Parent = <span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有引用到定义常量的类，因此不会触发定义常量的类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    System.out.println(Child.cons);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-类的存放位置"><a href="#4-类的存放位置" class="headerlink" title="4.类的存放位置"></a>4.类的存放位置</h3><p>当一个类被加载的时候，类的信息（有啥方法有啥遍历）会被存放到方法区，而常量会被存放到方法区里的常量池。完成这一切以后JVM会拷贝一份类的信息放到堆里方便使用。</p>
<h2 id="二、类的加载过程"><a href="#二、类的加载过程" class="headerlink" title="二、类的加载过程"></a>二、类的加载过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><blockquote>
<p>加载”是由类加载器完成的“类加载过程”的第一个阶段，在初始化之前完成。</p>
</blockquote>
<p>加载阶段完成以下三件事：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>值得一提的是，二进制流可以从zip包中获取，这也是JAR或者WAR包格式也能部署项目基础。</p>
<p>另外，类的加载阶段涉及类加载器和双亲委派模型等知识点，此处将另起新随笔详细介绍，在本文就不多费笔墨了。</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><blockquote>
<p>验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
</blockquote>
<p>验证阶段完成以下四件事：</p>
<ul>
<li><p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，</p>
<p>比如是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内、常量池的常量中是否有不被支持的常量类型等等；</p>
</li>
<li><p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，</p>
<p>比如父类是否继承了被final修饰的类，非抽象类是否都实现了父类或者接口的方法等等；</p>
</li>
<li><p><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；</p>
</li>
<li><p><strong>符号引用验证</strong>：对类自身以外的信息进行匹配性校验,</p>
<p>比如符号引用中通过字符串描述的全限定名是否能找到对应的类等等。</p>
</li>
</ul>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h3><blockquote>
<p>准备阶段是正式为类被static修饰的变量（不包含实例变量）分配内存并设置类变量初始值的阶段。</p>
</blockquote>
<p>这里区分常量与普通静态变量：</p>
<p>对于<strong>普通静态变量</strong>，比如 <code>public staic int num = 1</code>，准备阶段赋值为0，而把value赋值为123的putstatic指令是程序被编译后，存放于虚拟机装载一个类初始化的时候调用的类构造器方法<code>&lt;clinit&gt;()</code>之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p>
<p>而对于<strong>常量类型</strong>，比如 <code>public static final int = 1</code>，准备阶段就会赋值为1。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h3><blockquote>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
</blockquote>
<p>这里我们需要理解一下符号引用和直接引用：</p>
<ul>
<li><strong>符号引用</strong>：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用目标并不一定已经加载到内存中</li>
<li><strong>直接引用</strong>：直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄，直接引用与虚拟机实现的内存布局相关，如果有了直接引用，引用目标必定已经加载到内存中</li>
</ul>
<p>我们举个简单的例子：</p>
<p>最开始jvm要加载People类，但是一开始并不知道People的内存地址，此时就用符号“People”先表示它的地址，等到类加载器加载完People类的时候，就可以知道People类的实际地址了，于是就将“People”符号换成People这个类的实际内存地址。</p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h3><blockquote>
<p>类初始化阶段是类加载过程的最后一步。在前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码(字节码)。</p>
</blockquote>
<p>这里我们可以回头看准备阶段，我们知道准备阶段会调用类构造器<code>&lt;clinit&gt;()</code>方法.</p>
<p>实际上，初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<h2 id="三、初始化时的类构造器"><a href="#三、初始化时的类构造器" class="headerlink" title="三、初始化时的类构造器"></a>三、初始化时的类构造器</h2><p>我们在类加载的验证和初始化时都提到过类构造器 <code>&lt;clinit&gt;()</code>，这里稍微介绍一下。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块中的语句合并产生</strong>的。也就是说，如果一个类没有静态成员变量和静态块，是可以不执行类构造方法的。</p>
<h3 id="1-父类子类类构造器的执行顺序"><a href="#1-父类子类类构造器的执行顺序" class="headerlink" title="1.父类子类类构造器的执行顺序"></a>1.父类子类类构造器的执行顺序</h3><p>类构造器<code>&lt;clinit&gt;()</code>与实例构造器<code>&lt;init&gt;()</code>不同，它不需要程序员进行显式调用，虚拟机会保证在子类类构造器<code>&lt;clinit&gt;()</code>执行之前，父类的类构造<code>&lt;clinit&gt;()</code>执行完毕。这就导致了<strong>父类静态代码块比子类静态代码块先执行</strong>。</p>
<h3 id="2-类构造器中的赋值操作"><a href="#2-类构造器中的赋值操作" class="headerlink" title="2.类构造器中的赋值操作"></a>2.类构造器中的赋值操作</h3><p>对于静态块中的赋值操作，我们需要注意：<strong>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    System.out.println(i);<span class="comment">//在此处抛出错误：非法的向前引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-多线程环境下的类构造器"><a href="#3-多线程环境下的类构造器" class="headerlink" title="3.多线程环境下的类构造器"></a>3.多线程环境下的类构造器</h3><p><strong>在多线程环境下，虚拟机会保证总是只有一个线程去执行类构造器 <code>&lt;clinit&gt;()</code>，其他线程会阻塞直到构造器执行完毕</strong>。而一个类只会进行一次初始化，这就保证了多线程下类的正确初始化。</p>
<p>事实上，这有点像在我<a href="https://www.cnblogs.com/Createsequence/p/12945908.html">关于多线程的这篇文章</a>中提到的双重检查单例模式，也是因为这点，我们可以巧妙的使用内部类来实现一个线程安全的单例模式。</p>
<p>由于实例化的时候其他线程会阻塞，所以如果在类的静态块中进行了耗时较长的工作时，可能就会导致多个线程在你不知道的情况下堵塞，造成不必要的性能消耗。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（四）：类加载器</title>
    <url>/2020/08/12/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机设计团队把类加载阶段中的“<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。<strong>实现这个动作的代码模块称为类加载器。</strong></p>
<p>对于类加载，我们关注两个方面的问题：</p>
<ul>
<li>JVM定义的三个类加载器（Bootstrap，Extension，System）</li>
<li>双亲委派模型（机制，JDBC违背案例）</li>
</ul>
<h2 id="一、类加载器"><a href="#一、类加载器" class="headerlink" title="一、类加载器"></a>一、类加载器</h2><p>JVM使用以下三种类型的类加载器：</p>
<ul>
<li><p><strong>启动类（Bootstrap）类加载器</strong>：</p>
<p>这个类存放在<JAVA_HOME>\lib目录中，无法被Java程序直接引用；</p>
</li>
<li><p><strong>扩展（Extension）类加载器</strong>：</p>
<p>这个类加载器负责加载<JAVA_HOME>\lib\ext目录中的所有类库，开发者可以直接使用；</p>
</li>
<li><p><strong>引用程序（Application）类加载器</strong>：</p>
<p>这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以<strong>一般也称它为系统类加载器</strong>，负责加载用户类路径上所指定的类库。开发者可以直接使用。</p>
</li>
</ul>
<p>从java虚拟机的角度来说，一种是启动类加载器，是JVM的一部分；另一种是其他类加载器，独立于JVM，全部继承自抽象类java.lang.ClassLoader。只有其他类加载器程序员才能自己使用。</p>
<h2 id="二、双亲委派模型"><a href="#二、双亲委派模型" class="headerlink" title="二、双亲委派模型"></a>二、双亲委派模型</h2><h3 id="1-什么是双亲委派模型"><a href="#1-什么是双亲委派模型" class="headerlink" title="1.什么是双亲委派模型"></a>1.什么是双亲委派模型</h3><p>JVM在加载类时默认采用的是双亲委派机制。</p>
<p>通俗的讲，就是某个特定的类加载器在<strong>接到加载类的请求时，首先将加载任务委托给父类加载器</strong>，然后父类加载器再委托给它的父类……以此类推，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。</p>
<p><strong>只有父类加载器无法完成加载请求时，才会使用子类加载器去加载</strong>。</p>
<p>双亲委派模型的一个<strong>重要作用是为了保证类加载过程的安全性</strong>：</p>
<blockquote>
<ul>
<li>假设有一个开发者自己编写了一个名为 <code>java.lang.Object</code>的类，想借此欺骗JVM。现在他要使用自定义 <code>ClassLoader</code>来加载自己编写的 <code>java.lang.Object</code>类。</li>
<li>但是无论哪一个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，启动类加载器在其搜索范围内可以搜索到的只有<code>rt.jar</code>中的<code>java.lang.Object</code>类</li>
<li>这样就确保了Object类的唯一性，如果是String也是同理。</li>
</ul>
</blockquote>
<p>也因此，java判断类是否是同一个类，就是通过判断类的ClassLoader.class来判断的，举个简单的例子：只要不是一个爹妈生出来的，哪怕长的一模一样那也不是亲兄弟。</p>
<h3 id="2-类的加载顺序"><a href="#2-类的加载顺序" class="headerlink" title="2.类的加载顺序"></a>2.类的加载顺序</h3><p>我们打开<code>ClassLoader</code>类，找到<code>loadClass()</code>方法，可以在注释上看到如何按顺序搜索类的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*   Invoke &#123;@link #findLoadedClass(String)&#125; to check if the class</span><br><span class="line">*   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">*</span><br><span class="line">*   Invoke the &#123;@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method</span><br><span class="line">*   on the parent <span class="class"><span class="keyword">class</span> <span class="title">loader</span>.  <span class="title">If</span> <span class="title">the</span> <span class="title">parent</span> <span class="title">is</span> &lt;<span class="title">tt</span>&gt;<span class="title">null</span>&lt;/<span class="title">tt</span>&gt; <span class="title">the</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">*   <span class="title">loader</span> <span class="title">built</span>-<span class="title">in</span> <span class="title">to</span> <span class="title">the</span> <span class="title">virtual</span> <span class="title">machine</span> <span class="title">is</span> <span class="title">used</span>, <span class="title">instead</span>.  &lt;/<span class="title">p</span>&gt;&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="class">*</span></span><br><span class="line">*   Invoke the &#123;@link #findClass(String)&#125; method to find the</span><br><span class="line">*   class.</span><br></pre></td></tr></table></figure>

<p>即：</p>
<ul>
<li>使用<code>findLoadedClass()</code>方法检查类是否已经加载；</li>
<li>调用父类加载器的<code>loaderCalss()</code>方法。如果父类是null，就直接调用虚拟机内置的Bootstrap加载；</li>
<li>如果父类无法加载，使用自己<code>findClass()</code>加载。</li>
</ul>
<p>我们再看一下<code>loadClass()</code>方法的源码，更直观的展示了双亲委派模型下是如何加载类的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//线程安全，保证只有一个线程能对类初始化</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//1.检查类是否已经被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//2.如果没有被加载，判断是否存在父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//3.有就递归委派给父类加载器加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//4.否则就使用启动类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果到了启动类加载器还找不到类，则抛出ClassNotFoundException</span></span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">            <span class="comment">//如果父类加载器无法加载，就使用自身的findClass加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是为什么JDK在我们自定义类加载器的时候不推荐重写<code>loadClass()</code>只让我们重写<code>findClass()</code>方法的原因了，因为如果重写了方法，却不遵守双亲委派模型，就有可能导致不可预料的后果。</p>
<p>当然，不推荐归不推荐，如果有必要的话仍然可以重写<code>loadClass()</code>方法，比如<strong>JDBC、JNDI就打破了双亲委派模型</strong>。</p>
<h3 id="3-三种类加载器的关系"><a href="#3-三种类加载器的关系" class="headerlink" title="3.三种类加载器的关系"></a>3.三种类加载器的关系</h3><p><img src="http://img.xiajibagao.top/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="三种类加载器的关系"></p>
<p>我们运行一下以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;应用程序加载器：&quot;</span>+ClassLoader.getSystemClassLoader());</span><br><span class="line">    System.out.println(<span class="string">&quot;应用程序加载器的父类：&quot;</span>+ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;扩展加载器的父类：&quot;</span>+ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">应用程序加载器：sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">应用程序加载器的父类：sun.misc.Launcher$ExtClassLoader@<span class="number">29453f</span>44</span><br><span class="line">扩展加载器的父类：<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>由于启动类加载器是jvm内置的，我们无法直接调用，所以返回值是null。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（五）：类的实例化</title>
    <url>/2020/08/13/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道，一个对象在可以被使用之前必须要被正确地实例化。而实例化实际指的就是以一个java类为模板创建对象/实例的过程。比如说常见的 <code>Person = new Person()</code>代码就是一个将Person类实例化并创建引用的过程。</p>
<p>对于类的实例化，我们关注两个问题：</p>
<ul>
<li>如何实例化？（类的四种实例化方式）</li>
<li>什么时候实例化？（类的一个初始化过程和对象的三个初始化过程）</li>
</ul>
<h2 id="一、类的四种实例化方式"><a href="#一、类的四种实例化方式" class="headerlink" title="一、类的四种实例化方式"></a>一、类的四种实例化方式</h2><h3 id="1-使用new关键字"><a href="#1-使用new关键字" class="headerlink" title="1.使用new关键字"></a>1.使用new关键字</h3><p>这也是最常见最简单的创建对象的方法。通过这种方法，我们可以借助类的构造函数实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent p = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>

<h3 id="2-使用newInstance-方法"><a href="#2-使用newInstance-方法" class="headerlink" title="2.使用newInstance()方法"></a>2.使用newInstance()方法</h3><p>我们可以先通过类的全限定名获取类，然后通过Class类的<code>newInstance()</code>方法去调用类的<strong>无参构造方法</strong>创建一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class p = Class.forName(<span class="string">&quot;com.huang.Parent&quot;</span>);</span><br><span class="line">Parent parent = (Parent) p.newInstance();</span><br></pre></td></tr></table></figure>

<p>或者通过<code>java.lang.relect.Constructor</code>类里的<code>newInstance()</code>方法去构造对象，这个方法比起Class自带的更强大：</p>
<p>它可以调用类中<strong>有参构造方法</strong>和<strong>私有构造方法</strong>创建对象！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Parent私有的含参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Parent创建了！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Constructor调用</span></span><br><span class="line">Class p = Class.forName(<span class="string">&quot;com.huang.Parent&quot;</span>);</span><br><span class="line">Constructor&lt;Parent&gt; parentConstructor = p.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">Parent parent = (Parent) p.newInstance();</span><br></pre></td></tr></table></figure>

<h3 id="3-使用clone-方法"><a href="#3-使用clone-方法" class="headerlink" title="3.使用clone()方法"></a>3.使用clone()方法</h3><p>当我们调用clone方法，JVM会帮我们创建一个新的、一样的对象，特别需要说明的是，用clone方法创建对象的过程中并不会调用任何构造函数。这里涉及到一个深拷贝和浅拷贝的知识点，我会另起一篇随笔介绍，这里就多费笔墨了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent();</span><br><span class="line">Parent p2 = (Parent) parent.clone();</span><br></pre></td></tr></table></figure>

<h3 id="4-使用反序列化机制"><a href="#4-使用反序列化机制" class="headerlink" title="4.使用反序列化机制"></a>4.使用反序列化机制</h3><p>当我们反序列化一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写对象</span></span><br><span class="line">ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;parent.bin&quot;</span>));</span><br><span class="line">outputStream.writeObject(parent);</span><br><span class="line">outputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读对象</span></span><br><span class="line">ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">    <span class="string">&quot;parent.bin&quot;</span>));</span><br><span class="line">Parent parent2 = (Parent) inputStream.readObject();</span><br></pre></td></tr></table></figure>



<h2 id="二、类实例化的过程"><a href="#二、类实例化的过程" class="headerlink" title="二、类实例化的过程"></a>二、类实例化的过程</h2><p>我们以 <code>Person p = new Person()</code>这条语句为例，当这条语句执行的时候，jvm进行了四步操作：</p>
<ul>
<li>先执行new语句，以Person类为模板，在堆中创建Person对象</li>
<li>为Person对象执行构造方法（如果有父类会先执行父类构造方法）</li>
<li>创建Person类的引用变量p</li>
<li>将引用变量p指向内存中Person对象</li>
</ul>
<p>我们不难看出，其实实例化的过程其实就是第一和第二步，在这两步里，jvm其实也进行了四步操作：</p>
<ul>
<li>Person<strong>类</strong>的初始化</li>
<li>Person<strong>对象变量</strong>的初始化（如果有父类会先执行父类变量的初始化）</li>
<li>Person<strong>对象代码块</strong>的初始化</li>
<li>Person<strong>对象构造函数</strong>的初始化（如果有父类会先执行父类初始化）</li>
</ul>
<h3 id="1-类的初始化"><a href="#1-类的初始化" class="headerlink" title="1.类的初始化"></a>1.类的初始化</h3><p><strong>对于第一次被实例化的对象，第一步是必定是类的初始化，所以静态变量和静态代码块中的代码必然被赋值和执行。</strong></p>
<p>这点在我<a href="https://www.cnblogs.com/Createsequence/p/13461108.html">关于类加载机制的文章</a>中已有解释，这里就不多费笔墨。</p>
<h3 id="2-对象变量的初始化"><a href="#2-对象变量的初始化" class="headerlink" title="2.对象变量的初始化"></a>2.对象变量的初始化</h3><p>我们在定义对象中的变量的同时，还可以<strong>直接对对象变量进行赋值。它们会在构造函数执行之前完成这些初始化操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的构造方法执行了！&quot;</span>);</span><br><span class="line">        j += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = k + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i:&quot;</span>+i);</span><br><span class="line">        System.out.println(<span class="string">&quot;j:&quot;</span>+j);</span><br><span class="line">        System.out.println(<span class="string">&quot;k:&quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;l:&quot;</span>+l);</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的构造方法执行了！&quot;</span>);</span><br><span class="line">        k += <span class="number">8</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;k:&quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;l:&quot;</span>+l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Child child = <span class="keyword">new</span> Child();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">Parent的构造方法执行了！</span><br><span class="line">i:<span class="number">1</span></span><br><span class="line">j:<span class="number">12</span></span><br><span class="line">k:<span class="number">1</span></span><br><span class="line">l:<span class="number">2</span></span><br><span class="line">Child的构造方法执行了！</span><br><span class="line">k:<span class="number">9</span></span><br><span class="line">l:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>我们可以知道执行顺序是这样的：</p>
<ul>
<li><strong>父类的变量初始化</strong>：<code>i = 1,j=2</code>;</li>
<li><strong>执行父类的构造函数</strong>：<code>j = 2 + 10 = 12</code>;</li>
<li><strong>子类的变量初始化</strong>：<code>k = 1,l = 2</code>;</li>
<li><strong>执行子类构造函数</strong>：<code>k = 1 + 8 = 9</code></li>
</ul>
<p>这里有人认为父类的变量初始化了，而且父类的构造函数也执行了，那父类是不是也一起实例化了？</p>
<p>答案是没有，我们可以认为实例化的时候子类从父类一起拷贝了一份变量，构造函数的执行也是为了能让父类的变量初始化，最后实例化放到内存里的其实是子类+父类的一个混合体！</p>
<h3 id="3-代码块的初始化"><a href="#3-代码块的初始化" class="headerlink" title="3.代码块的初始化"></a>3.代码块的初始化</h3><p>我们一般指的代码块是构造代码块和静态代码块，静态代码块在类初始化时就执行，而<strong>构造代码块在类一创建就执行，也优先于构造方法</strong>。</p>
<p>我们举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的代码块被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent创建了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child创建了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的代码块被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Child child = <span class="keyword">new</span> Child();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Parent的代码块被执行了！</span><br><span class="line">Parent的构造方法执行了！</span><br><span class="line">Child的代码块被执行了！</span><br><span class="line">Child的构造方法执行了！</span><br></pre></td></tr></table></figure>

<p>我们可以知道执行顺序是这样的：</p>
<ul>
<li><strong>父类代码块</strong></li>
<li><strong>父类的构造方法</strong></li>
<li><strong>子类的代码块</strong></li>
<li><strong>子类的构造方法</strong></li>
</ul>
<h3 id="4-构造函数的初始化"><a href="#4-构造函数的初始化" class="headerlink" title="4.构造函数的初始化"></a>4.构造函数的初始化</h3><p>我们可以从上文知道，实例变量初始化与实例代码块初始化总是发生在构造函数初始化之前，那么我们下面着重看看构造函数初始化过程。众所周知，每一个Java中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。在编译生成的字节码中，这些构造函数会被命名成<code>&lt;init&gt;()</code>方法。</p>
<p>事实上，Java强制要求Object对象之外的所有对象构造函数的第一条语句必须是父类构造函数的调用语句，如果没有就会默认生成讴歌构造函数。这就保证了不管要实例化的类继承了多少父类，我们最终都能让实例继承到所有从父类继承到的属性。</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><p>结合以上文，我们可以看出类的实例化其实是一个递归的过程。</p>
<p>从子类不断向上递归，然后一直递归到直到抵达基类Object，然后一层一层的返回，先完成类的初始化：</p>
<ul>
<li>如果有类未初始化就先初始化（初始化静态块）</li>
</ul>
<p>再回到Object类，往下一层一层的返回，完成对象的三个初始化：</p>
<ul>
<li>初始化变量</li>
<li>初始化代码块</li>
<li>初始化构造函数</li>
</ul>
<p><img src="http://img.xiajibagao.top/%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%98%AF%E4%B8%AA%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png" alt="类实例化的递归过程"></p>
<p>所以最终我们可以总结出类初始化过程中类的各种代码块的执行顺序：</p>
<ul>
<li>父类静态块</li>
<li>子类静态块</li>
<li>父类代码块</li>
<li>父类构造函数</li>
<li>子类代码块</li>
<li>子类构造函数</li>
</ul>
<p>验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的静态块执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的代码块被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的静态块执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的代码块被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Child child = <span class="keyword">new</span> Child();</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Parent的静态块执行了！</span><br><span class="line">Child的静态块执行了！</span><br><span class="line">Parent的代码块被执行了！</span><br><span class="line">Parent的构造方法执行了！</span><br><span class="line">Child的代码块被执行了！</span><br><span class="line">Child的构造方法执行了！</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（一）：jvm内存结构</title>
    <url>/2020/08/09/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Ajvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们知道java代码先编译为.class文件，然后再将.class文件交由jvm执行。在程序运行的这一过程中，jvm会将其管理的内存空间划分为不同的区域，这些区域各有各的用途，我们将其分为五类：</p>
<ol>
<li>方法区</li>
<li>堆</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
</ol>
<p>其中方法区和堆是线程共享的，随jvm启动和停止而创建和销毁；</p>
<p>而虚拟机栈、本地方法栈和程序计数器则是线程私有的，随线程的创建和结束而创建和销毁。</p>
<p><img src="http://img.xiajibagao.top/jvm%E5%86%85%E5%AD%98%E4%BD%93%E7%B3%BB.png" alt="jvm内存体系"></p>
<h2 id="一、线程隔离数据区"><a href="#一、线程隔离数据区" class="headerlink" title="一、线程隔离数据区"></a>一、线程隔离数据区</h2><p>包括程序计数器，虚拟机栈，本地方法栈三部分，是线程私有的数据区。</p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><p><img src="http://img.xiajibagao.top/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="程序计数器"></p>
<blockquote>
<p>程序计数器用于记录当前线程执行的字节码指令的地址。</p>
</blockquote>
<p>我们知道cup实现多线程操作是根据每个线程分配是时间片来决定处的，每一个时间片cup都只处理抢到那个时间片的线程，因此很可能出现线程1指令执行到一半，结果下一个时间片又去处理另一个线程了。</p>
<p>为了能够在线程切换后依然能恢复到正确的指令位置，<strong>每一个线程都需要一个独立的计数器去记录正在执行的字节码指令地址</strong>，我们可以简单的理解为一个记录执行到的指令行数的一个指示器。</p>
<p><strong>如果指向的是java方法，计数器记录执行的字节码的地址，如果是非java代码的Native方法，这计数器为空。</strong></p>
<p><strong>计数器是唯一一个没有规定<code>OutOfMemoryError</code>的区域。</strong></p>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h3><p><img src="http://img.xiajibagao.top/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="虚拟机栈"></p>
<blockquote>
<p>虚拟机栈是描述java方法执行的一个内存模型。</p>
</blockquote>
<p>每个方法执行的时候会常见一个栈帧，栈帧中会储存局部变量表。操作数栈、动态链接、方法出口信息等。比如方法的局部变量会插入局部遍历表，对局部变量的运算和传递则通过数栈等等。</p>
<p><strong>每个方法从调用到完成就是一个栈帧在虚拟机栈中入栈到出栈的一个过程</strong>。我们使用递归时提到的栈就是虚拟机栈。</p>
<p>虚拟机栈规定有两种异常：<code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></p>
<p>我们知道方法调用实际就是栈帧入栈，<strong>如果栈的深度超过规定，就会抛出<code>StackOverflowError</code>异常</strong>；</p>
<p>栈的大小可以规定也可以动态扩展，<strong>如果栈扩展大小时申请不到足够的内存，就会抛出<code>OutOfMemoryError</code>异常</strong>.</p>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h3><p><img src="http://img.xiajibagao.top/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88.png" alt="本地方法栈"></p>
<blockquote>
<p>本地方法栈是描述j非java的方法执行的一个内存模型。</p>
</blockquote>
<p>它与虚拟机栈功能一样，但是不同的是本地方法栈用于存放实现方法非java代码的方法。当一个java方法要调用的的时候，会将java栈帧入虚拟机栈，而当非java方法要调用的时候就会入本地方法栈。</p>
<p>实际上两种栈之间往往会互相调用对方的方法，比如java方法A调用了java方法B，java方法B调用了C++方法C，这个C++方法又调用了java方法D，描述一下过程就会是：</p>
<p><code>A =》虚拟机栈，B =》虚拟机栈，C =》本地方法栈，D =》虚拟机栈</code></p>
<h2 id="二、线程共享数据区"><a href="#二、线程共享数据区" class="headerlink" title="二、线程共享数据区"></a>二、线程共享数据区</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h3><p><img src="http://img.xiajibagao.top/java%E5%A0%86.png" alt="java堆"></p>
<blockquote>
<p>堆用于存放对象实例、数组和字符串常量池</p>
</blockquote>
<p>堆用于存放类的实例对象、数组和字符串常量池、另外，由于实例对象存储于此区域，所以也是<strong>垃圾收集器管理的主要区域，故又称GC堆</strong>。</p>
<p>java对可以是固定大小，也可以是动态大小，如果<strong>堆中没有内存分配给新的实例对象的时候，就会抛出<code>OutOfMemoryError</code>异常</strong>。</p>
<h4 id="1-2字符串常量池"><a href="#1-2字符串常量池" class="headerlink" title="1.2字符串常量池"></a>1.2字符串常量池</h4><p>这里稍微提一下字符串常量池，正由于字符串常量池的存在，当创建字符串常量时，<strong>首先检查字符串常量池是否存在该字符串，存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</strong>。</p>
<p>这也是为什么字符串明明是对象却可以直接使用 == 比较，因为同样的字符指向的都是常量池里同一个字符串对象。</p>
<h4 id="1-3内存分配策略"><a href="#1-3内存分配策略" class="headerlink" title="1.3内存分配策略"></a>1.3内存分配策略</h4><p>另外值得一提的是，堆往往和垃圾回收问题一起出现，所以这里也简单的介绍一下内存分配的策略：</p>
<p>由于jvm内存回收机制采用了<strong>分代收集算法</strong>，所以java堆中还分为<strong>新生代和老年代</strong>，新生代中又分为占大部分控件的<code>eden</code>区域和占较小空间的<code>survivorSpace0</code>和<code>survivorSpace1</code>。</p>
<p>根据分代收集算法，堆中内存分配时一般遵循以下原则：</p>
<ul>
<li><p><strong>对象优先分配给<code>eden</code>区域</strong>。当eden区域没有足够弓箭时，发起一次GC。当垃圾回收时，根据复制算法：</p>
<p><code>eden</code>和一个<code>survivorSpace</code>中还存活的对象会复制到另一个<code>survivorSpace</code>中，然后清理原先的空间</p>
</li>
<li><p><strong>需要大量连续内存空间的大对象直接进入老年代</strong>。比如巨长的数组或者字符串，还有非常高的树之类的。</p>
</li>
<li><p><strong>长期存活的对象会进入老年代</strong>。对象在新生代活过一定次数GC后会移入老年代。</p>
</li>
<li><p><strong>动态对象年龄判定</strong>。如果在<code>survivorSpace</code>空间中相同年龄所有对象大小的总和大小大于<code>survivorSpace</code>空间的一半，年龄大于或等于该年龄的对象直接进入老年代</p>
</li>
</ul>
<p>当然，不同的垃圾收集器和不同的垃圾收集算法适应不同的程序运行情况，实际的内存回收机制要复杂的多，这里以后会在新随笔里另外再展开，这里就不再赘述了。</p>
<h3 id="2-方法区"><a href="#2-方法区" class="headerlink" title="2.方法区"></a>2.方法区</h3><blockquote>
<p>方法区主要用来存放类信息、类的静态变量、常量、运行时常量池等</p>
</blockquote>
<p>方法区和堆功能类似，主要用与存放类信息，常量和即时编译器编译后的代码等数据。</p>
<h4 id="2-2永久代"><a href="#2-2永久代" class="headerlink" title="2.2永久代"></a>2.2永久代</h4><p>很多文章提到方法区的时候都会涉及到这个“永久代”这个词。实际上，<strong>方法区是jvm的一个规范，永久代是这种规范的另一种实现</strong>，类似的还有元空间，这也是方法区的一种实现。</p>
<p>jvm虚拟机分为很多种，比如HotSpot ，JRockit（Oracle）、J9（IBM）等等，但是只有HotSpot才有永久代这个说法。硬要说的话，方法区可以理解为一个接口，永久区是这个接口的实现类。</p>
<h4 id="2-3-运行时常量池"><a href="#2-3-运行时常量池" class="headerlink" title="2.3 运行时常量池"></a>2.3 运行时常量池</h4><p><img src="http://img.xiajibagao.top/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="运行时常量池"></p>
<p>类似的问题还有运行时常量池。运行时常量池是方法区的一部分，用于存储各种编译时以及运行时产生的新常量，类加载以后的数据就存放于此，还有字符串手动入池方法<code>intern()</code>。</p>
<p>这里的 “运行时常量池”同上文提到的方法区和永久代的关系一样，也是jvm的规范而不是实现，运行时常量必然会有一个专门的储存空间，但是放在哪就得看虚拟机各自的实现了。</p>
<p>不过这里要额外理解一下字符串常量池：</p>
<p>常量池分为两块，一块是堆中的字符串常量池，一块是方法区中的常量池。实际上<strong>JDK8之前字符串常量池也在方法区中的常量池里边，而在JDK8之后被单独分离出来放到了堆里</strong>。</p>
<p><img src="http://img.xiajibagao.top/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9C%A8JDK8%E8%A2%AB%E5%88%86%E7%A6%BB.png" alt="字符串常量池在JDK8被分离"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装tomcat</title>
    <url>/2019/07/24/linux/linux%E4%B8%8B%E5%AE%89%E8%A3%85tomcat/</url>
    <content><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上传tomcat至自己想要的文件夹，我的是/usr/local</span></span><br><span class="line"><span class="string">tar</span> <span class="string">-zxvf</span> <span class="string">apache-tomcat-8.5.43.tar.gz</span></span><br><span class="line"><span class="comment">#解压完后是名为apache-tomcat-8.5.43的文件夹</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/apache-tomcat-8.5.43/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置tomcat环境变量</span></span><br><span class="line"><span class="comment">#用vim打开tomcat的bin目录下的setclasspath.sh</span></span><br><span class="line"><span class="string">vim</span> <span class="string">/usr/local/apache-tomcat-8.5.43/bin/setclasspath.sh</span></span><br><span class="line"><span class="comment">#添加JAVA_HOME变量</span></span><br><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/jdk1.8.0_221</span></span><br></pre></td></tr></table></figure>

<p><img src="http://img.xiajibagao.top/tomcatexport.PNG"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入bin目录，启动或关闭tomcat</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/apache-tomcat-8.5.43/bin</span></span><br><span class="line"><span class="string">./startup.sh</span> <span class="comment">#启动</span></span><br><span class="line"><span class="string">./shutdown.sh</span> <span class="comment">#关闭</span></span><br></pre></td></tr></table></figure>



<h2 id="2-如果tomcat启动过慢"><a href="#2-如果tomcat启动过慢" class="headerlink" title="2.如果tomcat启动过慢"></a>2.如果tomcat启动过慢</h2><blockquote>
<p>参考：<a href="https://www.liangzl.com/get-article-detail-2622.html">https://www.liangzl.com/get-article-detail-2622.html</a></p>
<p>参考：<a href="https://www.liangzl.com/get-article-detail-2622.html">https://www.liangzl.com/get-article-detail-2622.html</a></p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果tomcat启动过慢</span></span><br><span class="line"><span class="comment">#进入jre的bin中（根据需要换成自己的路径，下同）</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/jdk1.8.0_221/jre/lib/security/</span></span><br><span class="line"><span class="comment">#修改java.security</span></span><br><span class="line"><span class="string">vim</span> <span class="string">java.security</span> </span><br><span class="line"><span class="comment">#将securerandom.source=file:/dev/random 替换为securerandom.source=file:/dev/./urandom</span></span><br></pre></td></tr></table></figure>

<p><img src="http://img.xiajibagao.top/java.security.PNG"></p>
<h2 id="3-如果要直接使用tomcat的自带管理工具"><a href="#3-如果要直接使用tomcat的自带管理工具" class="headerlink" title="3.如果要直接使用tomcat的自带管理工具"></a>3.如果要直接使用tomcat的自带管理工具</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置账号</span></span><br><span class="line"><span class="comment">#到conf目录 修改 tomcat-users.xml 配置文件(根据需要换成自己的路径，下同)</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/apache-tomcat-8.5.43/conf/</span></span><br><span class="line"><span class="string">vim</span> <span class="string">tomcat-users.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在文件加上如下内容 账号密码自己设置</span></span><br><span class="line"><span class="string">&lt;role</span> <span class="string">rolename=&quot;manager-gui&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;role</span> <span class="string">rolename=&quot;admin-gui&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;user</span> <span class="string">username=&quot;用户名&quot;</span> <span class="string">password=&quot;密码&quot;</span> <span class="string">roles=&quot;manager-gui,admin-gui&quot;/&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#webapps/manager/META-INF 文件下修改 context.xml</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/apache-tomcat-8.5.43/webapps/manager/META-INF</span></span><br><span class="line"><span class="string">vim</span> <span class="string">context.xml</span></span><br><span class="line"><span class="comment">#加入以下变量（如果以有，则注释后再添加）</span></span><br><span class="line"><span class="string">&lt;Valve</span> <span class="string">className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span>  </span><br><span class="line">         <span class="string">allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1|\d+\.\d+\.\d+\.\d+&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">#重启tomcat后即可</span></span><br></pre></td></tr></table></figure>

<p>![](<a href="http://img.xiajibagao.top/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">http://img.xiajibagao.top/屏幕截图</a> 2020-10-27 094521.png)</p>
<p>然后访问8080端口，出现默认展示界面，点击三个选项任意一个</p>
<p>![](<a href="http://img.xiajibagao.top/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">http://img.xiajibagao.top/屏幕截图</a> 2020-10-27 094834.png)</p>
<p>进入项目管理</p>
<p><img src="http://img.xiajibagao.top/tomcat%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86.PNG"></p>
<p>在这个界面可以方便的部署本地项目，或者上传war包，也可以查看项目部署情况</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装jdk</title>
    <url>/2019/07/24/linux/linux%E4%B8%8B%E5%AE%89%E8%A3%85jdk/</url>
    <content><![CDATA[<h2 id="1-上传并解压jdk"><a href="#1-上传并解压jdk" class="headerlink" title="1.上传并解压jdk"></a>1.上传并解压jdk</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上传jdk至自己想要的文件夹，我的是/usr/local</span></span><br><span class="line"><span class="string">tar</span> <span class="string">-zxvf</span> <span class="string">jdk-8u221-linux-i586.tar.gz</span></span><br><span class="line"><span class="comment">#解压完后是名为jdk1.8.0_221的文件夹</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/jdk1.8.0_221/</span></span><br></pre></td></tr></table></figure>

<p><img src="http://img.xiajibagao.top/jdk%E8%B7%AF%E5%BE%84.PNG"></p>
<h2 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置变量</span></span><br><span class="line"><span class="string">vi</span>  <span class="string">/etc/profile</span></span><br><span class="line"><span class="comment">#添加</span></span><br><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/jdk1.8.0_221</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure>

<p><img src="http://img.xiajibagao.top/jdkexport.PNG"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#让配置生效</span></span><br><span class="line"><span class="string">.</span> <span class="string">/etc/profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#验证安装成功</span></span><br><span class="line"><span class="string">java</span> <span class="string">-version</span></span><br></pre></td></tr></table></figure>

<h2 id="3-如果查看版本报错"><a href="#3-如果查看版本报错" class="headerlink" title="3.如果查看版本报错"></a>3.如果查看版本报错</h2><p>当使用 <code>java -version</code> 的时候可能会报如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/jdk1.8.0_144/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录</span><br></pre></td></tr></table></figure>

<p>这个安装libc库后就可以了</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">yum</span> <span class="string">install</span> <span class="string">glibc.i686</span></span><br></pre></td></tr></table></figure>

<h2 id="4-查找已经安装的jdk"><a href="#4-查找已经安装的jdk" class="headerlink" title="4.查找已经安装的jdk"></a>4.查找已经安装的jdk</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#which java</span></span><br><span class="line">[<span class="string">root@iZwz9ev02los7q1d71e7muZ</span> <span class="string">/</span>]<span class="comment"># which java</span></span><br><span class="line"><span class="string">/usr/bin/java</span></span><br><span class="line"><span class="comment">#ls -lrt /usr/bin/java</span></span><br><span class="line">[<span class="string">root@iZwz9ev02los7q1d71e7muZ</span> <span class="string">/</span>]<span class="comment"># ls -lrt /usr/bin/java </span></span><br><span class="line"><span class="string">lrwxrwxrwx</span> <span class="number">1</span> <span class="string">root</span> <span class="string">root</span> <span class="number">22</span> <span class="string">Jul</span> <span class="number">31</span> <span class="number">19</span><span class="string">:10</span> <span class="string">/usr/bin/java</span> <span class="string">-&gt;</span> <span class="string">/etc/alternatives/java</span></span><br><span class="line"><span class="comment">#ls -lrt /etc/alternatives/java</span></span><br><span class="line">[<span class="string">root@iZwz9ev02los7q1d71e7muZ</span> <span class="string">/</span>]<span class="comment"># ls -lrt /etc/alternatives/java</span></span><br><span class="line"><span class="string">lrwxrwxrwx</span> <span class="number">1</span> <span class="string">root</span> <span class="string">root</span> <span class="number">73</span> <span class="string">Jul</span> <span class="number">31</span> <span class="number">19</span><span class="string">:10</span> <span class="string">/etc/alternatives/java</span> <span class="string">-&gt;</span> <span class="string">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64/jre/bin/java</span></span><br><span class="line"><span class="comment">#获得路径</span></span><br><span class="line"><span class="comment">#/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64/jre/bin/java</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装mysql</title>
    <url>/2019/07/24/linux/linux%E4%B8%8B%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取安装用的Yum Repository</span></span><br><span class="line"><span class="string">wget</span> <span class="string">-i</span> <span class="string">-c</span> <span class="string">http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span></span><br><span class="line"><span class="string">yum</span> <span class="string">-y</span> <span class="string">install</span> <span class="string">mysql57-community-release-el7-10.noarch.rpm</span></span><br><span class="line"><span class="comment">#安装MySQL服务</span></span><br><span class="line"><span class="string">yum</span> <span class="string">-y</span> <span class="string">install</span> <span class="string">mysql-community-server</span></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-v</span></span><br><span class="line"><span class="comment">#启动mysql</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">start</span> <span class="string">mysqld.service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找回初始密码并登录  jWTAeq-DF9tJ</span></span><br><span class="line"><span class="string">grep</span> <span class="string">&#x27;temporary password&#x27;</span> <span class="string">/var/log/mysqld.log</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-uroot</span> <span class="string">-p</span></span><br><span class="line"><span class="comment">#注意;找不到初始密码及其他情况参考下文&quot;修改密码&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用初始密码登录后需要先修改一次密码后才能操作</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;localhost&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">BY</span> <span class="string">&#x27;新密码&#x27;</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为避免Repository每次yum操作都会自动更新</span></span><br><span class="line"><span class="string">yum</span> <span class="string">-y</span> <span class="string">remove</span> <span class="string">mysql57-community-release-el7-10.noarch</span></span><br></pre></td></tr></table></figure>

<h2 id="2-修改密码"><a href="#2-修改密码" class="headerlink" title="2.修改密码"></a>2.修改密码</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.找回密码</span></span><br><span class="line"><span class="string">grep</span> <span class="string">&#x27;temporary password&#x27;</span> <span class="string">/var/log/mysqld.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.强制修改密码</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">stop</span> <span class="string">mysqld</span> <span class="comment">#停止服务</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">set-environment</span> <span class="string">MYSQLD_OPTS=&quot;--skip-grant-tables&quot;</span> <span class="comment">#跳过密码</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">start</span> <span class="string">mysqld</span> <span class="comment">#启动服务</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-u</span> <span class="string">root</span> <span class="comment">#登录</span></span><br><span class="line"><span class="string">UPDATE</span> <span class="string">mysql.user</span> <span class="string">SET</span> <span class="string">authentication_string</span> <span class="string">=</span> <span class="string">PASSWORD(&#x27;新密码&#x27;)</span> <span class="string">WHERE</span> <span class="string">User</span> <span class="string">=</span> <span class="string">&#x27;root&#x27;</span> <span class="string">AND</span> <span class="string">Host</span> <span class="string">=</span> <span class="string">&#x27;localhost&#x27;</span><span class="string">;</span> <span class="comment">#设置新密码</span></span><br><span class="line"><span class="string">FLUSH</span> <span class="string">PRIVILEGES;</span> <span class="comment">#刷新权限</span></span><br><span class="line"><span class="string">quit</span> <span class="comment">#退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.用操作系统账号修改密码</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-uroot</span> <span class="string">-p</span> <span class="comment">#使用centos账号密码登录</span></span><br><span class="line"><span class="string">UPDATE</span> <span class="string">mysql.user</span> <span class="string">SET</span> <span class="string">authentication_string</span> <span class="string">=</span> <span class="string">PASSWORD(&#x27;新密码&#x27;)</span> <span class="string">WHERE</span> <span class="string">User</span> <span class="string">=</span> <span class="string">&#x27;root&#x27;</span> <span class="string">AND</span> <span class="string">Host</span> <span class="string">=</span> <span class="string">&#x27;localhost&#x27;</span><span class="string">;</span> <span class="comment">#设置新密码</span></span><br><span class="line"><span class="string">FLUSH</span> <span class="string">PRIVILEGES;</span> <span class="comment">#刷新权限</span></span><br><span class="line"><span class="string">quit</span> <span class="comment">#退出</span></span><br></pre></td></tr></table></figure>

<h2 id="3-修改远程连接权限"><a href="#3-修改远程连接权限" class="headerlink" title="3.修改远程连接权限"></a>3.修改远程连接权限</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择mysql</span></span><br><span class="line"><span class="string">use</span> <span class="string">mysql;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#授权远程连接</span></span><br><span class="line"><span class="string">GRANT</span> <span class="string">ALL</span> <span class="string">PRIVILEGES</span> <span class="string">ON</span> <span class="string">*.*</span> <span class="string">TO</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">BY</span> <span class="string">&#x27;YYBrhr_2018&#x27;</span> <span class="string">WITH</span> <span class="string">GRANT</span> <span class="string">OPTION;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：如果navicat远程连接报1521错误</span></span><br><span class="line"><span class="string">GRANT</span> <span class="string">ALL</span> <span class="string">ON</span> <span class="string">*.*</span> <span class="string">TO</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;;</span> <span class="comment">#远程连接授权</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">BY</span> <span class="string">&#x27;password&#x27;</span> <span class="string">PASSWORD</span> <span class="string">EXPIRE</span> <span class="string">NEVER;</span> <span class="comment">#更改加密规则</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">WITH</span> <span class="string">mysql_native_password</span> <span class="string">BY</span> <span class="string">&#x27;123456&#x27;</span><span class="string">;</span> <span class="comment">#更改密码</span></span><br><span class="line"><span class="string">FLUSH</span> <span class="string">PRIVILEGES;</span> <span class="comment">#刷新权限</span></span><br></pre></td></tr></table></figure>

<p>注意，这一步需要小心，在自己的服务器或者内网的服务器就算了，如果是在外网的生产服务器上，务必先咨询同事。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（一）：队列</title>
    <url>/2020/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="一、什么是队列"><a href="#一、什么是队列" class="headerlink" title="一、什么是队列"></a>一、什么是队列</h2><p>队列是一种特殊的<strong>线性表</strong>。</p>
<p>队列元素的进出遵循“<strong>先进先出</strong>”原则：即只允许在前端（front）也就是<strong>队头</strong>进行<strong>删除</strong>操作，而只能在后端（rear）也就是<strong>队尾</strong>进行<strong>插入</strong>操作。</p>
<p><img src="http://img.xiajibagao.top/20200614170712.png"></p>
<p>如图所示：</p>
<ul>
<li>队列的最大长度为MaxSize，最大下标为MaxSize-1</li>
<li>入队时队头下标不变而队尾下标改变，出队时则相反</li>
</ul>
<h2 id="二、模拟队列"><a href="#二、模拟队列" class="headerlink" title="二、模拟队列"></a>二、模拟队列</h2><h3 id="1-简单的使用数组模拟队列："><a href="#1-简单的使用数组模拟队列：" class="headerlink" title="1.简单的使用数组模拟队列："></a>1.简单的使用数组模拟队列：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-11 16:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：用数组模拟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列最大长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line">    <span class="comment">//头指针，指向队头的元素的前一个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//尾指针，指向队尾的元素所在位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = size;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        <span class="keyword">this</span>.front = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当头指针和尾指针相等时队列为空</span></span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当尾指针等于maxSize-1时队列满</span></span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 入队元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addQueue</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否已满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已满！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾指针后移</span></span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = item;</span><br><span class="line">        <span class="keyword">return</span> rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">quitQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头指针后移</span></span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-解决“内存溢出”"><a href="#2-解决“内存溢出”" class="headerlink" title="2.解决“内存溢出”"></a>2.解决“内存溢出”</h3><p>咋一眼看上去没问题，但是实际上随着入队和出队操作，头指针和尾指针会不断后移，最后都到达maxSize-1的位置，此时即使实际上有空闲空间也无法往里面添加数据了。</p>
<p>如果要解决这个问题，可以这样改进：</p>
<p>当入队的时候进行一次判断，如果尾指针已经移动到maxSize-1的位置，并且头指针不在-1位置，也就是队列仍然还有空位，就触发一次数据迁移。</p>
<p>打个比方，如果队列长度为6，现在头指针在3，尾指针在5，触发数据迁移后下标3-5的数据移动到0-2去，然后把头指针移到0，尾指针移到2。</p>
<p>基于这个逻辑，只需要改变一下<code>addQueue()</code>入队方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 入队元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addQueue</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断队列是已满还是只是尾指针到头</span></span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        <span class="comment">//队列已满</span></span><br><span class="line">        <span class="keyword">if</span> (front == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已满！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//尾指针到头，触发数据迁移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; rear; i++) &#123;</span><br><span class="line">                arr[i - front] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移动指针</span></span><br><span class="line">            rear = rear - front;</span><br><span class="line">            front = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾指针后移</span></span><br><span class="line">    rear++;</span><br><span class="line">    arr[rear] = item;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然问题解决了，但是频繁的移动数据会消耗性能，为此仍需要加以改进：</p>
<p>当尾指针到头以后，如果头指针前还有空闲空间，尾指针应当能移动到头指针之前的位置，也就是队头元素出队了，空出的空间将可以放在队尾被元素入队。</p>
<p>打个比方，就相当于原本的队列是一条直线，走到头就没了，现在要把头和尾连接到一起，让它变成<strong>循环队列</strong>。</p>
<h2 id="三、循环队列"><a href="#三、循环队列" class="headerlink" title="三、循环队列"></a>三、循环队列</h2><img src="http://img.xiajibagao.top/20200614170726.png" style="zoom: 67%;" />

<p>对于循环队列，有两个问题需要考虑，一个是下标，另一个是队空和队满的判断条件</p>
<h3 id="1-环形队列的下标计算"><a href="#1-环形队列的下标计算" class="headerlink" title="1.环形队列的下标计算"></a>1.环形队列的下标计算</h3><p>由于队头元素出队后空间即用于队尾元素入队，所以很可能出现长度5的队列，头指针在1，尾指针在4，这个时候在按照原来的思路用rear+1去入队就会下标越界，因此需要进行取余操作，也就是<code>（rear+1）% maxSize</code>，这样获取下标的问题就解决了。</p>
<h3 id="2-环形队列的状态判断"><a href="#2-环形队列的状态判断" class="headerlink" title="2.环形队列的状态判断"></a>2.环形队列的状态判断</h3><p>由于队列变为环形，所以front=rear即可能是队满也可能是队空，针对这个问题有两种思路：</p>
<p><strong>第一种</strong>是添加一个变量来记录队列中元素的数量，以区分front=rear时是队满还队空；</p>
<p><strong>第二种</strong>是在rear后预留一个空位，通过计算判断rear+1后是否等于front以判断队满还是队空；</p>
<p>这里先用第二种来实现一下：</p>
<ul>
<li><p>队空的时候就是<code>front=rear</code></p>
</li>
<li><p>队满的时候就是<code>rear+1=front</code>，考虑到多次操作后指针可能跑了不止一圈，rear和front可能会大于maxSize，故也需要进行取余操作，所以正确的公式是</p>
<p><code>(rear+1)%maxSize = front%maxSize</code></p>
</li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-14 16:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：环形队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CricleQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列最大长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line">    <span class="comment">//头指针，指向队头的元素的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//尾指针，指向队尾的元素的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CricleQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于需要在尾指针后空一位作为队满队空的区分，所以实际大小是maxSize+1</span></span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> Object[maxSize + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当头指针和尾指针相等时队列为空</span></span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//头尾指针+1并取余时相等时队列满</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已满！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = item;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">quitQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object item = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十八）：图</title>
    <url>/2020/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="一、什么是图"><a href="#一、什么是图" class="headerlink" title="一、什么是图"></a>一、什么是图</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>首先，我们已经在之前学习过了树这种数据结构，树能反映一对多的关系，但是却无法反映多对多的关系，因此我们引入了图这种数据结构。</p>
<p>对于图，其节点也可以叫做<strong>顶点</strong>，每个节点具有<strong>零或者多个相连节点</strong>，每个节点之间的连接称为<strong>边</strong>，从一个节点到达另一个节点路线都称为<strong>路径</strong>。</p>
<p><img src="http://img.xiajibagao.top/%E5%9B%BE.png" alt="image-20200804155639505"></p>
<p>以上图为例，其中：</p>
<ul>
<li>无向图：顶点之间连接没有方向。比如从A到C，可是A -&gt; B -&gt; C，也可以是A -&gt; D -&gt; B -&gt; C。</li>
<li>有向图：顶点之间连接有方向。如果A到B，必须是A -&gt; B，不能是B -&gt; A</li>
<li>带权图：边带有权值。</li>
</ul>
<h3 id="2-树与图的关系"><a href="#2-树与图的关系" class="headerlink" title="2.树与图的关系"></a>2.树与图的关系</h3><p>实际上，对于有向图还分为两种情况，即图中含环或者图中不含环的单向图，其中含环的图可以从某个顶点出发最终返回原点。</p>
<p>结合对图的定义，我们不难发现，<strong>树也可以理解为不含有环的单向图</strong>，是图的子集。</p>
<p>两者的区别在于：</p>
<ul>
<li>图中每个节点可以有任意数量的边，而树两个节点间仅仅只有一条边</li>
<li>图没有根节点，而树有</li>
<li>图中可以存着环，而树不行</li>
<li>如果有n个节点，图最多有n*(n-1)条边，而树最多有n-1条边</li>
</ul>
<h2 id="二、图的表示与构建"><a href="#二、图的表示与构建" class="headerlink" title="二、图的表示与构建"></a>二、图的表示与构建</h2><p>图的表示就是边与边关系的表示，有二维数组（邻接矩阵）和链表（邻接表）两种表示方法。</p>
<h3 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1.邻接矩阵"></a>1.邻接矩阵</h3><p><img src="http://img.xiajibagao.top/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E5%9B%BE.png" alt="image-20200804161211188"></p>
<p>我们建立一个二维数组（矩阵），第一维表示顶点，而第二维表示与该顶点相连接的点。</p>
<p>比如说0号点与1,2,3,4相连，与0（自己）和5不相连，表示为<code>[0][011110]</code>，其中，二维数组中的1表示与0号点相连，0表示与0号点不相连</p>
<h3 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2.邻接表"></a>2.邻接表</h3><p><img src="http://img.xiajibagao.top/%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E5%9B%BE.png" alt="image-20200804161802498"></p>
<p>邻接表相比邻接矩阵，只表示关联的边而不表示不关联的表，相对邻接矩阵而言更简洁也更节省空间</p>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p>我们使用邻接矩阵的方式来示范如何使用代码构建一个图。</p>
<p>为了方便理解，我们使用两个数组来表示节点与节点之间的对应关系：</p>
<p><img src="http://img.xiajibagao.top/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9B%BE.png" alt="image-20200804172225850"></p>
<p>如上图，上图的节点之间的对应关系通过两个数组来表示就是<code>&#123;0,0,0,0,1&#125; -&gt; &#123;1,2,3,4,2&#125;</code>，即 <code>0-&gt;1,0-&gt;2,,0-&gt;3,,0-&gt;4,,1-&gt;2</code>，可见要创建的图有5个节点。</p>
<p>对应实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-08-04 16:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点与节点间的相连关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] node1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] node2;</span><br><span class="line">    <span class="comment">//有几个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="comment">//边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sideNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] graph;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span>[] node1, <span class="keyword">int</span>[] node2, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node1 = node1;</span><br><span class="line">        <span class="keyword">this</span>.node2 = node2;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.sideNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        CreateGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取二维数组，一维表示节点，二维表示节点的相邻节点</span></span><br><span class="line">        graph = <span class="keyword">new</span> <span class="keyword">int</span>[num][num];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            graph[i] = Arrays.copyOf(graph[i], num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node1.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//统计边数</span></span><br><span class="line">            <span class="keyword">if</span> (graph[node1[i]][node2[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                sideNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            graph[node1[i]][node2[i]] = <span class="number">1</span>;</span><br><span class="line">            graph[node2[i]][node1[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] n1 : graph) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n2 : n1) &#123;</span><br><span class="line">                System.out.print(n2 + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;有&quot;</span> + num + <span class="string">&quot;个节点，&quot;</span> + sideNum + <span class="string">&quot;条边&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">有<span class="number">5</span>个节点，<span class="number">5</span>条边</span><br></pre></td></tr></table></figure>



<h2 id="三、图的深度优先搜索"><a href="#三、图的深度优先搜索" class="headerlink" title="三、图的深度优先搜索"></a>三、图的深度优先搜索</h2><p>图的遍历有两种策略：<strong>深度优先搜索</strong>（DFS）和<strong>广度优先搜索</strong>（BFS）。</p>
<p>以下的演示我们仍基于第二部分创建的图为示例：</p>
<p><img src="D:\代码及jar包\学习记录\数据结构\图\构建一个图.png" alt="image-20200804172225850"></p>
<h3 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1.思路分析"></a>1.思路分析</h3><p>dfs的搜索大体思路是这样的：</p>
<blockquote>
<p>首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，然后重复以上步骤直到完成遍历。</p>
</blockquote>
<p>这个思路如果学过树的遍历会感觉非常熟悉。由前面知道，树就是一种特殊的图，所以<strong>树的前、中、后序遍历其实就是树的dfs</strong>。</p>
<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>将思路转换为代码实现的步骤：</p>
<ul>
<li>访问第一个节点v，并且将其标记为已访问</li>
<li>查找第一个节点的邻接节点w：<ol>
<li>如果w节点不存在，则继续查找v的下一个邻接节点</li>
<li>如果w存在，并且未访问，则将w当成下一个v，进行递归</li>
</ol>
</li>
</ul>
<p>第一步，我们需要在<code>Graph类</code>中添加<code>isVisted</code>公共变量用于标记节点是否被访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录节点是否被访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisted;</span><br></pre></td></tr></table></figure>

<p>第二步，我们需要查找节点是否存在相连节点方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找邻接节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果当前节点存在邻接节点就返回下标</span></span><br><span class="line">        <span class="keyword">if</span> (graph[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找下一个邻接节点的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index2 + <span class="number">1</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果当前节点存在邻接节点就返回下标</span></span><br><span class="line">        <span class="keyword">if</span> (graph[index1][index2] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，借助访问标记和查找邻接节点方法实现dfs</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dsf</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//访问节点</span></span><br><span class="line">    System.out.print(index + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//标记已访问节点</span></span><br><span class="line">    isVisted[index] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//获取第一个邻接节点</span></span><br><span class="line">    <span class="keyword">int</span> w = getNeighbor(index);</span><br><span class="line">    <span class="comment">//如果邻接节点存在</span></span><br><span class="line">    <span class="keyword">while</span> (w != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//并且该邻接节点未访问</span></span><br><span class="line">        <span class="keyword">if</span> (!isVisted[w]) &#123;</span><br><span class="line">            dsf(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该节点已被访问,就访问当前节点的邻接节点的下一个邻接节点</span></span><br><span class="line">        w = getNextNeighbor(index, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对所有节点进行dfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="comment">//如果该节点仍未被访问才进行dfs</span></span><br><span class="line">        <span class="keyword">if</span> (!isVisted[i]) &#123;</span><br><span class="line">            dsf(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;</span><br></pre></td></tr></table></figure>



<h2 id="四、图的广度优先搜索"><a href="#四、图的广度优先搜索" class="headerlink" title="四、图的广度优先搜索"></a>四、图的广度优先搜索</h2><h3 id="1-思路分析-1"><a href="#1-思路分析-1" class="headerlink" title="1.思路分析"></a>1.思路分析</h3><p>bfs的大题思路是这样的：</p>
<blockquote>
<p>首先创建一个队列，把第一个邻接节点入队，然后队列元素出队，把该元素的邻接节点入队，然后出队…..重复该步骤，一层一层的遍历同级节点</p>
</blockquote>
<p>如果我们按这个思路，将4作为起始节点，那么第一个4入队，然后4出队，把4的邻接节点0入队，接着0出队，把0的邻接节点1,2,3,入队；同理如果将0作为起始节点，那么第一次0入队，然后0出队，把0的邻接节点1,2,3入队……</p>
<h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>将思路转换为代码实现的步骤：</p>
<ul>
<li>访问初始节点v，标记并入队</li>
<li>当队列不为空时，将队头节点u出队，否则跳过本次循环</li>
<li>查找u的第一个邻接节点w，如果不存在就重复步骤2，否则：<ol>
<li>若w未被访问，则标记并入队</li>
<li>查找u继w后的下一个邻接节点，重复步骤3</li>
</ol>
</li>
</ul>
<p>这里继续复用上文dfs中使用的 <code>getNeighbor()</code>、<code>getNextNeighbor()</code>和 <code>isVisted[]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    LinkedList queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问节点</span></span><br><span class="line">    System.out.print(index + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//标记已访问节点</span></span><br><span class="line">    isVisted[index] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//节点入队</span></span><br><span class="line">    queue.addLast(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环直到遍历完所有队列中的节点</span></span><br><span class="line">    <span class="keyword">int</span> u, w = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//取出队列头结点下标</span></span><br><span class="line">        u = (<span class="keyword">int</span>) queue.removeFirst();</span><br><span class="line">        <span class="comment">//获取出队节点的邻接节点</span></span><br><span class="line">        w = getNeighbor(u);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果为被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisted[w]) &#123;</span><br><span class="line">                <span class="comment">//访问节点并标记</span></span><br><span class="line">                System.out.print(u + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                isVisted[w] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将节点入队</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接着查找下一个邻接节点</span></span><br><span class="line">            w = getNextNeighbor(u, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.isVisted = <span class="keyword">new</span> <span class="keyword">boolean</span>[num];</span><br><span class="line">    <span class="comment">//对所有节点进行bfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="comment">//如果该节点仍未被访问才惊喜dfs</span></span><br><span class="line">        <span class="keyword">if</span> (!isVisted[i]) &#123;</span><br><span class="line">            bfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;</span><br></pre></td></tr></table></figure>

<p>值得一提是，虽然上文的例子不太直观，但是bfs也常常用于<strong>树的层次遍历</strong>，比如</p>
<p><img src="http://img.xiajibagao.top/bfs%E7%94%A8%E4%BA%8E%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.png" alt="bfs用于层次遍历"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试数据</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>[] u = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span>-&gt;<span class="number">8</span>-&gt;</span><br></pre></td></tr></table></figure>

<p>可以很明显的看出，是一层一层遍历的，这也很直观的反应了bfs的执行逻辑。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十七）：B树，B+树</title>
    <url>/2020/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9AB%E6%A0%91%EF%BC%8CB+%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一、什么是多路查找树"><a href="#一、什么是多路查找树" class="headerlink" title="一、什么是多路查找树"></a>一、什么是多路查找树</h2><p>二叉树有诸多便利之处，但是当二叉树节点极多时，二叉树的构建速度就会受影响，而且过高的层数也会导致对树的操作效率降低。</p>
<img src="http://img.xiajibagao.top/过多节点的二叉树.png" alt="过多节点的二叉树" style="zoom:50%;" />

<p>对于树的查找而言，树的高度决定了查找的时间下限，但是同样数量的节点，如果要高度小那每一层容纳的节点就要多，而二叉树每一层固定的节点数导致的高度难以降低，为此每一个节点都能拥有多个子节点的**多叉树(multi way tree)**就出现了.</p>
<img src="http://img.xiajibagao.top/多叉树.png" alt="多叉树" style="zoom: 50%;" />

<p>B树，B+树都是多叉树</p>
<h2 id="二、B树"><a href="#二、B树" class="headerlink" title="二、B树"></a>二、B树</h2><p>B树也称B-树,它是一颗多路平衡查找树。</p>
<p>2-3树是最简单的B树，它具有以下特点：</p>
<ul>
<li>2-3树的所有叶子节点都在同一层（只要是B树都满足该条件）</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。三节点本身包含两个数据项</li>
<li>有三个子节点的节点叫三节点<strong>，</strong>三节点要么没有子节点<strong>，</strong>要么有三个子节点。二节点本身包含一个数据项</li>
<li>2-3树是由二节点和三节点构成的树。</li>
</ul>
<p>我们以数列{16,24,12,32,14,26,34,10,8,28,38,20}构建2-3树为例：</p>
<p><img src="http://img.xiajibagao.top/2-3%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9.png" alt="image-20200725183108854"></p>
<p>对于2-3树插入的特点，我们举几个具有代表性的例子：</p>
<ul>
<li>{16}插入24：由于24大于16，又16是一个二节点，他要么有两个值节点要么没有节点，所以只能插到16节点里，变成一个三节点</li>
<li>{16,24}插入12：由于12小于16，又[16|24]是一个三节点，所以将[16|12]拆开，以16为父节点，24为右子节点，12作为为左子节点插入</li>
<li>{16,24,12,32,14,26,34}插入10：按顺序找到[12|14]节点，将三节点拆开后，以12为父节点，14为左子节点，10作为为左子节点插入，由于插入10以后，树的所有叶子节点就不在同一层了，所以需要对其他子树进行调整，将[16|26]拆开，将26变为16的右子节点，原本的24与[32,34]节点变为24的左右子节点</li>
</ul>
<p>除了2-3树以外，还有一种2-3-4树也是B树的一种，相比2-3树，它多了一个包含能3个数据项与四个子节点的四节点：</p>
<p><img src="http://img.xiajibagao.top/2-3-4%E6%A0%91.png" alt="image-20200725185527418"></p>
<p><strong>由于B树的关键字集合可以分布在整颗树上，如果查找的数据离根节点很近，此时查找会比B+树快</strong></p>
<h2 id="三、B-树"><a href="#三、B-树" class="headerlink" title="三、B+树"></a>三、B+树</h2><p><img src="http://img.xiajibagao.top/b+%E6%A0%91.png" alt="image-20200725192414148"></p>
<p>B+树具有以下特点：</p>
<ul>
<li>B+树只有叶子节点存放数据（稠密索引），而非叶子节点只作为索引（稀疏索引），这使得非叶子节点所能保存的关键字大大增加</li>
<li>B+树的叶子节点存放的数据是有序的</li>
</ul>
<p><strong>相对B树，B+具有以下优点</strong>：</p>
<ol>
<li>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同</li>
<li>B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高</li>
<li>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描</li>
</ol>
<p><strong>也由于这些优点，在mysql中，索引实现是基于B+树的。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十三）：赫夫曼树</title>
    <url>/2020/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一、什么是赫夫曼树"><a href="#一、什么是赫夫曼树" class="headerlink" title="一、什么是赫夫曼树"></a>一、什么是赫夫曼树</h2><p>给定n个权值作为n个叶子节点，构造一课二叉树，若该树的带权路径长度和（wpl）达到最小，称这样的二叉树为<strong>最优二叉树</strong>，也就是<strong>赫夫曼树</strong>。</p>
<p>要理解这句话，我们需要了解几个关键词：</p>
<ul>
<li>路径：从一个节点往下一个节点之间的通路。若根节点层数为1，则根节点通往L层的节点路径长度为L-1</li>
<li>带权路径：权可以理解为节点值，而从根节点到某节点之间的路径长度与该点的权的成绩称为带权路径长度</li>
</ul>
<p>举个例子：</p>
<p><img src="http://img.xiajibagao.top/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt="image-20200717165237484"></p>
<p>如上图所示，节点13到根节点的路径长度是2，而权是13，所以带权路径长度就是2*13=26，同理，节点7的带权路径长度是14，8是16,3是6，最终该树的带权路径长度之和（wpl）就是26+14+16+6=62。</p>
<p><img src="http://img.xiajibagao.top/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%912.png" alt="image-20200717165733984"></p>
<p>而该树与上图有相同的叶子节点，但是wpl却是13+16+21+9=59，这<strong>是拥有这几个相同叶子节点的树里面wpl最小的</strong>，所以这颗树就是一颗赫夫曼树。</p>
<p>我们不难看出，赫夫曼树最大的特点：<strong>权越大的节点越靠近根节点</strong></p>
<h2 id="二、如何构建赫夫曼树"><a href="#二、如何构建赫夫曼树" class="headerlink" title="二、如何构建赫夫曼树"></a>二、如何构建赫夫曼树</h2><p>举个例子，我们要将{6,1,3,7,13,8,29}这一串数列组建为赫夫曼树</p>
<ol>
<li><p>首先，我们对齐从小到大排序，得到{1,3,6,7,8,13,29}</p>
</li>
<li><p>取出1和3，并以两节点之和4为根节点组建树</p>
<p><img src="http://img.xiajibagao.top/%E6%9E%84%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC1.png" alt="image-20200717172110379"></p>
</li>
<li><p>取出6，并与4之和10为根节点构建树</p>
<p><img src="http://img.xiajibagao.top/%E6%9E%84%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC2.png" alt="image-20200717172201798"></p>
</li>
<li><p>取出7，并与10之和17为根节点构建树</p>
<p><img src="http://img.xiajibagao.top/%E6%9E%84%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC3.png" alt="image-20200717172314477"></p>
</li>
<li><p>重复以上步骤最终得到赫夫曼树</p>
</li>
</ol>
<p><img src="http://img.xiajibagao.top/%E6%9E%84%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC4.png" alt="image-20200717172440901"></p>
<h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><p>首先先写一个节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-17 17:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：赫夫曼树使用的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父节点的构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.val = left.val + right.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;val=&quot;</span> + val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现排序接口，从大到小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(<span class="keyword">this</span>.val - o.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现一个构造赫夫曼树的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-17 17:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：赫夫曼树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建赫夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组元素拆分成节点</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建树</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出最小的两个数构建树</span></span><br><span class="line">            Node left = nodes.get(nodes.size() - <span class="number">1</span>);</span><br><span class="line">            Node right = nodes.get(nodes.size() - <span class="number">2</span>);</span><br><span class="line">            Node parant = <span class="keyword">new</span> Node(left, right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//删除两个节点</span></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将根节点添加至集合</span></span><br><span class="line">            nodes.add(parant);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十四）：赫夫曼编码</title>
    <url>/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="一、什么是赫夫曼编码"><a href="#一、什么是赫夫曼编码" class="headerlink" title="一、什么是赫夫曼编码"></a>一、什么是赫夫曼编码</h2><p>哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，</p>
<p>使用赫夫曼编码可以有效的压缩数据，通常可以节省20%~90%的空间。</p>
<p>在理解赫夫曼编码前，我们需要对通讯领域的两种编码方式有个粗略的了解。</p>
<p>假设我们需要传输 <code>I&#39;m a jvav programmer and I love programming</code>这样一句话，我们有两种传输方式：</p>
<ol>
<li><p>定长编码</p>
<p>直接转换为对应长度的二进制格式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">01101111</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100111</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100111</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span></span><br></pre></td></tr></table></figure>

<p>总长度为296个字符</p>
</li>
<li><p>变长编码</p>
<p>按照各个字符出现的次数进行编码，按出现次数编码，出现次数越多的，则编码越小：</p>
<p>比如空格出现最多次，然后是a，以此类推……</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>=  ，<span class="number">1</span>=a，<span class="number">10</span>=i，<span class="number">11</span>=o......</span><br></pre></td></tr></table></figure>

<p>当传输的信息越多的时候，变长编码实际传输的长度相对定长编码就越小</p>
</li>
</ol>
<p>另外，我们还需要了解一下什么是补码：</p>
<blockquote>
<p>计算机里面只有加法器，没有减法器，所以减法必须用加法来完成。<br>对于 100 以内的十进制数，“-1”就可以用”+99”代替。比如 25 － 1 ＝ 24，可以写成 25 ＋ 99 ＝ (1)24。<br>如果限定了两位数，那“-1”和“+99”就是等效的。同样，“-2”可以用“+98”代替。</p>
<p>它们之间，称为<strong>补数</strong>，而100就称为<strong>模</strong>。</p>
<p>对于<strong>8位二进制数</strong>：0000 0000~1111 1111(255)，<strong>模为256</strong>。<br>－1，可以用 +255(1111 1111)代替。<br>－2，可以用 +254(1111 1110)代替</p>
<p>这些二进制数，就称为负数的<strong>补码</strong></p>
</blockquote>
<h2 id="二、赫夫曼编码思路"><a href="#二、赫夫曼编码思路" class="headerlink" title="二、赫夫曼编码思路"></a>二、赫夫曼编码思路</h2><p>同样举个例子，我们要传输 <code>i like like like java do you like a java</code>这段话</p>
<ol>
<li><p>统计各字符的出现次数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">d:<span class="number">1</span> y:<span class="number">1</span> u:<span class="number">1</span> j:<span class="number">2</span> v:<span class="number">2</span> o:<span class="number">2</span> l:<span class="number">4</span> k:<span class="number">4</span> e:<span class="number">4</span> i:<span class="number">5</span> a:<span class="number">5</span> :<span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将字符出现次数作为节点的权，构建一个赫夫曼树（这里步骤同<a href="https://www.cnblogs.com/Createsequence/p/13331722.html#_label1">上一篇文章</a>）</p>
<p><img src="http://img.xiajibagao.top/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%A0%91.png" alt="image-20200717213740072"></p>
</li>
<li><p>我们使用0和1来描述某个节点在树中往左或往右的路径，比如j，从根节点出发抵达j的路径就是0000，抵达i的路径就是101</p>
<p>于是现在对所有字符的路径进行统计，就有：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">o: <span class="number">1000</span>     u: <span class="number">10010</span>     d: <span class="number">100110</span>     y: <span class="number">100111</span>    i: <span class="number">101</span>    a : <span class="number">110</span></span><br><span class="line">k: <span class="number">1110</span>     e: <span class="number">1111</span>      j: <span class="number">0000</span>       v: <span class="number">0001</span>      l: <span class="number">001</span>      : <span class="number">01</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按照上面的路径，我们将其转为二进制</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</span></span><br></pre></td></tr></table></figure>

<p>直接转为二进制长度为359，而经过赫夫曼编码长度则是133，与直接转为二进制相比，缩短了62.9%</p>
</li>
</ol>
<h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><h3 id="1-创建节点类"><a href="#1-创建节点类" class="headerlink" title="1.创建节点类"></a>1.创建节点类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-18 13:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：赫夫曼编码用节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCodeNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HuffmanCodeNode</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符</span></span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    HuffmanCodeNode left;</span><br><span class="line">    HuffmanCodeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanCodeNode</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanCodeNode</span><span class="params">(HuffmanCodeNode left, HuffmanCodeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算子节点权值之和</span></span><br><span class="line">        <span class="keyword">this</span>.weight = left.weight + right.weight;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(HuffmanCodeNode o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">            <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-统计字符出现次数，并组装节点列表"><a href="#2-统计字符出现次数，并组装节点列表" class="headerlink" title="2.统计字符出现次数，并组装节点列表"></a>2.统计字符出现次数，并组装节点列表</h3><p>对应思路中的第一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计字符在字符串中的出现次数，并组装节点列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HuffmanCodeNode&gt; <span class="title">getNodes</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将字符串转为字符串数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] strBytes = str.getBytes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历字节数组，并且统计某一字符出现次数</span></span><br><span class="line">    Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">        Integer count = counts.get(b);</span><br><span class="line">        <span class="comment">//判断某一字符是否第一次出现</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">            counts.put(b, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不是就让出现次数+1</span></span><br><span class="line">            counts.put(b, count ++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将map转为节点集合</span></span><br><span class="line">    List&lt;HuffmanCodeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HuffmanCodeNode(entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-生成赫夫曼树"><a href="#3-生成赫夫曼树" class="headerlink" title="3.生成赫夫曼树"></a>3.生成赫夫曼树</h3><p>对应思路中的第二步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建赫夫曼树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes 节点集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最终生成的树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HuffmanCodeNode <span class="title">createTree</span><span class="params">(List&lt;HuffmanCodeNode&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建树</span></span><br><span class="line">    <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line">        <span class="comment">//取出最小的两个数构建树</span></span><br><span class="line">        HuffmanCodeNode left = nodes.get(<span class="number">0</span>);</span><br><span class="line">        HuffmanCodeNode right = nodes.get(<span class="number">1</span>);</span><br><span class="line">        HuffmanCodeNode parant = <span class="keyword">new</span> HuffmanCodeNode(left, right);</span><br><span class="line">        <span class="comment">//删除两个节点</span></span><br><span class="line">        nodes.remove(left);</span><br><span class="line">        nodes.remove(right);</span><br><span class="line">        <span class="comment">//将根节点添加至集合</span></span><br><span class="line">        nodes.add(parant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个时候可以通过前序遍历来检查是否构建成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(HuffmanCodeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    System.out.println(node.toString());</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-得到赫夫曼编码"><a href="#4-得到赫夫曼编码" class="headerlink" title="4.得到赫夫曼编码"></a>4.得到赫夫曼编码</h3><p>对应思路中的第三步：</p>
<p>我们已经得到了赫夫曼树，现在我们需要获得从根节点到各个叶子结点的路径，也就是赫夫曼编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成赫夫曼树对应的赫夫曼编码集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 储存某个叶子节点的拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将传入的节点作为树的根节点，找到其所有的叶子结点的赫夫曼编码，并放入赫夫曼编码集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> way 叶子结点的路径，左为0，右为1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> builder 用于拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(HuffmanCodeNode node, String way, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(builder);</span><br><span class="line">    <span class="comment">//建路径拼接至上一路径</span></span><br><span class="line">    stringBuilder.append(way);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断当前是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//向左右递归直到找到叶子结点</span></span><br><span class="line">            getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">            getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//已经是叶子结点，将路径存入集合</span></span><br><span class="line">            huffmanCodes.put(node.data, stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建赫夫曼树</span></span><br><span class="line">    HuffmanCodeNode root = createTree();</span><br><span class="line">    <span class="comment">//处理左右子树</span></span><br><span class="line">    getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">    getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">    <span class="comment">//返回赫夫曼编码</span></span><br><span class="line">    <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-将得到的赫夫曼编码转回字节数组"><a href="#5-将得到的赫夫曼编码转回字节数组" class="headerlink" title="5.将得到的赫夫曼编码转回字节数组"></a>5.将得到的赫夫曼编码转回字节数组</h3><p>对应思路中的第四步，也就是最后一步：</p>
<p>我们得到了赫夫曼编码表，也就是这玩意： <code>Map&lt;Byte, String&gt; huffmanCodes</code>，每串赫夫曼编码字符串都<strong>对应一个字符</strong>，我们需要<strong>处理赫夫曼编码的每一个字符</strong>，将其<strong>转为二进制后再转为byte</strong>，最后处理完得到一队字节数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串对应的byte数组，转换为经过赫夫曼编码压缩后的byte数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">    <span class="comment">//获取赫夫曼编码</span></span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//遍历byte数组，一个byte表示一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (Byte b : bytes) &#123;</span><br><span class="line">        <span class="comment">//将字符转为赫夫曼编码格式，一个字符对应8位编码</span></span><br><span class="line">        stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个字符对应对应的8位的赫夫曼编码，如果赫夫曼编码无法被8整除，就直接补齐赫夫曼编码不足八位的那一个字符</span></span><br><span class="line">    <span class="keyword">int</span> len = stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span> ? stringBuilder.length() / <span class="number">8</span> : stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//System.out.println(&quot;有几个字符：&quot;+len);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将压缩后的赫夫曼编码按字符分开存储</span></span><br><span class="line">    <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">    <span class="comment">//计录已处理几个字符</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每8位编码对应一个byte，所以步长为8</span></span><br><span class="line">    <span class="comment">//每循环一次处理一个byte，也就是一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123;</span><br><span class="line">        String strBytes;</span><br><span class="line">        <span class="comment">//判断编码长度是否超过8位</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">8</span> &lt; stringBuilder.length()) &#123;</span><br><span class="line">            <span class="comment">//超过8位就从赫夫曼编码截取八位（也就是一个字符）</span></span><br><span class="line">            strBytes = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就有多少截多少</span></span><br><span class="line">            strBytes = stringBuilder.substring(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将赫夫曼编码转为二进制，存入byte数组</span></span><br><span class="line">        huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strBytes, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//位已处理字符数+1</span></span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环结束后，返回赫夫曼编码按字符转换得到的字节数组</span></span><br><span class="line">    <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] zip() &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">    Map&lt;Byte, String&gt; huffmanCodes = getCodes();</span><br><span class="line">    <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-解码"><a href="#6-解码" class="headerlink" title="6.解码"></a>6.解码</h3><p>信息被赫夫曼编码处理后我们会得到一队字节数组，如果要解码，我们需要先把字节数组按字符一个字节一个字节的转为二进制，然后通过赫夫曼编码表把二进制和字符字节一一找出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将byte转成二进制字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isComple 是否需要补高位。最后一个字节无需补位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 要转换的字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">byteToString</span><span class="params">(<span class="keyword">boolean</span> isComplate, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = b;</span><br><span class="line">    <span class="comment">//判断是否需要补齐高位</span></span><br><span class="line">    <span class="keyword">if</span> (isComplate) &#123;</span><br><span class="line">        temp |= <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回temp对应的二进制补码</span></span><br><span class="line">    String str = Integer.toBinaryString(temp);</span><br><span class="line">    <span class="keyword">return</span> isComplate ? str.substring(str.length() - <span class="number">8</span>) : str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码处理过的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 原来未被转为赫夫曼编码的的字符串字节素组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将赫夫曼编码处理过byte数组转为二进制字符串</span></span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isComplate = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果是最后一个字节就不用补高位了</span></span><br><span class="line">        <span class="keyword">if</span> (i == huffmanBytes.length - <span class="number">1</span>) &#123;</span><br><span class="line">            isComplate = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接字节转的二进制字符串</span></span><br><span class="line">        stringBuilder.append(byteToString(isComplate, huffmanBytes[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串按照指定赫夫曼编码进行解码</span></span><br><span class="line">    <span class="comment">//原本赫夫曼编码表是&lt;字节，二进制字符串&gt;，现在要转为&lt;二进制字符串，字节&gt;以通过转换得到的二进制字符串取出对应的字节</span></span><br><span class="line">    Map&lt;String, Byte&gt; reHuffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">        reHuffmanCodes.put(entry.getValue(), entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Byte&gt; bytes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//由于无法确认拼接后的二进制字符串每八位一定就能和某个字节对应，所以需要进行字符串匹配</span></span><br><span class="line">    <span class="comment">//这里可以简单理解为双指针，一号指针从i开始，二号指针从i+1开始</span></span><br><span class="line">    <span class="comment">//一号指针先指向字符串第i字符，然后二号指针从i+1个字符开始不断后移，然后进行进行匹配</span></span><br><span class="line">    <span class="comment">//比如：i=0，j=1，第一次截取并匹配的字符就是[0,1),也就是0；第二次是[0,2)，也就是01；然后是[0,3).....以此类推</span></span><br><span class="line">    <span class="comment">//直到找到以后，比如[2,7)，就移动一号指针到7，二号指针移动到8</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; stringBuilder.length(); i = --j) &#123;</span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!reHuffmanCodes.containsKey(key)) &#123;</span><br><span class="line">            key = stringBuilder.substring(i, j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes.add(reHuffmanCodes.get(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由集合转为字节数组</span></span><br><span class="line">    <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[bytes.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">        b[i] = bytes.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、完整代码"><a href="#四、完整代码" class="headerlink" title="四、完整代码"></a>四、完整代码</h2><p>具体代码和测试用例可以去<a href="https://github.com/Createsequence/data_structure">GitHub</a>上看，这里就放实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-18 13:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：赫夫曼编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code.length() == <span class="number">0</span> || code == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;字符串必须有至少一个字符！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.str = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计字符在字符串中的出现次数，并组装节点列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;HuffmanCodeNode&gt; <span class="title">getNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串转为字符串数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字节数组，并且统计某一字符出现次数</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">24</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            Integer count = counts.get(b);</span><br><span class="line">            <span class="comment">//判断某一字符是否第一次出现</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不是就让出现次数+1</span></span><br><span class="line">                counts.put(b, count ++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将map转为节点集合</span></span><br><span class="line">        List&lt;HuffmanCodeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> HuffmanCodeNode(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建赫夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HuffmanCodeNode <span class="title">createTree</span><span class="params">(List&lt;HuffmanCodeNode&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建树</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//从小到大排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出最小的两个数构建树</span></span><br><span class="line">            HuffmanCodeNode left = nodes.get(<span class="number">0</span>);</span><br><span class="line">            HuffmanCodeNode right = nodes.get(<span class="number">1</span>);</span><br><span class="line">            HuffmanCodeNode parant = <span class="keyword">new</span> HuffmanCodeNode(left, right);</span><br><span class="line">            <span class="comment">//删除两个节点</span></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            <span class="comment">//将根节点添加至集合</span></span><br><span class="line">            nodes.add(parant);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HuffmanCodeNode <span class="title">createTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTree(getNodes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(HuffmanCodeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        System.out.println(node.toString());</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HuffmanCodeNode root = createTree(getNodes());</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成赫夫曼树对应的赫夫曼编码集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 储存某个叶子节点的拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将传入的节点作为树的根节点，找到其所有的叶子结点的赫夫曼编码，并放入赫夫曼编码集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> way 叶子结点的路径，左为0，右为1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(HuffmanCodeNode node, String way, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(builder);</span><br><span class="line">        <span class="comment">//建路径拼接至上一路径</span></span><br><span class="line">        stringBuilder.append(way);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前是否为叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//向左右递归直到找到叶子结点</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//已经是叶子结点，将路径存入集合</span></span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回赫夫曼编码</span></span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建赫夫曼树</span></span><br><span class="line">        HuffmanCodeNode root = createTree();</span><br><span class="line">        <span class="comment">//处理左右子树</span></span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//返回赫夫曼编码</span></span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串对应的byte数组，转换为经过赫夫曼编码压缩后的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="comment">//获取赫夫曼编码</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历byte数组，一个byte表示一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (Byte b : bytes) &#123;</span><br><span class="line">            <span class="comment">//将字符转为赫夫曼编码格式，一个字符对应8位编码</span></span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个字符对应对应的8位的赫夫曼编码，如果赫夫曼编码无法被8整除，就直接补齐赫夫曼编码不足八位的那一个字符</span></span><br><span class="line">        <span class="keyword">int</span> len = stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span> ? stringBuilder.length() / <span class="number">8</span> : stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;有几个字符：&quot;+len);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将压缩后的赫夫曼编码按字符分开存储</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="comment">//计录已处理几个字符</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每8位编码对应一个byte，所以步长为8</span></span><br><span class="line">        <span class="comment">//每循环一次处理一个byte，也就是一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123;</span><br><span class="line">            String strBytes;</span><br><span class="line">            <span class="comment">//判断编码长度是否超过8位</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &lt; stringBuilder.length()) &#123;</span><br><span class="line">                <span class="comment">//超过8位就从赫夫曼编码截取八位（也就是一个字符）</span></span><br><span class="line">                strBytes = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则就有多少截多少</span></span><br><span class="line">                strBytes = stringBuilder.substring(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将赫夫曼编码转为二进制，存入byte数组</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strBytes, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//位已处理字符数+1</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环结束后，返回赫夫曼编码按字符转换得到的字节数组</span></span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] zip() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes();</span><br><span class="line">        <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将byte转成二进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isComple 是否需要补高位。最后一个字节无需补位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 要转换的字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">byteToString</span><span class="params">(<span class="keyword">boolean</span> isComplate, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        <span class="comment">//判断是否需要补齐高位</span></span><br><span class="line">        <span class="keyword">if</span> (isComplate) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回temp对应的二进制补码</span></span><br><span class="line">        String str = Integer.toBinaryString(temp);</span><br><span class="line">        <span class="keyword">return</span> isComplate ? str.substring(str.length() - <span class="number">8</span>) : str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码处理过的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来未被转为赫夫曼编码的的字符串字节素组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将赫夫曼编码处理过byte数组转为二进制字符串</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isComplate = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果是最后一个字节就不用补高位了</span></span><br><span class="line">            <span class="keyword">if</span> (i == huffmanBytes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                isComplate = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拼接字节转的二进制字符串</span></span><br><span class="line">            stringBuilder.append(byteToString(isComplate, huffmanBytes[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把字符串按照指定赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//原本赫夫曼编码表是&lt;字节，二进制字符串&gt;，现在要转为&lt;二进制字符串，字节&gt;以通过转换得到的二进制字符串取出对应的字节</span></span><br><span class="line">        Map&lt;String, Byte&gt; reHuffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            reHuffmanCodes.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Byte&gt; bytes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//由于无法确认拼接后的二进制字符串每八位一定就能和某个字节对应，所以需要进行字符串匹配</span></span><br><span class="line">        <span class="comment">//这里可以简单理解为双指针，一号指针从i开始，二号指针从i+1开始</span></span><br><span class="line">        <span class="comment">//一号指针先指向字符串第i字符，然后二号指针从i+1个字符开始不断后移，然后进行进行匹配</span></span><br><span class="line">        <span class="comment">//比如：i=0，j=1，第一次截取并匹配的字符就是[0,1),也就是0；第二次是[0,2)，也就是01；然后是[0,3).....以此类推</span></span><br><span class="line">        <span class="comment">//直到找到以后，比如[2,7)，就移动一号指针到7，二号指针移动到8</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; stringBuilder.length(); i = --j) &#123;</span><br><span class="line">            String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (!reHuffmanCodes.containsKey(key)) &#123;</span><br><span class="line">                key = stringBuilder.substring(i, j);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            bytes.add(reHuffmanCodes.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由集合转为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[bytes.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = bytes.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decode(<span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> decode(huffmanCodes, huffmanBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十一）：二叉树</title>
    <url>/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一、什么是二叉树"><a href="#一、什么是二叉树" class="headerlink" title="一、什么是二叉树"></a>一、什么是二叉树</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>首先，需要了解树这种数据结构的定义：</p>
<blockquote>
<p>树：是一类重要的非线性数据结构，是以分支关系定义的层次结构。每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树</p>
</blockquote>
<p><img src="http://img.xiajibagao.top/20200711203743.PNG"></p>
<p>树的结构类似现实中的树，一个父节点有若干子节点，而一个子节点又有若干子节点，以此类推。</p>
<h3 id="2-名词解释"><a href="#2-名词解释" class="headerlink" title="2.名词解释"></a>2.名词解释</h3><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>根节点</td>
<td>树的顶端结点</td>
</tr>
<tr>
<td>父节点</td>
<td>若一个节点含有子节点，则这个节点称为其子节点的父节点</td>
</tr>
<tr>
<td>子节点</td>
<td>具有相同父节点的节点</td>
</tr>
<tr>
<td>兄弟节点</td>
<td>彼此都拥有同一个父节点的节点</td>
</tr>
<tr>
<td>叶子节点</td>
<td>即没有子节点的节点</td>
</tr>
<tr>
<td>节点的权</td>
<td>即节点值</td>
</tr>
<tr>
<td>路节点的度</td>
<td>一个节点含有的子树的个数</td>
</tr>
<tr>
<td>树的度</td>
<td>一棵树中，最大的节点的度称为树的度</td>
</tr>
<tr>
<td>深度</td>
<td><strong>根结点到这个结点</strong>所经历的边的个数</td>
</tr>
<tr>
<td>层数</td>
<td>该节点的深度+1</td>
</tr>
<tr>
<td>高度</td>
<td><strong>结点到叶子结点</strong>的最长路径所经历的边的个数</td>
</tr>
<tr>
<td>树高度</td>
<td>即根节点的高度</td>
</tr>
<tr>
<td>森林</td>
<td>由m（m&gt;=0）棵互不相交的树的集合称为森林</td>
</tr>
</tbody></table>
<h3 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3.二叉树"></a>3.二叉树</h3><p>二叉树就是每个节点最多只有两颗子树的树：</p>
<p><img src="http://img.xiajibagao.top/%E4%BA%8C%E5%8F%89%E6%A0%91.PNG"></p>
<p>对于二叉树有：</p>
<ul>
<li><p>满二叉树：所有的子节点都在最后一层，且节点总数与层数有<code>节点总数=2^n-1</code></p>
<p><img src="http://img.xiajibagao.top/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
</li>
<li><p>完全二叉树：从根节点到倒数第二层都符合满二叉树，但是最后一层节点不完全充填，叶子结点都靠左对齐</p>
<p><img src="http://img.xiajibagao.top/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
</li>
</ul>
<h2 id="二、二叉树的遍历"><a href="#二、二叉树的遍历" class="headerlink" title="二、二叉树的遍历"></a>二、二叉树的遍历</h2><p>二叉树遍历分为三种：</p>
<ul>
<li>前序遍历: 先输出父节点，再遍历左子树和右子树 </li>
<li>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 </li>
<li>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</li>
</ul>
<p>可见，根据父节点输出顺序即可以判断是哪一种遍历。</p>
<h3 id="1-简单代码实现"><a href="#1-简单代码实现" class="headerlink" title="1.简单代码实现"></a>1.简单代码实现</h3><p>先创建节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-11 17:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nodeNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode left;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> nodeNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nodeNum = nodeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BinaryTreeNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;nodeNum=&quot;</span> + nodeNum +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNodeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nodeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNodeNum</span><span class="params">(<span class="keyword">int</span> nodeNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nodeNum = nodeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreeNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现遍历方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-11 17:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;根节点不允许为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印节点</span></span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="comment">//向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrder(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印节点</span></span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="comment">//向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrder(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        postOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印节点</span></span><br><span class="line">        System.out.println(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h3><p>对含有7个简单的满二叉树进行遍历的结果：</p>
<p><img src="http://img.xiajibagao.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%BE%8B%E5%AD%90.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前序遍历：</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">1</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">2</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">4</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">5</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">3</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">6</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">7</span>&#125;</span><br><span class="line">中序遍历：</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">4</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">2</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">5</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">1</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">6</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">3</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">7</span>&#125;</span><br><span class="line">后序遍历：</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">4</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">5</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">2</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">6</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">7</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">3</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、二叉树的查找"><a href="#三、二叉树的查找" class="headerlink" title="三、二叉树的查找"></a>三、二叉树的查找</h2><p>大体逻辑同遍历，这里就不在赘述了，直接放代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">preSearch</span><span class="params">(<span class="keyword">int</span> num,BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    BinaryTreeNode result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前节点是否为查找节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getNodeNum() == num) &#123;</span><br><span class="line">        result = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断左节点是否为空，不为空就前序查找节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = preSearch(num, node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左树找到就返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就判断并递归前序查找右树</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = preSearch(num, node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">inSearch</span><span class="params">(<span class="keyword">int</span> num,BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    BinaryTreeNode result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左节点是否为空，不为空就中序查找节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = inSearch(num, node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左树找到就返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左树未找到就判断当前节点是不是</span></span><br><span class="line">    <span class="keyword">if</span> (node.getNodeNum() == num) &#123;</span><br><span class="line">        result = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就判断并递归前序查找右树</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = inSearch(num, node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">postSearch</span><span class="params">(<span class="keyword">int</span> num,BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    BinaryTreeNode result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左节点是否为空，不为空就后序查找节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = postSearch(num, node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左树找到就返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则就判断并递归后序查找右树</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = postSearch(num, node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断右树是否找到</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果右树仍未找到就判断当前节点是不是</span></span><br><span class="line">    <span class="keyword">if</span> (node.getNodeNum() == num) &#123;</span><br><span class="line">        result = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、二叉树的删除"><a href="#四、二叉树的删除" class="headerlink" title="四、二叉树的删除"></a>四、二叉树的删除</h2><p>对于二叉树的删除，有以下逻辑：</p>
<ul>
<li>由于树的节点和节点之间的联系是单向的，对于要删除的节点，需要找到他的父节点进行删除</li>
<li>从根节点开始遍历节点，判断节点的左右子节点是否为目标节点</li>
<li>如果是就删除并返回</li>
<li>否则就持续向右或左递归，直到找到目标节点，或者将树遍历完为止</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num, BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断删除的是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.getNodeNum() == num) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不允许删除根节点！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果子节点就是要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span> &amp;&amp; node.getLeft().getNodeNum() == num) &#123;</span><br><span class="line">        node.setLeft(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span> &amp;&amp; node.getRight().getNodeNum() == num) &#123;</span><br><span class="line">        node.setRight(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就往左树或右树遍历直到找到或遍历完为止</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        delete(num, node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        delete(num,node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、顺序存储二叉树"><a href="#五、顺序存储二叉树" class="headerlink" title="五、顺序存储二叉树"></a>五、顺序存储二叉树</h2><p>一般想到二叉树都会先想到较为形象的链式存储，即用含有左右指针的节点来组成树，实际上，通过计算，也可以使用数组来表示二叉树。</p>
<p>可以简单的理解：顺序存储二叉树是逻辑的上一棵树，而链式存储二叉树是物理上的一棵树。</p>
<p>以下图的树为例：</p>
<p><img src="http://img.xiajibagao.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%BE%8B%E5%AD%90.png"></p>
<p>假设数组为{1,2,3,4,5,6,7,}，我们可以知道：</p>
<ul>
<li>下标为n的元素的左节点为：<code>2*n+1</code></li>
<li>下标为n的元素的右节点为：<code>2*n+2</code></li>
<li>下标为n的元素的父节点为：<code>(n-1)/2</code></li>
</ul>
<p>如果给顺序存储二叉树写一个前序遍历急就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出数组</span></span><br><span class="line">    System.out.println(arr[index]);</span><br><span class="line">    <span class="comment">//向左递归</span></span><br><span class="line">    <span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">        preOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右递归</span></span><br><span class="line">    <span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">        preOrder(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码的实现上和链式二叉树是差不多的，这里就不再一一列举了。</p>
<p>当然，由于顺序存储二叉树的性质，当树需要排序的情况下，顺序存储二叉树就会出现空间浪费的情况：</p>
<p><img src="http://img.xiajibagao.top/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十六）：平衡二叉树</title>
    <url>/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一、什么是平衡二叉树"><a href="#一、什么是平衡二叉树" class="headerlink" title="一、什么是平衡二叉树"></a>一、什么是平衡二叉树</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>平衡二叉树（AVL树）是一种带有平衡条件的二叉搜索树。它的特性如下：</p>
<ul>
<li>AVL树的左右两个子树的高度差的绝对值不超过1</li>
<li>AVL树的左右两个子树都是一棵平衡二叉树</li>
</ul>
<p><img src="http://img.xiajibagao.top/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20200722173142958"></p>
<p>举个例子，如上图所示：</p>
<ul>
<li>第一棵树左树高2，右树高1，差值为1，是一颗AVL树；</li>
<li>第二棵树左树高2，右树高2，差值为0，是一颗AVL树；</li>
<li>第三棵树左树高3，右树高1，差值为2，不是一颗AVL树；</li>
</ul>
<p>红黑树就是一直AVL树。</p>
<h3 id="2-为什么需要平衡二叉树"><a href="#2-为什么需要平衡二叉树" class="headerlink" title="2.为什么需要平衡二叉树"></a>2.为什么需要平衡二叉树</h3><p>当我们使用二叉排序树的时候，当连续插入顺序的节点的时候就会出现问题。比如，我们插入{1,2,3,4,5}这样一个数组：</p>
<p><img src="http://img.xiajibagao.top/%E6%95%88%E7%8E%87%E4%BD%8E%E4%B8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20200722173840094"></p>
<p>可见该树左树节点全为空，比起树更像单链表，这也导致了该树的插入和查询速度明显的下降，查询速度甚至因为每次多处一个比较左树的操作导致还不如单链表。为了避免这种情况，我们引入的AVL树。</p>
<h2 id="二、AVL树左旋转"><a href="#二、AVL树左旋转" class="headerlink" title="二、AVL树左旋转"></a>二、AVL树左旋转</h2><h3 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1.思路分析"></a>1.思路分析</h3><p>AVL为了避免左右树高度差超过1，在可能导致这种情况的插入或者删除操作时会进行旋转。</p>
<p>我们举个例子，现在有数列{4,3,6,5,7}，当插入8后，现在的得到的排序树如下图：</p>
<p><img src="http://img.xiajibagao.top/image-20200723175058126.png" alt="image-20200723175058126"></p>
<p>明显不再是一个AVL树，所以需要进行<strong>左旋转</strong>：</p>
<ol>
<li><p>我们以当前根节点值再创建一个新节点<code>newNode</code></p>
</li>
<li><p>让新节点的左子节点指向根节点的左子节点</p>
<p><code>newNode.left = root.left</code></p>
</li>
<li><p>让新节点的右子节点指向根节点的右子节点的左子节点</p>
<p><code>newNode.right = root.right.left</code></p>
<p><img src="http://img.xiajibagao.top/AVl%E5%B7%A6%E6%97%8B%E8%BD%AC1.png" alt="image-20200723183026891"></p>
</li>
<li><p>把根节点的值换成右子节点的值</p>
<p><code>root.val = root.right.val</code></p>
</li>
<li><p>把根节点的右子节点指向其右子节点的右子节点</p>
<p><code>root.right = root.right.right</code></p>
</li>
<li><p>让根节点的左子节点指向新节点（根节点的右子节点成为了新的根节点）</p>
<p><code>root.left = newNode</code></p>
<p><img src="http://img.xiajibagao.top/AVl%E5%B7%A6%E6%97%8B%E8%BD%AC2.png" alt="image-20200723183950837"></p>
</li>
</ol>
<p>我们调整一下图片样式，就可以直观的看到左旋转后树的样子：</p>
<p><img src="http://img.xiajibagao.top/AVl%E5%B7%A6%E6%97%8B%E8%BD%AC3.png" alt="image-20200723184527438"></p>
<p>网上看到一个非常形象直观的动图：</p>
<p><img src="http://img.xiajibagao.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E6%97%8B%E8%BD%AC.gif"></p>
<p>不难理解：<strong>左旋的目的是降低左子树的高度</strong></p>
<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>由于AVL树是基于BST改进的一种数据结构，所以这里的AVL树类继承了BST的方法和代码，使用同一个节点类，这里具体的代码可以参考<a href="https://www.cnblogs.com/Createsequence/p/13346146.html#_label1">之前的文章</a>。</p>
<p>我们先创建一个继承BST的AVL树类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-23 19:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：平衡二叉树</span></span><br><span class="line"><span class="comment"> * 由于是在二叉排序树的基础上改进，这里直接继承了二叉排序树类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> <span class="keyword">extends</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLTree</span><span class="params">(BinarySortTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于旋转的条件是左右子树高度差大于1，所以我们需要有几个方法来判断树的高度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前节点的右子树高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightHeight</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前节点的左子树高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftHeight</span><span class="params">(BinarySortTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取以当前节点为根节点的树高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前节点的左/右节点是否为空，是返回0，否则遍历返回当前节点的左右树最高值</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(node.left == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.left), node.right == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接着我们需要一个让树左旋的代码，步骤同思路分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序树左旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建新节点，与根节点值相同</span></span><br><span class="line">    BinarySortTreeNode node = <span class="keyword">new</span> BinarySortTreeNode(root.val);</span><br><span class="line">    <span class="comment">//2.让新节点左子节点指向根节点左子节点</span></span><br><span class="line">    node.left = root.left;</span><br><span class="line">    <span class="comment">//3.让新节点的右子节点指向根节点的右子节点的左子节点</span></span><br><span class="line">    node.right = root.right.left;</span><br><span class="line">    <span class="comment">//4.让根节点的值变为其右子节点的值</span></span><br><span class="line">    root.val = root.right.val;</span><br><span class="line">    <span class="comment">//5.把根节点的右子节点指向其右子节点的右子节点</span></span><br><span class="line">    root.right = root.right.right;</span><br><span class="line">    <span class="comment">//6.让根节点的左子节点指向新节点</span></span><br><span class="line">    root.left = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后我们再原先旧的添加方法上进行改进：</p>
<p>当添加完一个节点后，我们判断左右子树的高度差是否大于1，如果是就进行左旋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写二叉排序树的节点添加方法，当添加完节点后左子树与右子树高度差大于1时，让树进行左旋转，若情况相反则进行右旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.add(node);</span><br><span class="line">    <span class="comment">//添加完节点后，判断左子树与右子树高度差是否大于1</span></span><br><span class="line">    <span class="keyword">int</span> disparity = getRightHeight(root) - getLeftHeight(root);</span><br><span class="line">    <span class="keyword">if</span> (disparity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高度差:&quot;</span> + disparity + <span class="string">&quot;,左旋转！&quot;</span>);</span><br><span class="line">        <span class="comment">//左子树与右子树高度差大于1就左旋</span></span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>截止目前，仅仅只对左子树高度较高的情况作了处理！</strong></p>
<h2 id="三、AVL树的双旋转"><a href="#三、AVL树的双旋转" class="headerlink" title="三、AVL树的双旋转"></a>三、AVL树的双旋转</h2><p>左旋转是为了降低左子树的高度，但是如果是右子树高度过高，我们就需要右旋，事实上，一个完整的AVL树，应当是能够双旋的。</p>
<p>右旋的步骤与左旋基本一致，但是方向不同：</p>
<ol>
<li><p>我们以当前根节点值再创建一个新节点<code>newNode</code></p>
</li>
<li><p>让新节点的<strong>右子节点</strong>指向根节点的<strong>右子节点</strong></p>
<p><code>newNode.right = root.right</code></p>
</li>
<li><p>让新节点的<strong>左子节点</strong>指向根节点的<strong>左子节点</strong>的<strong>右子节点</strong></p>
<p><code>newNode.left = root.left.right</code></p>
</li>
<li><p>把根节点的值换成<strong>左子节点</strong>的值</p>
<p><code>root.val = root.left.val</code></p>
</li>
<li><p>把根节点的<strong>左子节点</strong>指向其<strong>左子节点</strong>的<strong>左子节点</strong></p>
<p><code>root.left = root.left.left</code></p>
</li>
<li><p>让根节点的右子节点指向新节点（根节点的左子节点成为了新的根节点）</p>
<p><code>root.right = newNode</code></p>
</li>
</ol>
<p><img src="http://img.xiajibagao.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E6%97%8B%E8%BD%AC.gif"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序树右旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建新节点，与根节点值相同</span></span><br><span class="line">    BinarySortTreeNode node = <span class="keyword">new</span> BinarySortTreeNode(root.val);</span><br><span class="line">    <span class="comment">//2.让新节点右子节点指向根节点右子节点</span></span><br><span class="line">    node.right = root.right;</span><br><span class="line">    <span class="comment">//3.让新节点的左子节点指向根节点的左子节点的右子节点</span></span><br><span class="line">    node.left = root.left.right;</span><br><span class="line">    <span class="comment">//4.让根节点的值变为其左子节点的值</span></span><br><span class="line">    root.val = root.left.val;</span><br><span class="line">    <span class="comment">//5.把根节点的左子节点指向其左子节点的左子节点</span></span><br><span class="line">    root.left = root.left.left;</span><br><span class="line">    <span class="comment">//6.让根节点的右子节点指向新节点</span></span><br><span class="line">    root.right = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在为排序树的add方法添加右旋的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写二叉排序树的节点添加方法，当添加完节点后左子树与右子树高度差大于1时，让树进行左旋转，若情况相反则进行右旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.add(node);</span><br><span class="line">    <span class="comment">//添加完节点后，判断左右树高度差是否大于1</span></span><br><span class="line">    <span class="keyword">int</span> disparity = getRightHeight(root) - getLeftHeight(root);</span><br><span class="line">    <span class="keyword">if</span> (disparity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高度差:&quot;</span> + disparity + <span class="string">&quot;,左旋转！&quot;</span>);</span><br><span class="line">        <span class="comment">//左子树与右子树高度差大于1就左旋</span></span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (- disparity &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//右子树与左子树高度差小于1就左旋</span></span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十五）：二叉排序树</title>
    <url>/2020/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一、什么是二叉排序树"><a href="#一、什么是二叉排序树" class="headerlink" title="一、什么是二叉排序树"></a>一、什么是二叉排序树</h2><blockquote>
<p><strong>二叉排序树</strong>（Binary Sort Tree）又称<strong>二叉查找树</strong>、<strong>二叉搜索树</strong>。 它或者是一棵空树；或者是具有下列性质的二叉树：</p>
<p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>（3）左、右子树也分别为二叉排序树；</p>
</blockquote>
<p><img src="http://img.xiajibagao.top/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.png" alt="image-20200720112917992"></p>
<p>当我们使用需要对数列进行操作的时候，我们原本有以下选择：</p>
<ul>
<li>数组：不排序的数组插入快而查找慢，排序数组通过算法可以快速查找，但是插入效率又会受到影响</li>
<li>链表：不管是否有序，插入都快，但是查找效率都不高</li>
<li>哈希表：查找修改都简单，但当哈希冲突严重的时候传统哈希表效率也会下降</li>
</ul>
<p>而二叉排序树的查找类似二分查找，而插入类似链表，相较以上三种结构可以较好的平衡查找和插入效率</p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><p>我们先实现一个节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-20 11:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉排序树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BinarySortTreeNode left;</span><br><span class="line">    BinarySortTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;val=&quot;</span> + val +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再实现一个二叉排序树类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-20 12:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉排序树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BinarySortTreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTree</span><span class="params">(BinarySortTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;根节点不允许为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="1-添加"><a href="#1-添加" class="headerlink" title="1.添加"></a>1.添加</h3><p>思路如下：</p>
<ul>
<li>获取要插入的节点与其父节点比较值，比父节点小向左树插，否则就向右插</li>
<li>插入是判断父节点的左/右子节点是否存在，存在就继续递归遍历左/右树直到找到插入位置，否则直接插入</li>
</ul>
<p>在节点类中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要添加的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode parent,BinarySortTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断子节点是否小于父节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent.val &gt; node.val) &#123;</span><br><span class="line">        <span class="comment">//判断要添加的位置是否还有节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//有就继续遍历左树</span></span><br><span class="line">            add(parent.left, node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则直接添加</span></span><br><span class="line">            parent.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            add(parent.right, node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2.查找"></a>2.查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 要查找的节点值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">search</span><span class="params">(BinarySortTreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前节点是否为要找到的值</span></span><br><span class="line">    <span class="keyword">if</span> (node.val != val) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; val) &#123;</span><br><span class="line">        <span class="comment">//如果当前节点大于查找值，就向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(node.left, val);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则就向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(node.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h3><p>删除节点时会出现三种情况：</p>
<ul>
<li>要删除的节点是叶子结点</li>
<li>要删除的节点是一棵树的根节点</li>
<li>要删除的节点是两棵树的根节点</li>
</ul>
<p>不管对于哪种情况而言，我们都需要先找到要要删除节点的父节点的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查找目标节点的父节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> val 要查找的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">searchParentOfTarget</span><span class="params">(BinarySortTreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前节点的子节点是否为目标节点</span></span><br><span class="line">    <span class="keyword">boolean</span> isTargetParent = (node.left != <span class="keyword">null</span> &amp;&amp; node.left.val == val) || (node.right != <span class="keyword">null</span> &amp;&amp; node.right.val == val);</span><br><span class="line">    <span class="keyword">if</span> (isTargetParent) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果查找值小于当前节点，向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; node.val &amp;&amp; node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchParentOfTarget(node.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= node.val &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果查找值大于当前节点,向右递归</span></span><br><span class="line">            <span class="keyword">return</span> searchParentOfTarget(node.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则目标节点不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先区分三种情况，然后在此基础上分别实现三种情况下的删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定叶子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要删除节点的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 要删除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断要删除的是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;树中只有根节点，无法删除!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找目标节点</span></span><br><span class="line">    BinarySortTreeNode target = search(val);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找目标节点的父节点</span></span><br><span class="line">    BinarySortTreeNode parent = searchTargetParent(val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断要删除的节点的子节点情况</span></span><br><span class="line">    <span class="keyword">if</span> (target.left == <span class="keyword">null</span> &amp;&amp; target.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//删除叶子节点</span></span><br><span class="line">        deleteLeafNode(val, parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.left != <span class="keyword">null</span> &amp;&amp; target.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//删除有两颗子树的节点的节点</span></span><br><span class="line">        deleteTwoBranchNode(target);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//删除只有一颗子树的节点</span></span><br><span class="line">        deleteOneBranchNode(val, target, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在以上代码的基础上继续分析思路。</p>
<h4 id="3-1删除的节点是叶子结点"><a href="#3-1删除的节点是叶子结点" class="headerlink" title="3.1删除的节点是叶子结点"></a>3.1删除的节点是叶子结点</h4><p>即方法<code>deleteLeafNode()</code></p>
<ul>
<li>找到要删除的节点，并判断其左右子节点是否都为空</li>
<li>若都为空，再找到其父节点，然后判断要删除的节点是父节点的左子节点还是右子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除叶子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要删除节点的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 要删除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteLeafNode</span><span class="params">(<span class="keyword">int</span> val, BinarySortTreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断目标节点是父节点左节点还是右节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.val == val) &#123;</span><br><span class="line">        parent.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2删除的节点有一课子树"><a href="#3-2删除的节点有一课子树" class="headerlink" title="3.2删除的节点有一课子树"></a>3.2删除的节点有一课子树</h4><p>即方法<code>deleteOneBranchNode()</code></p>
<ul>
<li>找到目标节点，判断目标节点有的那颗子树是左子树还是右子树</li>
<li>判断目标节点是否为根节点，如果是就直接将根节点替换为目标节点的子节点</li>
<li>如果不是根节点，再判断目标节点是其父节点的左子节点还是右子节点</li>
<li>让父节点的子节点指向目标节点的子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除只有一颗子树的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 要删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 要删除的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 要删除的节点的父节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteOneBranchNode</span><span class="params">(<span class="keyword">int</span> val, BinarySortTreeNode target, BinarySortTreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断目标节点有左子树还是右子树</span></span><br><span class="line">    <span class="keyword">if</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是根节点，就直接删除</span></span><br><span class="line">            root = target.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//目标节点只有左子树</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left.val == val) &#123;</span><br><span class="line">                parent.left = target.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = target.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = target.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//目标节点只有右子树</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left.val == val) &#123;</span><br><span class="line">                parent.left = target.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = target.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-删除的节点结点有两颗子树"><a href="#3-3-删除的节点结点有两颗子树" class="headerlink" title="3.3 删除的节点结点有两颗子树"></a>3.3 删除的节点结点有两颗子树</h4><p>即方法<code>deleteLeafNode()</code></p>
<p>当有要删除的节点有两颗子树时情况比较特殊，我们不能通过直接改变指针指向的方式让子树直接“移接”到目标节点的父节点上，我们需要在目标节点的子树中找到一个能替换目标节点并且不会改变排序树顺序的节点。</p>
<p>我们举个例子，现有{5,3,2,7,6,4,1,0,8}，形成的树</p>
<p><img src="http://img.xiajibagao.top/%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E7%BB%93%E7%82%B9%E6%9C%89%E4%B8%80%E9%A2%97%E5%AD%90%E6%A0%91.png" alt="image-20200720164054844"></p>
<p>我们要删除节点3，那3的位置就必须换成一个比3的右子树节点小而比左子树所有节点大的数，也就是说，这个数：</p>
<ul>
<li>左树选最大：可以是目标节点的左子节点的左树最大值，也就是2；</li>
<li>右树选最小：可以是目标节点的右子节点的右树最小值，也就是4；</li>
</ul>
<p>这里我们选择用右子树的最小值作为替换值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除有两颗子树的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteTwoBranchNode</span><span class="params">(BinarySortTreeNode target)</span> </span>&#123;</span><br><span class="line">    BinarySortTreeNode minNodeOfTargetRitht = target.right;</span><br><span class="line">    <span class="comment">//遍历找到目标节点右子树上的最小值</span></span><br><span class="line">    <span class="comment">//右子树上的最小值，也就是目标节点的右子节点的左树最大值</span></span><br><span class="line">    <span class="keyword">while</span> (minNodeOfTargetRitht.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        minNodeOfTargetRitht = minNodeOfTargetRitht.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除最小值</span></span><br><span class="line">    deleteNode(minNodeOfTargetRitht.val);</span><br><span class="line">    <span class="comment">//目标节点的值替换为该最小值</span></span><br><span class="line">    target.val = minNodeOfTargetRitht.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按以上方法，等于删除4，然后让3的值变为4：</p>
<p><img src="http://img.xiajibagao.top/%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E7%BB%93%E7%82%B9%E6%9C%89%E4%B8%80%E9%A2%97%E5%AD%90%E6%A0%912.png" alt="image-20200720165202316"></p>
<h2 id="三、完整代码"><a href="#三、完整代码" class="headerlink" title="三、完整代码"></a>三、完整代码</h2><p>具体代码和测试用例可以去<a href="https://github.com/Createsequence/data_structure">GitHub</a>上看，这里就放实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-20 12:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉排序树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BinarySortTreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTree</span><span class="params">(BinarySortTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;根节点不允许为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            show(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.toString());</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            show(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        show(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要添加的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode parent,BinarySortTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断子节点是否小于父节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.val &gt; node.val) &#123;</span><br><span class="line">            <span class="comment">//判断要添加的位置是否还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//有就继续遍历左树</span></span><br><span class="line">                add(parent.left, node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则直接添加</span></span><br><span class="line">                parent.left = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                add(parent.right, node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode node)</span></span>&#123;</span><br><span class="line">        add(root, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要查找的节点值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">search</span><span class="params">(BinarySortTreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前节点是否为要找到的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; val) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点大于查找值，就向左递归</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> search(node.left, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就向右递归</span></span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> search(node.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找目标节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BinarySortTreeNode <span class="title">searchTargetParent</span><span class="params">(BinarySortTreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前节点的子节点是否为目标节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isTargetParent = (node.left != <span class="keyword">null</span> &amp;&amp; node.left.val == val) || (node.right != <span class="keyword">null</span> &amp;&amp; node.right.val == val);</span><br><span class="line">        <span class="keyword">if</span> (isTargetParent) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找值小于当前节点，向左递归</span></span><br><span class="line">            <span class="keyword">if</span> (val &lt; node.val &amp;&amp; node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> searchTargetParent(node.left, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= node.val &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果查找值大于当前节点,向右递归</span></span><br><span class="line">                <span class="keyword">return</span> searchTargetParent(node.right, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则目标节点不存在</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">searchTargetParent</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchTargetParent(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要删除节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断要删除的是否为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;树中只有根节点，无法删除!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找目标节点</span></span><br><span class="line">        BinarySortTreeNode target = search(val);</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查找目标节点的父节点</span></span><br><span class="line">        BinarySortTreeNode parent = searchTargetParent(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断要删除的节点的子节点情况</span></span><br><span class="line">        <span class="keyword">if</span> (target.left == <span class="keyword">null</span> &amp;&amp; target.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//删除叶子节点</span></span><br><span class="line">            deleteLeafNode(val, parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.left != <span class="keyword">null</span> &amp;&amp; target.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//删除有两颗子树的节点的节点</span></span><br><span class="line">            deleteTwoBranchNode(target);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除只有一颗子树的节点</span></span><br><span class="line">            deleteOneBranchNode(val, target, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除有两颗子树的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTwoBranchNode</span><span class="params">(BinarySortTreeNode target)</span> </span>&#123;</span><br><span class="line">        BinarySortTreeNode minNodeOfTargetRitht = target.right;</span><br><span class="line">        <span class="comment">//遍历找到目标节点右子树上的最小值</span></span><br><span class="line">        <span class="comment">//右子树上的最小值，也就是目标节点的右子节点的左树最大值</span></span><br><span class="line">        <span class="keyword">while</span> (minNodeOfTargetRitht.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minNodeOfTargetRitht = minNodeOfTargetRitht.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除最小值</span></span><br><span class="line">        deleteNode(minNodeOfTargetRitht.val);</span><br><span class="line">        <span class="comment">//目标节点的值替换为该最小值</span></span><br><span class="line">        target.val = minNodeOfTargetRitht.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除只有一颗子树的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteOneBranchNode</span><span class="params">(<span class="keyword">int</span> val, BinarySortTreeNode target, BinarySortTreeNode parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断要目标节点有左子树还是右子树</span></span><br><span class="line">        <span class="keyword">if</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是根节点，就直接删除</span></span><br><span class="line">                root = target.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标节点只有左子树</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left.val == val) &#123;</span><br><span class="line">                    parent.left = target.left;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.right = target.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = target.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标节点只有右子树</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left.val == val) &#123;</span><br><span class="line">                    parent.left = target.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.right = target.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除叶子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteLeafNode</span><span class="params">(<span class="keyword">int</span> val, BinarySortTreeNode parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断目标节点是父节点左节点还是右节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.val == val) &#123;</span><br><span class="line">            parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十二）：堆排序</title>
    <url>/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="一、什么是堆排序"><a href="#一、什么是堆排序" class="headerlink" title="一、什么是堆排序"></a>一、什么是堆排序</h2><h3 id="1-堆，堆排序"><a href="#1-堆，堆排序" class="headerlink" title="1.堆，堆排序"></a>1.堆，堆排序</h3><p>对于“<strong>堆</strong>”我们可以理解为具有以下性质的<strong>完全二叉树</strong>：</p>
<ul>
<li>每个结点的值都<strong>大于或等于</strong>其左右孩子结点的值，称为<strong>大顶堆</strong></li>
<li>每个结点的值都<strong>小于或等于</strong>其左右孩子结点的值，称为<strong>小顶堆</strong></li>
</ul>
<p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
<p>在排序时，一般<strong>升序</strong>采用大顶堆，<strong>降序</strong>采用小顶堆。</p>
<h3 id="2-大顶堆"><a href="#2-大顶堆" class="headerlink" title="2.大顶堆"></a>2.大顶堆</h3><p><img src="http://img.xiajibagao.top/%E5%A4%A7%E9%A1%B6%E5%A0%86.png"></p>
<p>我们可以看到，层数从小到大，节点的数字是越来越小的，映射到数组有：<code>&#123;50,45,40,20,25,35,30,10,15&#125;</code></p>
<p>特点是<code>arr[i] &gt;= arr[2*i+1] &amp;&amp; arr[i] &gt;= arr[2*i+2]</code></p>
<h3 id="3-小顶堆"><a href="#3-小顶堆" class="headerlink" title="3.小顶堆"></a>3.小顶堆</h3><p><img src="http://img.xiajibagao.top/%E5%B0%8F%E9%A1%B6%E5%A0%86.png" alt="image-20200714202759899"></p>
<p>跟大顶堆相反，层数从小到大，节点的数字是越来越大，映射到数组：<code>&#123;10,20,15,25,50,30,40,35,45&#125;</code></p>
<p>特点是：<code>arr[i] &lt;= arr[2*i+1] &amp;&amp; arr[i] &lt;= arr[2*i+2]</code></p>
<h2 id="二、堆排序的思路分析"><a href="#二、堆排序的思路分析" class="headerlink" title="二、堆排序的思路分析"></a>二、堆排序的思路分析</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><ul>
<li>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li>
<li>遍历构建大顶堆，在这过程中元素的个数逐渐减少，直到最后得到一个有序序列了.</li>
</ul>
<h3 id="2-举个例子"><a href="#2-举个例子" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><p>对数组{4,6,8,5,9}进行排序。</p>
<h4 id="第一遍排序"><a href="#第一遍排序" class="headerlink" title="第一遍排序"></a>第一遍排序</h4><ol>
<li><p>我们从最后一个非叶子结点开始排序。第一个非叶子结点为<code>arr.length/2-1=5/2-1=1</code>，也就是元素6.，我们对他进行对比并调整位置；</p>
<p><img src="http://img.xiajibagao.top/%E5%A0%86%E6%8E%92%E5%BA%8F1.png"></p>
</li>
<li><p>在{6,5,4}中，5比6小，而9比6大，所以9和6交换位置；</p>
<p><img src="http://img.xiajibagao.top/%E5%A0%86%E6%8E%92%E5%BA%8F2.png" alt="image-20200716171927431"></p>
</li>
<li><p>接着找到第二个非叶子节点4，由于9是{9,4,8}这个树中最大的，故9与4交换位置</p>
<p><img src="http://img.xiajibagao.top/%E5%A0%86%E6%8E%92%E5%BA%8F3.png" alt="image-20200716172640232"></p>
</li>
<li><p>由于9与4交换位置打乱了原先{9,5,6}这棵树顺序，所以继续对新树{4,5,6}进行排序</p>
<p><img src="http://img.xiajibagao.top/%E5%A0%86%E6%8E%92%E5%BA%8F4.png" alt="image-20200716172926921"></p>
</li>
<li><p>由此得到了一个大顶堆，然后将堆顶元素9与末尾元素4进行交换，得到数组{4,6,8,5,9}</p>
<p><img src="http://img.xiajibagao.top/%E5%A0%86%E6%8E%92%E5%BA%8F5.png" alt="image-20200716173427122"></p>
</li>
</ol>
<p><strong>至此，第一遍排序已经完成，我们确定了最大元素9的位置</strong></p>
<h4 id="第二遍排序"><a href="#第二遍排序" class="headerlink" title="第二遍排序"></a>第二遍排序</h4><p>第二遍排序开始时，最大元素9的位置已经确定，实际上要排序的数组变成了{4,6,8,5}</p>
<ol>
<li><p>继续从6开始比较，{6,5}排序正常，所以接着比较{4,6,8}，8是最大的，所以与4交换位置</p>
<p><img src="http://img.xiajibagao.top/%E5%A0%86%E6%8E%92%E5%BA%8F6.png" alt="image-20200716184743652"></p>
</li>
<li><p>由此得到了一个大顶堆，然后将堆顶元素8与末尾元素5进行交换，得到数组{8,6,4}</p>
<p><img src="http://img.xiajibagao.top/%E5%A0%86%E6%8E%92%E5%BA%8F7.png" alt="image-20200716184933083"></p>
</li>
</ol>
<p><strong>至此，第一遍排序已经完成，我们确定了最第二大元素8的位置</strong></p>
<h4 id="第三遍-第n遍排序"><a href="#第三遍-第n遍排序" class="headerlink" title="第三遍~第n遍排序"></a>第三遍~第n遍排序</h4><p>第二遍排序开始时，最大元素9和第二大元素8的位置已经确定，实际上要排序的数组变成了{5,6,4}</p>
<p>重复比较-排序-交换堆顶和队尾元素位置这一过程，直到最终获得有序数列</p>
<p><img src="http://img.xiajibagao.top/%E5%A0%86%E6%8E%92%E5%BA%8F8.png" alt="image-20200716185250532"></p>
<h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-16 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组进行堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">//将无序数组构建成一个大/小顶堆</span></span><br><span class="line">        <span class="comment">//有几个非叶子节点就排序几次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sortHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//交换数组头尾元素，将最大的元素排沉到队尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//交换头尾元素</span></span><br><span class="line">            temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.交换完后，此时最大的元素在arr[0]，最小的元素在arr[i]，即确定了本次排序范围最大的数</span></span><br><span class="line">            <span class="comment">//2.然后对0~i-1的范围进行排序，重新获得的数组最小的元素在arr[0]，最大的元素在arr[i-1]</span></span><br><span class="line">            sortHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3.接着进入下一次循环，重复步骤1，2，每次循环排序范围都缩小一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将以非叶子节点i为根节点的树调整为一个大顶堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 要调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 非叶子结点在数组中的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 要调整的数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortHeap(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数列必须至少有一个元素！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取根节点值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左节点开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span> + <span class="number">1</span>; j &lt; length; j = j * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//比较左右节点大小，将j指向值大的节点</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; arr[j + <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较将左右节点与父节点大小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">                <span class="comment">//如果子节点大于父节点，交换两节点位置</span></span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                <span class="comment">//然后继续从该子节点向下遍历</span></span><br><span class="line">                i = j;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束循环时，arr[i]已经存放了以原arr[i]为根节点的树的最大值</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十）：哈希表</title>
    <url>/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><blockquote>
<p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做<strong>散列表</strong>。</p>
</blockquote>
<p><img src="http://img.xiajibagao.top/20200704134654.png"></p>
<p>通俗的理解一下：</p>
<ul>
<li>如果我们有n个元素要存储，那我们就用l个内存单元来存储他们</li>
<li>然后我们有一个哈希函数f(x)，我们把<strong>元素n用函数计算得到哈希值</strong>，也就是f(n)</li>
<li><strong>f(n)就是存储元素n的那个内存单位的位置</strong>，也就是元素在l中的下标</li>
</ul>
<h3 id="2-为什么哈希表查询速度快"><a href="#2-为什么哈希表查询速度快" class="headerlink" title="2.为什么哈希表查询速度快"></a>2.为什么哈希表查询速度快</h3><p>理解了哈希表的基本思路，我们也就不难理解为什么哈希表查询效率高了：</p>
<p>由于每个元素都能通过哈希函数直接计算获得地址，所以查找消耗时间非常少。</p>
<p>举个例子：</p>
<p>我们有哈希函数f(n)=n%3，现有元素{1,2,3}，我们使用哈希函数分别获得其哈希值，并把哈希值作为下标存入一个数组，</p>
<p>也就是放f(1)=1，f(2)=2，f(3)=0，如果使用传统线性查找，需要遍历四次，而使用哈希函数计算并查找，只需要一步就能找到，</p>
<p>可以看得出，理想情况下，哪怕数列再长，找到某个元素都只需要一步。</p>
<h3 id="3-哈希冲突"><a href="#3-哈希冲突" class="headerlink" title="3.哈希冲突"></a>3.哈希冲突</h3><p>按照上文的例子，数列{1,2,3}通过哈希函数f(n)=n%3可以计算出哈希值，但是如果出现两个元素的哈希值相同就会出现哈希冲突，</p>
<p>比如f(1)和f(4)都会算出1，这个时候显然不可能上上面一样通过一个一维数组直接存储。</p>
<p>对此我们有两种方法，即开放地址法和分离链表法：</p>
<ul>
<li><p>开放地址法：如果某一哈希值对应的位置已经被占用了，就找另一个没被占用的位置。</p>
<ol>
<li>开放地址法容易产生堆积问题；不适于大规模的数据存储</li>
<li>插入时可能会出现多次冲突的现象，而删除时如果元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂</li>
<li>结点规模很大时会浪费很多空间</li>
</ol>
<p>注：关于开放地址法，具体可以参考<a href="https://blog.csdn.net/wxy941011/article/details/80740716">这篇文章</a></p>
</li>
<li><p>分离链表法：将散列表的每一个单元都扩展成为一个链表，相同哈希值的元素会被存储在同一个链表中。</p>
<ol>
<li>分离链表法处理冲突简单，且无堆积现象，平均查找长度短</li>
<li>链表中的结点是动态申请的</li>
<li>相对开放地址法更加节省空间</li>
<li>插入与删除结点比较方便</li>
</ol>
</li>
</ul>
<p>在jdk8中，使用的就是分离链表法，当哈希冲突超过一点的限制，链表会转为红黑树。</p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><p>在这里我们实现一个基于分离链表法的哈希表：</p>
<h3 id="1-节点类"><a href="#1-节点类" class="headerlink" title="1.节点类"></a>1.节点类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点序号</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> + <span class="string">&quot;num=&quot;</span> + num + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-单链表"><a href="#2-单链表" class="headerlink" title="2.单链表"></a>2.单链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是尾节点就继续遍历下一个节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将尾节点指向即将插入的新节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据序号获取节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要获取的节点序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要更新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取要更新的节点序号</span></span><br><span class="line">        <span class="keyword">int</span> nodeNum = node.num;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果已经遍历完链表</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + temp.num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了该节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.num == nodeNum) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要删除的节点编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果链表到底了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了待删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.num == num) &#123;</span><br><span class="line">                <span class="comment">//判断待删除节点是否为尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.next = temp.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3.哈希表"></a>3.哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-04 11:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//用于存放数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> SingleLinkList[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        arr = <span class="keyword">new</span> SingleLinkList[size];</span><br><span class="line">        <span class="comment">//初始化链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> SingleLinkList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hashCode = getHashCode(item);</span><br><span class="line">        <span class="comment">//判断哈希值是否超过数组范围</span></span><br><span class="line">        <span class="keyword">if</span> (hashCode &gt;= size || hashCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;哈希值：&quot;</span> + hashCode + <span class="string">&quot;超出初始化长度！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该元素在链表中不存在就插入</span></span><br><span class="line">        <span class="keyword">if</span> (arr[hashCode].isEmpty() || arr[hashCode].get(item) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//插入元素</span></span><br><span class="line">            arr[hashCode].add(<span class="keyword">new</span> Node(item));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就更新</span></span><br><span class="line">            arr[hashCode].update(<span class="keyword">new</span> Node(item));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hashCode = getHashCode(item);</span><br><span class="line">        <span class="comment">//判断哈希值是否超过数组范围</span></span><br><span class="line">        <span class="keyword">if</span> (hashCode &gt;= size || hashCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查找元素</span></span><br><span class="line">        <span class="keyword">return</span> arr[hashCode].get(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hashCode = getHashCode(item);</span><br><span class="line">        <span class="comment">//删除元素</span></span><br><span class="line">        arr[hashCode].delete(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示某个哈希值对应链表的全部数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hashCode = getHashCode(item);</span><br><span class="line">        arr[hashCode].show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示哈希表的所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//只展示非空链表</span></span><br><span class="line">            <span class="keyword">if</span> (!arr[i].isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;条链表：&quot;</span>);</span><br><span class="line">                arr[i].show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（九）：查找</title>
    <url>/2020/07/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="什么是查找？"><a href="#什么是查找？" class="headerlink" title="什么是查找？"></a>什么是查找？</h2><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。</p>
<p>定义：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>
<p>分类：</p>
<ol>
<li><p>静态查找和动态查找</p>
<ul>
<li>静态查找：不对表的数据元素和结构进行任何改变。</li>
<li>动态查找：在查找过程同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</li>
</ul>
</li>
<li><p>无序查找和有序查找。</p>
<ul>
<li>无序查找：被查找数列有序无序均可</li>
<li>有序查找：被查找数列必须为有序数列。</li>
</ul>
</li>
</ol>
<h2 id="一、线性查找"><a href="#一、线性查找" class="headerlink" title="一、线性查找"></a>一、线性查找</h2><p>遍历数组并且依次对比值，相等时返回下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在给定数组中线性查找指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h2><h3 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1.思路分析"></a>1.思路分析</h3><ul>
<li>要查找数target，首先要在给定的有序数组中找到中间位置的数，定义为arr[mid]</li>
<li>比较target与arr[mid]大小：<ol>
<li>target &lt; arr[mid]：说明target元素的下标小于mid，向右查找</li>
<li>target &gt; arr[mid]：说明target元素的下标大于mid，向左查找</li>
<li>target = arr[mid]：即找到了</li>
</ol>
</li>
<li>递归重复以上步骤直到找到或者找不到元素为止</li>
</ul>
<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><p>查找不含有重复数字的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找不重复目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 查找的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 查找目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于每次遍历右指针总是右移，左指针总是右移</span></span><br><span class="line">    <span class="comment">//所以当如果查找的是一个不存在的数时，即右指针小于左指针</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标比中位数小，向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">        <span class="comment">//如果目标表中位数打，向右递归</span></span><br><span class="line">        <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//中位数即为目标</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找含有重复数字的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找重复目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 查找的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 查找目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; targets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于每次遍历右指针总是右移，左指针总是右移</span></span><br><span class="line">    <span class="comment">//所以当如果查找的是一个不存在的数时，即右指针小于左指针</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">        <span class="keyword">return</span> targets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标比中位数小，向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">        <span class="comment">//如果目标表中位数打，向右递归</span></span><br><span class="line">        <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果找到了</span></span><br><span class="line">        <span class="comment">//向左查找相同的数</span></span><br><span class="line">        <span class="keyword">int</span> tempIndex = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//到第一个数就不再继续找</span></span><br><span class="line">            <span class="keyword">if</span>(tempIndex &lt; <span class="number">0</span> || arr[tempIndex] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            targets.add(tempIndex);</span><br><span class="line">            tempIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放入中间值</span></span><br><span class="line">        targets.add(mid);</span><br><span class="line">        <span class="comment">//向右查找相同的数</span></span><br><span class="line">        tempIndex = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//到最后一个数就不再继续找</span></span><br><span class="line">            <span class="keyword">if</span>(tempIndex &gt; arr.length - <span class="number">1</span> || arr[tempIndex] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            targets.add(tempIndex);</span><br><span class="line">            tempIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、插值查找"><a href="#三、插值查找" class="headerlink" title="三、插值查找"></a>三、插值查找</h2><p>插值查找与二分查找基本一致，但是不一样的是不再像二分那样总是将数组均匀分为两份，而是通过公式将分割的中间点自适应定在目标元素附近。</p>
<p><img src="http://img.xiajibagao.top/20200701214402.png"></p>
<p>即将原先的mid计算方式换成这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将原先的1/2换为(key-a[low])/(a[high]-a[low])</span></span><br><span class="line">mid=low+(high-low)*(key-a[low])/(a[high]-a[low])</span><br></pre></td></tr></table></figure>

<p>由于mid的计算方式改为由查找数动态计算，所以为了防止取arr[mid]时下标越界，我们需要新的边界条件：</p>
<ul>
<li>目标target不能小于有序数组最小数，即arr[0]</li>
<li>目标target不能大于于有序数组最大数，即arr[arr.length]</li>
</ul>
<p>所以代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插值查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 查找的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 查找目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; targets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询大小目标必须在数组范围内，防止arr[mid]时下标越界</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left || target &gt; arr[arr.length - <span class="number">1</span>] || target &lt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> targets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) * (target - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">    <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标比中位数小，向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (midVal &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &lt; target) &#123;</span><br><span class="line">        <span class="comment">//如果目标表中位数打，向右递归</span></span><br><span class="line">        <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果找到了</span></span><br><span class="line">        <span class="comment">//向左查找相同的数</span></span><br><span class="line">        <span class="keyword">int</span> tempIndex = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//到第一个数就不再继续找</span></span><br><span class="line">            <span class="keyword">if</span>(tempIndex &lt; <span class="number">0</span> || arr[tempIndex] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            targets.add(tempIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放入中间值</span></span><br><span class="line">        targets.add(mid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右查找相同的数</span></span><br><span class="line">        tempIndex = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//到最后一个数就不再继续找</span></span><br><span class="line">            <span class="keyword">if</span>(tempIndex &gt; arr.length - <span class="number">1</span> || arr[tempIndex] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            targets.add(tempIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、斐波那契查找"><a href="#四、斐波那契查找" class="headerlink" title="四、斐波那契查找"></a>四、斐波那契查找</h2><p>斐波那契查找跟差值查找一样从中位数mid上下文章，但是又有不同之处，要想理解斐波那契查找的思路，需要先了解一下斐波那契数列：</p>
<p>举个例子， {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 就是一个斐波那契数列，他有两个特点：</p>
<ul>
<li>F[k] = F[k-1] + F[k-2]</li>
<li>相邻数之比无限接近黄金分割值0.618</li>
</ul>
<h3 id="1-思路分析-1"><a href="#1-思路分析-1" class="headerlink" title="1.思路分析"></a>1.思路分析</h3><ul>
<li><p>由于F[k] = F[k-1] + F[k-2]，我们能推出（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1，也就是说：</p>
<p>若数组的长度F[k]-1，则每一数组可以被分成<strong>长度为F[k-1]-1和F[k-2]-1的两段，两段的平分点mid即有mid=low+F[k-1]-1</strong></p>
<p><img src="http://img.xiajibagao.top/20200701214406.png"></p>
</li>
<li><p>但数组长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可</p>
<p>举个例子：延长{1,8, 10, 89, 1000, 1234}，得到{1,8, 10, 89, 1000, 1234, 1234, 1234}，</p>
</li>
</ul>
<h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAXSIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一个斐波那契数列，用于提供数组分割点位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getFibonacci() &#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[MAXSIZE];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXSIZE; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组第一位和最后一位下标</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//斐波那契数列下标</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生成的斐波那契数列</span></span><br><span class="line">    <span class="keyword">int</span>[] f = getFibonacci();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中间值</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取离arr.length-1最近的分割点下标</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数组长度延长到f[k]</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">    <span class="comment">//将延长的那部分用原数组的最后一位填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = right + <span class="number">1</span>; i &lt; f[k]; i++) &#123;</span><br><span class="line">        temp[i] = arr[right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找目标数字</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//获取分割数组的中间点下标</span></span><br><span class="line">        mid = left + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果元素在分割点的左边</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; temp[mid]) &#123;</span><br><span class="line">            <span class="comment">//向分割点左边查找</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//中间点右移到前一个分割点</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; temp[mid]) &#123;</span><br><span class="line">            <span class="comment">//向分割点右边查找</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            k-=<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到要查找的数字</span></span><br><span class="line">            <span class="comment">//判断要返回的下标</span></span><br><span class="line">            <span class="keyword">if</span> (mid &lt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（八）：排序</title>
    <url>/2020/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="什么是排序？"><a href="#什么是排序？" class="headerlink" title="什么是排序？"></a>什么是排序？</h2><blockquote>
<p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。</p>
</blockquote>
<h3 id="1-排序的分类"><a href="#1-排序的分类" class="headerlink" title="1.排序的分类"></a>1.排序的分类</h3><p>排序分为两类：</p>
<ul>
<li>内部排序：若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。</li>
<li>外部排序：若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。</li>
</ul>
<p>一般来说，外部排序只有数据量极大时会使用，一般情况下排序指的都是内部排序。</p>
<p><img src="http://img.xiajibagao.top/20200630224748.png" alt="image-20200627110216492"></p>
<h3 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2.空间复杂度"></a>2.空间复杂度</h3><blockquote>
<p>1.类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</p>
<p>2.空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。</p>
<p>3.在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。</p>
</blockquote>
<h3 id="3-排序的稳定"><a href="#3-排序的稳定" class="headerlink" title="3.排序的稳定"></a>3.排序的稳定</h3><blockquote>
<p>待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中arr[i]领先于arr[j]（即i&lt;j）。若在排序后的序列中arr[i]仍然领先于arr[j]，则称所用的方法是稳定的。</p>
<p>比如int数组[1,1,1,6,4]中arr[0]，arr[1]，arr[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的。</p>
</blockquote>
<ul>
<li>稳定的排序：冒泡排序，插入排序，归并排序，基数排序，计数排序</li>
<li>不稳定的排序：快速排序，希尔排序，选择排序，堆排序</li>
</ul>
<p>稳定性设计到排序的现实意义，举个例子：</p>
<blockquote>
<p>例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。</p>
</blockquote>
<p>更多关于稳定性的理解可以<a href="https://blog.csdn.net/csdn_kou/article/details/82965310">参考这个</a></p>
<h3 id="4-各排序时间复杂度概览"><a href="#4-各排序时间复杂度概览" class="headerlink" title="4.各排序时间复杂度概览"></a>4.各排序时间复杂度概览</h3><table>
<thead>
<tr>
<th align="left">排序法</th>
<th>平均时间</th>
<th align="left">最差情形</th>
<th>是否稳定</th>
<th>优先选择条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冒泡排序</td>
<td>O(n^2)</td>
<td align="left">O(n^2)</td>
<td>稳定</td>
<td>n小时较好</td>
</tr>
<tr>
<td align="left">交换排序</td>
<td>O(n^2)</td>
<td align="left">O(n^2)</td>
<td>不稳定</td>
<td>n小时较好</td>
</tr>
<tr>
<td align="left">选择排序</td>
<td>O(n^2)</td>
<td align="left">O(n^2)</td>
<td>不稳定</td>
<td>n小时较好</td>
</tr>
<tr>
<td align="left">插入排序</td>
<td>O(n^2)</td>
<td align="left">O(n^2)</td>
<td>稳定</td>
<td>大部分已排序时较好</td>
</tr>
<tr>
<td align="left">基数排序</td>
<td>O(logRB)</td>
<td align="left">O(logRB)</td>
<td>稳定</td>
<td>B是真数（0-9）,R是基数(个十百)</td>
</tr>
<tr>
<td align="left">希尔排序</td>
<td>O(nlogn)</td>
<td align="left">O(ns)1&lt;s&lt;2</td>
<td>不稳定</td>
<td>s是所选分组</td>
</tr>
<tr>
<td align="left">快速排序</td>
<td>O(nlogn)</td>
<td align="left">O(n2)</td>
<td>不稳定</td>
<td>n大时较好</td>
</tr>
<tr>
<td align="left">归并排序</td>
<td>O(nlogn)</td>
<td align="left">O(nlogn)</td>
<td>稳定</td>
<td>n大时较好</td>
</tr>
<tr>
<td align="left">堆排序</td>
<td>O(nlogn)</td>
<td align="left">O(nlogn)</td>
<td>不稳定</td>
<td>n大时较好</td>
</tr>
</tbody></table>
<h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><p>冒泡排序是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。</p>
<p><img src="http://img.xiajibagao.top/20200630224744.gif"></p>
<h3 id="1-举个例子"><a href="#1-举个例子" class="headerlink" title="1.举个例子"></a>1.举个例子</h3><p>要对10,-1,8,3这四个数进行排序：</p>
<blockquote>
<p>第一次排序：</p>
<ul>
<li><p>-1,10,8,3  //比较10和-1，逆序则交换</p>
</li>
<li><p>-1,8,10,3  //比较10和8</p>
</li>
<li><p>-1,8,3,<strong>10</strong> //比较10和3</p>
<p>第一次排序结束，确定了四个数里最大的数的位置</p>
</li>
</ul>
<p>第二次排序：</p>
<ul>
<li><p>-1,8,3,<strong>10</strong> //比较-1和8，不逆序所以不需要移动</p>
</li>
<li><p>-1,3,<strong>8</strong>,<strong>10</strong> //比较8和3</p>
<p>由于已经确定了10为最大数，所以只需要比较到倒数第二位。</p>
<p>第二次排序结束，确定了第二大的数的位置</p>
</li>
</ul>
<p>第三次排序：</p>
<ul>
<li><p>-1,<strong>3</strong>,<strong>8</strong>,<strong>10</strong> //比较-1和3</p>
<p>由于已经确定了第三和第四大的数，所以只需要比较到倒数第三位。</p>
<p>第三次排序结束，确定了第三大的数，故第一大的数也随之确定</p>
</li>
</ul>
</blockquote>
<h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
<li></li>
</ul>
<h3 id="3-实现代码"><a href="#3-实现代码" class="headerlink" title="3.实现代码"></a>3.实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//如果某次排序不发生交换，说明上一次排序前已经为有序</span></span><br><span class="line">    <span class="keyword">boolean</span> isChange = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据数组长度决定一共需要排序几次</span></span><br><span class="line">    <span class="keyword">int</span> round = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; round; i++) &#123;</span><br><span class="line">        <span class="comment">//每次排序需要对比到第几位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; round - i; j++) &#123;</span><br><span class="line">            <span class="comment">//对比大小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//发生交换</span></span><br><span class="line">                isChange = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断本次排序是否发生交换</span></span><br><span class="line">        <span class="keyword">if</span> (!isChange) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次排序无交换，第&quot;</span> + i + <span class="string">&quot;次排序已为有序！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            isChange = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次排序：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;-1, 52, 9, 13, -5, 7&#125;排序运行结果</span></span><br><span class="line">第<span class="number">1</span>次排序：[-<span class="number">1</span>, <span class="number">9</span>, <span class="number">13</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">52</span>]</span><br><span class="line">第<span class="number">2</span>次排序：[-<span class="number">1</span>, <span class="number">9</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br><span class="line">第<span class="number">3</span>次排序：[-<span class="number">1</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br><span class="line">第<span class="number">4</span>次排序：[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br><span class="line">第<span class="number">5</span>次排序无交换，第<span class="number">4</span>次排序已为有序！</span><br></pre></td></tr></table></figure>



<h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><p>选择排序，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<p><img src="http://img.xiajibagao.top/20200630224739.gif"></p>
<h3 id="1-举个例子-1"><a href="#1-举个例子-1" class="headerlink" title="1.举个例子"></a>1.举个例子</h3><blockquote>
<p>选择排序（select sorting）也是一种简单的排序方法。<br>它的基本思想是：<br>第一次从arr[0]<del>arr[n-1]中选取最小值，与arr[0]交换;<br>第二次从arr[1]</del>arr[n-1]中选取最小值，与arr[1]交换;<br>第三次从arr[2]<del>arr[n-1]中选取最小值，与arr[2]交换;<br>…<br>第i次从arr[i-1]</del>arr[n-1]中选取最小值，与arr[i-1]交换;<br>…<br>第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换,<br>总共通过n-1次，得到一个按排序码从小到大排列的有序序列。</p>
</blockquote>
<h3 id="2-思路-1"><a href="#2-思路-1" class="headerlink" title="2.思路"></a>2.思路</h3><ul>
<li>需要进行n-1轮排序</li>
<li>若要为第i个数排序，就先默认第i个元素为最小数，记录其大小和下标</li>
<li>接着从第i+1到第n个数开始依次比较，如果有数小于最小数，则用该数替换原最小数和其下标</li>
<li>第i轮比较结束后，让找出的最小数与第i个数交换位置</li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length -<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//用于存放每次选择中最小数的下标，最小值默认为第一个数为i</span></span><br><span class="line">        <span class="keyword">int</span> minNumIndex = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从（i+1,arr.length）的范围中筛选最小的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//如果范围内有数比现有minNum小，则替换下标</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minNumIndex]) &#123;</span><br><span class="line">                minNumIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一次选择结束，将（i+1,arr.length）的范围中的最小数与arr[i]交换位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[minNumIndex];</span><br><span class="line">        arr[minNumIndex] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;-1, 52, 9, 13, -5, 7&#125;排序运行结果</span></span><br><span class="line">第<span class="number">1</span>轮后:[-<span class="number">5</span>, <span class="number">52</span>, <span class="number">9</span>, <span class="number">13</span>, -<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">2</span>轮后:[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">3</span>轮后:[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">4</span>轮后:[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">52</span>, <span class="number">13</span>]</span><br><span class="line">第<span class="number">5</span>轮后:[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-与冒泡排序比较"><a href="#4-与冒泡排序比较" class="headerlink" title="4.与冒泡排序比较"></a>4.与冒泡排序比较</h3><p>同样对长度80000的数字进行排序，选择排序比冒泡排序快不少，原因在于选择排序每次排序只移动指针，找到位置后才进行一次元素交换，而冒泡需要多次交换。</p>
<p>换句话说，要排序的数组越长，冒泡每次排序元素要移动的次数就越多，与选择排序的差距就越明显。</p>
<p>这个同样能解释希尔排序的两种实现方式的速度差距。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序交换值，交换n次值</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">arr[j] = arr[j + gap]</span><br><span class="line">    </span><br><span class="line"><span class="comment">//插入排序交换值，交换n次指针</span></span><br><span class="line">arr[j] = arr[j - gap]</span><br><span class="line"><span class="comment">//然后交换1次值</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">arr[j] = arr[j + gap]</span><br></pre></td></tr></table></figure>



<h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><p>插入排序，是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表</p>
<p><img src="http://img.xiajibagao.top/20200630224735.gif"></p>
<h3 id="1-举个例子-2"><a href="#1-举个例子-2" class="headerlink" title="1.举个例子"></a>1.举个例子</h3><blockquote>
<p>有数组{5,2,4,6,1,3}要进行排序，</p>
<ul>
<li>从第二位往前看，5比2大，且5为第一个数，于是5后移，把2插入5前。现在是{2,5,4,6,1,3}</li>
<li>从第三位往前看，5比4大，于是5后移，继续往前看，2比4小，所以把4插入原先5的位置。现在是{2,4,5,6,1,3}</li>
<li>从第四位往前看，4比6小，于是6就不动了。现在是{2,4,5,6,1,3}</li>
<li>从第五位往前看，6比1小，于是6后移，继续往前看，5比1小，5后移，继续往前看…..2比1小，2后移，又2为第一个数，于是把1插入原本2的位置。现在是{1,2,4,5,6,3}</li>
<li>从第六位往前看，6比3小，于是6后移，继续往前看，…..3比2大，于是把3插入原先4的位置。排序完成。</li>
</ul>
</blockquote>
<p><img src="http://img.xiajibagao.top/20200630224731.png"></p>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2.思路分析"></a>2.思路分析</h3><ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<h3 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//需要从第二位开始，避免i-1出现控制针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//指向当前插入位置前一个元素的指针</span></span><br><span class="line">        <span class="keyword">int</span> pre = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前处理元素的值</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让比当前元素大的元素不断的后移，直到到头了或者找到了比当前元素小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (pre &gt;= <span class="number">0</span> &amp;&amp; arr[pre] &gt; val) &#123;</span><br><span class="line">            <span class="comment">//前一个元素往后移</span></span><br><span class="line">            arr[pre + <span class="number">1</span>] = arr[pre];</span><br><span class="line">            <span class="comment">//继续往前移动</span></span><br><span class="line">            pre--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳出循环时即找到了当前元素的正确插入位置</span></span><br><span class="line">        <span class="comment">//将该位置的值赋成处理元素的值</span></span><br><span class="line">        arr[pre + <span class="number">1</span>] = val;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;-1, 52, 9, 13, -5, 7&#125;排序运行结果</span></span><br><span class="line">第<span class="number">2</span>轮：[-<span class="number">1</span>, <span class="number">52</span>, <span class="number">9</span>, <span class="number">13</span>, -<span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">3</span>轮：[-<span class="number">1</span>, <span class="number">9</span>, <span class="number">52</span>, <span class="number">13</span>, -<span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">4</span>轮：[-<span class="number">1</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>, -<span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">5</span>轮：[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">6</span>轮：[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br></pre></td></tr></table></figure>



<h2 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为缩小增量排序。</p>
<blockquote>
<p>希尔排序是把记录按下标的一定增量分组， 对每组使用直接插入排序算法排序； 随着增量逐渐减少，每组包含的关键词越来越多， 当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
</blockquote>
<p><img src="http://img.xiajibagao.top/20200630224726.gif"></p>
<h3 id="1-举个例子-3"><a href="#1-举个例子-3" class="headerlink" title="1.举个例子"></a>1.举个例子</h3><p><img src="http://img.xiajibagao.top/20200630224723.png"></p>
<h3 id="2-思路-2"><a href="#2-思路-2" class="headerlink" title="2.思路"></a>2.思路</h3><ul>
<li>将数组除于2进行分组，得到gap组数字</li>
<li>对gap组数字进行插入排序，由于数据共分为gap组，所以同一组相邻的数字在数组中的位置总是相隔gap</li>
<li>遍历gap组数字，表现在数组上就是从gap遍历到arr.length</li>
</ul>
<h3 id="3-代码实现-2"><a href="#3-代码实现-2" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><p>有两种实现思路，一种是<strong>交换法</strong>，一种是<strong>移位法</strong>，</p>
<p>先说结论：<strong>移位法比交换法快</strong>，原因在于：</p>
<p>交换法思路有点类似于冒泡排序，需要不断的比较并交换数值，</p>
<p>而移位法即选择排序，仅仅遍历赋值后移动指针，找到插入位置后，再把元素插入到有序表，而不是多次交换加入有序表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换法交换n次值</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">arr[j] = arr[j + gap]</span><br><span class="line">    </span><br><span class="line"><span class="comment">//位移法移动n次指针后只交换一次值</span></span><br><span class="line">arr[j] = arr[j - gap]</span><br></pre></td></tr></table></figure>

<h4 id="3-1交换法实现"><a href="#3-1交换法实现" class="headerlink" title="3.1交换法实现"></a>3.1交换法实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行希尔排序</span></span><br><span class="line"><span class="comment"> * 注意，此方法为移位法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将数组每次对半分分成多组，组数逐渐缩小</span></span><br><span class="line">    <span class="comment">// gap为每次分组后的同组元素的间隔，比如分成5组，那同组元素间隔即为5，即位置是i和i+5的元素是一组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从第gap个元素开始，逐步遍历其所在的组，即从第一组开始向后遍历</span></span><br><span class="line">        <span class="comment">// 第gap个元素即为第一组的最后一个元素，也就是i即表示某组的最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 接着遍历同组元素，即一组有几个元素就遍历几次</span></span><br><span class="line">            <span class="comment">// j=i-gap即获得第某组的倒数第二个元素位置</span></span><br><span class="line">            <span class="comment">// 向前遍历，每隔gap个元素就对比一次大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j = j - gap) &#123;</span><br><span class="line">                <span class="comment">//如果当前元素大于后一个元素,就交换位置</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + gap];</span><br><span class="line">                    arr[j + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (++count) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;-1, 52, 9, 13, -5, 7&#125;排序运行结果</span></span><br><span class="line">第<span class="number">1</span>轮：[-<span class="number">1</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">2</span>轮：[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br></pre></td></tr></table></figure>

<h4 id="3-2-移位法实现"><a href="#3-2-移位法实现" class="headerlink" title="3.2 移位法实现"></a>3.2 移位法实现</h4><p><strong>下面是通过移位法实现的排序，比交换法更快更稳定：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行希尔排序</span></span><br><span class="line"><span class="comment"> * 注意，此方法为移位法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortByMove(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将数组每次对半分分成多组，组数逐渐缩小</span></span><br><span class="line">    <span class="comment">// gap为每次分组后的同组元素的间隔，比如分成5组，那同组元素间隔即为5，即位置是i和i+5的元素是一组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第gap个元素开始，逐个对其所在组进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            <span class="comment">//如果某组最后一个元素比前一个元素小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                <span class="comment">//将同组元素不断后移，直到该元素找到位置或者到头为止</span></span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                    j = j - gap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当找到位置时插入元素</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (++count) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><img src="http://img.xiajibagao.top/20200630224718.gif"></p>
<h3 id="1-举个例子-4"><a href="#1-举个例子-4" class="headerlink" title="1.举个例子"></a>1.举个例子</h3><p><img src="http://img.xiajibagao.top/20200630224715.png"></p>
<blockquote>
<ul>
<li>先选择一个中间位置数11，分别将数组中比11大和比11小的数放到左右两个数组中</li>
<li>对两个数组分别选一个中间位置数，也就是5和21，各自再根据比中间数小或者比中间数大再次分为两个数组。以此类推</li>
</ul>
</blockquote>
<h3 id="2-思路-3"><a href="#2-思路-3" class="headerlink" title="2.思路"></a>2.思路</h3><ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
<li>对左支和右支可通过递归实现排序</li>
</ul>
<h3 id="3-代码实现-3"><a href="#3-代码实现-3" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，并根据给定的左右指针对指定的范围其进行排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到中间数</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">    <span class="comment">//用于元素交换的临时变量</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将比中间数小的放左边，比中间数大的放右边</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 从左往右遍历，寻找比中间数大的数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左遍历，寻找比中间数小的数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果l &gt; r，即左指针右指针都越过了中间数，说明两边数都已经有序</span></span><br><span class="line">        <span class="comment">// 如果l = r，即可能存在多个与中间数同值的元素的情况下，左右指针一起指向了同一边的同一个元素，也说明两边数都已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换元素</span></span><br><span class="line">        temp = arr[l];</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        arr[r] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果交换完后，发现现在右侧有一个与中间数相同的数，右指针前移一位</span></span><br><span class="line">        <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果交换完后，发现现在左侧有一个与中间数相同的数，左指针后移一位</span></span><br><span class="line">        <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止死循环</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        l += <span class="number">1</span>;</span><br><span class="line">        r -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向右递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">        sort(arr, l, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">        sort(arr, left, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<p><img src="http://img.xiajibagao.top/20200630224710.gif"></p>
<h3 id="1-举个例子-5"><a href="#1-举个例子-5" class="headerlink" title="1.举个例子"></a>1.举个例子</h3><p><img src="http://img.xiajibagao.top/20200630224706.png"></p>
<p>我们以上图最后一次合并为例：</p>
<p><img src="http://img.xiajibagao.top/20200630224703.png"></p>
<p><img src="http://img.xiajibagao.top/20200630224700.png"></p>
<p>以上多个有序数组间的合并需要进行多次，通过递归完成</p>
<h3 id="2-思路-4"><a href="#2-思路-4" class="headerlink" title="2.思路"></a>2.思路</h3><ul>
<li>把长度为n的数组分成两个长度为n/2的子数组；</li>
<li>如果子数组仍然长度大于1，就重复步骤1直到所有数组都被拆分完毕</li>
<li>将拆分后的元素两两合并为一个有序数组，然后相邻两个数组A，B进行合并：<ol>
<li>创建一个新数组，然后遍历B数组并与A数组第一位进行比较，如果该数字比A数组第一小则放入新数组第一位</li>
<li>否则将A数组第一位放入新数组</li>
</ol>
</li>
<li>重复上面步骤3直到A，B数组所有元素都有序放入新数组，即合并完成</li>
<li>重复步骤3，直到所有数组都最终都被合并为一个有序数组</li>
</ul>
<h3 id="3-代码实现-4"><a href="#3-代码实现-4" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">return</span> sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 临时存储的中转数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//获取中间索引</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//向左递归分解</span></span><br><span class="line">        sort(arr, left, mid, temp);</span><br><span class="line">        <span class="comment">//向右递归分解</span></span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 先左遍历到最左边，然后向右遍历，当l=r时触发排序</span></span><br><span class="line">        merge(arr, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 临时存储的中转数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左边有序序列的初始索引</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="comment">//中间索引</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//temp的索引</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先把左右两边有序的数据按照规则填充到temp数组，直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//如果左边的有序序列的当前元素小于等于右边有序序列的当前元素</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则将右边有序序列的当前元素填充到temp数组</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[t] = arr[i];</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[t] = arr[j];</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将temp数组里的有序元素拷贝回arr数组</span></span><br><span class="line">    <span class="comment">//从左边开始拷贝， 注意：不是每次都拷贝所有</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tempLeft = left;</span><br><span class="line">    <span class="comment">//第一次合并：templeft = 0，right = 1。 第二次合并：templeft = 2，right = 3。 最后一次：templeft = 0，right = 7</span></span><br><span class="line">    <span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">        arr[tempLeft] = temp[t];</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        tempLeft += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="七、基数排序"><a href="#七、基数排序" class="headerlink" title="七、基数排序"></a>七、基数排序</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p><img src="http://img.xiajibagao.top/20200630224653.gif"></p>
<h3 id="1-举个例子-6"><a href="#1-举个例子-6" class="headerlink" title="1.举个例子"></a>1.举个例子</h3><p><img src="http://img.xiajibagao.top/20200630224650.png"></p>
<p><img src="http://img.xiajibagao.top/20200630224648.png"></p>
<p><img src="http://img.xiajibagao.top/20200630224641.png"></p>
<h3 id="2-思路-5"><a href="#2-思路-5" class="headerlink" title="2.思路"></a>2.思路</h3><ul>
<li>取得数组中的最大数，并取得位数</li>
<li>准备一个长度为10，内部一位数组长度为arr.length的二维数组，可以理解为10个高度为arr.length的桶</li>
<li>遍历数组，根据数组中个位数决定要放在哪个桶，即如果个位数为1就放入1号桶，为2就放入2号桶，直到数组所有元素分配完毕</li>
<li>遍历桶将桶中数字放回原数组，然后清空桶。即完成了个位数的排序</li>
<li>重复步骤3和步骤4，但是排序依据从个位数换成十位数，然后百位数…..以此类推，直到数组最大位数</li>
</ul>
<h3 id="3-代码实现-5"><a href="#3-代码实现-5" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中的最大数的位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(max).length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 临时存储的中转数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//设置二维数组用于表示桶</span></span><br><span class="line">    <span class="comment">//第一层数组下标即表示存放某数位为x的数字的桶，比如下标为2的桶用于存放个位数为2的数字；下标为0的桶用于存放十位数为0的数字</span></span><br><span class="line">    <span class="comment">//第二层数组即表示桶高度</span></span><br><span class="line">    <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示某个桶内用几个元素，比如bucketElementCount[0]即表示bucket[0]桶有几个元素</span></span><br><span class="line">    <span class="comment">//由于数字下标从0开始，所以这同时也表示了桶下一个元素的插入下标，比如bucketElementCount[0]=1，就意味着bucket[0]下一个元素应该插到bucket[0][1]去</span></span><br><span class="line">    <span class="keyword">int</span>[] bucketElementCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大数有几位就循环排序几次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt;= getMaxDigit(arr); i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历元素并归类到桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//获取元素某数位的数字</span></span><br><span class="line">            <span class="comment">//根据遍历，获取数字的个位，十位数，百位数......</span></span><br><span class="line">            <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//将其归类到桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCount[digitOfElement]] = arr[j];</span><br><span class="line">            <span class="comment">//提高桶高度</span></span><br><span class="line">            bucketElementCount[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按顺序将每一个桶中元素取出并放入原集合</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCount.length; k++) &#123;</span><br><span class="line">            <span class="comment">//如果桶中有元素就取出</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCount[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历桶中元素并放入数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCount[k]; l++) &#123;</span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//清空桶</span></span><br><span class="line">            bucketElementCount[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-基数排序注意事项："><a href="#4-基数排序注意事项：" class="headerlink" title="4.基数排序注意事项："></a>4.基数排序注意事项：</h3><ul>
<li><p>基数排序是典型的空间换时间，当排序的数字过多的时候可能会发生<code>OutOfMemoryError</code>（实测八千万时报错）</p>
</li>
<li><p>基数排序要排负数的时候需要加以改进：</p>
<p>将数组中的负数单独摘出并取绝对值后进行排序，然后倒序插入排序完的整数数组，并且在插入过程加上负号</p>
</li>
</ul>
<h2 id="八、堆排序"><a href="#八、堆排序" class="headerlink" title="八、堆排序"></a>八、堆排序</h2><p>参照<a href="">二叉树部分</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（五）：递归和栈实现简单计算器</title>
    <url>/2020/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="一、计算器的计算思路分析"><a href="#一、计算器的计算思路分析" class="headerlink" title="一、计算器的计算思路分析"></a>一、计算器的计算思路分析</h2><p>我们以计算<code>3+8*2-6</code>这个算式为例：</p>
<ol>
<li><p>将算式解析为数字和符号：<code>3，+，8，*，2，-，6</code></p>
</li>
<li><p>准备一个用于存放数字的数字栈numStack，还有一个存放运算符号的符号栈symbolStack，下面分别简称栈n和栈s</p>
</li>
<li><p>按顺序扫描解析后的数字和符号，</p>
<p>如果是数字，就直接入数栈n，</p>
<p>如果是符号，且如果<strong>符号栈s为空</strong>，就直接入栈，</p>
<p>如果s不为空，就需要比较栈顶符号与当前符号的优先级，再分两种情况：</p>
<ul>
<li>如果<strong>栈顶符号优先级比当前符号大</strong>，就从栈n弹出两个数字，从栈s弹出一个符号，然后进行运算，最后得出的结果再入栈n</li>
<li>如果<strong>栈顶符号优先级小于或等于当前符号</strong>，就将符号入栈s</li>
</ul>
</li>
</ol>
<p><img src="http://img.xiajibagao.top/20200625203947.png"></p>
<p>按照这个流程，扫描完后栈n会留下<code>3，16，6</code>这三个数，栈s会留下<code>+，-</code>这两个 符号，</p>
<p>然后按顺序，栈n弹出两个数字，栈s弹出一个符号，然后运算得到结果后再入栈n，重复此步骤，最后栈s清空，栈n只剩一个数字，即为运算结果。</p>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><p>我们先来实现一个加减乘除的数计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-25 16:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：使用栈实现一个计算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数字栈</span></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//符号栈</span></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;String&gt; symbolStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据计算公式运算并输出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression 计算公式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用于多位数拼接</span></span><br><span class="line">        String numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串里的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length() ; i++) &#123;</span><br><span class="line">            String ch = expression.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//检验是否数字</span></span><br><span class="line">            <span class="keyword">if</span> (ch.matches(<span class="string">&quot;[0-9]&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果该数字已经是最后一个字符就直接存入数字栈</span></span><br><span class="line">                <span class="keyword">if</span> (i == expression.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.valueOf(ch));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是字符串最后一个字符，就拼接入字符串</span></span><br><span class="line">                    numStr += ch;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是符号，就把之前拼接的多位数存入数字栈</span></span><br><span class="line">            numStack.push(Integer.valueOf(numStr));</span><br><span class="line">            numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果是符号就比较符号优先级</span></span><br><span class="line">            <span class="keyword">if</span> (isFrist(ch))&#123;</span><br><span class="line">                <span class="comment">//如果当前符号与符号栈栈栈顶符号优先或者平级就入栈</span></span><br><span class="line">                symbolStack.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则就从栈中取两数字和一个符号先计算</span></span><br><span class="line">                <span class="keyword">int</span> num = getCalculateResult();</span><br><span class="line">                <span class="comment">//再把计算结果入数栈</span></span><br><span class="line">                numStack.push(num);</span><br><span class="line">                <span class="comment">//再把当前符号入栈</span></span><br><span class="line">                symbolStack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当符号栈为空时，说明计算完成，此时数字栈唯一数字即为结果</span></span><br><span class="line">        <span class="keyword">while</span> (!symbolStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = getCalculateResult();</span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结束！结果为：&quot;</span> + numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据数字和符号运算并返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num1 后出栈的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num2 先出栈的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol 运算符号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculateResult</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据符号进行运算</span></span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = num1 - num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;只支持加减乘除运算！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(num1 + symbol + num2 + <span class="string">&quot;=&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接从数栈取两数字，符号栈取一符号进行计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculateResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = numStack.pop();</span><br><span class="line">        <span class="keyword">int</span> num2 = numStack.pop();</span><br><span class="line">        String symbol = symbolStack.pop();</span><br><span class="line">        <span class="keyword">int</span> result = getCalculateResult(num2, num1, symbol);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较符号和当前符号栈顶符号的优先级。</span></span><br><span class="line"><span class="comment">     * 如果当前符号优先级小于符号栈栈顶符号的优先级，就返回false，否则返回true</span></span><br><span class="line"><span class="comment">     * 如果当前符号栈为空，直接返回true</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFrist</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前符号栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (symbolStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出并放回栈顶符号</span></span><br><span class="line">        String stackSymbol = symbolStack.pop();</span><br><span class="line">        symbolStack.push(stackSymbol);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈顶符号的优先级</span></span><br><span class="line">        <span class="keyword">int</span> stackSymbolGrade = getSymbolGrade(stackSymbol);</span><br><span class="line">        <span class="comment">//当前符号的优先级</span></span><br><span class="line">        <span class="keyword">int</span> symbolgrade = getSymbolGrade(symbol);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> symbolgrade &gt; stackSymbolGrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据符号返回符号的优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加减返回0，乘除返回1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSymbolGrade</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> grade;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(symbol) || <span class="string">&quot;-&quot;</span>.equals(symbol)) &#123;</span><br><span class="line">            grade = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(symbol) || <span class="string">&quot;/&quot;</span>.equals(symbol)) &#123;</span><br><span class="line">            grade = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不支持的操作符类型：&quot;</span> + symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在输入运算公式调用<code>calculate()</code>函数即可得出结果，但是目前这个计算器仍然还有致命问题没有解决：</p>
<p>当连续乘除时无法识别，比如：<code>2*3*3+3</code>会被识别为<code>(2*3)*(3+3)</code>，</p>
<p>这个问题下面我们将用递归来解决。</p>
<h2 id="三-、使用递归解决连乘问题"><a href="#三-、使用递归解决连乘问题" class="headerlink" title="三.、使用递归解决连乘问题"></a>三.、使用递归解决连乘问题</h2><p>我们分析主函数<code>calculate()</code>中关于比较符号的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是符号就比较符号优先级</span></span><br><span class="line"><span class="keyword">if</span> (isFrist(ch))&#123;</span><br><span class="line">    <span class="comment">//如果当前符号与符号栈栈栈顶符号优先或者平级就入栈</span></span><br><span class="line">    symbolStack.push(ch);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则就从栈中取两数字和一个符号先计算</span></span><br><span class="line">    <span class="keyword">int</span> num = getCalculateResult();</span><br><span class="line">    <span class="comment">//再把计算结果入数栈</span></span><br><span class="line">    numStack.push(num);</span><br><span class="line">    <span class="comment">//再把当前符号入栈</span></span><br><span class="line">    symbolStack.push(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以知道主要问题在于运算符的比较只能进行一次，实际上可能会有连需乘除的情况。</p>
<p>举个例子，要计算<code>1*2*3*4+3</code>，+入栈前，数字栈有1234，符号栈有三个*：</p>
<ol>
<li>加号入栈前，取出第一个乘号比较，发现乘法优先，于是取出4和3乘后得12，把12入数栈</li>
<li>此时数栈有1，2和12，符号栈有两个*，然后<strong>重复步骤1过程</strong>，再把乘号取出一个进行比较……</li>
<li>步骤2结束后数字栈有1和24，符号栈还有一个*，于是再重<strong>复步骤1过程</strong>…..</li>
<li>最终，符号栈没有比+更优先的符号了，于是加号入栈</li>
</ol>
<p>以此类推，无论有多少个乘号，实际上的代码都是<strong>重复执行步骤1</strong>，直到<strong>满足进入步骤4的条件时结束</strong>。</p>
<p>如果我们把步骤1提取成一个函数，让他执行结束后再调用自己，有几个乘号就让他自己调用几次，那么等到满足步骤4的条件时，也就说明套娃到底了，这时就可以结束调用返回结果。</p>
<p>按照这个思路，我们把原先的代码提取成一个递归方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归解决连乘或连除问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">compareAndOperation</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是符号就比较符号优先级</span></span><br><span class="line">    <span class="keyword">if</span> (isFrist(symbol))&#123;</span><br><span class="line">        <span class="comment">//如果当前符号与符号栈栈栈顶符号优先或者平级就入栈</span></span><br><span class="line">        symbolStack.push(symbol);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则就从栈中取两数字和一个符号先计算</span></span><br><span class="line">        <span class="keyword">int</span> num = getCalculateResult();</span><br><span class="line">        <span class="comment">//再把计算结果入数栈</span></span><br><span class="line">        numStack.push(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归，继续比较上一个是否与当前符号的优先级</span></span><br><span class="line">        compareAndOperation(symbol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就能计算连续乘除的情况了！</p>
<h2 id="四-完整代码"><a href="#四-完整代码" class="headerlink" title="四.完整代码"></a>四.完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-25 16:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：使用栈实现一个计算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数字栈</span></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//符号栈</span></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;String&gt; symbolStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据计算公式运算并输出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression 计算公式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用于多位数拼接</span></span><br><span class="line">        String numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串里的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length() ; i++) &#123;</span><br><span class="line">            String ch = expression.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//检验是否数字</span></span><br><span class="line">            <span class="keyword">if</span> (ch.matches(<span class="string">&quot;[0-9]&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果该数字已经是最后一个字符就直接存入数字栈</span></span><br><span class="line">                <span class="keyword">if</span> (i == expression.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.valueOf(ch));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是字符串最后一个字符，就拼接入字符串</span></span><br><span class="line">                    numStr += ch;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是符号，就把之前拼接的多位数存入数字栈</span></span><br><span class="line">            numStack.push(Integer.valueOf(numStr));</span><br><span class="line">            numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是符号就比较符号优先级并进行计算和入栈操作</span></span><br><span class="line">            compareAndOperation(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当符号栈为空时，说明计算完成，此时数字栈唯一数字即为结果</span></span><br><span class="line">        <span class="keyword">while</span> (!symbolStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = getCalculateResult();</span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结束！结果为：&quot;</span> + numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用递归解决连乘或连除问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">compareAndOperation</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是符号就比较符号优先级</span></span><br><span class="line">        <span class="keyword">if</span> (isFrist(symbol))&#123;</span><br><span class="line">            <span class="comment">//如果当前符号与符号栈栈栈顶符号优先或者平级就入栈</span></span><br><span class="line">            symbolStack.push(symbol);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就从栈中取两数字和一个符号先计算</span></span><br><span class="line">            <span class="keyword">int</span> num = getCalculateResult();</span><br><span class="line">            <span class="comment">//再把计算结果入数栈</span></span><br><span class="line">            numStack.push(num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//递归，继续比较上一个是否与当前符号的优先级</span></span><br><span class="line">            compareAndOperation(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据数字和符号运算并返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num1 后出栈的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num2 先出栈的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol 运算符号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculateResult</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据符号进行运算</span></span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = num1 - num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;只支持加减乘除运算！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(num1 + symbol + num2 + <span class="string">&quot;=&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接从数栈取两数字，符号栈取一符号进行计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculateResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = numStack.pop();</span><br><span class="line">        <span class="keyword">int</span> num2 = numStack.pop();</span><br><span class="line">        String symbol = symbolStack.pop();</span><br><span class="line">        <span class="keyword">int</span> result = getCalculateResult(num2, num1, symbol);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较符号和当前符号栈顶符号的优先级。</span></span><br><span class="line"><span class="comment">     * 如果当前符号优先级小于符号栈栈顶符号的优先级，就返回false，否则返回true</span></span><br><span class="line"><span class="comment">     * 如果当前符号栈为空，直接返回true</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFrist</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前符号栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (symbolStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出并放回栈顶符号</span></span><br><span class="line">        String stackSymbol = symbolStack.pop();</span><br><span class="line">        symbolStack.push(stackSymbol);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈顶符号的优先级</span></span><br><span class="line">        <span class="keyword">int</span> stackSymbolGrade = getSymbolGrade(stackSymbol);</span><br><span class="line">        <span class="comment">//当前符号的优先级</span></span><br><span class="line">        <span class="keyword">int</span> symbolgrade = getSymbolGrade(symbol);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> symbolgrade &gt; stackSymbolGrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据符号返回符号的优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加减返回0，乘除返回1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSymbolGrade</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> grade;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(symbol) || <span class="string">&quot;-&quot;</span>.equals(symbol)) &#123;</span><br><span class="line">            grade = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(symbol) || <span class="string">&quot;/&quot;</span>.equals(symbol)) &#123;</span><br><span class="line">            grade = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不支持的操作符类型：&quot;</span> + symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（四）：栈</title>
    <url>/2020/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A0%88/</url>
    <content><![CDATA[<h2 id="一、什么是栈"><a href="#一、什么是栈" class="headerlink" title="一、什么是栈"></a>一、什么是栈</h2><p>栈（stack）是一种<strong>先进后出</strong>的有序列表，其中的元素只能在<strong>线性表的同一端进出</strong>，</p>
<p>允许元素插入和删除的一端被称为<strong>栈顶</strong>（top），固定的另一端被称为<strong>栈底</strong>（button）。</p>
<p><img src="http://img.xiajibagao.top/20200623214705.png"></p>
<h2 id="二、数组简单实现栈"><a href="#二、数组简单实现栈" class="headerlink" title="二、数组简单实现栈"></a>二、数组简单实现栈</h2><p>由于栈是只在一端进出，也就是说相比队列实际上只需要有一个栈顶指针top即可：</p>
<ol>
<li>当栈空时top为-1</li>
<li>入栈后top+1</li>
<li>出栈后top-1</li>
</ol>
<p>根据思路我们可以用数组实现一个简单的栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-23 16:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：使用数组模拟栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否已满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        top = top + <span class="number">1</span>;</span><br><span class="line">        arr[top] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object item = arr[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历并打印栈中元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack&quot;</span> + i + <span class="string">&quot;：&quot;</span> + arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、链表简单模拟栈"><a href="#三、链表简单模拟栈" class="headerlink" title="三、链表简单模拟栈"></a>三、链表简单模拟栈</h2><p>数组可以比较简单的实现一个栈，但是缺点的数组随着元素的增加会需要扩容，如果初始化申请的存储空间太大，会造成空间的浪费，如果申请的存储空间太小，后期会经常需要扩充存储空间，为此我们可以用链表实现的栈来避免这个问题。</p>
<p>假设现有头结点，一号元素A，我们需要往里面插入或弹出B，，由于要实现“先进后出”的效果：</p>
<ol>
<li>入栈时，B需要插入头结点和A之间，取代A的位置：<ul>
<li><code>B.next = head.next</code>，也就是B指向A</li>
<li><code>head.next = B.next</code>，也就是让头结点指向B</li>
</ul>
</li>
<li>出栈时，B需要从头结点和A之间移除：<ul>
<li><code>head.next = A</code>，也就是让头结点直接指向A即可</li>
</ul>
</li>
</ol>
<p><img src="http://img.xiajibagao.top/20200623214702.png"></p>
<p>按照这个思路，我们先写一个节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后简单实现一个链表栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-23 21:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：链表栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="string">&quot;我是头结点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否空栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 要插入的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(item);</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//如果空栈就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不是空栈就插到头结点头面</span></span><br><span class="line">        node.next = temp.next;</span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出栈元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        head.next = node.next;</span><br><span class="line">        <span class="keyword">return</span> node.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.data);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（六）：递归</title>
    <url>/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="一、什么是递归"><a href="#一、什么是递归" class="headerlink" title="一、什么是递归"></a>一、什么是递归</h2><p>所谓递归，简单点来说，就是一个函数直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</p>
<p>引用知乎大佬的例子：</p>
<blockquote>
<p>我们可以把” 递归 “比喻成 “查字典 “，当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词。</p>
<p>可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。</p>
</blockquote>
<p>我们把查字典理解成一个函数<code>search()&#123;&#125;</code>，而“明白了”就是停止条件。</p>
<p>按这个思路，那这个流程就是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果明白了就停止函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;明白了&quot;</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没明白调用自己继续查</span></span><br><span class="line">    search();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们举个简单的例子：</p>
<p>要计算阶乘<code>1*2*3*.....*(n-1)*n</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件，当n=1时直接返回1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算n*(n-1).....</span></span><br><span class="line">    <span class="keyword">return</span> n * mult(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、递归和栈的关系"><a href="#二、递归和栈的关系" class="headerlink" title="二、递归和栈的关系"></a>二、递归和栈的关系</h2><blockquote>
<p>递归的过程就是出入栈的过程</p>
</blockquote>
<p>递归的问题实际上都能拆分成出入栈问题，我们可以举上面计算<code>1*2*3*.....*(n-1)*n</code>这个例子来理解一下：</p>
<p>如果n=4，那么过程就是这样：</p>
<ol>
<li>mult(4)调用了mult(3)</li>
<li>mult(3)调用了mult(2)</li>
<li>mult(2)调用了mult(1)</li>
<li>到了mult(1)时满足了终止条件，返回结果</li>
</ol>
<p>用出入栈的思维理解：</p>
<ol>
<li>步骤1-3都是一个入栈过程，mult(4)计算得出结果后入栈，然后运行mult(3)得出结果，然后在入栈……以此类推</li>
<li>当到达n=1的停止条件时递归停止不再入栈，此时栈深度就是4，这也叫递归深度</li>
<li>满足停止条件后出栈，mult(1)的结果出栈，与mult(2)的结果出栈相乘，再与随后出栈的mult(3)的结果相乘…..以此类推</li>
</ol>
<p>递归的本质就是栈的出入过程，所以实际上当深度过深，超过了jvm规定允许的栈最大深度的时候，就会出现栈溢出的问题，也就是java里的<code>StackOverflowError</code></p>
<h2 id="三、递归的使用条件"><a href="#三、递归的使用条件" class="headerlink" title="三、递归的使用条件"></a>三、递归的使用条件</h2><p>那么，我们是时候可以使用递归来解决问题呢：</p>
<ul>
<li>当问题可以拆分为子问题，并且子问题与原问题解决方法相同</li>
<li>有一个明确的程序停止条件</li>
</ul>
<p>比如<a href="https://www.cnblogs.com/Createsequence/p/13192879.html">之前的文章</a>中提到连续乘除问题就是一个典型的例子。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（七）：迷宫回溯和八皇后问题</title>
    <url>/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF%E5%92%8C%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一、迷宫回溯问题"><a href="#一、迷宫回溯问题" class="headerlink" title="一、迷宫回溯问题"></a>一、迷宫回溯问题</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>一个7*8的数组模拟迷宫，障碍用1表示，通路使用0表示，给定起点（1,1）和终点（6,5），要求给出起点到终点的通路</p>
<p><img src="http://img.xiajibagao.top/20200626224906.png"/><img src="http://img.xiajibagao.top/20200626224701.png"></p>
<h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><ol>
<li>首先，我们需要给程序一个寻向的基本策略，我们先假定寻向顺序为“下-右-上-左”，也就是说从起点出发，先往下走，往下走不通就往右…..以此类推</li>
<li>然后我们需要给走过的路一个标记，暂记为2</li>
<li>而当从一个方向走到一个只能原路返回的死胡同时，就给这段路标记为3</li>
<li>当抵达终点坐标（6,5）时程序结束</li>
</ol>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><h4 id="3-1生成地图"><a href="#3-1生成地图" class="headerlink" title="3.1生成地图"></a>3.1生成地图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个二维数组,用于模拟8*7迷宫</span></span><br><span class="line"><span class="comment"> * 使用1表示不可通过的实心方块，0表示可通过砖块</span></span><br><span class="line"><span class="comment"> * （6,5）为默认终点，（1,1）为默认起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getMap()&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">    <span class="comment">//上下全置为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;<span class="number">7</span> ;i++)&#123;</span><br><span class="line">        map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右全置为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置挡板</span></span><br><span class="line">    map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出地图</span></span><br><span class="line">    System.out.println(<span class="string">&quot;地图的初始情况:&quot;</span>);</span><br><span class="line">    showMap(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示地图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMap</span><span class="params">(<span class="keyword">int</span>[][] map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">7</span>;j++)&#123;</span><br><span class="line">            System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-寻路逻辑的实现"><a href="#3-2-寻路逻辑的实现" class="headerlink" title="3.2 寻路逻辑的实现"></a>3.2 寻路逻辑的实现</h4><p>对于这个寻路程序，我们可以看见，往四个方向走的过程实际上除了方向外动作上是一样的；而具体分析同一个方向，每走过一个坐标的动作也是一样的，我们对流程进行分析：</p>
<ol>
<li>出发，先往下走，判断下一格有没有障碍（<code>int[x][y]==1</code>）</li>
<li>如果没有障碍，就继续往下走，然后重复步骤1到碰到障碍为止</li>
<li>如果有障碍，就按“下-右-上-左”的顺序，换个方向，然后重复步骤1到碰到障碍为止</li>
<li>如果找到了（6,5）就结束</li>
</ol>
<p>表现为代码实际上就是一个递归的过程：</p>
<ul>
<li>找路是方法体</li>
<li>找到了（6,5）或者死胡同是终止条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定起始点，根据地图找路</span></span><br><span class="line"><span class="comment"> * 使用2表示可以走通的路，使用3表示走过但是不通的路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 地图二维数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 起始点横坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y 起始点纵坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果走到了终点就终止</span></span><br><span class="line">    <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//只有为0的路才能通过</span></span><br><span class="line">        <span class="keyword">if</span> (map[y][x] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果该点可以走通就打上标记</span></span><br><span class="line">            map[y][x] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWay(map, x, y + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//向下递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, x + <span class="number">1</span>, y)) &#123;</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, x, y - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//向上递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, x - <span class="number">1</span>, y)) &#123;</span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//都走不通说明是死胡同</span></span><br><span class="line">                map[y][x] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不为0说明要么是死路要么是障碍</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-运行结果"><a href="#3-3-运行结果" class="headerlink" title="3.3 运行结果"></a>3.3 运行结果</h4><p><img src="http://img.xiajibagao.top/20200626225137.png"><img src="http://img.xiajibagao.top/20200626225158.png"></p>
<p>将<code>findWay()</code>方法中的终止条件从<code>map[6][5] == 2</code>换成其他坐标即可更换终点位置，</p>
<p>棋盘大小和障碍物位置不影响<code>findWay()</code>方法寻路。</p>
<h2 id="二、八皇后问题"><a href="#二、八皇后问题" class="headerlink" title="二、八皇后问题"></a>二、八皇后问题</h2><h3 id="1-问题-1"><a href="#1-问题-1" class="headerlink" title="1.问题"></a>1.问题</h3><p>皇后问题，一个古老而著名的问题，是<strong>回溯算法</strong>的典型案例。该问题由国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：</p>
<p>在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，求有多少种摆法？</p>
<p><img src="http://img.xiajibagao.top/20200626224753"></p>
<h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><ol>
<li><p>首先，我们先使用一个长度为8数组来表示八皇后的摆放位置，<strong>数组下标+1即表示棋盘的第几行</strong>，<strong>数组下标对应的存放的数字+1即为棋盘的第几列</strong>。举个例子：</p>
<p>arr = {0,2,3,8,4,6,2,7}</p>
<p>其中，元素0下标为0，即表示<strong>第一行第一列</strong>；元素2下标为1，即表示<strong>第二行第三列</strong>……以此类推。</p>
</li>
<li><p>任意假设任意坐标分标为<code>(x1,y1)，(x2,y2)</code>，也就是用数组表示为<code>arr[x1]=y1，arr[x2]=y2</code>的两个皇后不允许在同一列，我们可以理解为：</p>
<p><code>arr[x1] != arr[x2]</code>;</p>
<p>而任意坐标的皇后不允许在同一斜线，即<code>(x2-x1)=(y2-y1)</code>，也就是斜率不应当相同，我们可以理解为：</p>
<p><code>Math.abs(x2-x1) != Math.abs(arr[x2]-arr[x1])</code></p>
<p>（注：<code>Math.abs()</code>为求绝对值方法）</p>
</li>
</ol>
<h3 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><h4 id="3-1-检查摆放位置的代码实现"><a href="#3-1-检查摆放位置的代码实现" class="headerlink" title="3.1 检查摆放位置的代码实现"></a>3.1 检查摆放位置的代码实现</h4><p>在前面明确了如何用数组表示位置，以及如何检查皇后是否允许摆放后，我们有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示皇后位置的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查第n个皇后是否与前面摆放的皇后冲突</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查第n层之前的皇后位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// arr[i] == arr[n] 检查是否同一列</span></span><br><span class="line">        <span class="comment">// Math.abs(n - i) == Math.abs(arr[n] - arr[i]) 检查是否同一斜线</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[n] ||</span><br><span class="line">            Math.abs(n - i) == Math.abs(arr[n] - arr[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-完整代码"><a href="#3-2-完整代码" class="headerlink" title="3.2 完整代码"></a>3.2 完整代码</h4><p>接着我们需要考虑如何使用递归方法来做到以下效果：</p>
<p>使用一个方法遍历第n行的每一列，检查每一列是否可以放置皇后：</p>
<ol>
<li>如果可以放置皇后，将位置出入arr[n]中，然后递归调用自己，传入n+1开始遍历下一行…..以此类推</li>
<li>如果不可以放置皇后，就跳过该列检查下一列，如果可以就重复步骤1</li>
<li>若n行中全部位置都不合适，则结束本层返回上一层n-1层，重复步骤1</li>
<li>如果最后n=8，即八个皇后全部放置完毕，记一次完成摆放，然后结束递归返回第一层，继续检查第一层的下一列</li>
</ol>
<p>最终代码实现结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-26 20:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：八皇后问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueens</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightQueens eightQueens = <span class="keyword">new</span> EightQueens();</span><br><span class="line">        eightQueens.set(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共有摆法：&quot;</span> + eightQueens.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录八皇后有几种摆法</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示皇后位置的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 摆放皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第几个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果放置好了第8个皇后</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">8</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">            <span class="comment">//记录一种摆放方式</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//回到第一层继续递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历第n行的每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//将该皇后放置在第n行第i列</span></span><br><span class="line">            arr[n] = i;</span><br><span class="line">            <span class="comment">//检查放置位置是否合适</span></span><br><span class="line">            <span class="keyword">if</span> (check(n))&#123;</span><br><span class="line">                <span class="comment">//如果位置合适，就递归找下一个（n+1）皇后的摆放位置</span></span><br><span class="line">                set(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果位置不合适，就跳过这一列检查下一列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查第n个皇后是否与前面摆放的皇后冲突</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查第n层之前的皇后位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// arr[i] == arr[n] 检查是否同一列</span></span><br><span class="line">            <span class="comment">// Math.abs(n - i) == Math.abs(arr[n] - arr[i]) 检查是否同一斜线</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[n] ||</span><br><span class="line">                Math.abs(n - i) == Math.abs(arr[n] - arr[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示某一摆法中八皇后的摆放位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（三）：双向链表</title>
    <url>/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8F%8C%E5%90%91%E8%BF%9E%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一、双向链表"><a href="#一、双向链表" class="headerlink" title="一、双向链表"></a>一、双向链表</h2><p>双向链表与单链表基本相似，但是最大的区别在于双向链表在节点中除了指向下一节点的next指针外，<strong>还有指向前一节点的prev指针</strong>，这使得双向链表在可以在任意节点<strong>从头尾两个方向进行遍历</strong>，是“双向”的。</p>
<p>和单链表相比，双向链表在删除和查询等方面明显在操作上更具有灵活性，但是会消耗更多的内存，需要根据使用条件进行取舍。</p>
<p>java中的LinkedHashMap的本质即是一个双向链表。</p>
<p><img src="http://img.xiajibagao.top/20200621114143.png"></p>
<h2 id="二、双向链表的简单实现"><a href="#二、双向链表的简单实现" class="headerlink" title="二、双向链表的简单实现"></a>二、双向链表的简单实现</h2><p>修改原来的Node类，在里面添加一个新成员变量<code>Node prev</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点序号</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一节点</span></span><br><span class="line">    Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> num, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;num=&quot;</span> + num +</span><br><span class="line">            <span class="string">&quot;, data=&quot;</span> + data +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-添加"><a href="#1-添加" class="headerlink" title="1.添加"></a>1.添加</h3><p>添加与单向链表代码逻辑一样，但是新节点在添加时需要修改prev指针指向原来的尾节点。</p>
<p>举个例子，对于无排序插入，原本有节点A，现在要插入一个B：</p>
<ol>
<li>找到A，然后让<code>A.next</code>指向B</li>
<li>让<code>B.prev</code>指向A</li>
</ol>
<p>而对于排序插入，就是原有节点A，C，要在中间插入B：</p>
<ol>
<li>找到A，让<code>B.prev</code>指向A</li>
<li>让<code>B.next</code>指向<code>A.next</code>，也就是让B的next指向C</li>
<li>让<code>A.next.prev</code>指向B，也就是让C的prev指向B</li>
<li>让<code>A.next</code>指向B</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点到链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是尾节点就继续遍历下一个节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将尾节点指向即将插入的新节点</span></span><br><span class="line">    temp.next = node;</span><br><span class="line">    node.prev = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按顺序添加节点到链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表到底了就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            node.prev = temp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num &gt; node.num)&#123;</span><br><span class="line">            <span class="comment">//如果后一节点比当新节点大，就插入当前节点</span></span><br><span class="line">            node.prev = temp;</span><br><span class="line">            node.next = temp.next;</span><br><span class="line"></span><br><span class="line">            temp.next.prev = node;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num == node.num)&#123;</span><br><span class="line">            <span class="comment">//如果后一节点等于新节点，抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;插入节点与已有节点序号重复！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果后一节点比当前节点小，就继续遍历</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h3><p>由于相对单链表，双向链表的节点可以自己找到上一节点，所以删除的时候可以直接找到要删除的节点进行操作。</p>
<p>举个例子，假设有节点A，B，C，现在要删除B：</p>
<ol>
<li>找到B，让<code>B.prev.next=B.next</code>，也就是让A的next指向C</li>
<li>让<code>B.next.prev=B.prev</code>，也就是让C的prev指向A</li>
</ol>
<p>如果要删除的节点已经是尾节点了，那就跟单链表一样了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要删除的节点编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表到底了</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了待删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">            <span class="comment">//判断待删除节点是否为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.prev.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.prev.next = temp.next;</span><br><span class="line">                temp.next.prev = temp.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续遍历下一节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-修改，查询（与单链表一致）"><a href="#3-修改，查询（与单链表一致）" class="headerlink" title="3.修改，查询（与单链表一致）"></a>3.修改，查询（与单链表一致）</h3><p>由于修改和查询与单链表基本一致，这里就不在赘述了，直接放代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp.toString());</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据序号获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要获取的节点序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要更新的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取要更新的节点序号</span></span><br><span class="line">    <span class="keyword">int</span> nodeNum = node.num;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果已经遍历完链表</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + temp.num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了该节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.num == nodeNum) &#123;</span><br><span class="line">            temp.data = node.data;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续遍历下一节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（二）：单链表</title>
    <url>/2020/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一、什么是链表"><a href="#一、什么是链表" class="headerlink" title="一、什么是链表"></a>一、什么是链表</h2><p>链表是一种数据结构，跟数组不同，链表<strong>不需要连续的内存空间</strong>，而是<strong>通过指针将零散的内存块连接</strong>起来。</p>
<p>因此，链表的查找需要通过节点按顺序遍历，而增加与删除通过只需要操作指针指向，这也造成了相比数组，链表的<strong>查找性能消耗大</strong>而<strong>增加和删除消耗小</strong>的特点。</p>
<p>链表由节点组成，一般每个节点最少包含用于储存数据的data区和用于指向下一个节点的指针next，有的链表可能会有头结点或尾结点用于存储链表长度等信息。</p>
<p><img src="http://img.xiajibagao.top/20200620142817.png"></p>
<h2 id="二、链表的简单实现"><a href="#二、链表的简单实现" class="headerlink" title="二、链表的简单实现"></a>二、链表的简单实现</h2><p>先来实现一个简单的节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点序号</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> num, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;num=&quot;</span> + num +</span><br><span class="line">            <span class="string">&quot;, data=&quot;</span> + data +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-插入节点"><a href="#1-插入节点" class="headerlink" title="1.插入节点"></a>1.插入节点</h3><h4 id="1-1不按照排序的插入"><a href="#1-1不按照排序的插入" class="headerlink" title="1.1不按照排序的插入"></a>1.1不按照排序的插入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line">	<span class="comment">//默认初始化一个头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="string">&quot;我是头结点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是尾节点就继续遍历下一个节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将尾节点指向即将插入的新节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2按照排序插入"><a href="#1-2按照排序插入" class="headerlink" title="1.2按照排序插入"></a>1.2按照排序插入</h4><p><img src="http://img.xiajibagao.top/20200620142813.png"></p>
<p>要想按顺序插入节点，需要确定节点的位置，也就是确定新节点的大小，以图为例：</p>
<p>遍历链表，我们把遍历到的节点叫A，A之前的节点叫A-1，A之后的节点叫A+1，要插入的节点叫B，有以下几种情况：</p>
<ol>
<li>当A的序号<strong>大于</strong>B时，就把B插到A前，也就是原本的A和A-1之间</li>
<li>当A的序号<strong>等于</strong>B时，抛出异常禁止插入</li>
<li>当A的序号<strong>小于</strong>B时，就跳过这个节点，继续遍历，然后对比A+1和B的大小</li>
<li><strong>当A就是链表最后一个节点时，A还是小于B</strong>，那就直接让B插到A后，变成链表的尾节点</li>
</ol>
<p>按这个思路，我们在原来的类里新增一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按顺序添加节点到链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表到底了就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num &gt; node.num)&#123;</span><br><span class="line">            <span class="comment">//如果当前节点比当要插入的节点大，就把新节点插到当前节点之前</span></span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num == node.num)&#123;</span><br><span class="line">            <span class="comment">//如果有节点序号和要插入的节点重复就抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;插入节点与已有节点序号重复！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前节点比当要插入的节点小，就继续遍历</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-查找节点"><a href="#2-查找节点" class="headerlink" title="2.查找节点"></a>2.查找节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示链表全部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp.toString());</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据序号获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要获取的节点序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是要获取的节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-修改节点"><a href="#3-修改节点" class="headerlink" title="3.修改节点"></a>3.修改节点</h3><p>修改节点与按顺序插入逻辑相似，需要先遍历并找到要修改的节点，然后用新节点去替换旧节点，或者干脆直接修改节点内的信息</p>
<p><img src="http://img.xiajibagao.top/20200620142808.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要更新的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取要更新的节点序号</span></span><br><span class="line">    <span class="keyword">int</span> nodeNum = node.num;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果已经遍历完链表</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + temp.num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了该节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.num == nodeNum) &#123;</span><br><span class="line">            temp.data = node.data;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续遍历下一节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-删除节点"><a href="#4-删除节点" class="headerlink" title="4.删除节点"></a>4.删除节点</h3><p><img src="http://img.xiajibagao.top/20200620142800.png"></p>
<p>因为在单向链表中，节点无法知道自己前一个节点的情况，以图为例：</p>
<p>如果我们想要删除节点A，那么就要找到A的前一个节点A-1，根据是否存在A后的节点A+1有以下几种情况：</p>
<ol>
<li><p>A节点就是链表尾节点，此时只需让A-1节点的next指向null即可</p>
<p><code>nodeA-1.next = null</code></p>
</li>
<li><p>A节点后有A+1，此时让A-1节点指向A+1节点</p>
<p><code>nodeA-1.next = nodeA-1.next.next</code></p>
</li>
</ol>
<p>按这个思路，在类里新加一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要删除的节点编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表到底了</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了待删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next.num == num) &#123;</span><br><span class="line">            <span class="comment">//判断待删除节点是否为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续遍历下一节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、完整实现代码"><a href="#三、完整实现代码" class="headerlink" title="三、完整实现代码"></a>三、完整实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="string">&quot;我是头结点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是尾节点就继续遍历下一个节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将尾节点指向即将插入的新节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据序号获取节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要获取的节点序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果链表到底了就直接插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num &gt; node.num)&#123;</span><br><span class="line">                <span class="comment">//如果后一节点比当新节点大，就插入当前节点</span></span><br><span class="line">                node.next = temp.next;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num == node.num)&#123;</span><br><span class="line">                <span class="comment">//如果后一节点等于新节点，抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;插入节点与已有节点序号重复！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果后一节点比当前节点小，就继续遍历</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要更新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取要更新的节点序号</span></span><br><span class="line">        <span class="keyword">int</span> nodeNum = node.num;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果已经遍历完链表</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + temp.num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了该节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.num == nodeNum) &#123;</span><br><span class="line">                temp.data = node.data;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要删除的节点编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果链表到底了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了待删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.num == num) &#123;</span><br><span class="line">                <span class="comment">//判断待删除节点是否为尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.next = temp.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、环形链表"><a href="#四、环形链表" class="headerlink" title="四、环形链表"></a>四、环形链表</h2><p>循环链表是一种特殊单链表，他跟单链表的区别在于尾节点的尾指针指向了链表的头结点，也就是相当于将链表连接成了一个环形。</p>
<p>环形链表可以用于处理能描述为环形的数据，典型的比如约瑟夫问题。</p>
<p><img src="http://img.xiajibagao.top/20200623155928.png"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>博客园自定义代码块样式</title>
    <url>/2020/07/14/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id></span></h2><p>一直都用博客园写博客，后面自己曾经想自己写一个博客项目，但是因为各种各样的事情最后做了一半就没能继续做下去。但是中间定制markdawn样式的时候接触到的代码高亮插件highlight.js倒是给我留下了很深的影响，今天有时间于是决定利用当初的经验重新diy一下博客园的代码块样式，算是对夭折的博客项目的一个弥补吧。</p>
<h2><span id="一-下载highlightjs">一、下载highlight.js</span></h2><p>可以去<a href="https://highlightjs.org/">highlight.js官网</a>直接下载。</p>
<p>下载完的文件里有highlight.pack.js，决定你的代码哪里高亮，而styles文件夹存放各种样式，决定你的代码怎么样高亮。</p>
<p>按照官网文档引入三行代码即可生效：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--选择你想要的引入的样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/path/to/styles/default.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入highlight.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/path/to/highlight.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>hljs.initHighlightingOnLoad();<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以自己建一个页面试一试，样式有很多种，我个人比较喜欢darcula.css这个样式，接下来就以这个样式为例。</p>
<h2><span id="二-将样式引入博客园">二、将样式引入博客园</span></h2><p>首先自定义css需要开通自定义权限，这个跟着流程来即可，我就不再赘述了。</p>
<p>打开你想要引入的css样式，复制代码黏贴到“页面定制css代码”，</p>
<p><strong>注意：这里要直接把css文件的代码复制过来，而不是引用！</strong></p>
<p><img src="http://img.xiajibagao.top/image-20200713160332026.png" alt="image-20200713160332026"></p>
<p>然后将js添加到“博客园侧边栏公告”</p>
<p><strong>注意：这里不需要引入css！</strong></p>
<p><img src="http://img.xiajibagao.top/image-20200713160421251.png"></p>
<p>这里js文件资源我直接放到了博客园自带的文件仓库了，要放自己的静态资源仓库，或者引用第三方都行，</p>
<p>然后保存以后代码样式就会发生变化。</p>
<p><strong>但是仍然还会有各种各样的小问题</strong>，比如字体和背景颜色不对之类的。</p>
<h2><span id="三-修复冲突的字体或背景颜色">三、修复冲突的字体或背景颜色</span></h2><p>一般主要问题都是字体或者背景颜色不对，我们直接覆盖<code>.cnblogs-markdown .hljs</code>的样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 替换背景和字体颜色 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#2b2b2b</span> <span class="meta">!important</span>;</span><br><span class="line">    color: #bababa !important;;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 代码块不换行 */</span></span><br><span class="line">    <span class="selector-tag">white-space</span>: <span class="selector-tag">pre</span>;</span><br><span class="line">    <span class="selector-tag">word-break</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据自己的需求修改代码，然后把代码添加到“页面定制css代码”就可以了</p>
<h2><span id="四-修改字体样式或者代码块样式">四、修改字体样式或者代码块样式</span></h2><p>用chrome浏览器按F12查看你的文章页面元素，然后可以发现：</p>
<p><img src="http://img.xiajibagao.top/image-20200713161507669.png" alt="image-20200713161507669"></p>
<p><code>.cnblogs-markdown .hljs, .cnblogs-post-body .hljs</code>这块就是控制代码块字体和边距的样式，你可以直接根据自己的需求调整样式然后直接黏贴到“页面定制css代码”里就行了。</p>
<p>博客园代码块默认边距是5，字体大小是12，行高是1.5，我想让换个好看的字体，顺便行距大小啥的都大点：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    	<span class="attribute">font-family</span>: consola;</span><br><span class="line">    	<span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;http://static.xxxxx.top/consola.ttf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-class">.hljs</span>, <span class="selector-class">.cnblogs-post-body</span> <span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: consola <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.7</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="五-前后样式对比">五、前后样式对比</span></h2><p>原本的样式：</p>
<p><img src="http://img.xiajibagao.top/image-20200713162724416.png" alt="image-20200713162724416"></p>
<p>保存之后的新样式：</p>
<p><img src="http://img.xiajibagao.top/image-20200713162145863.png" alt="image-20200713162145863"></p>
<p>明显比默认的样式好看多了</p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(一)：三大日志概述</title>
    <url>/2020/10/25/mysql/Mysql%E5%88%9D%E6%8E%A2(%E4%B8%80)%EF%BC%9A%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 2、15节日志相关部分和网上一些相关文章的内容的总结</p>
</blockquote>
<h2><span id="一-redo-log">一、redo log</span></h2><p><strong>redo log 又叫重做日志，提供的是数据丢失后的前滚操作。</strong></p>
<p><strong>redo log 是 innodb 引擎独有的日志</strong>，使用了 WAL 技术（Write-Ahead Logging），也就是预写日志。它的关键点就是<strong>先写日志，再写磁盘</strong>。对应到 mysql 中具体操作，就是每次更新操作，先写日志，然后更新内存数据，最后等系统压力小的时候再进行IO更新磁盘数据。避免了每一次更新都需要进行IO操作。<strong>redo log 是保证了事务持久性的关键</strong>。</p>
<p>redo log 一般用在数据库恢复的情况：</p>
<ol>
<li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为<strong>脏页</strong>。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至<strong>与 redo log 毫无关系</strong>。</li>
<li>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会<strong>将它读到内存，然后让 redo log 更新内存内容</strong>。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li>
</ol>
<p>另外，<strong>redo log 与 undo log 都被叫做事务日志</strong>。</p>
<p>redo log 是一个物理日志，我们知道数据库引擎加载是按“页”来的，redo log记录的就是每个“页”上的数据发生的变化。但是不像 binlog 那样，redo log 不记录 sql，而是以类似 session_id + date + file_id + block_id + 修改数据这样的格式去记录数据。</p>
<p><img src="http://img.xiajibagao.top/image-20200930111506778.png" alt="image-20200930111506778"></p>
<p>redo log 的日志文件大小是根据配置固定的，如果有一组有四个文件，每个文件的大小是 1GB，那么总共就只能记录 4GB 的日志。</p>
<p>因为 redo log 是前滚日志，也就是说一旦事务成功提交且数据持久化落盘之后，此时日志中的对应事务数据记录就失去了意义。所以 redo log 类似一个环形链表，<strong>从前往后写，到底了就删除最前面的再回到开头往后写</strong>。</p>
<p><strong>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的并且在日志中有记录都数据可以找回，这个能力称为 crash-safe。</strong></p>
<h2><span id="二-undo-log">二、undo log</span></h2><p>undo log 又叫<strong>回滚日志</strong>。事务未提交之前，undo log 保存了未提交之前的版本数据，可作为数据旧版本快照供其他并发事务进行快照读。</p>
<p>因此，他能够提供两个功能：</p>
<ul>
<li><p><strong>回滚</strong>：当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>简单的说：如果我们执行了insert操作，那么日志中就会新增一条相反的 delete 的 sql；</p>
</li>
<li><p>**多行版本控制(MVCC)**：当读取的某一行被其他事务锁定时，它可以从 undo log 中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p>
</li>
</ul>
<p><strong>undo log 保证了事务的原子性。</strong></p>
<h2><span id="三-binlog">三、binlog</span></h2><p>binlog 又叫二进制日志。是 Server 层特有的日志，无论哪个引擎都能使用。</p>
<p>它被用于记录 mysql 的数据更新（即使更新零条或者删除零条也会记录）。</p>
<p>binlog有三种工作模式：</p>
<ul>
<li>Row ：日志中会记录<strong>每一行数据被修改</strong>的情况，然后在slave端对相同的数据进行修改。</li>
<li> Statement：每一条<strong>被修改数据的sql</strong>都会记录到 master 的 binlog 中，slave 在复制的时候sql进程会解析成和原来 master 端执行过的相同的sql再次执行。</li>
<li>Mixed：结合了 Row 和 Statement 的优点，同时 binlog 结构也更复杂。</li>
</ul>
<p><strong>binlog 和 redo log 的区别如下</strong>：</p>
<ul>
<li>binlog 是 mysql 自带的，redo log 是 innodb 引擎自带的</li>
<li>binlog 记录的是每一行数据的变化或修改数据的 sql，redo log 记录的是数据页的变化</li>
<li>binlog 能够实现归档功能，通过 binlog 可以实现备份，redo log 是循环写的，历史日志不会一直保留</li>
<li>mysql 高可用基于 binlog，像主从等系统机制都依赖于 binlog</li>
</ul>
<h2><span id="五-两阶段提交">五、两阶段提交</span></h2><h3><span id="1概述">1.概述</span></h3><p><img src="http://img.xiajibagao.top/image-20201011182232866.png" alt="image-20201011182232866"></p>
<p>当innodb执行修改时，会经历一个两阶段提交的过程：</p>
<ul>
<li>执行器根据sql写入新数据，然后新数据更新到内存里</li>
<li>将这个更新操作<strong>记录到 redo log 里面，此时 redo log 处于 prepare 状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器<strong>生成这个操作的 binlog，并把 binlog 写入磁盘</strong>。</li>
<li>执行器调用引擎的提交事务接口，<strong>引擎把刚刚写入的 redo log 改成提交（commit）状态</strong>，更新完成</li>
</ul>
<p>那么如果事务提交过程中出现了异常，数据库崩溃了，就会有以下几种情况：</p>
<ul>
<li><p><strong>写 binlog 前崩溃了</strong>：对于时刻A，redo log 还是 prepare，binlog 没写，此时崩溃后事务回滚。</p>
</li>
<li><p><strong>写 binlog 后崩溃了</strong>：对于时刻B，redo log 还是 prepare，binlog 已经写了，此时发生崩溃后情况如下：</p>
<ol>
<li><p>如果redo log 已经标记为 commit，则提交事务，重做</p>
</li>
<li><p>如果redo log 还是 prepare，则去检查 binlog 记录的对应事务是否存在：</p>
<p>如果存在，就提交事务，重做</p>
<p>如果不存在，就回滚</p>
</li>
</ol>
</li>
</ul>
<h3><span id="2为什么需要两阶段提交">2.为什么需要两阶段提交</span></h3><p>我们举个反例，说明一下他的必要性。假设我们要更新某条数据的A字段由0变为2：</p>
<ul>
<li>先 redo log 再 binlog，服务挂了：由于 redo log 还在，可以通过 redo log 恢复数据，A此时是2。但是如果后面要通过 binlog 恢复数据时，由于 binlog 中没有这次修改的记录，恢复后的数据库/备份库就会变为0，<strong>丢失了这次更新</strong>。</li>
<li>先 binlog 再 redo log，服务挂了：由于 redo log 没记录这次更新，所以恢复后这次事务无效，A此时是0。但是 binlog 已经有了“A从0变成2这个记录”，所以恢复以后等于<strong>多了一次事务</strong>。</li>
</ul>
<p>之所以这样做，<strong>归根结底是为了保证数据库事务的一致性</strong>：</p>
<p>因为不管是从库或者备份库都需要通过读取 binlog 来同步数据，所以为了保证保证和主库数据一致，binlog 里记录的每一条事务就必须是已经提交了的，也就是<strong>一定要保证往 binlog 里写入数据以后事务不能回滚</strong>。</p>
<h2><span id="六-总结">六、总结</span></h2><ul>
<li>redo log保证更新不丢失，支持的是事务的持久性</li>
<li>undo log保证事务不成功可以回滚，支持的是事务的原子性</li>
<li>redo log和binlog的二次提交机制，为事务的一致性提供了一定的保证</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(八)：间隙锁的加锁条件</title>
    <url>/2020/11/09/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%85%AB)%EF%BC%9A%E9%97%B4%E9%9A%99%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 21、30、40节锁相关部分的总结</p>
</blockquote>
<h2><span id="间隙锁的加锁原则">间隙锁的加锁原则</span></h2><p>间隙锁加锁的情况，<strong>包含了两个“原则”、两个“优化”和一个“bug”。</strong></p>
<ol>
<li>原则 1：加锁的基本单位是 next-key lock。即间隙锁+行锁（前开后闭区间）。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给<strong>唯一索引加锁</strong>的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<p>以下面的表为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要注意一下，c 是加了索引的，而 d 没有。直观点就是下图：</p>
<p><img src="http://img.xiajibagao.top/image-20201108173043844.png" alt="image-20201108173043844"></p>
<h2><span id="一唯一索引等值查询间隙锁">一.唯一索引等值查询间隙锁</span></h2><p><img src="http://img.xiajibagao.top/image-20201108173614816.png" alt="等值查询的间隙锁"></p>
<p>由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<ol>
<li>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li>
<li>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li>
</ol>
<p>所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</p>
<h2><span id="二非唯一索引等值查询间隙锁">二.非唯一索引等值查询间隙锁</span></h2><p><img src="http://img.xiajibagao.top/image-20201108173725306.png" alt="只加在非唯一索引下的锁"></p>
<p>我们分析一下这个过程：</p>
<ol>
<li>首先，根据原则1，会为（0,5] 范围加上 next-key lock；</li>
<li>由于 c 是普通索引，所以因此查到5以后不会停下，会向右遍历到第一个不符合条件的值，也就是10以后才会停下。所以锁的范围会扩张到（0,10]；</li>
<li>由于符合优化2，所以 next-key lock 会退化为间隙锁，也就是会变成（0,10）；</li>
<li>根据原则2，只有访问到的才加锁，也就是锁只加在c字段上，对主键索引是没关系的，所以 sessionB 可以更新成功。但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</li>
</ol>
<p>需要注意，在这个例子中，<strong>lock in share mode 只锁覆盖索引</strong>，但是如果是 for update 就不一样了。 <strong>执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</strong>。</p>
<p>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就<strong>必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段</strong>。比如，将 session A 的查询语句改成 <code>select d from t where c=5 lock in share mode</code>。</p>
<h2><span id="三唯一索引范围锁">三.唯一索引范围锁</span></h2><p>假如现在有两条 sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">10</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>在逻辑上，两条 sql 是等价的，但是加锁的情况是不一样的。以第二条 sql 为例：</p>
<p><img src="http://img.xiajibagao.top/image-20201108175305570.png" alt="主键索引范围锁"></p>
<ol>
<li>首先加了一个范围为 （5,10] 的 next-key lock，由于id 是唯一索引，根据优化1锁会退化为行锁，也就是只锁id=10；</li>
<li>由于是范围查找，会继续向右遍历，找到id=15的行发现第一条不符合 id&lt;10 的数据，然后加上（10，15]的锁。</li>
</ol>
<p>也就是说，最终 sessionA 会加上 [10,15] 的锁。</p>
<p>需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。也就是说，&gt;= 这个查询，<strong>实际上是等值+范围查询，两次锁的分别加上的</strong>。</p>
<h2><span id="四非唯一索引范围锁">四.非唯一索引范围锁</span></h2><p><img src="http://img.xiajibagao.top/image-20201108180453457.png" alt="非唯一索引范围锁"></p>
<ul>
<li>首先，由于 c&gt;=10 满足的第一条数据就是 c=10 的这行，因此会加上（5,10] 的 next-key lock，由于 c 不是唯一索引，所以不符合优化1的条件，所以最终加锁范围还是（5,10]</li>
<li>由于是范围查找，继续向右遍历，直到找到第一行不符合 c&lt;11 的数据，也就是 c=15 这行，加上（10，15] 的，由于后半段是范围查询，所以不符合优化2的条件，所以最终加锁范围还是（10,15]</li>
</ul>
<p>也就是说，最终 sessionA 会加上 （5,15] 的锁。</p>
<h2><span id="五唯一索引范围锁-bug">五.唯一索引范围锁 bug</span></h2><p><img src="http://img.xiajibagao.top/image-20201108181439263.png" alt="唯一索引范围锁 bug"></p>
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 加上 (10,15] 这个 next-key lock。并且因为 id 是唯一键，相比于情况三，id = 15的这条数据是存在的，所以循环判断到 id=15 这一行就应该停止了。</p>
<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。</p>
<h2><span id="六两个相同的非唯一索引上的等值查询">六.两个相同的非唯一索引上的等值查询</span></h2><h3><span id="1不加limit的情况">1.不加limit的情况</span></h3><p>现在已经有了（10,10,10）这条数据，再插入（30,10,30），也就是说，现在有两条 c = 10 的数据。但是由于非唯一索引上包含主键的值，所以两种是不可能完全相同的，这两条数据也有间隙。</p>
<p><img src="http://img.xiajibagao.top/image-20201108182444617.png" alt="两个相同的非唯一索引上的间隙"></p>
<p>在上图的状态，执行sql：</p>
<p><img src="http://img.xiajibagao.top/image-20201108182706835.png" alt="delete 示例"></p>
<ol>
<li>先找到第一条 c=10 的数据，也就是 id=10 的这行，加上（5,10] 的锁;</li>
<li>向右遍历，一直到第一个不符合条件的数据，也就是加上（10,15] 的锁。注意，这里指的是id，也就是现在这个区间的锁包含了id为（30,15,20）这三条数据和他们的间隙。由于这是等值查询，根据优化1，会退化为间隙锁，也就是变成（10,15）；</li>
</ol>
<p>也就是说，现在加锁的就会变成：</p>
<p><img src="http://img.xiajibagao.top/image-20201108183431275.png" alt="相同索引的等值查询加锁范围"></p>
<h3><span id="2加limit限制的情况">2.加limit限制的情况</span></h3><p>现在，在上文的 delete 的情况加上 limit：</p>
<p><img src="http://img.xiajibagao.top/image-20201108183726684.png" alt="加了limit语句限制的情况"></p>
<p>加锁的逻辑会有一点变化：</p>
<ol>
<li>依然先加（5,10] 的锁；</li>
<li>向右遍历找到第二条符合条件的数据，即 id=30 的数据。由于加上了 limit ，已经找到两条了，所以就不必向后再找到一条不符合的数据了，也就不需要加上（30,15）的锁了。</li>
</ol>
<p><img src="http://img.xiajibagao.top/image-20201108184255128.png" alt="加了limit语句限制的锁范围"></p>
<p>可以看见，这样做减少了锁的范围。</p>
<p>这个例子对我们实践的指导意义就是，<strong>在删除数据的时候尽量加 limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<h2><span id="七-间隙锁的扩大">七、间隙锁的扩大</span></h2><p><img src="http://img.xiajibagao.top/image-20201109202937260.png" alt="间隙锁的扩大"></p>
<p>我们来分析一下：</p>
<ol>
<li>由于 id &lt;= 15 第一条满足的数据就是 id=15 这条数据，因此加上 (10,15] 的锁，因为 id &gt; 10，所以不必再理id=10之前的数据了。由于是一个等值查询，所以（10,15] 退化为间隙锁（10,15）；</li>
<li>sessionB 删除了 id=10 这行数据，由于没锁到 id=10，所以顺利删除了该数据；</li>
<li>由于缺少了10，所以原本（10,15）的间隙锁扩大为（5,15），因此插入语句被阻塞。</li>
</ol>
<p>类似的例子还有这个：</p>
<p><img src="http://img.xiajibagao.top/image-20201109204020361.png" alt="间隙锁的扩大2"></p>
<ol>
<li>sessionA 加上了 ( 5,supremum] 的锁；</li>
<li>sessionB 将 c=5 变成了 c=1，现在锁扩大到了（1,supremum]；</li>
<li>sessionB 试图将 c=5 变成 c=1，此时c=5已经在锁的范围了，因此更新的sql被堵塞。</li>
</ol>
<h2><span id="八-总结">八、总结</span></h2><p>分析间隙锁的加锁原则：两个原则，两个优化，一个bug。</p>
<p>加锁的对象一般来说是索引，也就是说，只要更新使用的索引跟上锁的索引不一样，就不会影响到插入间隙的行为。除非使用 for update，这会为整段数据都加上锁。</p>
<p>加锁单位是 next-key lock，即间隙锁+行锁，是一个前开后闭的区间。也就是，访问到了A，那么锁就是（A-1，A]，即实际上加锁范围由间隙右边的节点决定。</p>
<p>有且仅在等值查询的过程，对于唯一索引，锁有可能退化为行锁也可能退化为间隙锁；但是对于非唯一索引，锁只可能退化为间隙锁。</p>
<p>如果删除了间隙锁的“边界”，会导致间隙锁的扩大。</p>
<p>对于唯一索引：</p>
<ol>
<li>等值查询：先加本段的 next-key lock，即前面一段间隙锁加本行行锁。如果本行即使要查询的数据，就退化为行锁，否则就退化为间隙锁。</li>
<li>范围查询：同上，但是必然会向后查找到第一个不符合的数据，先加上后半段的 next-key lock，再退化为间隙锁。</li>
</ol>
<p>对于非唯一索引：</p>
<ol>
<li>等值查询：先加本段的 next-key lock，不管要查找的值存不存在，必在查找值的基础上向后找到第一条不符合的数据，加上 next-key lock，再让后半段锁退化为间隙锁。</li>
<li>范围查询：同上，由于不是等值查询所以不符合优化2的条件，相比等值查询，他的后半段还是 next-key lock 而不会退化为间隙锁。</li>
<li>多个重复的索引值，不加 limit：可以看成特殊的范围查询，会把第一个索引位置的前半段加上 next-key lock，然后再为第一到最后一个索引位置的这段区域全加上 next-key lock，最后再向后查找到第一个不符合条件的值，并加上 next-key lock，由于也算等值查询，根据优化2后半段从 next-key lock退化为间隙锁。</li>
<li>多个重复的索引值，加 limit：同上，但是由于加了条数限制，所以不必再向后查找到第一个不符合条件的值，所以相比不加 limit 少加最后一个索引位置的之后的一段间隙锁。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(十)：count</title>
    <url>/2020/11/12/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81)%EF%BC%9Acount/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的14节count相关内容的笔记</p>
</blockquote>
<h2><span id="一-count的查询过程">一、count的查询过程</span></h2><p>count() 函数用于查询数据的数量，不同的引擎有不同的实现。</p>
<p>在 MySAM 引擎会专门记录表的总数；而在 innodb 中，由于 MVCC 的原因，在统计数量的时候需要一行一行的判断当前数据是否对查询的事务的可见的。此外，<code>show table status</code>的 Rows 字段也能获取表的总条数，但是这只是预估值，实际上并不准确。</p>
<p>因此，表的遍历是无法避免的，但是 innodb 也有针对此做出优化：</p>
<p>主键索引树的叶子节点是数据行，而普通索引树的叶子节点是主键，针对 count 操作遍历那颗树都是一样的，因此查询的时候回找到最小的那颗索引树进行遍历。</p>
<h2><span id="二-计数操作的实现">二、计数操作的实现</span></h2><p>计数这个功能通过 redis 也可以实现，即在 redis 中设定一个值用于计数，但是在遇到异常停止服务后不免会遇到数据丢失的问题。</p>
<p>如果结合 mysql 来做，即 redis 更新数据后再变更数据库里的数据，读取的时候直接从 redis 读，这样虽然一定程度避免了数据丢失的问题，但是却有可能导致数据不一致。举个例子：</p>
<p>现在计数是5，我们要为计数+1</p>
<ul>
<li>先更新 redis 再更新 mysql：如果中间其他线程进行了一次查询，此时数据库是5，但是却查到了6</li>
<li>先更新 mysql 在更新 redis：如果中间其他线程进行了一次查询，此时数据库是6，但是却查到了5</li>
</ul>
<p>而如果使用 mysql，借助 innodb 可重复读下事务隔离的特性，我们就可以比较好的避免上述问题。</p>
<p>另外，值得一提的是，由于 innodb 的两阶段提交机制，<strong>更新获取的行锁会等到事务提交才释放，所以最好先插入再更新</strong>。</p>
<h2><span id="三-不同-count-的区别">三、不同 count 的区别</span></h2><p>我们常见的 count 的用法一般有这三种：count(*)，count(1)，count(id)。下面就来描述一下这三种的区别。</p>
<p>count() 是一个聚合函数，他会判断括号中的条件是否为 null，不是就累加1。因此，对于 count(id) 这样涉及字段的操作，一般流程是这样的：</p>
<ul>
<li>遍历数据行</li>
<li>取出 id 字段的值并返回</li>
<li>判断 id 不为 null</li>
<li>计数+1</li>
</ul>
<p>而 count(1) 则是这样：</p>
<ul>
<li>遍历数据行</li>
<li>直接返回 1</li>
<li>判断 1 不为 null</li>
<li>计数+1 </li>
</ul>
<p>count(*) 专门做了优化，流程与 count(1) 差不多。</p>
<p>因此，不难理解，由于需要去解析数据并且取出字段值，相对于不需要这些操作的 count(1) 和 count(*) 来说，速度是要慢一些的。而 count(字段) 相比起作为主键索引树上的 id，如果没有专门建索引，速度只会比 count(id) 更慢。</p>
<p>也就是说，他们速度是这样的：*<em>count(字段) &lt; count(id) &lt;count(1) ≈ count(</em>)**</p>
<h2><span id="四-总结">四、总结</span></h2><p>MySAM 会专门记录条数，查询的时候直接返回。innodb 由于 MVCC 机制， count 查询需要遍历数据以判断事务可见性。</p>
<p>redis 计数不能保证数据不丢失，redis + mysql 缓存和数据库数据可能会不一致，借助 innodb 的事务可以避免以上问题。</p>
<p>因为 innodb 的两阶段提交机制，最好先插入再更新。</p>
<p>查询速度：count(字段) &lt; count(id) &lt;count(1) ≈ count(*)</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(九)：关于元数据锁 online ddl插队问题</title>
    <url>/2020/11/11/mysql/Mysql%E5%88%9D%E6%8E%A2(%E4%B9%9D)%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%20online%20ddl%E6%8F%92%E9%98%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的元数据锁相关部分问题的思考总结</p>
</blockquote>
<h2><span id="一-读写锁堵塞">一、读写锁堵塞</span></h2><p>前面在锁这块介绍了元数据锁（MDL 锁）。元数据锁是一种读写锁，他的读读不互斥，读写和写写是互斥的。因此我们参考下面的时序图：</p>
<p><img src="http://img.xiajibagao.top/image-20201111201636187.png" alt="image-20201111201636187"></p>
<p>现在等待队列中有四个 session 要获取锁：</p>
<ul>
<li>由于 sessionA 和 sessionB 都是读操作，读读不互斥，因此两个 session 都持有读锁；</li>
<li>sessionA 和 sessionB 还未释放，此时 sessionC 要获取写锁，由于读写互斥，此时 sessionC 发生堵塞；</li>
<li>由于写锁的获取优先级高于读锁，sessionC 的写锁没获取到，后面其他 session 的读锁也无法获取到。此时 sessionD 堵塞；</li>
</ul>
<p>上面是一个很典型的读写锁堵塞的场景。但是实际测试的时候，会出现 sessionC 和 sessionD 都堵塞了，但是将 sessionA 和 sessionB 提交以后，sessionC 仍然保持堵塞状态，必须等 sessionD 也提交以后，才会继续执行。也就说，sessionD 好像发生了一个插队的现象。</p>
<h2><span id="二-锁降级">二、锁降级</span></h2><p>我们知道 mysql 有一个 online ddl，即 执行 ddl 的时候不会直接锁表导致无法执行其他查询的操作。其实这涉及到一个锁降级的概念。即原本流程是：</p>
<ul>
<li>拿写锁</li>
<li>做 DDL</li>
<li>释放锁</li>
</ul>
<p>其他查询语句必须等到 DDL完整的做完这三步以后才能拿到锁，引入锁降级以后，流程变成：</p>
<ul>
<li>先只拿读锁；</li>
<li>自己先申请内存执行 DDL，先把一些处理做好；</li>
<li>去拿写锁；</li>
<li>真正完成 DDL，替换表结构</li>
<li>释放锁</li>
</ul>
<p>原本一开始就拿写锁，现在换成了先拿读锁，保证在这期间没有其他 DDL 先执行去修改表，然后自己先把一些读写的过程完成，最后再去拿写锁，把表结构替换上去。相当于原本大家排队买票，轮到了一个人，但是他电话来了，由于他堵着窗口，大家都得等他接完电话才能继续买票。后面大家跟他商量了一些，他接电话的时候先出去，让后面的先继续买票，等他打完电话在回来直接插到最前面。但是这样做的好处在于，避免了修改数据的过程长时间的占用写锁，导致其他 DML 被堵塞。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(二)：日志的文件是如何保证不丢失的</title>
    <url>/2020/10/27/mysql/Mysql%E5%88%9D%E6%8E%A2(%E4%BA%8C)%EF%BC%9A%E6%97%A5%E5%BF%97%E7%9A%84%E6%96%87%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的23节日志相关部分的学习总结</p>
</blockquote>
<h2><span id="一-持久化的过程">一、持久化的过程</span></h2><p>从总的来看，日志一般分为两部分：内存中<strong>易遗失的缓存日志</strong>和磁盘上<strong>持久化的日志文件</strong>。</p>
<p>一次事务中，日志<strong>先被写入内存</strong>，存放在 cache/buffer 中，然后事务结束以后准备持久化：<strong>先写入磁盘的 page cache 中，这个过程叫做 write</strong> ，他仍然是内存操作，只不过从 mysql 的内存去了操作系统的内存，所以比较快；<strong>然后再调用操作系统的方法来写入磁盘，这个过程叫做 fsync ，是真正的持久化过程</strong>，比较耗费时间。</p>
<p>这个过程，我们可以简单的理解为下图：</p>
<p><img src="http://img.xiajibagao.top/image-20201116192502318.png" alt="日志的持久化过程"></p>
<p>基于以上的概念，我们了解一下 binlog 和 redo log 的持久化策略。</p>
<h2><span id="二-binlog-的持久化">二、binlog 的持久化</span></h2><h3><span id="1文件结构">1.文件结构</span></h3><p>系统给 binlog cache 分配了一片内存，<strong>每个线程独享一块内存</strong>，参数 <code>binlog_cache_size</code> 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p><img src="http://img.xiajibagao.top/image-20201116172850486.png" alt="binlog 写盘状态"></p>
<p>每个线程有自己 binlog cache，但是共用同一份 binlog 文件。这样是因为 binlog 的执行是不允许打断的，事务必须完成后完整的写入日志，不能也不允许出现像 redo log 那样两阶段提交只完成了一个阶段就能刷盘的情况。</p>
<h3><span id="2刷盘策略">2.刷盘策略</span></h3><p>当事务执行的时候，会<strong>先把日志写到内存里的 binlog cache 中，然后事务提交以后再调用 fsync 写入磁盘的 log file 上</strong>。由于一个事务的 binlog 不能拆开，因此每次写入都代表一次事务提交。</p>
<ul>
<li>图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。</li>
<li>图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync() 才占磁盘的 IOPS。</li>
</ul>
<p>write 和 fsync 的时机，是由参数 <code>sync_binlog</code> 控制的：</p>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都<strong>只 write，不 fsync</strong>；</li>
<li>sync_binlog=1 的时候，表示每次提交事务<strong>都会执行 fsync</strong>；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示<strong>每次提交事务都 write，但累积 N 个事务后才 fsync</strong>。</li>
</ol>
<p>因此，在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。</p>
<p>但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</p>
<h2><span id="三-redo-log-的持久化">三、redo log 的持久化</span></h2><h3><span id="1刷盘策略">1.刷盘策略</span></h3><p>和 binlog 相同，在事务未提交前，生成的日志也会先放在内存，不过不同于 <strong>binlog 存放在 binlog cache，redo log 存放在了 redo log buffer</strong>。</p>
<p>在 mysql 的运行过程中，redo log 的数据可能存在三种状态：</p>
<p><img src="http://img.xiajibagao.top/image-20201116175630245.png" alt="image-20201116175630245"> </p>
<p>这三种状态分别是：</p>
<ol>
<li>红色：存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</li>
<li>黄色：写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</li>
<li>绿色：持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</li>
</ol>
<p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：</p>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都<strong>只是把 redo log 留在 redo log buffer 中</strong> ;</li>
<li>设置为 1 的时候，表示每次事务提交时<strong>都将 redo log 直接持久化到磁盘</strong>；</li>
<li>设置为 2 的时候，表示每次事务提交时都<strong>只是把 redo log 写到 page cache，由后台线程一秒sync一次</strong>。</li>
</ol>
<p>一般情况下，不建议设置为0，如果需要的话可以设置为2，因为实际上 redo log 写到 page cache 也很快，而且只留在 redo log buffer 中风险太大，万一数据库崩溃就没法起到重做的效果了。</p>
<h3><span id="2未提交事务写入磁盘的情况">2.未提交事务写入磁盘的情况</span></h3><p>正如前文提到的，innodb 有一个两阶段提交机制，因此在事务未提交的时候，日志是有可能直接在 prepare 阶段就被 write 的：</p>
<ol>
<li>InnoDB 有一个后台线程，<strong>每隔 1 秒，就会把 redo log buffer 中的日志刷盘</strong>；</li>
<li>redo log buffer 占<strong>用的空间即将达到 innodb_log_buffer_size 一半</strong>的时候，后台线程会主动刷盘；</li>
<li><strong>并发事务提交</strong>的时候，先提交的那个事务会将 redo log buffer 中的日志全部刷盘。这个行为取决于 <code>innodb_flush_log_at_trx_commit</code> 参数，<strong>当该参数为 1 的时候，就会发生这种情况</strong>。</li>
</ol>
<p>由于当数据库崩溃后一个事务要同时有 prepare 阶段的 redo log 和 binlog 的记录才会被重做，因此一般情况下，我们会同时设置 <code>sync_binlog</code> 和 <code>innodb_flush_log_at_trx_commit</code> 参数为1，也就是一次事务刷两次盘： binlog 一次，redo log 一次。</p>
<h3><span id="3-组提交">3. 组提交</span></h3><p>按照上文的逻辑，当设置“双1”配置的时候，实际上要刷盘的次数就会两倍与看到的 TPS，但是事实并非如此。</p>
<p>当事务提交的时候，会通过<strong>日志逻辑序列号（LSN）</strong>来记录一条日志的长度，通过日志的长度确定事务的起始点和结束点。</p>
<p>假如我们现在有三个日志等待提交：</p>
<p><img src="http://img.xiajibagao.top/image-20201116200506743.png" alt="image-20201116200506743"></p>
<p><img src="http://img.xiajibagao.top/image-20201116200520213.png" alt="image-20201116200520213"></p>
<p><img src="http://img.xiajibagao.top/image-20201116200601118.png" alt="image-20201116200601118"></p>
<p>以上三张图就是三个事务的提交过程。我们可以看到：</p>
<ul>
<li>trx1 是第一个到达的，会被选为这组的 leader；</li>
<li>等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；</li>
<li>trx1 去写盘的时候，<strong>带的就是 LSN=160</strong>，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；</li>
<li>这时候 trx2 和 trx3 就可以直接返回了。</li>
</ul>
<p>所以，<strong>一次组提交里面，组员越多</strong>，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p>
<p>在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。为此，mysql 在两阶段提交做了一个优化：</p>
<p><img src="http://img.xiajibagao.top/image-20201116200841655.png" alt="image-20201116200841655"></p>
<p>我们可以看到，<strong>在 redo log 一阶段提交的时候，并没有在 write 完以后立刻就调用 fsync 刷盘，而是等到 binlog 的 write 结束以后才刷盘；binlog 则等 redo log 一阶段刷盘以后才刷盘</strong>，因此可以减少 IOPS 的消耗。</p>
<p>不过通常情况下第 3 步执行得会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p>
<p>如果你<strong>想提升 binlog 组提交的效果</strong>，可以通过设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 来实现。</p>
<ol>
<li><code>binlog_group_commit_sync_delay</code> 参数，表示延迟多少微秒后才调用 fsync;</li>
<li><code>binlog_group_commit_sync_no_delay_count</code> 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>这两个条件是或的关系，也就是说<strong>只要有一个满足条件就会调用 fsync</strong>。</p>
<p>所以，当 <code>binlog_group_commit_sync_delay</code> 设置为 0 的时候，<code>binlog_group_commit_sync_no_delay_count</code> 也无效了。</p>
<h3><span id="4-redo-log-提交策略的选择">4. redo log 提交策略的选择</span></h3><p>适当的刷盘策略可以降低 IO 带来的性能压力。结合以上的内容，我们可以有以下三种策略：</p>
<ol>
<li>增大<code>binlog_group_commit_sync_no_delay_count</code>和<code>binlog_group_commit_sync_delay</code> 参数，减少 binlog 刷盘次数，提高组提交的效果，但是这样虽然不会丢失数据，却会增加响应的时间；</li>
<li>增大 <code>sync_binlog</code> ，但是这样万一数据库崩溃会丢失 binlog 日志；</li>
<li>将<code>innodb_flush_log_at_trx_commit</code> 设置为 2，但是这样数据库崩溃会丢失数据，无法重做。</li>
</ol>
<h2><span id="四-总结">四、总结</span></h2><p><strong>持久化过程</strong></p>
<p>日志的持久化分为三步：</p>
<ul>
<li>写入内存里的 buffer/cache 中，此时仍然归于 mysql 进程；</li>
<li>从内存写入操作系统的 page cache，此操作为 write；</li>
<li>从 page cache 持久化到磁盘，此操作为 fsync，是真正持久化；</li>
</ul>
<p><strong>日志文件结构</strong></p>
<p>所有线程持久化同一个 binlog 日志文件，但是每个线程都有自己的 binlog cache，这是因为 binlog 必须保证每一次写入都是完整的事务。而 redo log 存在两阶段提交，并且需要 prepare 阶段的 redo log 来重做，所以允许未提交的事务被 write，因此线程共享一个 redo log buffer 和 redo log 日志文件。</p>
<p><strong>刷盘策略</strong></p>
<p>binlog 无论 <code>sync_binlog</code>参数怎么设置，都必须要 write：</p>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都<strong>只 write，不 fsync</strong>；</li>
<li>sync_binlog=1 的时候，表示每次提交事务<strong>都会执行 fsync</strong>；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示<strong>每次提交事务都 write，但累积 N 个事务后才 fsync</strong>。</li>
</ol>
<p>redo log 通过 <code>innodb_flush_log_at_trx_commit</code> 参数控制：</p>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都<strong>只是把 redo log 留在 redo log buffer 中</strong> ;</li>
<li>设置为 1 的时候，表示每次事务提交时<strong>都将 redo log 直接持久化到磁盘</strong>；</li>
<li>设置为 2 的时候，表示每次事务提交时都<strong>只是把 redo log 写到 page cache</strong>。</li>
</ol>
<p><strong>组提交</strong></p>
<p>mysql 通过日志逻辑序列号（LSN）去根据事务数据长度来记录事务在日志中的开始和结束位置。因此，假如有三个并发事务先后准备写入，第一个被 fsync 的日志可以作为 leader，直接携带从一号到三号事务的 LSN 去刷盘，这样后两个事务就不必再单独刷盘，减少的写磁盘的次数。</p>
<p>针对组提交，二阶段提交进行了优化，redo log 的 write 以后，会等到 binlog 的 wirte 后才调用 fsync，binlog 再等 redo log 的 fsync 完成后才进行 fsync。不过由于时间太短， binlog 的组提交效果不显著，可以通过增大：</p>
<ol>
<li><code>binlog_group_commit_sync_delay</code> 参数，表示延迟多少微秒后才调用 fsync;</li>
<li><code>binlog_group_commit_sync_no_delay_count</code> 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>两个参数来提高组提交效率，不过这样会降低语句的响应时间。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(三)：内存数据刷盘机制</title>
    <url>/2020/10/28/mysql/Mysql%E5%88%9D%E6%8E%A2(%E4%B8%89)%EF%BC%9A%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的12节的学习笔记</p>
</blockquote>
<h2><span id="一-mysql-的刷盘机制">一、mysql 的刷盘机制</span></h2><p>而之前提到过，mysql 使用了 WAL 技术，即更新的时候先更新内存中的数据，然后必要的时候再将内存中的数据刷入磁盘。我们把内存中这些被修改过，跟磁盘中的数据页不一致的数据页称为脏页。</p>
<p>其中，有四种情况会触发脏页的刷盘：</p>
<ol>
<li>redo log 可写空间满了。</li>
<li>内存满了，需要淘汰的数据页恰好是脏页。</li>
<li>系统不繁忙的时候。</li>
<li>关闭数据库的时候。</li>
</ol>
<p>其中，第三种情况不会为系统带来过多影响的，第四中情况下不会在乎为系统带来的影响。所以我们只需要关注第一和第二种情况：</p>
<p>对于第二种情况，由于 mysql 的更新需要先写日志，所以<strong>当日志满了的情况下，所有的更新都会停止，一直到刷完盘日志腾出了空间为止</strong>；</p>
<p>而对于第二种情况，当查询的数据在内存中的数据页没有的时候，就需要淘汰旧页释放内存以读入新页，<strong>所以当一次查询导致需要淘汰的脏页过多的时候，就需要先等待较长的刷盘时间，然后才能获取响应</strong>。</p>
<p>为了避免上述两种情况，必须要控制脏页在内存中的比例。</p>
<h2><span id="二-刷脏页的控制策略">二、刷脏页的控制策略</span></h2><p>首先，我们必须要知道主机磁盘的写入能力有多强，这样 innodb 才可以知道它刷脏页的速度最快应该是多快。</p>
<p>我们可以通过<strong>设置 <code>innodb_io_capacity</code> 这个参数来告诉 innodb 磁盘的写入速度</strong>。这个参数的值不宜过小，因为这会导致 innodb 错误的估计刷盘速度，最后导致刷脏页的速度跟不上脏页生成的速度。</p>
<p> <code>innodb_io_capacity</code>规定了刷脏页速度的极限，但是实际上磁盘不可能只服务这么一个功能，所以还需要参考 <strong>redo log 的刷盘速度</strong>和<strong>允许的内存中的脏页</strong>比例。</p>
<p><strong>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限</strong>，默认值是 75%。innodb 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，这个公式是 <code>F1(M)</code> 。</p>
<p>而每次写入 redo log 的写入点 wp 都会有一个序号，innodb 会根据这个序号和上一次清理日志的界限 cp 之间的差值——我们假设为 N——计算得到一个范围在 0 到 100 之间的数字，这个公式是 <code>F2(N)</code></p>
<p>根据上述算得的 <code>F1(M)</code> 和 <code>F2(N)</code> 两个值，取其中较大的值记为 R，之后引擎就可以按照 <code>innodb_io_capacity</code> 定义的能力乘以 R% 来控制刷脏页的速度。</p>
<p>这一整个流程对应的图片是这样的：</p>
<p><img src="http://img.xiajibagao.top/image-20201029164736099.png" alt="image-20201029164736099"></p>
<p>所以，我们需要关注内存中的脏页比例，让它尽量不要到75%，并且合理的设置 <code>innodb_io_capacity</code> 参数。</p>
<p>其中，针对脏页的比例，我们可以通过 <code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code>去设置。</p>
<p>另外，由于 mysql 存在这样一个机制：如果要刷盘的脏页相邻的数据页恰好也是脏页，就一起写入磁盘，如果邻居的邻居也是如此。在机械硬盘时代这个策略可以减少随机IO，但是如果使用固态硬盘的话随机IO的性能往往比较高，所以使用这个策略反而拖累了查询性能。因此可以通过 <code>innodb_flush_neighbors</code>关闭这个“连坐”的策略。</p>
<h2><span id="三-总结">三、总结</span></h2><p>innodb 有四种情况会触发脏页的刷盘：</p>
<ul>
<li>redo log 可写空间满了；</li>
<li>内存满了，需要淘汰的数据页恰好是脏页；</li>
<li>系统不繁忙的时候；</li>
<li>关闭数据库的时候。</li>
</ul>
<p>innodb 通过的刷盘速度通过类似这样的公式计算：</p>
<blockquote>
<p><code>innodb_io_capacity * Max( F(innodb_max_dirty_pages_pct)， F(redo log的wp - redo log的cp) )</code></p>
<p>其中，<code>innodb_io_capacity</code>表示磁盘的最大IO能力；<code>innodb_max_dirty_pages_pct</code>表示允许脏页在内存中的占比，默认值为75%；</p>
</blockquote>
<p>当使用固态硬盘的时候，可以设置<code>innodb_flush_neighbors</code>关闭默认的刷新相邻脏页的策略。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(五)：数据库表空间的回收</title>
    <url>/2020/10/30/mysql/Mysql%E5%88%9D%E6%8E%A2(%E4%BA%94)%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间MySQL实战45讲第13节的笔记</p>
</blockquote>
<h2><span id="一-表数据的存放位置">一、表数据的存放位置</span></h2><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 <code>innodb_file_per_table</code> 控制的：</p>
<ol>
<li>OFF ：表的数据放在系统共享表空间，即跟数据字典放在一起；</li>
<li>ON ：表数据存储在一个以 .ibd 为后缀的文件中。（MySQL 5.6.6 默认为 ON）</li>
</ol>
<p>一般情况下，表单独存放的时候，可以通过 drop table 语句直接删除，而如果放在共享表空间，及时删除了表也无法回收空间。</p>
<h2><span id="二-表数据的删除">二、表数据的删除</span></h2><p>一般情况下，很少有直接连结构带数据直接删掉表的情况，更多时候是只删除一些数据，但是这样往往会遇到这样的问题：<strong>表中的数据被删除了，但是表空间却没有被回收</strong>。</p>
<p>实际上，这与 innodb 中数据都以 B+ 树的结构存储有关：</p>
<p><img src="http://img.xiajibagao.top/image-20201105203027271.png" alt="image-20201105203027271"></p>
<p>以上图为例，如果我们删除 R4 这条数据，则 innodb 会把 R4 这个位置标记为删除，之后如果插入一个在 300~600 的记录的时候，就会直接使用现在 R4 的位置。同理，如果我们清除这个 PageA，那么这个数据页都会被标记删除，等到下一个数据页加载的时候就可以直接使用这个空间。而当两个相邻的数据页上被删除了记录很多，也就是页的利用率都很低的时候，系统就会自动合并两个页的数据，并且标记其中一个为可复用。</p>
<p>值得一提的是，记录的空间被复用，必须限定位置，比如 R4 的空间被复用，就不能插入300 ~ 600之外的数据；而数据页的空间则可以被任意一页新加载的页复用。</p>
<p>综上所述，不难理解，<strong>我们使用 delete 删除的数据只是把这块空间标记为可复用，是一种逻辑上的删除，并没有实际减少磁盘空间的占用</strong>。</p>
<p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<p><img src="http://img.xiajibagao.top/image-20201105204359077.png" alt="image-20201105204359077"></p>
<p>假如 PageA 已满，再插入一条550，PageA 就会不得不分离成两页，这就是页的分裂。当分裂完以后，PageA 就会留下一个空洞，新页 PageB 一样没有占满。</p>
<p>另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这很有可能破坏了索引的有序性，也是会造成空洞的</p>
<p>也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，<strong>如果能够把这些空洞去掉，就能达到收缩表空间的目的</strong>。</p>
<p>而重建表，就可以达到这样的目的。</p>
<h2><span id="三-重建表">三、重建表</span></h2><h3><span id="1重建表的流程">1.重建表的流程</span></h3><p>为了去掉表中的空洞，我们可以新建一个与表 A 结构相同的表 B，然后<strong>按照主键 ID 递增的顺序</strong>，把数据一行一行地从表 A 里读出来再插入到表 B 中。</p>
<p>由于表 B 是新建的表，所以表 A 主键索引上的空洞，在表 B 中就都不存在了。显然地，表 B 的主键索引更紧凑，数据页的利用率也更高。如果我们把表 B 作为临时表，数据从表 A 导入表 B 的操作完成后，用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。</p>
<p>可以使用 <code>alter table A engine=InnoDB</code> 命令来重建表。在 MySQL 5.5 版本之前，这个命令的执行流程跟我们前面描述的差不多，mysql 会自动完成全部操作。</p>
<h3><span id="2优化">2.优化</span></h3><p>但是这个 DDL 语句不是 online 的，也就说，<strong>如果过程中有新的数据往 A 表插入，有可能不会被读到并且一起转移到 B 表，导致最后丢失更新</strong>。因此，在 5.6 版本以后，引入的 online DDL 对这个流程做了优化。</p>
<p>新的流程如下：</p>
<ol>
<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>
<li>生成临时文件的过程中，<strong>将所有对 A 的操作记录在一个日志文件</strong>中；</li>
<li>临时文件生成后，<strong>将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件</strong>；</li>
<li>用临时文件替换表 A 的数据文件。</li>
</ol>
<p>因为过程中对表 A 的操作最后都会通过日志同步到临时文件，所以在整个 DDL 执行的过程不会影响对表 A 的增删改查。</p>
<h3><span id="3inplace">3.inplace</span></h3><p>我们可以注意到，5.6 之前是创建临时表，而 5.6 以后则是创建了临时文件。这两者的区别在于：<strong>临时表是创建在 server 层的</strong>，<strong>临时文件是创建在 innodb 内部</strong>的，整个 DDL 过程都在 innodb 内部完成。对于 server 层来说，后者没有把数据移到临时表，相当于一个原地操作，所以叫 inplace。</p>
<p>也就是说，<code>alter table t engine=InnoDB</code> 这个 DDL 实际上相当于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=inplace;</span><br></pre></td></tr></table></figure>

<p>相对于创建临时表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>

<h3><span id="4三种重建表方式的区别">4.三种重建表方式的区别</span></h3><ol>
<li>从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认的就是上面图 4 的流程了；</li>
<li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；</li>
<li>optimize table t 等于 recreate + analyze。</li>
</ol>
<h2><span id="四-总结">四、总结</span></h2><p>数据库表文件可以存在共享表空间里；也可以单独以 .ibd 文件存储。共享表空间中的表使用 drop table 无法清除。通过<code>innodb_file_per_table</code>参数的 off/on 可以控制存放策略。mysql 5.6.6 以后默认为 on。</p>
<p>innodb 中的删除只是标记空间为可复用，没有实际删除数据。当非有序的插增删改影响了索引上的数据的有序性时，可能产生“空洞”降低空间利用率。当内存中相邻表空间利用率都很低的时候，可能引起页的合并，反之，过满或者无序插入会引发页分裂。</p>
<p>通过拷贝数据到临时表，再有序将数据插入原表，即重建表可以收缩空间。可以使用 <code>alter table A engine=InnoDB</code>的 sql 实现。</p>
<p>5.5 之前版本拷贝过程中原表的正删改可能在重建后丢失，5.6 之后将对原表的正删改写入临时日志后再同步，实现了 online DDL。</p>
<p>5.6 之前重建操作为在server 层创建临时表，5.6 之后为在 innodb 内创建临时文件，他们的写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认为inplace</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>(,ALGORITHM=inplace);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(六)：数据库事务概述</title>
    <url>/2020/11/02/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%85%AD)%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 3、8、18、19节事务相关部分的总结</p>
</blockquote>
<h2><span id="一-事务的启动方式">一、事务的启动方式</span></h2><p>mysql 主要有两种事务的启动方式：</p>
<ol>
<li><code>begin</code> 或 <code>start transaction</code>显式启动事务。对应的提交语句是 <code>commit</code> ，回滚是 <code>rollback</code></li>
<li><code>set autocommit = 0</code>关闭自动提交，然后在执行第一条 sql 的时候启动事务，这个事务会一直持续到你主动 commit 或者 rollback，或者断开连接才会结束。</li>
</ol>
<p>有一些客户端连接框架会在连接成功后默认修改设置，这可能导致意外的长事务。因此，显示启动事务明显是比较安全的，但是对于一些需要频繁使用事务的业务，每次都需要调用 begin 然后再 commit。对于这种情况，可以使用 <code>commit work and chain</code>，当 <code>autocommit = 1</code>时，<strong>使用该语句可以在提交以后自动开启下一个新事务</strong>。</p>
<p>这样省去了再次执行 begin 语句的开销，而且可以明确地知道每个语句是否处于事务中。</p>
<p>除此之外，我们还可以使用 sql 去在 information_schema 库的 innodb_trx 这个表中查询长事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started)) &gt; <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>比如上面这条语句，就是用于查找持续时间超过 60s 的事务</p>
<h2><span id="二-事务的隔离级别">二、事务的隔离级别</span></h2><p>我们知道事务有四大特性（ACID）：原子性，一致性，隔离性，持久性。</p>
<p>针对隔离性，我们有：</p>
<ol>
<li><strong>读未提交</strong>：一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读已提交</strong>：一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong>：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化</strong>：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ol>
<p>简单的理解：</p>
<ol>
<li><strong>读未提交</strong>：别人改数据的事务<strong>尚未</strong>提交，我在我的事务中<strong>也能读到</strong>。</li>
<li><strong>读已提交</strong>：别人改数据的事务<strong>已经提交</strong>，我在我的事务中<strong>才能读到</strong>。</li>
<li><strong>可重复读</strong>：别人改数据的事务<strong>已经提交</strong>，我在我的事务中<strong>也不去读</strong>。</li>
<li><strong>串行化</strong>：我的事务尚未提交，别人就别想改数据。</li>
</ol>
<p>以这张图为例：</p>
<p><img src="http://img.xiajibagao.top/image-20200930144400423.png" alt="image-20200930144400423"></p>
<ol>
<li><strong>读未提交</strong>： 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li>
<li><strong>读已提交</strong>：则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li>
<li><strong>可重复读</strong>：则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li>
<li><strong>串行化</strong>：则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li>
</ol>
<p>我们不难看出，读已提交和可重复读，最大的区别在于，当一个查询的事务尚未提交，另一个修改的事务的提交是否会影响到这次查询结果。</p>
<h2><span id="三-事务隔离的实现">三、事务隔离的实现</span></h2><h3><span id="1脏读幻读不可重复读">1.脏读，幻读，不可重复读</span></h3><p>说起事务，就不得不提到三种错误读：</p>
<ol>
<li><strong>脏读（读到了RoolBack）</strong>：表示一个事务能够读取另一个事务中还未提交的数据。这个未提交数据就是脏读（Dirty Read）。</li>
<li><strong>幻读（读到了insert）</strong>：指同一个事务内多次查询返回的结果集不一样。</li>
<li><strong>不可重复读（读到了update</strong>）：是指在一个事务内，多次读同一数据。<ul>
<li>第一类丢失更新：两个事务更新同一条数据资源，后做的事务撤销，发生回滚造成已完成事务的更新丢失</li>
<li>第二类丢失更新：两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失</li>
</ul>
</li>
</ol>
<h3><span id="2事务隔离的实现">2.事务隔离的实现</span></h3><p>在实现上，数据库里面会创建一个视图，当访问的时候以视图的逻辑结果为准。</p>
<p>这里需要注意一下，这里的视图区别于我们自己创建的 View ：</p>
<blockquote>
<p> innodb 创建的，用于实现 MVCC 时的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别。</p>
</blockquote>
<ol>
<li><strong>读未提交</strong>：直接返回记录上的最新值，没有视图概念；</li>
<li><strong>读已提交</strong>：这个视图是在每个 SQL 语句开始执行的时候创建的。</li>
<li><strong>可重复读</strong>：这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>
<li><strong>串行化</strong>：直接用加锁的方式来避免并行访问。</li>
</ol>
<p>这里单独对读已提交和可重复读的逻辑做一个区分：</p>
<ul>
<li>在可重复读隔离级别下，只需要在<strong>事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图</strong>；</li>
<li>在读提交隔离级别下，<strong>每一个语句执行前都会重新算出一个新的视图</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>读已提交</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>可重复读</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>串行化</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h2><span id="四-mvcc">四、MVCC</span></h2><h3><span id="1概述">1.概述</span></h3><p>MVCC 即是并发版本控制。拿可重复读举个例子：</p>
<p>我们知道 innodb 有个 undo log ，每条记录在更新的时候都会在 undo log 中记录一条回滚操作，通过日志记录可以回滚到上一状态的值。</p>
<p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<p><img src="http://img.xiajibagao.top/image-20200930145105580.png" alt="image-20200930145105580"></p>
<p>当前的值是4，但是对于不同时间段启动的事务创建的视图ABC而言，分别为1，2，4，这时就算把4再改成5，对于ABC三个视图也不会有影响。</p>
<p><strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong>。</p>
<h3><span id="2一致性读视图的实现">2.一致性读视图的实现</span></h3><p>当在可重复读隔离级别下时，事务在启动的时候就给整库“拍了个快照”，这个快照就是我们在事务的隔离提到过一致性读视图。这个视图是逻辑上的，用于描述事务之间的可见性。</p>
<p>在 innodb 里，每个事务都有独有的 transaction id，这是在事务开始的时候向系统申请的，是严格递增的。</p>
<p>而每行数据也有多个版本，每次事务更新数据的时候都会把 id 赋给对应版本数据的 row trx_id。</p>
<p><img src="http://img.xiajibagao.top/image-20201023102713922.png" alt="image-20201023102713922"></p>
<p>如上图，我们可以看到这一行数据被三个事务进行了修改，现在有四个版本,每个版本更新前都会记录一条回滚的语句在 undo log。</p>
<p>事实上，V1，V2这些版本的数据并不是真实存在的，而是在需要的时候才通过 undo log 计算获取。比如需要 V2，就从 V4 经过 U3 和 U2 获得。</p>
<p>现在我们知道数据版本是如何跟事务绑定的，那么事务的隔离就很好理解了：<strong>当一个事务启动的时候，获取事务 id，事务id比他小的说明是在他之前就产生的，这些事务对应的版本就是被本事务承认的，反之，则这些数据是不被本事务承认的，要向前找到可以承认的数据版本。</strong></p>
<p>为此，innodb 会在事务启动的时候，为事务创建一个数组，这个数字里会存放所有当前启动了但是还没提交的事务的 id。这个数组里最小的视为低水位，最大的+1视为高水位，从低水位到高水位中间的这块区域，就是<strong>当前事务的一致性视图</strong>。这段操作是在锁保护性进行的。</p>
<h3><span id="3数据版的一致性读">3.数据版的一致性读</span></h3><p>假如我们只在事务里面进行查询，而暂时不涉及到更新，那么基于一致性视图，当前事务就可以根据数据版本id，也就是 row trx_id 来判断当前数据版本对于自己而言是否可见：</p>
<p><img src="http://img.xiajibagao.top/image-20201023104832814.png" alt="image-20201023104832814"></p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况<ul>
<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>
<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ul>
</li>
</ol>
<p>当然，可能存在这么一种情况：如果有一个事务在未提交事务的区间，但是在当前事务获</p>
<p>仍然以上图为例，假如有一个事务，他的低水位是18，也就是说在他启动的时候，row trx_id 是17 的V3是最新的版本，在他查询的时候，而最新的版本变成了 row trx_id 是25的V4，那么对他而言V4是不可见的，于是通过 undo log U3 计算得到V3，V3低于他的低水位，所以V3是可见的，故对于该事务而言值就是V3的值。</p>
<p>可以看到，<strong>事务开始前和事务开始后读到的数据都一致的，这个就是一致性读</strong>。可重复读依赖这个隔离级别核心依赖于此。</p>
<h3><span id="4数据的当前读">4.数据的当前读</span></h3><p>当事务里只进行查询的时候一致性读可以保证读取的正确性，但是如果进行的是更新，那么一致性读反而会导致错误。我们以下图为例：</p>
<p><img src="http://img.xiajibagao.top/image-20201023110829190.png" alt="image-20201023110829190"></p>
<p>原本 k 是2，事务C进行了更新并且率先提交，对于事务C而言，此时k是3，但是事务B又进行了一次更新，那么等到提交的时候，k该是3还是4？</p>
<p>这里涉及到一个规则。<strong>因为更新总是需要先读后改，所以更新的读必须要读最新的数据，也就是当前读</strong>。</p>
<p>值得一提的是，如果是 select 语句，如果加了读锁或者写锁，也是当前读：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加读锁</span></span><br><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="comment"># 加写锁</span></span><br><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>然后，我们在前面了解了行锁，而行锁有一个两阶段锁的机制：<strong>事务里的有对某一行数据的更新，那么sql执行前就会去获取行锁，然后执行完sql之后不释放，等到事务提交之后才会去释放锁</strong>。由于事务C先获取了行锁，那么事务B的更新就会等待事务C释放锁以后才会得到锁。反映到执行上，就是事务B的 update 等到 事务C提交了才会继续进行。</p>
<p>也就说<strong>，而行锁的两阶段锁保证了更新的顺序进行，当前读机制保证的更新语句总是能拿到最新的数据。</strong></p>
<h3><span id="5一致性视图与可重复读和读已提交">5.一致性视图与可重复读和读已提交</span></h3><p>MVCC 实现的核心在于一致性视图，可重复读和读已提交建立视图的机制决定了他们实现效果的不同：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<h3><span id="6为什么要避免长事务">6.为什么要避免长事务</span></h3><ol>
<li><strong>占用日志空间</strong>：因为一致性视图需要通过 undo log 去计算旧版本的数据，而 undo log 只有在没有比某条日志更早的一致性视图时才会删除。所以如果存在长事务，可能就会导致数据库的视图存在很长时间，直到这些视图删除前日志都会一直保留，这将会导致占用大量存储空间。</li>
<li><strong>影响版本控制计算性能</strong>：在可重复读这个隔离级别下，如果其他事务对某条数据进行了非常多次的操作，最后会导致本事务读取的时候必须要通过 undo log 计算非常多次才能找到最初的数据版本。</li>
<li><strong>占用锁资源</strong>：长事务还会可能会占用锁资源，比如只有等事务提交才能释放的行锁。</li>
</ol>
<h2><span id="五-总结">五、总结</span></h2><p>1.<strong>事务的启动</strong>：</p>
<ul>
<li><code>begin</code> 或 <code>start transaction</code>显式启动事务。对应的提交语句是 <code>commit</code> ，回滚是 <code>rollback</code>；</li>
<li>set autocommit = 0`关闭自动提交，然后在执行第一条 sql 的时候启动事务，这个事务会一直持续到你主动 commit 或者 rollback，或者断开连接才会结束。</li>
</ul>
<p>2.<strong>事务的隔离级别</strong>：</p>
<ul>
<li>读未提交：别人改数据的事务<strong>尚未</strong>提交，我在我的事务中<strong>也能读到</strong>。会脏读，幻读，不可重复读；</li>
<li>读已提交：别人改数据的事务<strong>已经提交</strong>，我在我的事务中<strong>才能读到</strong>。会幻读，不可重复读；</li>
<li>可重复读：别人改数据的事务<strong>已经提交</strong>，我在我的事务中<strong>也不去读</strong>。会不可重复读；</li>
<li>串行化：我的事务尚未提交，别人就别想改数据。加锁，不会错误读。</li>
</ul>
<p>3.<strong>并发版本控制</strong>（MVCC）：</p>
<ul>
<li><p>每个事务的更新都会产生一个新版本数据，每个数据版本有自己的 row trx_id，对应更新他们的事务的 transaction  id；</p>
</li>
<li><p>事务启动时 innodb 为事务创建一个数组，这个数字里会存放所有当前启动了但是还没提交的事务的 id。这个数组里最小的视为低水位，最大的+1视为高水位，从低水位到高水位中间的这块区域，就是<strong>当前事务的一致性视图</strong>。根据事务版本 id 从一致性视图中判断该版本对本事务是否可见；</p>
</li>
<li><p>可重复读和读已提交建立视图的机制决定了他们实现效果的不同：</p>
<p>在<strong>可重复读隔离级别</strong>下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</p>
<p>在<strong>读提交隔离级别</strong>下，每一个语句执行前都会重新算出一个新的视图。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(十三)：自增主键，自增锁</title>
    <url>/2020/11/16/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%B8%89)%EF%BC%9A%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%8C%E8%87%AA%E5%A2%9E%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的39节的学习笔记</p>
</blockquote>
<h2><span id="一-自增值的保存方式">一、自增值的保存方式</span></h2><p>我们前面提到过，自增主键的连续性使得表在空间上排列的更紧密，提高了空间利用率，避免了页分裂。实际上，自增主键大部分情况下可以保证连续性，但是也有例外的时候。</p>
<p>当我们创建表的时候，表结构会存储在 .frm 文件中，但是并不会一起保存自增值。<strong>MyISAM 引擎将自增值保存在数据文件</strong>，而 innodb 在 mysql8.0 之前只会<strong>将自增值保存在内存</strong>。</p>
<p>也就是说，对于 innodb 引擎来说，每次重启后，都需要<strong>寻找表中最大的自增值 X，将 X+1 作为新的自增值</strong>，如果当前最大值为 10，自增值就会是11，如果删除了自增值为 10 的行，那么此时重启数据库，新插入的行自增值就会变成11，当自增值是主键的时候，相当于从新增变成了更新。</p>
<p><strong>而 8.0 以后，innodb 会将自增值的变更记录到 redo log，重启以后依靠日志重做</strong>。</p>
<h2><span id="二-自增值的自增机制">二、自增值的自增机制</span></h2><p>在 mysql 中，如果字段 id 被定义为 AUTO_INCREMENT，那么插入时：</p>
<ol>
<li>如果插入数据时 id 字段指定为 <strong>0、null 或未指定值</strong>，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>
<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。</p>
<ol>
<li>如果 X&lt;Y，那么这个表的自增值不变；</li>
<li>如果 X≥Y，就需要<strong>把当前自增值修改为新的自增值</strong>。</li>
</ol>
<p>其中，有 <code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> ，分别表示自增值的<strong>初始值</strong>和自增的<strong>步长</strong>，一般默认为1，如果是在一些特殊的情况下：比如双 master 的结构下，就会将其中一个库的 <code>auto_increment_offset</code>  设置为2，让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数，避免两个库生成的主键发生冲突。</p>
<p>当需要自增的时候，会在<code>auto_increment_offset</code> 的基础上，累加<code>auto_increment_increment</code> ，直到找到第一个比插入值 X 大的数作为新的自增值。</p>
<h2><span id="三-自增锁和释放策略">三、自增锁和释放策略</span></h2><p>为了在并发条件下维护自增值的有序性，mysql 引入自增锁。在 mysql 5.1.22 之前的版本，当有需要获取自增值的 sql ——而不是事务——要执行的时候，就会<strong>为计数器加一个表锁，在锁释放前这张表不会有新的 sql 能获得到新的值</strong>。很显然，这个和表的读写锁一样，在<strong>大量 sql 同时请求的时候比较容易发生堵塞</strong>。</p>
<p>mysql 在5.1.22 版本引入了一个新策略，新增参数 <code>innodb_autoinc_lock_mode</code>，默认值是 1。</p>
<ol>
<li>设置为 0：表示采用之前 MySQL 5.0 版本的策略，即<strong>语句执行结束后才释放锁</strong>；</li>
<li>设置为 1：分两种情况<ul>
<li><strong>普通 insert 语句，自增锁在申请之后就马上释放</strong>；</li>
<li>类似 insert … select 这样的<strong>批量插入数据的语句，自增锁还是要等语句结束后才被释放</strong>；</li>
</ul>
</li>
<li>设置为 2：所有的申请自增主键的动作都是<strong>申请后就释放锁</strong>。</li>
</ol>
<p>这个策略的疑问在于，为什么 insert … select 不可以直接使用第三种策略，申请以后就释放？</p>
<p>假如现在有以下的时序图：</p>
<p><img src="http://img.xiajibagao.top/image-20201112202134714.png" alt="自增锁的加锁策略"></p>
<p>假如在第三个时刻：</p>
<ol>
<li>sessionB 已经写入了（1,1,1）和（2,2,2）；</li>
<li>此时 sessionA 写入了 （3,5,5）；</li>
<li>sessionB 继续写入（4,3,3）和（5,4,4）；</li>
</ol>
<p>也就是说，在表 t 上的数据应该是（1,1,1）（2,2,2）（3,3,3）（4,4,4），但是写到表 t2 变成了（1,1,1）（2,2,2）3,5,5）（4,3,3）（5,4,4）</p>
<p>考虑到 sessionB 的语义并没有强制要求 t2 与 t1 相同，所以这不是大问题，但是这样的行为反应到 binlog 就有问题了：</p>
<p>一般情况下，binlog 默认为 statement ，即记录 sql，在<strong>实际上两个 sql 是并行执行的，但是在 binlog 上是串行写入</strong>的，不管是谁先谁后，使用 binlog 恢复的备份里，<strong>表 t2 的数据都会和原来的数据库不一致</strong>。 </p>
<p>发生这个问题的根本原因在于 <strong>sessionB 的 insert…select 这一条语句批量插入数据的 id 是不连续的</strong>，如果要避免这个问题，有两个办法：</p>
<ul>
<li>从根本上解决：让 insert…select 拿到的自增值一定是连续的，方案就是<strong>让锁等 sql 执行完才提交</strong>；</li>
<li>解决出问题的人：<strong>把 binlog 改为 row</strong>，直接记录数据的变化，避免恢复备份是数据出错。</li>
</ul>
<p>为了并发性能考虑，一般情况下，都选择 <strong><code>binlog_format = row</code></strong> + <strong><code>innodb_autoinc_lock_mode = 2</code></strong> 的模式。</p>
<h2><span id="四-事务回滚导致自增不连续">四、事务回滚导致自增不连续</span></h2><p>一般情况下，以自增值为主键的表插入一条 id 为 null 的记录的过程如下：</p>
<ol>
<li>执行器调用 innodb 引擎，写入一行；</li>
<li>innodb 发现没指定主键，获取要插入的表的自增值；</li>
<li>将自增值赋给要插入的新数据作为主键；</li>
<li>自增值自增；</li>
<li>完成插入。</li>
</ol>
<p>实际上，如果因为一些其他的情况，导致第五步没有执行，就会导致自增值增加了，但是上一个自增值却没有对应的数据。比如第五步的时候发现<strong>唯一索引冲突</strong>，或者插入完以后<strong>事务回滚</strong>。</p>
<p>实际上，事务回滚理论上应该回滚完全部的数据，但是却没有回滚自增值，是为了性能上的考虑：</p>
<p>假如事务A和事务B分别申请了2和3这两个值作为id，现在自增值为4，<strong>如果事务A发生回滚，而事务B提交了，此时就会出现自增值回滚为2，但是已经出现了id=3的数据</strong>，那么下一条插入的数据就会因此id=3这个主键冲突而插入失败。</p>
<p>如果要解决这个问题，那么方法有两种：</p>
<ol>
<li>每次插入前扫描一下主键，是否存在同值，有就跳过；</li>
<li>把自增锁从语句级别扩大到事务级别，必须先等上一个事务提交，下一个事务的 sql 才能获取新的自增值；</li>
</ol>
<p>这两种方法都非常影响性能，所以 mysql 事务回滚不会回滚自增值，<strong>自增值只能保证递增有序，不能保证连续。</strong></p>
<h2><span id="五-批量插入的申请策略">五、批量插入的申请策略</span></h2><p>insert..select 语句之所以需要加锁，是因为<strong>无法确定到底要插入多少条数据</strong>，对于 insert……values (),(),() 这样语句来说，由于一开始就能确定有多少条要插入，可以直接申请对应数量的自增值。</p>
<p>实际上，mysql 针对 insert…select 这样不确定数量的批量插入也有申请自增id的策略：</p>
<ol>
<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>
<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>
<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>
<li>依此类推，同一个语句去申请自增 id，<strong>每次申请到的自增 id 个数都是上一次的两倍</strong>。</li>
</ol>
<p>我们举个例子：假如 sessionA 要执行 insert…select 语句，需要插入四次。在第三次申请 id 的时候，自增 id 就会变成 2 + 4 = 6，如果这个时候来了另一个 sessionB 要插入数据，就会直接插入 7，等到 sessionB 提交了以后，sessionA 第四次要申请的时候，自增id就会从8开始，也就说，<strong>4和5这个id就被跳过了，这也会导致出现自增主键的“空洞”</strong>。</p>
<h2><span id="六-总结">六、总结</span></h2><h3><span id="1自增主键保存和增长策略">1.自增主键保存和增长策略</span></h3><p>mysql 8.0 之前自增值保存在内存里，重启以后会获取表的最大值，在最大值基础上+1。8.0 之后可以通过 redo log 重做获得最新的自增值。</p>
<p><code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 分别表示自增值的初始值和自增的步长，当插入记录已经指明了自增值的时候，则会直接使用插入值，并且比较该值与最新初始值的大小，如果初始值小，则会累加步长直到比插入值大位置，反正就不改变初始值，下次插入还用它。</p>
<p>事务回滚不会回滚自增值，这样做是为了避免先进行的事务回滚，导致自增值回滚后小于最新数据自增id，下一次插入可能会出现主键冲突。</p>
<h3><span id="2自增锁的加锁策略">2.自增锁的加锁策略</span></h3><p>mysql 针对自增锁有三种策略，根据<code>innodb_autoinc_lock_mode</code>设置：</p>
<ul>
<li>设置为 0 ：语句结束后释放自增锁；</li>
<li>设置为 1：普通 insert 申请后立刻释放； insert … select 这样批量插入的语句会等到执行完后才释放；</li>
<li>设置为 2：不分普通和批量插入，语句获取锁后都立刻释放锁；</li>
</ul>
<p>当有插入的 sql 和批量插入并发写的时候，可能会出现自增主键连续，但是 binlog 备份恢复出来的数据库跟原库不一致，这种情况最好选择 <code>statement + innodb_autoinc_lock_mode = 2</code></p>
<h3><span id="3自增主键不一致的可能性">3.自增主键不一致的可能性</span></h3><p>mysql 针对确定数量的批量插入是可以直接申请一大批自增值的，但是针对不确定的插入，会每次插入都申请两倍于上一次插入申请的数量的自增主键。</p>
<p>综上，主键不自增有可能有两种情况：</p>
<ul>
<li>插入失败，事务回滚导致申请了的自增值没用上；</li>
<li>批量插入申请了大量主键，中途其他事务插入导致自增值被迫维持在最大值；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(十一)：join</title>
    <url>/2020/11/13/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%B8%80)%EF%BC%9Ajoin/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 34、35节join相关内容的笔记</p>
</blockquote>
<h2><span id="一-join的查询流程">一、Join的查询流程</span></h2><p>假设我们有表 t1 和表 t2，他们都有字段 a，b，其中 t1 有 100条数据，而 t2 有1000条数据。</p>
<p>我们要执行这么一条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> t2.a = t1.a</span><br></pre></td></tr></table></figure>

<p>执行流程就是会这样的：</p>
<ol>
<li>先取出 t1 的一条数据 R；</li>
<li>然后根据 R 的 a 字段 去 t2 表里找复合条件的数据；</li>
<li>找到以后，就和 R 的数据拼起来作为结果集的一部分；</li>
<li>重复以上步骤，直到遍历完 t1 最后一条数据。</li>
</ol>
<p>其中，被驱动表的关联条件是否有索引对性能有着很大的影响。</p>
<h2><span id="二-关联条件有索引">二、关联条件有索引</span></h2><h3><span id="1njl算法">1.NJL算法</span></h3><p>还是以上面的 sql 为例：</p>
<ol>
<li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li>
<li>而对于每一行 R，根据 a 字段去表 t2 查找，<strong>走的是树搜索过程</strong>。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li>
<li>所以，整个执行流程，总扫描行数是 200。</li>
</ol>
<p>这个算法叫做<strong>NJL</strong>（Index Nested-Loop Join），由于从 t1 往 t2 查找的过程中使用了索引，所以关联查询的过程其实是一个查找树的过程：</p>
<blockquote>
<p>假设<strong>被驱动表的行数是 M</strong>。每次在被驱动表查一行数据，要先搜索索引 a，再搜索主键索引。每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。</p>
<p>假设<strong>驱动表的行数是 N</strong>，执行过程就要扫描驱动表 N 行，然后对于每一行，到被驱动表上匹配一次。</p>
<p><strong>因此整个执行过程，近似复杂度是 <code>N + N * 2 * log2M</code>。</strong></p>
</blockquote>
<p>所以，对于有索引的情况下，<strong>需要让小表做驱动表</strong>。</p>
<h3><span id="2mrr优化">2.MRR优化</span></h3><p>对于关联条件上有索引，但是查询条件没有实现索引覆盖的字段，仍然需要在获得了非主键索引后，进行回表获取数据。在这过程，回表需要一行一行的扫描主键索引树。</p>
<p>假设我们执行一条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">join</span> t4 <span class="keyword">on</span> t3.a = t4.a <span class="keyword">where</span> t3.a &gt; <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>由于 a 索引树是按 a 排序的，按照 a 的排序去回表，很可能对应主键索引树上的记录是无序的。比如 a 索引树上按顺序是a=1，a=2，a=3….而对应的主键索引树上，是id=1(a=2)，id=2(a=8)，id=3(a=1)….也就是说，可能会出现随机访问，性能较差。</p>
<p>针对这个问题，使用MRR（Multi-Range Read）这个过程优化为顺序读：</p>
<ol>
<li>先查找 a 索引树，找到相关记录</li>
<li>在一块 read_rnd_buffer  内存中对 a 索引树的记录按 id 自增排序</li>
<li>回表，返回并且拼接复合条件的记录</li>
</ol>
<p>在这里，read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</p>
<p>MRR 能够提升性能的核心在于，这条<strong>查询语句在索引 a 上做的是一个范围查询</strong>，可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序读”的优势。</p>
<h3><span id="3bka算法">3.BKA算法</span></h3><p>基于上面 MRR 优化的思想，MySQL 在 5.6 版本后开始引入的 批量索引访问（Batched Key Access）算法，针对关联条件有索引情况下的索引嵌套循环算法 NLJ 进行了优化。由于 NLJ 并没有像无索引条件下的块嵌套循环 BNL 算法那样，使用到 join_buffer，因此刚好将次内存区作为 MRR 优化的 read_rnd_buffer 。</p>
<p>如果要使用 BKA 优化算法的话，你需要在执行 SQL 语句之前，先设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>其中，前两个参数的作用是要启用 MRR。这么做的原因是，BKA 算法的优化要依赖于 MRR。</p>
<h2><span id="三-关联条件无索引">三、关联条件无索引</span></h2><h3><span id="1bnl算法">1.BNL算法</span></h3><p>在无索引的情况下，如果仍然使用索引循环嵌套的算法，那么每次关联 t2 的时候都需要对 t2 进行一次全表扫描，也就是说，如果执行联查的 sql，就需要查询 t2 100000次。这个算法叫做SNL（Simple Nested-Loop Join）</p>
<p>实际上，SNL 太过笨重了，Mysql 选择的是<strong>BNL</strong>（Block Nested-Loop Join）算法：</p>
<ol>
<li>将 t1 读入线程内存 join buffer 中，<strong>如果放不下就分块进行</strong>；</li>
<li>全表扫描 t2 ，每扫描一行就和 t1的每一行进行比较；</li>
<li>把复合条件的数据返回结果集；</li>
</ol>
<p>这个做法和 SNL 需要扫描的次数一样，但是由于判断在内存进行，所以速度会快很多。</p>
<p>当 join_buffer_size 规定的 join buffer 大小能够装下 t1 时：</p>
<blockquote>
<p>假设小表的行数是 N，大表的行数是 M，那么在这个算法里：</p>
<ol>
<li>两个表都做一次全表扫描，所以总的扫描行数是 M+N；</li>
<li>内存中的判断次数是 M*N。</li>
</ol>
</blockquote>
<p>可以看到，调换这两个算式中的 M 和 N 没差别，因此<strong>这时候选择大表还是小表做驱动表，执行耗时是一样的</strong>。</p>
<p><strong>但是，如果 join buffer 放不下 t1，这个过程就需要分块进行</strong>：</p>
<ol>
<li>假如只放得下88行，那么就先将 t1 的前88行读入内存；</li>
<li>扫描 t2，每一行都比较88次，然后符合条件的放入结果集</li>
<li>清空 join buffer</li>
<li>重复以上步骤，处理完剩下的12行数据</li>
</ol>
<p>这种情况下，驱动表的选择是这么考虑的：</p>
<blockquote>
<p>假设，驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。</p>
<p>注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。</p>
<p>所以，在这个算法的执行过程中：</p>
<ol>
<li>扫描行数是 <code>N + λ * N * M</code>；</li>
<li>内存判断 N*M 次。</li>
<li>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在 M 和 N 大小确定的情况下，N 小一些，整个算式的结果会更小。</li>
</ol>
</blockquote>
<p>所以结论是，<strong>还是应该让小表当驱动表</strong>。</p>
<p>当然，你会发现，在 N+λ<em>N</em>M 这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好，而决定了需要分几块的关键参数就在于 join buffer 的大小，join buffer 越大，一次性放入的数据就越多，需要分的块 K ——也就是 λ*N ——就越小。</p>
<p>所以，如果连表查询速度很慢，可以试着吧 join_buffer_size 调大。</p>
<h3><span id="2bnl算法存在的问题">2.BNL算法存在的问题</span></h3><p>由于 InnoDB 对 Bufffer Pool 的 LRU 算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在 old 区域。如果 1 秒之后这个数据页不再被访问了，就不会被移动到 LRU 链表头部，这样对 Buffer Pool 的命中率影响就不大。</p>
<p>但是，如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到 LRU 链表头部。</p>
<p>这种情况对应的，是冷表的数据量小于整个 Buffer Pool 的 3/8，能够完全放入 old 区域的情况。</p>
<p>如果这个冷表很大，就会出现另外一种情况：<strong>业务正常访问的数据页，没有机会进入 young 区域</strong>。</p>
<p>由于优化机制的存在，一个正常访问的数据页，要进入 young 区域，需要隔 1 秒后再次被访问到。但是，由于我们的 join 语句在循环读磁盘和淘汰内存页，进入 old 区域的数据页，很可能在 1 秒之内就被淘汰了。这样，就会导致这个 MySQL 实例的 Buffer Pool 在这段时间内，young 区域的数据页没有被合理地淘汰。</p>
<p>也就是说，这两种情况都会影响 Buffer Pool 的正常运作。</p>
<p><strong>大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</strong></p>
<p>为了减少这种影响，你可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数。</p>
<p>也就是说，BNL 算法对系统的影响主要包括三个方面：</p>
<ol>
<li>可能会多次扫描被驱动表，占用磁盘 IO 资源；</li>
<li>判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；</li>
<li>可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。</li>
</ol>
<h3><span id="3bnl算法的优化">3.BNL算法的优化</span></h3><p>假如我们要执行这样一条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.b&gt;=<span class="number">1</span> <span class="keyword">and</span> t2.b&lt;=<span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<p>其中，表 t1 有1000条数据，表 t2 中有100万条数据，但是经过 where 条件过滤后，需要参与 join 的只有 2000 行数据。</p>
<p>在 BNL 算法的逻辑下：</p>
<ol>
<li>把 t1 存入 join_buffer</li>
<li>扫描 t2，每一条都去跟 t1 的数据对比，先判断 t1.b=t2.b ，再判断 t2.b&gt;=1和 t2.b&lt;=2000</li>
<li>返回满足条件的结果集</li>
</ol>
<p>按这个做法，每一条数据都必须要跟 join_buffer 里的每一条数据进行比对，也就是 1000*100 万 =10 亿次，显然很不明智。</p>
<p><strong>加索引</strong></p>
<p>要优化这个情况，<strong>最直接的方法仍然是查询条件加上索引，将默认的 BNL 算法转为 NLJ 算法</strong>。</p>
<p><strong>临时表</strong></p>
<p>当然，并不是所有情况下都时候给字段加上索引的，为此我们可以将整个查询过程分开来，<strong>使用临时表的策略</strong>：先将一部分数据筛选出来，出入临时表，然后在临时表上建立索引，最后再用临时表代替 t2 去跟 t1 联查。也就是这样的形式：</p>
<ol>
<li>创建一张临时表，为关联字段加上索引</li>
<li>先从 t2 查出数据，然后插入临时表</li>
<li>让临时表代替 t2 去跟 t1 联查。</li>
</ol>
<p>对应的 sql 就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(b))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> b&gt;=<span class="number">1</span> <span class="keyword">and</span> b&lt;=<span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure>

<p><strong>Hash join</strong></p>
<p>当然，仔细想想，临时表中虽然数据少了很多，但是仍然摆脱不了对数据集的遍历，为此，最好的做法就是使用 hash join，1000*2000次查找换成1000次哈希查找。由于 mysql 并不支持 hash join，所以我们需要自己使用业务代码来实现：</p>
<ol>
<li>先查出 t2 的数据，存入 HashMap 这样的结构</li>
<li>查出 t1 的数据，根据需要从数据结构中去获取值</li>
</ol>
<h2><span id="四-总结">四、总结</span></h2><p>在默认情况下，最好做到以下两点：</p>
<ol>
<li>尽量为被驱动表的连接条件加上索引；</li>
<li>使用小表作为驱动表（即查询行数少的，查询字段少的表）。</li>
</ol>
<p>在以上情况下，可以继续扩展的做法：</p>
<ol>
<li>已经为关联字段建索引的情况：开启 MRR 支持，将 NJL 算法优化为 BKA 算法</li>
<li>还没有为关联字段建索引的情况：<ul>
<li>加索引，将 BNL 算法优化为 NJL 算法；</li>
<li>使用临时表；</li>
<li>在业务代码中实现 hash join。</li>
</ul>
</li>
</ol>
<p>其中，对应没有给关键字建索引的情况，要注意根据情况调整 join_buffer_size 以减少对表的减少扫描次数：</p>
<ol>
<li>一方面，可以提高查找效率；</li>
<li>另一方面，减少对了 Buffer Pool 的影响，尽可能避免影响内存命中率。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(十二)：order by</title>
    <url>/2020/11/15/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%8D%81%E4%BA%8C)%EF%BC%9Aorder%20by/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的16节order by相关内容的笔记</p>
</blockquote>
<h2><span id="一-order-by-的执行流程">一、order by 的执行流程</span></h2><h3><span id="1全字段排序">1.全字段排序</span></h3><p>假如此时有这么一张表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>现在要按姓名排序查询杭州1000个人的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>这条 sql 的执行流程如下：</p>
<ol>
<li>在内存中初始化 sort_buffer，放入 city，name，age 三个字段</li>
<li>从 city 索引树找到 city = ‘杭州’ 叶子节点存放的主键 id</li>
<li>回表根据主键 id 找到数据，取出全部字段放入 sort_buffer</li>
<li>重复上述过程，直到全部符合条件的数据都放入内存</li>
<li>在 sort_buffer 对数据按 name 进行排序</li>
<li>按照排序结果取前 1000 行返回</li>
</ol>
<p>因为先查了全部需要字段才排序，我们把这个叫做<strong>全字段排序</strong>。</p>
<p>不难看出，跟 join 有点像，排序也专门在内存里开辟了一块空间 sort_buffer。其中，<code>sort_buffer_size</code>参数的大小决定了 sort_buffer 的大小，<strong>如果 sort_buffer 放不下全部的字段，就必须在磁盘中创建临时文件辅助排序</strong>，这个排序使用的是归并排序，即先让分片变得有序，最后再总体进行排序。<strong>sort_buffer 越小，就会让临时文件越多</strong>。</p>
<h3><span id="2rowid-排序">2.rowid 排序</span></h3><p>全字段排序的问题在于，如果需要查询返回的数据行数过多，那么就会导致少量的行数也会占满 sort_buffer 。</p>
<p>为此我们可以调整 <code>max_length_for_sort_data</code> 参数，即当单行的长度超过这个值，就会只在 sort_buffer  中放入主键 id 和需要排序的字段，其他的字段等到排完序再回表查询。</p>
<p>这个算法的执行流程如下：</p>
<ol>
<li>在内存中初始化 sort_buffer，只放入 id，name 两个字段</li>
<li>从 city 索引树找到 city = ‘杭州’ 叶子节点存放的主键 id</li>
<li>回表根据主键 id 找到数据，<strong>只取出 id 和 name 字段放入 sort_buffer</strong></li>
<li>重复上述过程，直到全部符合条件的数据都放入内存</li>
<li>在 sort_buffer 对数据按 name 进行排序</li>
<li>遍历排序结果，取前 1000 行，<strong>并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回</strong>。</li>
</ol>
<p>因为排序的时候只拿需要排序的字段，我们可以把这个叫做 rowid 排序</p>
<h2><span id="二-优化">二、优化</span></h2><p>我们可以看到，rowid 排序只担心单行长度过大导致 sort_buffer 一次只能放入少量数据的时候使用，因为 rowid 排序完以后还需要回表进行一次查询，会造成磁盘读，因此不会是一个优先的选择。</p>
<p>这也是 mysql 优化查询过程中的原则，即<strong>能在内存里处理就尽量在内存里处理，避免回表</strong>。</p>
<p>排序是一个消耗颇大的操作，但是我们可以<strong>借助索引结构的有序性避免一些额外的排序过程</strong>。同样是上面的例子，我们建一个（city，name）联合索引，那么就可以保证在遍历过程中，只要 city=‘杭州’，那么 name 就一定是有序的。</p>
<p>这样一来，查询流程就是：</p>
<ul>
<li>从联合索引找到第一条city=’杭州’的数据对应的主键</li>
<li>回表找到city，name，age三个数据加入数据集</li>
<li>重复上述过程直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束</li>
</ul>
<p>可以看到，由于索引已经确保的数据的有序性，索引就不需要加入内存中的临时表进行排序的过程了。</p>
<p>如果只查询 city 和 name，或者为联合索引再加上 age 字段，就能实现<strong>索引覆盖，甚至不需要回表</strong>。不过考虑到维护索引的代价，这个就需要根据业务取舍了。</p>
<h2><span id="三-总结">三、总结</span></h2><p>mysql 的 order by 分全字段排序和 rowid 排序。</p>
<p>全字段排序需要先查出数据放入 sort_buffer ，然后在内存中排序后返回。如果数据超过了<code>sort_buffer_size</code>参数，就会在磁盘生成临时文件，辅助进行归并排序。</p>
<p>如果单行长度超过<code>max_length_for_sort_data</code> 参数，就会转为 rowid 排序。即只取 id 和排序字段放入内存，排序完后回表取出对应的数据。</p>
<p>通过索引结构天然有序，可以借助合适的索引避免额外的排序过程。如果实现了索引覆盖还可以避免回表。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(七)：全局锁，表锁，行锁，间隙锁</title>
    <url>/2020/11/03/mysql/Mysql%E5%88%9D%E6%8E%A2(%E4%B8%83)%EF%BC%9A%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81%EF%BC%8C%E8%A1%8C%E9%94%81%EF%BC%8C%E9%97%B4%E9%9A%99%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 6、7、20 节锁相关部分的总结</p>
</blockquote>
<h2><span id="一-全局锁">一、全局锁</span></h2><h3><span id="1概述">1.概述</span></h3><p>全局锁就是对整个数据库实例加锁。通过使用 <code>Flush tables with read lock</code>（FTWRL）语句加锁，此后整个库都会处于只读状态，这时，其他线程的数据定义语句（DDL），数据操作语句（DML）以及更新类事务的提交语句都会被阻塞。</p>
<p>也就是说，<strong>加了全局锁以后，其他线程不能对数据增删改，也不能对表增删改</strong>。</p>
<p>另外值得一提的是，在此之前，数据库会<strong>等待 FTWRL 操作前的所有读写操作完成，事务提交完毕；并且把脏页的数据从缓存刷入磁盘，保证数据的一致性</strong>。</p>
<p>全局锁的典型使用场景是对数据库进行整库备份。</p>
<h3><span id="2全局锁的缺陷和解决方案">2.全局锁的缺陷和解决方案</span></h3><p>全局锁有以下问题：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li>
</ul>
<p>但是，<strong>如果不加锁，备份时如果有表的数据发生了变更，那么备份后的数据库就不能保证整个库的表都是在同一个逻辑时间点</strong>，可能会导致使用备份恢复数据库的时候，发生类似“我扣款了但是我下的单没了”，或者“我下单了但是没扣款”这样的问题。</p>
<p>根据前文提到的数据库事务相关知识，我们知道，要保证一个事务进行中，其他事务的提交不影响会到这个事务，也就是要求事务执行前后的数据要一致，就需要<strong>开启可重复读的隔离级别</strong>。根据这个原理，官方自带的逻辑备份工具 mysqldump 当使用参数 <code>–single-transaction</code> 的时候，<strong>导出数据之前就会启动一个事务，来确保拿到一致性视图</strong>。而且由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>
<p>single-transaction 虽好，但是对于像 MyISAM 这样不支持事务的引擎而言就享受不到这样的便利，所以还是需要 FTWRL 语句。这也是为什么推荐使用 innodb 引擎的原因之一。</p>
<h3><span id="3-为何不能使用readonly替代">3. 为何不能使用readonly替代</span></h3><p>全局锁的效果表现为全库变为只读，但是同样的效果，<code>set global readonly=true</code> 却不是一个合适的替代方案：</p>
<ol>
<li><strong>global 不宜改动</strong>：在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大。</li>
<li><strong>在异常处理机制上有差异</strong>：<strong>如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁</strong>，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会<strong>一直保持 readonly 状态</strong>，这样会导致整个库长时间处于不可写状态，风险较高。</li>
<li><strong>无法限制超管操作</strong>：只会禁止普通用户权限的 mysql 写操作，不能限制 super 权限用户的写操作。</li>
</ol>
<h2><span id="二-表级锁">二、表级锁</span></h2><p>表级锁是针对数据库表的锁，分为两种：表锁和元数据锁（MDL）。</p>
<h3><span id="1表锁">1.表锁</span></h3><p>表锁的语法是<code>lock tables … read/write</code>他与全局锁类似，也可以通过<code>unlock tables</code>提前释放锁，也可以在客户端断开连接的时候自动释放锁。 </p>
<p>如语法所说，表锁区分读锁和写锁，与全局锁不同的是，<strong>表锁除了限制别的线程的操作外，也会限制本线程的操作</strong>：</p>
<blockquote>
<p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
</blockquote>
<h3><span id="2元数据锁">2.元数据锁</span></h3><p>元数据锁跟表锁相比，最显著的差别在于<strong>元数据锁不需要显式的调用，在访问表的时候会自动加上</strong>。</p>
<p>元数据锁的作用在于保证读写的正确性。假设在没有加表锁的情况下，一个线程对另一个线程正在查询的表结构做了修改，那么就会导致查询出了结构不正确的数据。为此 mysql 在5.5版本中引入了 MDL：当读的时候加 MDL 读锁，写的时候加 MDL 写锁。</p>
<p>申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到 MDL 锁后，直到事务执行完才会将锁释放。<strong>如果事务中包含 DDL 操作，mysql 会在 DDL 操作语句执行前，隐式提交commit，以保证该DDL语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放</strong>。</p>
<p>换句话说，<strong>元数据锁最主要的目的不是保证 select 与 update 之间的正确进行，而是保证 DDL 语句 和 DML/DQL 语句之间的正确进行</strong>。</p>
<p>其中：</p>
<ol>
<li>读锁与读锁之间不互斥，因此可以同时有多个线程对同一张表进行查询；</li>
<li>读锁之写锁之间是互斥的，并且写锁获取优先级高，这可以避免一次事务的两次查询查到不一样的表结构；</li>
<li>写锁与写锁之间是互斥的，这可以用来保证要更改表结构的操作的安全性；</li>
</ol>
<p>第二点很好理解，但是第一点可能有点难理解，我们举个例子：</p>
<p>假如A和B线程同时修改T表的两行数据，A 线程先分别获取 MDL 读锁和 MDL 写锁，然后 B 线程获取 MDL 读锁，但是 B 线程无法获取MDL写锁，所以 B 线程进入等待，等到 A 线程完成后B线程才获取写锁，继续操作。</p>
<h3><span id="3元数据锁存在的问题">3.元数据锁存在的问题</span></h3><p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。所以可能会出现这样的问题：</p>
<p><img src="http://img.xiajibagao.top/image-20201022131135062.png" alt="image-20201022131135062"></p>
<ol>
<li>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行；</li>
<li>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞；</li>
<li>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了；</li>
<li>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</li>
</ol>
<p>针对以上的情况，我们有以下的改善方式：</p>
<ol>
<li>假如不是热点表：如果要修改的表有长事务要进行，<strong>要么 kill 掉长事务，要么先暂停表结构的修改</strong>；</li>
<li>假如是热点表：<strong>为 alert 语句加上等待时间</strong>，避免长时间的阻塞后面的语句。</li>
</ol>
<h2><span id="三-行锁">三、行锁</span></h2><h3><span id="1概述">1.概述</span></h3><p>顾名思义，行锁的作用是保证对同一行数据的并发修改可以正确进行。</p>
<p>假设我们有这样一条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> a = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> a = <span class="number">3</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>这个过程是这样的：</p>
<ol>
<li>开启了一个事务；</li>
<li>第一条 sql 获得了 id = 1 这一行的行锁，执行完后不释放；</li>
<li>第二条 sql 获得了 id = 2 这一行的行锁，但是执行完也不释放；</li>
<li>提交事务，并且释放所有的行锁。</li>
</ol>
<p>我们可以看到，<strong>行锁是需要的时候就加上，但是更新完后并不会立刻释放，而是等到事务提交后再统一释放。这就是行锁的两阶段锁。</strong></p>
<p>基于两阶段锁的原理，对于一些 sql ，我们可以做一些优化，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> a = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> a = <span class="number">3</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>上面这条 sql 涉及到两个 update 的 sql，一条 select 的 sql。如果可能的话，我们可以把 select 的操作放到最前面，这样就能减少两条 update 的 sql 获取行锁的时间。</p>
<h3><span id="2死锁与死锁处理策略">2.死锁与死锁处理策略</span></h3><p>在学多线程的时候不难理解死锁的概念，两个线程互相持有对方所需要的锁就会导致死锁。我们拿数据库中的死锁举例：</p>
<p><img src="http://img.xiajibagao.top/image-20201022134524700.png" alt="image-20201022134524700"></p>
<p>这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。</p>
<p>当出现死锁以后，有两种策略：</p>
<ol>
<li><p><strong>直接进入等待，直到超时</strong>。</p>
<p>这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。</p>
</li>
<li><p>发<strong>起死锁检测，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行</strong>。</p>
<p>将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p>
</li>
</ol>
<p>设置超时时间看上去是个好选择，但是实际上这个时间很难把握。innodb 的默认超时时间是50s，这个时间几乎是不可能接受的。但是如果将时间设置果断，可能又会导致正常的等待锁释放的过程受到影响。</p>
<p>因此，还是需要采用第二种策略，死锁检测。<strong>这个也是 innodb 默认开启的。死锁检测的问题在于检测过程也是一个非常消耗性能的过程</strong>。当多个事务同时更新一条数据的时候，每个线程都要把所有争夺这把锁的线程检测一遍。这也是有时候 cpu 利用率极高，但是每秒仍然执行不了几个事务。</p>
<h3><span id="3死锁检测的优化">3.死锁检测的优化</span></h3><p>说明的是，并非所有的访问都需要加锁，对于读和一般不太可能出现死锁的情况是不会进行检测的，比如：</p>
<blockquote>
<p>B在等A，D在等C，现在来了一个E，发现E需要等D，那么E才判断跟D、C是否会形成死锁，这个检测不用管B和A</p>
</blockquote>
<p>死锁检测的处理过程是很难优化的，我们只能想办法避免这个过程。为此，我们有以下几种方式来优化死锁检测：</p>
<ul>
<li><strong>关掉不必要是死锁检测</strong>。如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的；</li>
<li><strong>在客户端做控制并发度</strong>。即控制客户端的并发线程。但是这个方法并不可靠，因为客户端的数量并不可控，即使每个客户端只允许存在三个并发线程，一旦客户端达到1000个，最后还是会可能达到3000个的并发线程；</li>
<li><strong>在服务端做并发控制</strong>。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。但是这个方案有很高的技术要求。</li>
<li><strong>分散锁冲突</strong>。即在逻辑上把一行数据改成多行数据，比如对一个总金额字段改为多个金额字段的和。这样在操作的时候锁冲突就会由一个锁分散到多个锁。但是这个方案需要修改业务逻辑，也涉及到一些其他代码的改动。</li>
</ul>
<h3><span id="4行锁的锁定范围">4.行锁的锁定范围</span></h3><p>虽然叫行锁，但是<strong>锁并不是只锁一条数据，有些时候行锁会锁住多条数据，在一些没指明主键的情况，行锁会直接转为表锁</strong>。</p>
<p>我们举个例子: </p>
<p>假设有个表单 products ，里面有 id 跟 name 二个字段。</p>
<ol>
<li><p>明确指定主键，并且有能查到，加行锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">&#x27;3&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">&#x27;3&#x27;</span> <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>明确指定主键，不能查到，不加锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">&#x27;-1&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不指明主键，加表锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;Mouse&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键不明确，加表锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="string">&#x27;3&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">&#x27;3&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>实际上，不难看出，如果没有使用索引，行锁很容易就会上升到表锁。</p>
<h2><span id="四-间隙锁">四、间隙锁</span></h2><h3><span id="1行锁的局限性">1.行锁的局限性</span></h3><p>假设有表 t，t 有 id 和 d 两个字段。现有数据（0，5）和（2，1）。</p>
<p>我们开启一个事务，加上写锁，进行了三次查询，这样每次都是“当前读”;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">where</span> d = <span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d = <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d = <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q2</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d = <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q3</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>其中，在 Q1 和 Q2 的间隙有一个事务进行了更新：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d = <span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>; <span class="comment"># Q4</span></span><br></pre></td></tr></table></figure>

<p>在 Q2 和 Q3 的间隙进行了一次插入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">5</span>); <span class="comment"># Q5</span></span><br></pre></td></tr></table></figure>

<p>现在 sql 的执行顺序是：Q1 -&gt; Q4 -&gt; Q2 -&gt; Q5 -&gt; Q3</p>
<p>在这种情况下，三条查询的 sql 分别查询出了一条、两条、三条数据：</p>
<ul>
<li>Q1：查到了（10，5）</li>
<li>Q2：查到了（0，5），（2，5）</li>
<li>Q3：查到了（0，5），（2，5），（3，5）</li>
</ul>
<p>其中，<strong>Q3 查到了一条原本不存在的数据，也就是幻读</strong>。</p>
<p>我们可以看到，虽然在事务一开始的时候就已经拿到了（0，5）的行锁，但是由于没有锁住其他的行，导致最后在 binlog 里出现了严重的数<strong>据不一致问题</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d = <span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">where</span> d = <span class="number">5</span> <span class="comment"># 最后事务提交的时候行锁才释放</span></span><br></pre></td></tr></table></figure>

<p>也就是说，当从库同步的时候，或者通过 binlog 备份的时候，<strong>原本在数据中的数据，应该只有（0，5）这行的 id 被改成了5，但是最后备份的时候（2，5）和（3，5）的 id 也要被改成了5</strong>，先不说是否能成功，这种情况显然是不允许出现的。</p>
<p>由于没锁住其他的行，导致了 binlog 上因为顺序导致的数据不一致问题，那么如果把所有扫描到的行都加上锁，那么 Q1 和 Q2 之间的更新就会被放到 Q3 执行事务提交完后，反应到 binlog：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">where</span> d = <span class="number">5</span> <span class="comment"># 最后事务提交的时候行锁才释放</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d = <span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>; <span class="comment"># 拿到写锁后才能更新</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，及时这样，insert 语句还是会引起 binlog 上的数据不一致，最根本的原因在于，<strong>加锁的时候（3，5）这行还不存在，所以锁加不到这行数据上</strong>。这就是幻读引起的问题。</p>
<p>因此，需要一种新的锁，来锁住行与行的间隙，来防止意外的插入，这就是间隙锁。</p>
<h3><span id="2间隙锁">2.间隙锁</span></h3><p>行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”，所以可能会出现幻读的情况。因此，为了解决这个问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p>
<p>顾名思义，<strong>间隙锁（next-key lock），锁的就是两个值之间的空隙</strong>。</p>
<p>在最开始，表 t 一共有两条（0，5），（2，5）数据，那么就有三个<strong>前开后闭的区间/间隙</strong>（-∞，0 ]，（0，2 ]，（2，+  supremum )。其中，supremum 是 innodb 允许的索引最大值，这是一个概念上的数，可以认为是正无穷。</p>
<p>当我们执行第 <code>select * from t whrere d = 5 for update</code>的时候，除了为扫描到的两条数据加上行锁外，还会为这三个区间加上间隙锁。</p>
<h3><span id="3间隙锁引起死锁问题">3.间隙锁引起死锁问题</span></h3><p>间隙锁跟间隙锁之间是不冲突的，有冲突的是往间隙插入值的行为。也就是说，同样的一个间隙，两条 sql 分别加上了间隙锁，这样就很可能引起死锁。</p>
<p>举个例子：</p>
<p>在一开始的时候，表有（0，5）和（2，1）这两条数据，sessionA 执行了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q1</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># Q2</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>sessionB 在 sessionA 开始事务后也开启了事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q3</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># Q4</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>现在，语句的执行顺序的：Q1 -&gt; Q3 -&gt; Q4 -&gt; Q2。</p>
<p>在这种情况下，不等到 Q4 执行，就已经形成死锁了：</p>
<ol>
<li>session A 执行 Q1 语句，由于 id=1 这一行并不存在，因此会加上间隙锁 (0,2);</li>
<li>session B 执行 Q3 语句，同样会加上间隙锁 (5,12)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li>
<li>session B 试图插入 Q4，被 session A 的间隙锁挡住了，只好进入等待；</li>
<li>session A 试图插入一行  Q2，被 session B 的间隙锁挡住了。</li>
</ol>
<p>至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。</p>
<p>间隙锁在解决了一些问题的情况下，又引入了一些新的问题，所以我们也有其他的选择，并非一定需要引入间隙锁：</p>
<blockquote>
<p>隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。这也是现在不少公司使用的配置组合。</p>
</blockquote>
<p>读提交每次每次 sql 执行的时候都是当前读，所以影响数据的一致性；而 binlog 设置为 row 以后记录的就是每一条数据的变化，因而备份的时候不会导致数据不一致。</p>
<h2><span id="五-总结">五、总结</span></h2><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类，其中针对行锁难以解决的幻读问题，又添加了间隙锁。</p>
<p><strong>全局锁</strong>：</p>
<ol>
<li>通过 <code>Flush tables with read lock</code>（FTWRL）语句加锁，可以主动释放或者在客户端断开连接时释放；</li>
<li>会限制其他线程的 DDL 和 DML 操作，但不会限制自己的；</li>
<li>一般用于 MyISAM 之类不支持事务的引擎进行整库备份。若 innodb 的话，可以开启事务为可重复读，接着 MVCC 实现无全局锁备份。</li>
</ol>
<p><strong>表级锁</strong>：</p>
<ol>
<li>分为表锁和元数据锁，两者都区分读锁和写锁；</li>
<li>表锁：<ul>
<li>表锁和全局锁一样，可以主动释放或者在客户端断开连接时释放；</li>
<li>表锁是显式使用的，不但限制其他线程对表的操作，也会限制本线程对表的操作；</li>
</ul>
</li>
<li>元数据锁：<ul>
<li>是一种典型的读写锁，每一条 DDL 都会自动加上元数据锁；</li>
<li>作用是确保 DDL 和 DML/DQL 语句的正确执行；</li>
<li>元数据锁可能会因为无法获取锁而引起阻塞，最好的办法是避免长事务和 DDL 的同时存在，对于热点数据由于可能存在频繁的事务开启，所以最好为 DDL 语句添加超时时间，再无法修改表结构的情况下避免阻塞。</li>
</ul>
</li>
</ol>
<p><strong>行级锁</strong>：</p>
<ol>
<li><p>存在两阶段锁的机制：即需要就先获取锁，而使用后不释放锁，直到事务结束再统一释放锁。</p>
<p>因此，优化思路是在执行 sql 的时候把需要获取行锁的语句放在后面，避免过长时间的占用锁；</p>
</li>
<li><p>可能会存在死锁问题，处理策略有两种：</p>
<ul>
<li>调整超时时间。innodb_lock_wait_timeout 默认为50s。但是调长容易引起阻塞，调短可能影响正常的锁等待；</li>
<li>死锁检测。每次获取锁都检测是否有死锁，有就回滚其中一个事务。innodb_deadlock_detect 是默认开启的，但是容易死锁检测在并发线程多的情况下非常消耗性能。</li>
</ul>
</li>
<li><p>死锁检测的优化思路有四种：</p>
<ul>
<li>关掉不必要是死锁检测。可能引起大量超时，导致操作丢失；</li>
<li>在客户端做控制并发度。限制客户端线程并发数，但是无法限制客户端数量，所以不是很有效；</li>
<li>在服务端做并发控制。使用中间件或者修改 mysql 源码，让争夺锁的线程进入等待队列；</li>
<li>分散锁冲突。将一个字段在逻辑上分为多个字段，避免多个线程争夺同一把锁。</li>
</ul>
</li>
<li><p>锁同时存在的情况下，并不是只要满足粒度最小的锁不互斥就可以了，而是必须满足全部全部不互斥才行。</p>
</li>
</ol>
<p><strong>间隙锁</strong>：</p>
<ol>
<li>锁索引之间的间隙，是前开后闭的区间；</li>
<li>间隙锁之间不冲突，但是插入间隙的行为是冲突的，所以当两个事务同时为一个间隙加锁容易引起死锁；</li>
<li>能解决幻读，但不是必须的。读已提交 + 把 binlog 格式设置为 row 也可以防止幻读。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql初探(四)：索引</title>
    <url>/2020/10/29/mysql/Mysql%E5%88%9D%E6%8E%A2(%E5%9B%9B)%EF%BC%9A%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 4、5、9、10、11、15、18节索引相关部分的总结</p>
</blockquote>
<h2><span id="一-innodb索引模型">一、Innodb索引模型</span></h2><h3><span id="1主键非主键索引的区别">1.主键/非主键索引的区别</span></h3><p>每个索引在Innodb中都是一颗B+树，其中根据索引叶子节点的不同，分为主键索引和非主键索引。</p>
<p><img src="http://img.xiajibagao.top/image-20200930164149290.png" alt="image-20200930164149290"></p>
<p>我们可以看到：</p>
<ul>
<li>主键索引将索引和整行的数据都放在了一起，所以又叫<strong>聚簇索引</strong></li>
<li>非主键索引的叶子节点内容是主键的值。所以又叫<strong>二级索引</strong></li>
</ul>
<p>其中，如果非主键索引查询字段没有做到覆盖索引，就需要先从非主键索引树中找到对应的主键，然后再回到主键索引树找到对应的行数据，这个过程叫做<strong>回表</strong>。</p>
<p>而相应的，直接把全部的主键索引过一遍，然后每拿到一个主键索引，就把相应的数据拿出来，这个过程叫做<strong>全表扫描</strong>。</p>
<h3><span id="2索引维护">2.索引维护</span></h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p>
<p>以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<strong>页分裂</strong>。在这种情况下，性能自然会受影响。（同理，相邻的两个页如果删除了数据，也会执行一个合并的过程）</p>
<h3><span id="3根据主键和非主键索引排序">3.根据主键和非主键索引排序</span></h3><p>假设t有字段a，b，c，d，设定（a，b）为主键索引，c，（c，b）为非主键索引，当查询的时候情况如下：</p>
<ul>
<li>使用（a，b），则默认排序为先按a排序，再按b排序</li>
<li>使用c，则实际为（c，a，b），先按c排序，再按a排序，接着按b排序</li>
<li>使用（c，b），这实际为（c，b，a），先按c排序，再按b排序，接着按a排序</li>
</ul>
<p>我们可以认为，<strong>排序的时候innodb会默认去重并且在排序条件上加上主键</strong></p>
<h2><span id="二-为什么要使用自增主键">二 .为什么要使用自增主键</span></h2><h3><span id="1索引有序">1.索引有序</span></h3><p>当我们使用自增主键的时候，插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。这样的主键是默认有序的，不涉及到挪动其他记录，也不会触发叶子节点的分裂</p>
<h3><span id="2节约空间">2.节约空间</span></h3><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p>
<p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。一页加载出来的数据就越多</strong></p>
<h3><span id="3非自增主键的情况">3.非自增主键的情况</span></h3><p>一些项目会使用雪花算法获取 id，主键是递增的，就并不会影响索引的有序性。</p>
<h2><span id="三-覆盖索引与最左前缀">三、覆盖索引与最左前缀</span></h2><h3><span id="1索引覆盖">1.索引覆盖</span></h3><p>假如我们建立了一个覆盖字段id和B的联合索引，如果执行的语句是 select id，B from T where id between 3 and 5，由于要查询的字段id和B都已经在B索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引已经“覆盖了”我们的查询需求，我们称为<strong>覆盖索引</strong>。</p>
<h3><span id="2最左前缀">2.最左前缀</span></h3><p>由于Innodb的索引结构是B+树，所以索引可以通过最左前缀原则让联合索引的“一部分”也能起作用。</p>
<p>我们以（name，age）联合索引举例：</p>
<p><img src="http://img.xiajibagao.top/image-20200930171920117.png" alt="image-20200930171920117"></p>
<p>当搜索条件是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>都能通过索引快速定位到第一个符合条件的记录，然后向后遍历获取数据。</p>
<p>可见，这个<strong>最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong>。</p>
<p>如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
<p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。</p>
<h3><span id="3索引下推">3.索引下推</span></h3><p>根据上一个例子，我们有sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">where</span> age = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比age字段值。</p>
<p>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， 可以在索引遍历过程中，先<strong>对索引中包含的字段先做判断，直接过滤掉不满足条件的记录</strong>，减少回表次数。</p>
<p>InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
<p><strong>简单的说，如果你的判断字段被联合索引覆盖了，但是又不符合最左前缀，那样数据库引擎会自动在非主键索引树阶段就做完判断，避免不必要的回表。</strong></p>
<h2><span id="四-前缀索引">四、前缀索引</span></h2><h3><span id="1前缀索引的优劣">1.前缀索引的优劣</span></h3><p>很多情况下，我们需要根据一个长字符串类型的字段去查找记录，比如身份证，邮箱，为了避免全表扫描，就需要为字符串字段添加索引。</p>
<p>由于Mysql支持前缀索引，所以我们可以选择<strong>将整个字段添加索引，或者只将前一部分的字符串加上索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#整个字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">index</span> index1(email);</span><br><span class="line"><span class="comment">#一部分字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">index</span> index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>假设我们执行一条查询sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>对于完整索引：</p>
<ol>
<li>从 index1 索引树找到满足索引值是’<a href="mailto:&#122;&#x68;&#x61;&#110;&#103;&#x73;&#115;&#120;&#x79;&#x7a;&#64;&#x78;&#x78;&#120;&#46;&#x63;&#x6f;&#x6d;">&#122;&#x68;&#x61;&#110;&#103;&#x73;&#115;&#120;&#x79;&#x7a;&#64;&#x78;&#x78;&#120;&#46;&#x63;&#x6f;&#x6d;</a>’的这条记录，取得 ID2 的值；</li>
<li>到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</li>
<li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email=’zhangssxyz@xxx.com’的条件了，循环结束。</li>
</ol>
<p>而对于前缀索引：</p>
<ol>
<li>从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；</li>
<li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是’<a href="mailto:&#x7a;&#x68;&#97;&#110;&#103;&#x73;&#x73;&#120;&#121;&#122;&#x40;&#x78;&#x78;&#120;&#46;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#110;&#103;&#x73;&#x73;&#120;&#121;&#122;&#x40;&#x78;&#x78;&#120;&#46;&#99;&#111;&#109;</a>’，这行记录丢弃；</li>
<li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在 index2 上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>根据这个流程，我们不难发现前缀索引有以下问题：</p>
<ul>
<li><strong>索引覆盖失效</strong>：由于前缀索引在命中以后，必须再回主键索引树确定一次，所以索引覆盖对前缀索引来说是无效的。</li>
<li><strong>回表次数多</strong>：使用前缀索引后，可能会导致查询语句读数据的次数变多。</li>
</ul>
<h3><span id="2如何选择合适的长度">2.如何选择合适的长度</span></h3><p>前缀索引需要有足够的区分度才能提高查找效率。比如有ABCC，ABDD，ABEE三条数据，选前两个个字符作为索引等于没加索引，选前三个字符作为索引就很合适。当然，实际情况肯定会更复杂，我们就需要更具体的分析。</p>
<ul>
<li><p>首先，算出这个列上有多少个不同的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> T;</span><br></pre></td></tr></table></figure>
</li>
<li><p>依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)）<span class="keyword">as</span> L4,</span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)）<span class="keyword">as</span> L5,</span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)）<span class="keyword">as</span> L6,</span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)）<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> T;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用前缀索引必然会损失一部分区分度，所以我们需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，然后选择最短的长度。</p>
</li>
</ul>
<h3><span id="3其他优化方式">3.其他优化方式</span></h3><p>对于邮箱，前缀索引效果还比较明显，因为@之前的字符串一般不会有太多的相似度，但是对于比如像身份证这样，同一个县市里的市民只有后几位才会有较大区别的长字符串，可能就需要设置一个非常长的前缀索引了，这显然不是我们乐意见到的。</p>
<ul>
<li><p><strong>倒序存储</strong></p>
<p>我们可以借助<code>reverse()</code>函数实现倒序存储。比如身份证存入的时候我们可以倒序存储，查找的时候也先反转在查找。这样加索引以后只需要选择前几位辨识度高的即可。</p>
</li>
<li><p><strong>Hash字段</strong></p>
<p>我们借助<code>crc32/64()</code>函数去获取长字符串的校验码，在表上另外开一个字段用于存储对应的校验码，以长度较短的校验码作为索引。不过由于<code>crc32</code>仍然会出现值重复的情况，所以查询的时候还需要判断拿到的记录是否与条件字段完全一致。</p>
</li>
</ul>
<p>他们的异同如下：</p>
<ul>
<li><strong>都不支持范围查找</strong></li>
<li><strong>占用空间</strong>：倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>
<li><strong>额外消耗</strong>：序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 <code>crc32()</code> 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>
<li><strong>查询效率</strong>：使用 hash 字段方式的查询性能相对更稳定一些。因为 <code>crc32()</code> 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ul>
<p>当然，还有一种折中的方法，就是<strong>拆分字段</strong>：</p>
<p>对于像邮箱这样的字段，有时候@后面的字段往往都是固定的几种，可以单独拆分出来作为一个字段，@前的作为单独的字段直接加全字段索引，这样减少的字段长度，并且保证也了范围查找的性能。</p>
<h3><span id="4小结">4.小结</span></h3><p>要给字符串类型字段的加索引，我们有以下几种方式：</p>
<ol>
<li>直接创建完整索引，这样可能比较占用空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ol>
<h2><span id="五-唯一索引和-change-buffer">五、唯一索引和 change buffer</span></h2><h3><span id="1对查找的影响">1.对查找的影响</span></h3><p>对于普通索引，当执行定值查找的时候，会先按索引找到对应的叶子节点，即数据页，然后通过二分法查找到第一条符合条件的数据，然后继续查找直到遇到第一个不符合条件的数据。</p>
<p>而对于唯一索引，当找到第一条符合条件的数据即返回，因为已经能确定是唯一的了。</p>
<p>由于mysql加载数据是根据页来加载的，当已有的页里找不到对应的数据的时候，不会从磁盘单独读取一条数据，而是接着加载下一页然后再在内存里查找，因此，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。由于一个数据页可以放很多的数据，大多数情况下相邻的数据都在同一页，相对于现在强大的cpu性能，节省的那些查找时间可以忽略不计。</p>
<p>也就是说，<strong>对于查找，唯一索引和普通索引差别的不大</strong>。</p>
<h3><span id="2对更新的影响">2.对更新的影响</span></h3><p>首先我们需要了解一个新东西：<strong>change buffer，也就是写缓冲。</strong></p>
<p>change buffer 和 log buffer 一样，也是 buffer pool 的一部分，他会占用 buffer pool 的容量。</p>
<p>我们知道，mysql按页去将磁盘中的数据读取到内存中（一页的大小通常是16k），当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。一般在三种情况下会进行merge：</p>
<ul>
<li>这个数据页被访问</li>
<li>在数据库正常关闭的过程中</li>
<li>后台线程会定时执行</li>
</ul>
<p>而唯一索引在插入或者更新时必须先获取对应记录以保证唯一性，也就是说<strong>当更新的时候必然要访问数据页，所以唯一索引无法使用 change buffer</strong> 。所以，如果要更新一条数据，而该数据所在页又不在内存中，就要先把数据页读入内存，这一过程随机的磁盘IO，是消耗非常大的操作。</p>
<p>所以，<strong>一般情况下，不推荐使用唯一索引。除非业务需要保证字段的唯一性。</strong></p>
<h3><span id="3写缓冲的使用场景">3.写缓冲的使用场景</span></h3><p>值得一提的是，并不是所有情况下使用 change buffer 都会带来收益，因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多，收益就越大。</p>
<p>因此，<strong>对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好</strong>。这种业务模型常见的就是账单类、日志类的系统。</p>
<p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，<strong>对于这种立刻写立刻读的业务模式来说，change buffer 反而起到了副作用</strong>。这种情况就需要关闭写缓冲。</p>
<h2><span id="六-索引失效的情况">六、索引失效的情况</span></h2><p>一般来说，如果查询很慢，应该优先考虑一下是不是没加索引，或是因为 sql 的写法而导致查询未能走索引。针对以下例子，我们讨论日常可能出现的“索引失效”的情况。</p>
<p>这里我们需要针对“索引失效”的情况做一下区分：</p>
<ul>
<li>全表扫描：即真正意义上的索引失效，指的是不走索引回表而是直接进行全表扫描，把数据一行一行的拿出来对比字段；</li>
<li>索引扫描：指的是通过索树快速定位了<strong>一部分数据</strong>，然后再根据索引树上的主键id会主键索引树把对应的数据拿出来；</li>
<li>全索引扫描：指的是介于两者中间的状态：使用了索引，但是<strong>把全部的索引都走了一遍</strong></li>
</ul>
<p>这里的情况大多数是指全索引扫描。</p>
<h3><span id="1对条件字段的函数操作">1.对条件字段的函数操作</span></h3><p>假如我们执行了这么一条SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计7月的总记录条数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>其中原本 t_modified 是有索引的，但是使用了 month() 函数之后走了全索引扫描，影响了查询速度。</p>
<p><img src="http://img.xiajibagao.top/image-20201030140942153.png" alt="image-20201030140942153"></p>
<p>上图是索引的树结构，我们不难看出，由于索引同层节点间是有序的，如果使用日期去查询的话，可以很快的定位到存在目标数据的下一层对应的父节点，也就是绿色箭头的路线。但是使用了 month() 函数后，由于索引的节点并不直接包含 month() 计算得到的树值，所以是无序的，如上图的二级节点所示，所以只能选择直接从叶子结点把所有的节点都过一遍，也就是说，如果有十万条数据，他就得把十万个索引节点都走一遍。</p>
<p>当然，虽然不能快速定位，但是查询依然通过遍历索引树的方式走了查询，没有直接回表全表查询，也就是说，其实还是走了索引，但是没有用到 B+ 树快速定位的性质，查询是速度还是有所下降的。</p>
<p>总结一下，就是：<strong>由于加了函数操作，MySQL 无法再使用索引快速定位功能，而只能使用全索引扫描。</strong></p>
<p>值得一提的是，虽然不是所有的函数操作都会破坏索引树的有序性，但是优化器仍然会选择不使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全索引扫描</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">10000</span></span><br><span class="line"><span class="comment"># 快速定位</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">10000</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3><span id="2隐式类型转换">2.隐式类型转换</span></h3><p>假如要执行以下的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全索引扫描</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid = <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>其中，由于 tradeid 是 varchar 类型，但是查询的条件却是 int 类型，这导致了隐式的类型转换，也就是使用了函数操作。</p>
<p>而在 mysql 中，字符串和数字比较，是转换字符串为数字，也就说，上面的 sql 实际上等同于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="built_in">int</span>)  = <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>这里的原理和上文提到了对条件字段的函数操作是一样的，因为对条件字段的操作破坏了索引树的有序性，导致只能全索引扫描。换而言之，如果不破坏有序性，函数操作就不会影响索引树的快速定位：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速定位</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">&#x27;110717&#x27;</span>;</span><br><span class="line"><span class="comment"># 上面的sql等同于下面</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="keyword">id</span> = <span class="keyword">CAST</span>(<span class="string">&#x27;110717&#x27;</span> <span class="keyword">AS</span> signed <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>

<p>如上，id 是 int 类型的字段，那么不会导致索引的快速定位失效。</p>
<p>也就是说：<strong>要将函数操作的对象从条件字段变成条件字段的参数</strong></p>
<h3><span id="3隐式字符编码转换">3.隐式字符编码转换</span></h3><p>假如要执行以下的 sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> trade_detail d <span class="keyword">on</span> d.tradeid = l.tradeid</span><br><span class="line"><span class="keyword">where</span> l.id=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>其中，trade_detail 的 tradeid 字段是有索引的，但是 explain 后却显示查询 trade_detail 仍然全表扫描。</p>
<p>也就是说，我们希望 tradelog 拿到了 tradeid 以后，能够直接在 trade_detail 的 tradeid 索引树上找到对应的记录，然后直接回表取出对应的数据，但是他却没通过索引，而是直接把 trade_detail 扫了一遍，把 tradeid 符合的数据拿出来了。</p>
<p>原因在于，tradelog 的字符集是 utf8，trade_detail 的字符集是 utf8mb4。而</p>
<blockquote>
<p>utf8mb4 是 utf8 的超集。类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。</p>
</blockquote>
<p>所以对于 trade_detail，他的 sql 实际上是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将trade_detail的tradeid转成utf8mb4</span></span><br><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> trade_detail d <span class="keyword">where</span> <span class="keyword">CONVERT</span>(d.tradeid <span class="keyword">USING</span> utf8mb4) = l.tradeid</span><br></pre></td></tr></table></figure>

<p>可见，这又是一个对条件字段使用了函数操作的情况。</p>
<p>根据上面两种情况的，我们有两种方法来优化这个 sql：</p>
<ul>
<li><p>将 trade_detail 表转为 utf8mb4 的编码格式</p>
</li>
<li><p>将函数操作的对象从条件字段变成条件字段的参数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> trade_detail d <span class="keyword">where</span> d.tradeid = <span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8mb4) </span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2><span id="七-总结">七、总结</span></h2><ol>
<li>尽量做到索引覆盖，减少回表次数；</li>
<li>排序总是会在按排序条件排完后，再根据主键排序，所以联合索引的最后不必包含主键字段；</li>
<li>索引需要尽可能的保证有序，并且尽可能的小；</li>
<li>条件字段需要尽可能的使用索引覆盖，以便索引下推，减少回表；</li>
<li>条件字段需要尽可能的按照联合索引的字段顺序排序，以便最左前缀原则生效；</li>
<li>长字符串索引使用索引：<ul>
<li>完整索引。这样可能比较占用空间；</li>
<li>前缀索引。节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储。再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建 hash 字段索引。查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ul>
</li>
<li>类型转换和字符集转换的实质都是实用的函数，而函数操作会引起的索引失效和全索引扫描问题，解决方式是将要将函数操作的对象从条件字段变成条件字段的参数</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>资源推荐：数据库内核月报</title>
    <url>/2020/11/17/mysql/%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5/</url>
    <content><![CDATA[<p>今天在舍友的安利下发现了一个新的宝藏，阿里的<a href="http://mysql.taobao.org/monthly/">数据库内核日报</a>，内容之全面让小白我瞠目结舌，简单的爬了一下 mysql 相关的文章。</p>
<p>完整版可以直接<a href="http://xiajibagao.top/down/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5(%E6%88%AA%E6%AD%A22020%E5%B9%B411%E6%9C%8817%E6%97%A5).md">点击链接下载</a>。以下只是 Mysql 内容的整合：</p>
<ol>
<li>MetadataLock子系统的优化 - <a href="http://mysql.taobao.org/monthly/2014/11/05/">2014/11/05/</a></li>
<li>Recovery改进 - <a href="http://mysql.taobao.org/monthly/2014/11/03/">2014/11/03/</a></li>
<li>高可用支持 - <a href="http://mysql.taobao.org/monthly/2014/11/04/">2014/11/04/</a></li>
<li>在线Truncateundolog表空间 - <a href="http://mysql.taobao.org/monthly/2014/11/06/">2014/11/06/</a></li>
<li>OptimizerCostModel - <a href="http://mysql.taobao.org/monthly/2014/10/01/">2014/10/01/</a></li>
<li>Renametable死锁分析 - <a href="http://mysql.taobao.org/monthly/2016/03/06/">2016/03/06/</a></li>
<li>CongratulationsonMySQL8.0GA - <a href="http://mysql.taobao.org/monthly/2018/05/01/">2018/05/01/</a></li>
<li>Redolog - <a href="http://mysql.taobao.org/monthly/2019/03/03/">2019/03/03/</a></li>
<li>tablespace源码分析 - <a href="http://mysql.taobao.org/monthly/2019/01/08/">2019/01/08/</a></li>
<li>TTL特性介绍 - <a href="http://mysql.taobao.org/monthly/2018/04/04/">2018/04/04/</a></li>
<li>MyRocks参数介绍 - <a href="http://mysql.taobao.org/monthly/2018/01/09/">2018/01/09/</a></li>
<li>OptimizerHints - <a href="http://mysql.taobao.org/monthly/2020/09/07/">2020/09/07/</a></li>
<li>ParallelIndexScans,OneisBetterThanTwo - <a href="http://mysql.taobao.org/monthly/2019/10/03/">2019/10/03/</a></li>
<li>数据的读取(二) - <a href="http://mysql.taobao.org/monthly/2018/12/08/">2018/12/08/</a></li>
<li>数据的读取(一) - <a href="http://mysql.taobao.org/monthly/2018/11/05/">2018/11/05/</a></li>
<li>LevelCompact分析 - <a href="http://mysql.taobao.org/monthly/2018/10/08/">2018/10/08/</a></li>
<li>TransactionDB介绍 - <a href="http://mysql.taobao.org/monthly/2018/10/09/">2018/10/09/</a></li>
<li>Memtableflush分析 - <a href="http://mysql.taobao.org/monthly/2018/09/04/">2018/09/04/</a></li>
<li>WritePreparedPolicy - <a href="http://mysql.taobao.org/monthly/2018/08/02/">2018/08/02/</a></li>
<li>MemTable的写入逻辑 - <a href="http://mysql.taobao.org/monthly/2018/08/08/">2018/08/08/</a></li>
<li>写入逻辑的实现 - <a href="http://mysql.taobao.org/monthly/2018/07/04/">2018/07/04/</a></li>
<li>ColumnFamily介绍 - <a href="http://mysql.taobao.org/monthly/2018/06/09/">2018/06/09/</a></li>
<li>MANIFEST文件介绍 - <a href="http://mysql.taobao.org/monthly/2018/05/08/">2018/05/08/</a></li>
<li>WAL(WriteAheadLog)介绍 - <a href="http://mysql.taobao.org/monthly/2018/04/09/">2018/04/09/</a></li>
<li>rbtreeblockallocator - <a href="http://mysql.taobao.org/monthly/2016/11/03/">2016/11/03/</a></li>
<li>checkpoint过程 - <a href="http://mysql.taobao.org/monthly/2016/06/06/">2016/06/06/</a></li>
<li>日志子系统和崩溃恢复过程 - <a href="http://mysql.taobao.org/monthly/2016/05/07/">2016/05/07/</a></li>
<li>TokuDB索引结构–FractalTree - <a href="http://mysql.taobao.org/monthly/2016/04/09/">2016/04/09/</a></li>
<li>Savepoint漫谈 - <a href="http://mysql.taobao.org/monthly/2016/04/10/">2016/04/10/</a></li>
<li>事务子系统和MVCC实现 - <a href="http://mysql.taobao.org/monthly/2016/03/01/">2016/03/01/</a></li>
<li>TokuDB之黑科技工具 - <a href="http://mysql.taobao.org/monthly/2016/02/06/">2016/02/06/</a></li>
<li>Cachetable的工作线程和线程池 - <a href="http://mysql.taobao.org/monthly/2016/01/06/">2016/01/06/</a></li>
<li>让HotBackup更完美 - <a href="http://mysql.taobao.org/monthly/2015/12/06/">2015/12/06/</a></li>
<li>TokuDB中的行锁 - <a href="http://mysql.taobao.org/monthly/2015/11/09/">2015/11/09/</a></li>
<li>文件目录谈 - <a href="http://mysql.taobao.org/monthly/2015/09/10/">2015/09/10/</a></li>
<li>疯狂的filenum++ - <a href="http://mysql.taobao.org/monthly/2015/08/08/">2015/08/08/</a></li>
<li>TokuDBCheckpoint机制 - <a href="http://mysql.taobao.org/monthly/2015/07/02/">2015/07/02/</a></li>
<li>TokuDB数据文件大小计算 - <a href="http://mysql.taobao.org/monthly/2015/06/10/">2015/06/10/</a></li>
<li>collation限制 - <a href="http://mysql.taobao.org/monthly/2018/09/09/">2018/09/09/</a></li>
<li>clusteredindex特性 - <a href="http://mysql.taobao.org/monthly/2018/07/07/">2018/07/07/</a></li>
<li>事务锁分析 - <a href="http://mysql.taobao.org/monthly/2018/03/07/">2018/03/07/</a></li>
<li>相关tools介绍 - <a href="http://mysql.taobao.org/monthly/2017/12/10/">2017/12/10/</a></li>
<li>myrocks之Bloomfilter - <a href="http://mysql.taobao.org/monthly/2017/09/04/">2017/09/04/</a></li>
<li>myrocks写入分析 - <a href="http://mysql.taobao.org/monthly/2017/07/05/">2017/07/05/</a></li>
<li>MyRocks之memtable切换与刷盘 - <a href="http://mysql.taobao.org/monthly/2017/06/08/">2017/06/08/</a></li>
<li>fastdataload - <a href="http://mysql.taobao.org/monthly/2017/05/09/">2017/05/09/</a></li>
<li>myrocks监控信息 - <a href="http://mysql.taobao.org/monthly/2017/03/10/">2017/03/10/</a></li>
<li>myrocks之备份恢复 - <a href="http://mysql.taobao.org/monthly/2017/02/02/">2017/02/02/</a></li>
<li>myrocksindexconditionpushdown - <a href="http://mysql.taobao.org/monthly/2017/01/02/">2017/01/02/</a></li>
<li>myrocks统计信息 - <a href="http://mysql.taobao.org/monthly/2016/12/02/">2016/12/02/</a></li>
<li>myrocks之事务处理 - <a href="http://mysql.taobao.org/monthly/2016/11/02/">2016/11/02/</a></li>
<li>datadictionary分析 - <a href="http://mysql.taobao.org/monthly/2016/10/05/">2016/10/05/</a></li>
<li>GTID启动优化 - <a href="http://mysql.taobao.org/monthly/2014/12/09/">2014/12/09/</a></li>
<li>InnoDB物理行中null值的存储的推断与验证 - <a href="http://mysql.taobao.org/monthly/2016/08/07/">2016/08/07/</a></li>
<li>MySQL5.7的JSON实现 - <a href="http://mysql.taobao.org/monthly/2016/01/03/">2016/01/03/</a></li>
<li>MySQL数据库SYSCPU高的可能性分析 - <a href="http://mysql.taobao.org/monthly/2015/05/02/">2015/05/02/</a></li>
<li>RDS三节点企业版的高可用体系 - <a href="http://mysql.taobao.org/monthly/2020/03/03/">2020/03/03/</a></li>
<li>MYSQL开源软件源码阅读小技巧 - <a href="http://mysql.taobao.org/monthly/2019/12/03/">2019/12/03/</a></li>
<li>复制性能改进过程 - <a href="http://mysql.taobao.org/monthly/2015/01/05/">2015/01/05/</a></li>
<li>MySQLindex_condition_pushdown - <a href="http://mysql.taobao.org/monthly/2015/03/05/">2015/03/05/</a></li>
<li>InnoDBBufferPool并发控制 - <a href="http://mysql.taobao.org/monthly/2020/05/06/">2020/05/06/</a></li>
<li>InnoDBmutex实现分析 - <a href="http://mysql.taobao.org/monthly/2020/03/05/">2020/03/05/</a></li>
<li>InnoDB的统计信息 - <a href="http://mysql.taobao.org/monthly/2020/03/08/">2020/03/08/</a></li>
<li>RedoLogging动态开关 - <a href="http://mysql.taobao.org/monthly/2020/08/03/">2020/08/03/</a></li>
<li>8.0新的火山模型执行器 - <a href="http://mysql.taobao.org/monthly/2020/07/01/">2020/07/01/</a></li>
<li>semi-join四个执行strategy - <a href="http://mysql.taobao.org/monthly/2020/07/04/">2020/07/04/</a></li>
<li>InnoDBbtreelatch优化历程 - <a href="http://mysql.taobao.org/monthly/2020/06/02/">2020/06/02/</a></li>
<li>Attachabletransaction - <a href="http://mysql.taobao.org/monthly/2020/06/03/">2020/06/03/</a></li>
<li>Linkbuf - <a href="http://mysql.taobao.org/monthly/2020/06/04/">2020/06/04/</a></li>
<li>一致性协议underthehood - <a href="http://mysql.taobao.org/monthly/2020/09/02/">2020/09/02/</a></li>
<li>binlog拉取速度的控制 - <a href="http://mysql.taobao.org/monthly/2015/07/09/">2015/07/09/</a></li>
<li>5.6并行复制实现分析 - <a href="http://mysql.taobao.org/monthly/2015/08/09/">2015/08/09/</a></li>
<li>MySQL表定义缓存 - <a href="http://mysql.taobao.org/monthly/2015/08/10/">2015/08/10/</a></li>
<li>InnoDBWarmup特性 - <a href="http://mysql.taobao.org/monthly/2014/10/06/">2014/10/06/</a></li>
<li>再议MySQL的故障恢复 - <a href="http://mysql.taobao.org/monthly/2018/12/04/">2018/12/04/</a></li>
<li>RDSMySQL参数调优最佳实践 - <a href="http://mysql.taobao.org/monthly/2015/12/04/">2015/12/04/</a></li>
<li>innodb_additional_mem_pool_size - <a href="http://mysql.taobao.org/monthly/2016/04/01/">2016/04/01/</a></li>
<li>thread_concurrency - <a href="http://mysql.taobao.org/monthly/2014/09/05/">2014/09/05/</a></li>
<li>timed_mutexes - <a href="http://mysql.taobao.org/monthly/2014/08/01/">2014/08/01/</a></li>
<li>innodb_flush_log_at_trx_commit - <a href="http://mysql.taobao.org/monthly/2014/08/02/">2014/08/02/</a></li>
<li>relayfetch备库优化 - <a href="http://mysql.taobao.org/monthly/2015/09/08/">2015/09/08/</a></li>
<li>MySQL的字段数据存储格式 - <a href="http://mysql.taobao.org/monthly/2020/02/05/">2020/02/05/</a></li>
<li>HybridDBforMySQL数据压缩 - <a href="http://mysql.taobao.org/monthly/2017/07/08/">2017/07/08/</a></li>
<li>对字符集和字符序支持的实现 - <a href="http://mysql.taobao.org/monthly/2017/03/06/">2017/03/06/</a></li>
<li>Sphinx源码剖析(三) - <a href="http://mysql.taobao.org/monthly/2017/10/06/">2017/10/06/</a></li>
<li>Sphinx源码剖析（二） - <a href="http://mysql.taobao.org/monthly/2017/04/03/">2017/04/03/</a></li>
<li>Sphinx源码剖析（一） - <a href="http://mysql.taobao.org/monthly/2016/11/05/">2016/11/05/</a></li>
<li>InnoDBhistorylist无法降到0的原因 - <a href="http://mysql.taobao.org/monthly/2019/04/04/">2019/04/04/</a></li>
<li>InnoDB行锁分析 - <a href="http://mysql.taobao.org/monthly/2018/05/04/">2018/05/04/</a></li>
<li>create_timeinstatus - <a href="http://mysql.taobao.org/monthly/2014/09/04/">2014/09/04/</a></li>
<li>InnoDB隐式锁功能解析 - <a href="http://mysql.taobao.org/monthly/2020/09/06/">2020/09/06/</a></li>
<li>truncatetable在大bufferpool下的优化 - <a href="http://mysql.taobao.org/monthly/2020/08/01/">2020/08/01/</a></li>
<li>INNODBUNDOLOG分配 - <a href="http://mysql.taobao.org/monthly/2020/08/02/">2020/08/02/</a></li>
<li>InnoDBBufferPage生命周期 - <a href="http://mysql.taobao.org/monthly/2020/08/04/">2020/08/04/</a></li>
<li>InnoDBUNDOLOG写入 - <a href="http://mysql.taobao.org/monthly/2020/08/05/">2020/08/05/</a></li>
<li>InnoDB数据文件简述 - <a href="http://mysql.taobao.org/monthly/2020/08/06/">2020/08/06/</a></li>
<li>InnoDBredologthreadcpuusage - <a href="http://mysql.taobao.org/monthly/2020/07/05/">2020/07/05/</a></li>
<li>基于GTID复制实现的工作原理 - <a href="http://mysql.taobao.org/monthly/2020/05/09/">2020/05/09/</a></li>
<li>8.0WindowFunctions剖析 - <a href="http://mysql.taobao.org/monthly/2020/04/04/">2020/04/04/</a></li>
<li>Performance_schema内存分配 - <a href="http://mysql.taobao.org/monthly/2020/04/05/">2020/04/05/</a></li>
<li>手动分析InnoDBB+Tree结构 - <a href="http://mysql.taobao.org/monthly/2020/04/06/">2020/04/06/</a></li>
<li>8.0LockManager - <a href="http://mysql.taobao.org/monthly/2020/04/09/">2020/04/09/</a></li>
<li>8.0InstantAddColumn功能解析 - <a href="http://mysql.taobao.org/monthly/2020/03/01/">2020/03/01/</a></li>
<li>Latch持有分析 - <a href="http://mysql.taobao.org/monthly/2020/03/07/">2020/03/07/</a></li>
<li>排序实现 - <a href="http://mysql.taobao.org/monthly/2020/03/09/">2020/03/09/</a></li>
<li>庖丁解InnoDB之REDOLOG - <a href="http://mysql.taobao.org/monthly/2020/02/01/">2020/02/01/</a></li>
<li>InnoDBBufferPool浅析 - <a href="http://mysql.taobao.org/monthly/2020/02/02/">2020/02/02/</a></li>
<li>8.0heaptable介绍 - <a href="http://mysql.taobao.org/monthly/2020/02/04/">2020/02/04/</a></li>
<li>MYSQLBinlogCache详解 - <a href="http://mysql.taobao.org/monthly/2020/02/06/">2020/02/06/</a></li>
<li>二级索引分析 - <a href="http://mysql.taobao.org/monthly/2020/01/01/">2020/01/01/</a></li>
<li>X-EngineOnlineDDL - <a href="http://mysql.taobao.org/monthly/2020/01/02/">2020/01/02/</a></li>
<li>InnoDBredolog之writeahead - <a href="http://mysql.taobao.org/monthly/2020/01/05/">2020/01/05/</a></li>
<li>InnodbWAL物理格式 - <a href="http://mysql.taobao.org/monthly/2020/01/06/">2020/01/06/</a></li>
<li>动态元信息持久化 - <a href="http://mysql.taobao.org/monthly/2019/12/01/">2019/12/01/</a></li>
<li>Binlogencryption浅析 - <a href="http://mysql.taobao.org/monthly/2019/12/02/">2019/12/02/</a></li>
<li>多线程调试工具DEBUG_SYNC的源码实现和使用 - <a href="http://mysql.taobao.org/monthly/2019/12/04/">2019/12/04/</a></li>
<li>InnoDBParallelreadofindex - <a href="http://mysql.taobao.org/monthly/2019/12/05/">2019/12/05/</a></li>
<li>RDS三节点企业版一致性协议 - <a href="http://mysql.taobao.org/monthly/2019/11/06/">2019/11/06/</a></li>
<li>RDS三节点企业版Learner只读实例 - <a href="http://mysql.taobao.org/monthly/2019/11/07/">2019/11/07/</a></li>
<li>Innodb表空间 - <a href="http://mysql.taobao.org/monthly/2019/10/01/">2019/10/01/</a></li>
<li>POLARDB并行查询加速全程详解 - <a href="http://mysql.taobao.org/monthly/2019/10/02/">2019/10/02/</a></li>
<li>SequenceEngine - <a href="http://mysql.taobao.org/monthly/2019/10/05/">2019/10/05/</a></li>
<li>临时表改进 - <a href="http://mysql.taobao.org/monthly/2019/09/01/">2019/09/01/</a></li>
<li>初探ClonePlugin - <a href="http://mysql.taobao.org/monthly/2019/09/02/">2019/09/02/</a></li>
<li>网络模块优化 - <a href="http://mysql.taobao.org/monthly/2019/09/03/">2019/09/03/</a></li>
<li>Multi-ValuedIndexes简述 - <a href="http://mysql.taobao.org/monthly/2019/09/04/">2019/09/04/</a></li>
<li>8.0Innodbredologrecord源码分析 - <a href="http://mysql.taobao.org/monthly/2019/08/03/">2019/08/03/</a></li>
<li>clone_plugin - <a href="http://mysql.taobao.org/monthly/2019/08/05/">2019/08/05/</a></li>
<li>ROLLUP功能用法和实现 - <a href="http://mysql.taobao.org/monthly/2019/08/08/">2019/08/08/</a></li>
<li>BufferPool漫谈 - <a href="http://mysql.taobao.org/monthly/2019/07/03/">2019/07/03/</a></li>
<li>CTE(CommonTableExpressions) - <a href="http://mysql.taobao.org/monthly/2019/07/06/">2019/07/06/</a></li>
<li>安全及权限改进相关 - <a href="http://mysql.taobao.org/monthly/2019/06/01/">2019/06/01/</a></li>
<li>说说InnoDBLogSystem的隐藏参数 - <a href="http://mysql.taobao.org/monthly/2019/06/07/">2019/06/07/</a></li>
<li>CHECKCONSTRAINT - <a href="http://mysql.taobao.org/monthly/2019/06/08/">2019/06/08/</a></li>
<li>通过SQL管理UNDOTABLESPACE - <a href="http://mysql.taobao.org/monthly/2019/05/04/">2019/05/04/</a></li>
<li>SkipScanRange - <a href="http://mysql.taobao.org/monthly/2019/05/06/">2019/05/06/</a></li>
<li>临时表那些事儿 - <a href="http://mysql.taobao.org/monthly/2019/04/01/">2019/04/01/</a></li>
<li>新的事务锁调度VATS简介 - <a href="http://mysql.taobao.org/monthly/2019/04/06/">2019/04/06/</a></li>
<li>增加系统文件追踪spaceID和物理文件的映射 - <a href="http://mysql.taobao.org/monthly/2019/04/07/">2019/04/07/</a></li>
<li>8.0DescendingIndex - <a href="http://mysql.taobao.org/monthly/2019/03/07/">2019/03/07/</a></li>
<li>MySQL状态信息Status实现 - <a href="http://mysql.taobao.org/monthly/2019/03/09/">2019/03/09/</a></li>
<li>InspectingtheContentofaMySQLHistogram - <a href="http://mysql.taobao.org/monthly/2019/02/02/">2019/02/02/</a></li>
<li>Thedesignofmysql8.0redolog - <a href="http://mysql.taobao.org/monthly/2019/02/05/">2019/02/05/</a></li>
<li>InnoDBMVCC相关实现 - <a href="http://mysql.taobao.org/monthly/2018/11/04/">2018/11/04/</a></li>
<li>CostModel,直方图及优化器开销优化 - <a href="http://mysql.taobao.org/monthly/2018/10/02/">2018/10/02/</a></li>
<li>B+树并发控制机制的前世今生 - <a href="http://mysql.taobao.org/monthly/2018/09/01/">2018/09/01/</a></li>
<li>IO_CACHE源码解析 - <a href="http://mysql.taobao.org/monthly/2018/09/03/">2018/09/03/</a></li>
<li>主库binlog概览 - <a href="http://mysql.taobao.org/monthly/2018/08/01/">2018/08/01/</a></li>
<li>WAL那些事儿 - <a href="http://mysql.taobao.org/monthly/2018/07/01/">2018/07/01/</a></li>
<li>InnoDB表空间加密 - <a href="http://mysql.taobao.org/monthly/2018/04/01/">2018/04/01/</a></li>
<li>InnoDB数据页解析 - <a href="http://mysql.taobao.org/monthly/2018/04/03/">2018/04/03/</a></li>
<li>INFORMATION_SCHEMA系统表的实现 - <a href="http://mysql.taobao.org/monthly/2018/02/08/">2018/02/08/</a></li>
<li>GroupReplication内核解析之二 - <a href="http://mysql.taobao.org/monthly/2018/01/01/">2018/01/01/</a></li>
<li>MySQL内核对读写分离的支持 - <a href="http://mysql.taobao.org/monthly/2018/01/02/">2018/01/02/</a></li>
<li>InnoDB事务系统 - <a href="http://mysql.taobao.org/monthly/2017/12/01/">2017/12/01/</a></li>
<li>Innodb锁子系统浅析 - <a href="http://mysql.taobao.org/monthly/2017/12/02/">2017/12/02/</a></li>
<li>DROPTABLE之binlog解析 - <a href="http://mysql.taobao.org/monthly/2017/11/02/">2017/11/02/</a></li>
<li>TokuDBhot-index机制 - <a href="http://mysql.taobao.org/monthly/2017/11/08/">2017/11/08/</a></li>
<li>InnoDBminitransation - <a href="http://mysql.taobao.org/monthly/2017/10/03/">2017/10/03/</a></li>
<li>GroupReplication内核解析 - <a href="http://mysql.taobao.org/monthly/2017/08/01/">2017/08/01/</a></li>
<li>InnoDB崩溃恢复 - <a href="http://mysql.taobao.org/monthly/2017/07/01/">2017/07/01/</a></li>
<li>从节点可更新机制 - <a href="http://mysql.taobao.org/monthly/2017/06/03/">2017/06/03/</a></li>
<li>InnoDBBufferPool - <a href="http://mysql.taobao.org/monthly/2017/05/01/">2017/05/01/</a></li>
<li>InnoDBIO子系统 - <a href="http://mysql.taobao.org/monthly/2017/03/01/">2017/03/01/</a></li>
<li>InnoDB同步机制 - <a href="http://mysql.taobao.org/monthly/2017/01/01/">2017/01/01/</a></li>
<li>Infobright列存数据库 - <a href="http://mysql.taobao.org/monthly/2016/12/01/">2016/12/01/</a></li>
<li>ColumnCompression浅析 - <a href="http://mysql.taobao.org/monthly/2016/11/04/">2016/11/04/</a></li>
<li>InnoDBCOUNT(*)优化(?) - <a href="http://mysql.taobao.org/monthly/2016/06/10/">2016/06/10/</a></li>
<li>基于InnoDB的物理复制实现 - <a href="http://mysql.taobao.org/monthly/2016/05/01/">2016/05/01/</a></li>
<li>InnoDB文件系统之文件物理结构 - <a href="http://mysql.taobao.org/monthly/2016/02/01/">2016/02/01/</a></li>
<li>InnoDB文件系统之IO系统和内存管理 - <a href="http://mysql.taobao.org/monthly/2016/02/02/">2016/02/02/</a></li>
<li>InnoDB事务锁系统简介 - <a href="http://mysql.taobao.org/monthly/2016/01/01/">2016/01/01/</a></li>
<li>InnoDB事务子系统介绍 - <a href="http://mysql.taobao.org/monthly/2015/12/01/">2015/12/01/</a></li>
<li>InnoDB全文索引简介 - <a href="http://mysql.taobao.org/monthly/2015/10/01/">2015/10/01/</a></li>
<li>InnoDBAdaptivehashindex介绍 - <a href="http://mysql.taobao.org/monthly/2015/09/01/">2015/09/01/</a></li>
<li>Innodbchangebuffer介绍 - <a href="http://mysql.taobao.org/monthly/2015/07/01/">2015/07/01/</a></li>
<li>InnoDBindexlock前世今生 - <a href="http://mysql.taobao.org/monthly/2015/07/05/">2015/07/05/</a></li>
<li>MySQLlogicalread-ahead - <a href="http://mysql.taobao.org/monthly/2015/07/08/">2015/07/08/</a></li>
<li>InnoDB崩溃恢复过程 - <a href="http://mysql.taobao.org/monthly/2015/06/01/">2015/06/01/</a></li>
<li>InnoDBredolog漫游 - <a href="http://mysql.taobao.org/monthly/2015/05/01/">2015/05/01/</a></li>
<li>InnoDBundolog漫游 - <a href="http://mysql.taobao.org/monthly/2015/04/01/">2015/04/01/</a></li>
<li>PageCache优化管理 - <a href="http://mysql.taobao.org/monthly/2020/09/01/">2020/09/01/</a></li>
<li>CloudDBASQL优化建议之统计信息获取 - <a href="http://mysql.taobao.org/monthly/2017/10/02/">2017/10/02/</a></li>
<li>MySQL常见SQL错误用法 - <a href="http://mysql.taobao.org/monthly/2017/03/03/">2017/03/03/</a></li>
<li>条件下推到物化表 - <a href="http://mysql.taobao.org/monthly/2016/07/08/">2016/07/08/</a></li>
<li>5.7.6InnoDBpageflush优化 - <a href="http://mysql.taobao.org/monthly/2015/03/02/">2015/03/02/</a></li>
<li>InnoDBbufferpoolflush策略漫谈 - <a href="http://mysql.taobao.org/monthly/2015/02/01/">2015/02/01/</a></li>
<li>GroupCommit优化 - <a href="http://mysql.taobao.org/monthly/2015/01/01/">2015/01/01/</a></li>
<li>启用GTID场景的性能问题及优化 - <a href="http://mysql.taobao.org/monthly/2015/01/03/">2015/01/03/</a></li>
<li>5.7Innodb事务系统 - <a href="http://mysql.taobao.org/monthly/2014/12/01/">2014/12/01/</a></li>
<li>threadpool原理分析 - <a href="http://mysql.taobao.org/monthly/2014/12/03/">2014/12/03/</a></li>
<li>并行复制外建约束问题 - <a href="http://mysql.taobao.org/monthly/2014/12/04/">2014/12/04/</a></li>
<li>BulkLoadforCREATEINDEX - <a href="http://mysql.taobao.org/monthly/2014/12/07/">2014/12/07/</a></li>
<li>hash_scan算法的实现解析 - <a href="http://mysql.taobao.org/monthly/2014/11/07/">2014/11/07/</a></li>
<li>LOCK_active_mi/LOCK_msp_map优化思路 - <a href="http://mysql.taobao.org/monthly/2017/02/03/">2017/02/03/</a></li>
<li>弱序内存模型导致的死锁问题 - <a href="http://mysql.taobao.org/monthly/2020/01/03/">2020/01/03/</a></li>
<li>UK包含NULL值备库延迟分析 - <a href="http://mysql.taobao.org/monthly/2018/01/04/">2018/01/04/</a></li>
<li>Errorinmunmap()”Cannotallocatememory” - <a href="http://mysql.taobao.org/monthly/2018/01/05/">2018/01/05/</a></li>
<li>字符集相关变量介绍及binlog中字符集相关缺陷分析 - <a href="http://mysql.taobao.org/monthly/2018/01/07/">2018/01/07/</a></li>
<li>信号处理机制分析 - <a href="http://mysql.taobao.org/monthly/2017/10/10/">2017/10/10/</a></li>
<li>showbinarylogs灵异事件 - <a href="http://mysql.taobao.org/monthly/2017/09/03/">2017/09/03/</a></li>
<li>InnoDBcrash - <a href="http://mysql.taobao.org/monthly/2017/06/05/">2017/06/05/</a></li>
<li>5.7mysql_upgrade元数据锁等待 - <a href="http://mysql.taobao.org/monthly/2017/04/10/">2017/04/10/</a></li>
<li>event_scheduler慢日志记错 - <a href="http://mysql.taobao.org/monthly/2017/01/05/">2017/01/05/</a></li>
<li>5.6中ORDERBY+LIMIT错选执行计划 - <a href="http://mysql.taobao.org/monthly/2016/12/08/">2016/12/08/</a></li>
<li>备库1206错误问题说明 - <a href="http://mysql.taobao.org/monthly/2016/07/10/">2016/07/10/</a></li>
<li>left-join多表导致crash - <a href="http://mysql.taobao.org/monthly/2016/05/10/">2016/05/10/</a></li>
<li>并行复制外键约束问题二 - <a href="http://mysql.taobao.org/monthly/2016/04/04/">2016/04/04/</a></li>
<li>MySQL外键异常分析 - <a href="http://mysql.taobao.org/monthly/2015/11/06/">2015/11/06/</a></li>
<li>ORDER/GROUPBY导致mysqldcrash - <a href="http://mysql.taobao.org/monthly/2015/11/08/">2015/11/08/</a></li>
<li>orderbylimit造成优化器选择索引错误 - <a href="http://mysql.taobao.org/monthly/2015/11/10/">2015/11/10/</a></li>
<li>startslavecrash诊断分析 - <a href="http://mysql.taobao.org/monthly/2015/10/05/">2015/10/05/</a></li>
<li>删除索引导致表无法打开 - <a href="http://mysql.taobao.org/monthly/2015/10/06/">2015/10/06/</a></li>
<li>BUG几例 - <a href="http://mysql.taobao.org/monthly/2015/09/03/">2015/09/03/</a></li>
<li>建表过程中crash造成重建表失败 - <a href="http://mysql.taobao.org/monthly/2015/09/05/">2015/09/05/</a></li>
<li>唯一键约束失效 - <a href="http://mysql.taobao.org/monthly/2015/06/02/">2015/06/02/</a></li>
<li>ALTERIGNORETABLE导致主备不一致 - <a href="http://mysql.taobao.org/monthly/2015/06/03/">2015/06/03/</a></li>
<li>任性的normalshutdown - <a href="http://mysql.taobao.org/monthly/2015/06/07/">2015/06/07/</a></li>
<li>5.6与5.5InnoDB不兼容导致crash - <a href="http://mysql.taobao.org/monthly/2015/05/03/">2015/05/03/</a></li>
<li>MySQLDDLBUG - <a href="http://mysql.taobao.org/monthly/2015/05/06/">2015/05/06/</a></li>
<li>临时表操作导致主备不一致 - <a href="http://mysql.taobao.org/monthly/2015/05/08/">2015/05/08/</a></li>
<li>连接断开导致XA事务丢失 - <a href="http://mysql.taobao.org/monthly/2015/04/05/">2015/04/05/</a></li>
<li>GTID下slave_net_timeout值太小问题 - <a href="http://mysql.taobao.org/monthly/2015/04/06/">2015/04/06/</a></li>
<li>Relaylog中GTIDgroup完整性检测 - <a href="http://mysql.taobao.org/monthly/2015/04/07/">2015/04/07/</a></li>
<li>删被引用索引导致crash - <a href="http://mysql.taobao.org/monthly/2015/04/09/">2015/04/09/</a></li>
<li>pidfile丢失问题分析 - <a href="http://mysql.taobao.org/monthly/2015/03/03/">2015/03/03/</a></li>
<li>DROPDATABASE外键约束的GTIDBUG - <a href="http://mysql.taobao.org/monthly/2015/03/06/">2015/03/06/</a></li>
<li>变量修改导致binlog错误 - <a href="http://mysql.taobao.org/monthly/2015/02/07/">2015/02/07/</a></li>
<li>InnoDB自增列重复值问题 - <a href="http://mysql.taobao.org/monthly/2015/01/04/">2015/01/04/</a></li>
<li>mysqlclientcrash一例 - <a href="http://mysql.taobao.org/monthly/2015/01/07/">2015/01/07/</a></li>
<li>设置gtid_purged破坏AUTO_POSITION复制协议 - <a href="http://mysql.taobao.org/monthly/2015/01/08/">2015/01/08/</a></li>
<li>replicatefilter和GTID一起使用的问题 - <a href="http://mysql.taobao.org/monthly/2015/01/09/">2015/01/09/</a></li>
<li>Openedtablesblockreadonly - <a href="http://mysql.taobao.org/monthly/2014/12/08/">2014/12/08/</a></li>
<li>OPTIMIZE不存在的表 - <a href="http://mysql.taobao.org/monthly/2014/11/01/">2014/11/01/</a></li>
<li>SIGHUP导致binlog写错 - <a href="http://mysql.taobao.org/monthly/2014/11/02/">2014/11/02/</a></li>
<li>binlog重放失败 - <a href="http://mysql.taobao.org/monthly/2014/10/03/">2014/10/03/</a></li>
<li>从库OOM - <a href="http://mysql.taobao.org/monthly/2014/10/04/">2014/10/04/</a></li>
<li>崩溃恢复失败 - <a href="http://mysql.taobao.org/monthly/2014/10/05/">2014/10/05/</a></li>
<li>GTID和DELAYED - <a href="http://mysql.taobao.org/monthly/2014/09/01/">2014/09/01/</a></li>
<li>GTID和binlog_checksum - <a href="http://mysql.taobao.org/monthly/2014/09/03/">2014/09/03/</a></li>
<li>auto_increment - <a href="http://mysql.taobao.org/monthly/2014/09/06/">2014/09/06/</a></li>
<li>Count(Distinct)ERROR - <a href="http://mysql.taobao.org/monthly/2014/08/03/">2014/08/03/</a></li>
<li>mysqldumpBUFFEROVERFLOW - <a href="http://mysql.taobao.org/monthly/2014/08/04/">2014/08/04/</a></li>
<li>longsemaphorewaits - <a href="http://mysql.taobao.org/monthly/2014/08/05/">2014/08/05/</a></li>
<li>bug分析两例 - <a href="http://mysql.taobao.org/monthly/2016/09/06/">2016/09/06/</a></li>
<li>ConnectionControl - <a href="http://mysql.taobao.org/monthly/2020/05/08/">2020/05/08/</a></li>
<li>undrop-for-innodb - <a href="http://mysql.taobao.org/monthly/2017/11/01/">2017/11/01/</a></li>
<li>告别frm文件 - <a href="http://mysql.taobao.org/monthly/2014/10/07/">2014/10/07/</a></li>
<li>DDLfastfail - <a href="http://mysql.taobao.org/monthly/2015/01/02/">2015/01/02/</a></li>
<li>MySQL哈希连接实现介绍 - <a href="http://mysql.taobao.org/monthly/2019/11/02/">2019/11/02/</a></li>
<li>5.7中Derivedtable变形记 - <a href="http://mysql.taobao.org/monthly/2017/03/05/">2017/03/05/</a></li>
<li>CTE执行过程与实现原理 - <a href="http://mysql.taobao.org/monthly/2017/02/06/">2017/02/06/</a></li>
<li>审计日志实用案例分析 - <a href="http://mysql.taobao.org/monthly/2016/07/07/">2016/07/07/</a></li>
<li>X-Engine并行扫描 - <a href="http://mysql.taobao.org/monthly/2020/04/03/">2020/04/03/</a></li>
<li>RDS三节点企业版热点组提交 - <a href="http://mysql.taobao.org/monthly/2020/02/03/">2020/02/03/</a></li>
<li>8.0redolog写入性能问题分析 - <a href="http://mysql.taobao.org/monthly/2020/01/04/">2020/01/04/</a></li>
<li>今天你并行了吗？—洞察PolarDB8.0之并行查询 - <a href="http://mysql.taobao.org/monthly/2019/11/01/">2019/11/01/</a></li>
<li>性能分析的大杀器—Optimizertrace - <a href="http://mysql.taobao.org/monthly/2019/11/03/">2019/11/03/</a></li>
<li>X-EngineMySQLRDS用户的新选择 - <a href="http://mysql.taobao.org/monthly/2019/10/04/">2019/10/04/</a></li>
<li>StatementOutline - <a href="http://mysql.taobao.org/monthly/2019/07/01/">2019/07/01/</a></li>
<li>RDSMySQL8.0语句级并发控制 - <a href="http://mysql.taobao.org/monthly/2019/06/02/">2019/06/02/</a></li>
<li>通过ResourceGroup来控制线程计算资源 - <a href="http://mysql.taobao.org/monthly/2019/05/05/">2019/05/05/</a></li>
<li>如何使用C++实现MySQL用户定义函数 - <a href="http://mysql.taobao.org/monthly/2019/02/08/">2019/02/08/</a></li>
<li>MySQL多队列线程池优化 - <a href="http://mysql.taobao.org/monthly/2019/02/09/">2019/02/09/</a></li>
<li>MySQL中的IO共享操作 - <a href="http://mysql.taobao.org/monthly/2019/01/09/">2019/01/09/</a></li>
<li>性能问题多维度诊断 - <a href="http://mysql.taobao.org/monthly/2018/11/08/">2018/11/08/</a></li>
<li>8.0CTE和窗口函数的用法 - <a href="http://mysql.taobao.org/monthly/2018/11/09/">2018/11/09/</a></li>
<li>一个TPC-C测试工具sqlbench使用 - <a href="http://mysql.taobao.org/monthly/2018/07/09/">2018/07/09/</a></li>
<li>难以置信，MySQL也可以无损自由切换 - <a href="http://mysql.taobao.org/monthly/2018/06/03/">2018/06/03/</a></li>
<li>在线收缩UNDOTablespace - <a href="http://mysql.taobao.org/monthly/2018/02/09/">2018/02/09/</a></li>
<li>一个“异常”的索引选择 - <a href="http://mysql.taobao.org/monthly/2017/12/06/">2017/12/06/</a></li>
<li>如何索引JSON字段 - <a href="http://mysql.taobao.org/monthly/2017/12/09/">2017/12/09/</a></li>
<li>什么时候该升级内存规格 - <a href="http://mysql.taobao.org/monthly/2017/11/04/">2017/11/04/</a></li>
<li>分区表基本类型 - <a href="http://mysql.taobao.org/monthly/2017/11/09/">2017/11/09/</a></li>
<li>空间优化 - <a href="http://mysql.taobao.org/monthly/2016/06/08/">2016/06/08/</a></li>
<li>RDS只读实例延迟分析 - <a href="http://mysql.taobao.org/monthly/2016/04/08/">2016/04/08/</a></li>
<li>RDSMySQL线上实例insert慢常见原因分析 - <a href="http://mysql.taobao.org/monthly/2018/09/07/">2018/09/07/</a></li>
<li>8.0 - <a href="http://mysql.taobao.org/monthly/2020/05/05/">2020/05/05/</a></li>
<li>内部XA和组提交 - <a href="http://mysql.taobao.org/monthly/2020/05/07/">2020/05/07/</a></li>
<li>InnoDB读写锁实现分析 - <a href="http://mysql.taobao.org/monthly/2020/04/02/">2020/04/02/</a></li>
<li><code>slowlog</code>与<code>CSV</code>引擎 - <a href="http://mysql.taobao.org/monthly/2019/07/08/">2019/07/08/</a></li>
<li>聚合函数（AggregateFunction）的实现过程 - <a href="http://mysql.taobao.org/monthly/2019/05/02/">2019/05/02/</a></li>
<li>LinkBuf设计与实现 - <a href="http://mysql.taobao.org/monthly/2019/05/08/">2019/05/08/</a></li>
<li>CHECKTABLE实现 - <a href="http://mysql.taobao.org/monthly/2019/03/05/">2019/03/05/</a></li>
<li>8.0Functionalindex的实现过程 - <a href="http://mysql.taobao.org/monthly/2019/02/06/">2019/02/06/</a></li>
<li>Innodb缓冲池刷脏的多线程实现 - <a href="http://mysql.taobao.org/monthly/2018/09/02/">2018/09/02/</a></li>
<li>连接与认证过程 - <a href="http://mysql.taobao.org/monthly/2018/08/07/">2018/08/07/</a></li>
<li>8.0原子DDL的实现过程续 - <a href="http://mysql.taobao.org/monthly/2018/07/02/">2018/07/02/</a></li>
<li>binlogcrashrecovery - <a href="http://mysql.taobao.org/monthly/2018/07/05/">2018/07/05/</a></li>
<li>changemasterto - <a href="http://mysql.taobao.org/monthly/2018/05/09/">2018/05/09/</a></li>
<li>协议模块浅析 - <a href="http://mysql.taobao.org/monthly/2018/04/05/">2018/04/05/</a></li>
<li>InnoDB的readview，回滚段和purge过程简介 - <a href="http://mysql.taobao.org/monthly/2018/03/01/">2018/03/01/</a></li>
<li>原子DDL的实现过程 - <a href="http://mysql.taobao.org/monthly/2018/03/02/">2018/03/02/</a></li>
<li>常用SQL语句的MDL加锁源码分析 - <a href="http://mysql.taobao.org/monthly/2018/02/01/">2018/02/01/</a></li>
<li>权限浅析 - <a href="http://mysql.taobao.org/monthly/2018/02/03/">2018/02/03/</a></li>
<li>新连接的建立 - <a href="http://mysql.taobao.org/monthly/2018/02/07/">2018/02/07/</a></li>
<li>InnoDBLRUList刷脏改进之路 - <a href="http://mysql.taobao.org/monthly/2017/11/05/">2017/11/05/</a></li>
<li>Innodb引擎Redo日志存储格式简介 - <a href="http://mysql.taobao.org/monthly/2017/09/07/">2017/09/07/</a></li>
<li>一条insert语句的执行过程 - <a href="http://mysql.taobao.org/monthly/2017/09/10/">2017/09/10/</a></li>
<li>MySQLreplicationpartialtransaction - <a href="http://mysql.taobao.org/monthly/2017/08/03/">2017/08/03/</a></li>
<li>mysql认证阶段漫游 - <a href="http://mysql.taobao.org/monthly/2017/08/05/">2017/08/05/</a></li>
<li>内存分配机制 - <a href="http://mysql.taobao.org/monthly/2017/08/06/">2017/08/06/</a></li>
<li>SHUTDOWN过程 - <a href="http://mysql.taobao.org/monthly/2017/08/09/">2017/08/09/</a></li>
<li>InnoDB异步IO工作流程 - <a href="http://mysql.taobao.org/monthly/2017/07/10/">2017/07/10/</a></li>
<li>Tokudb序列化和反序列化过程 - <a href="http://mysql.taobao.org/monthly/2017/06/01/">2017/06/01/</a></li>
<li>InnoDBRepeatableRead隔离级别之大不同 - <a href="http://mysql.taobao.org/monthly/2017/06/07/">2017/06/07/</a></li>
<li>MySQL半同步复制数据一致性分析 - <a href="http://mysql.taobao.org/monthly/2017/04/01/">2017/04/01/</a></li>
<li>MySQLBINLOG半同步复制数据安全性分析 - <a href="http://mysql.taobao.org/monthly/2017/03/07/">2017/03/07/</a></li>
<li>词法分析及其性能优化 - <a href="http://mysql.taobao.org/monthly/2017/02/04/">2017/02/04/</a></li>
<li>无法revoke单库或单表权限 - <a href="http://mysql.taobao.org/monthly/2016/10/06/">2016/10/06/</a></li>
<li>QueryCache并发处理 - <a href="http://mysql.taobao.org/monthly/2016/08/09/">2016/08/09/</a></li>
<li>网络通信模块浅析 - <a href="http://mysql.taobao.org/monthly/2016/07/04/">2016/07/04/</a></li>
<li>QueryCache内部剖析 - <a href="http://mysql.taobao.org/monthly/2016/07/09/">2016/07/09/</a></li>
<li>InnoDB伙伴内存分配系统实现分析 - <a href="http://mysql.taobao.org/monthly/2020/09/04/">2020/09/04/</a></li>
<li>PerconaXtraBackup备份原理 - <a href="http://mysql.taobao.org/monthly/2016/03/07/">2016/03/07/</a></li>
<li>一些流行引擎存储格式简介 - <a href="http://mysql.taobao.org/monthly/2017/10/04/">2017/10/04/</a></li>
<li>InnoDB对binlog_format的限制 - <a href="http://mysql.taobao.org/monthly/2018/08/04/">2018/08/04/</a></li>
<li>8.0对WAL的设计修改 - <a href="http://mysql.taobao.org/monthly/2018/06/01/">2018/06/01/</a></li>
<li>8.0WriteSet并行复制 - <a href="http://mysql.taobao.org/monthly/2018/06/04/">2018/06/04/</a></li>
<li>MySQL8.0资源组(ResourceGroups) - <a href="http://mysql.taobao.org/monthly/2018/05/03/">2018/05/03/</a></li>
<li>MySQL的预编译功能 - <a href="http://mysql.taobao.org/monthly/2018/04/07/">2018/04/07/</a></li>
<li>(deleted)临时空间 - <a href="http://mysql.taobao.org/monthly/2018/04/08/">2018/04/08/</a></li>
<li>innodb_buffer_pool_size在线修改 - <a href="http://mysql.taobao.org/monthly/2018/03/06/">2018/03/06/</a></li>
<li>LOGICAL_CLOCK并行复制原理及实现分析 - <a href="http://mysql.taobao.org/monthly/2017/12/03/">2017/12/03/</a></li>
<li>MySQL5.7外部XAReplication实现及缺陷分析 - <a href="http://mysql.taobao.org/monthly/2017/11/06/">2017/11/06/</a></li>
<li>数据一样checksum不一样 - <a href="http://mysql.taobao.org/monthly/2017/10/08/">2017/10/08/</a></li>
<li>浅谈MySQL5.7XA事务改进 - <a href="http://mysql.taobao.org/monthly/2017/09/05/">2017/09/05/</a></li>
<li>利用gdb跟踪MDL加锁过程 - <a href="http://mysql.taobao.org/monthly/2017/09/06/">2017/09/06/</a></li>
<li>到底是谁执行了FTWL - <a href="http://mysql.taobao.org/monthly/2017/08/04/">2017/08/04/</a></li>
<li>commontableexpression - <a href="http://mysql.taobao.org/monthly/2017/04/05/">2017/04/05/</a></li>
<li>5.7errorlog时区和系统时区不同 - <a href="http://mysql.taobao.org/monthly/2017/01/09/">2017/01/09/</a></li>
<li>直方图的实现与分析 - <a href="http://mysql.taobao.org/monthly/2016/10/09/">2016/10/09/</a></li>
<li>执行计划缓存设计与实现 - <a href="http://mysql.taobao.org/monthly/2016/09/04/">2016/09/04/</a></li>
<li>MySQL5.7新特性系列四 - <a href="http://mysql.taobao.org/monthly/2016/08/01/">2016/08/01/</a></li>
<li>MyRocks简介 - <a href="http://mysql.taobao.org/monthly/2016/08/03/">2016/08/03/</a></li>
<li>MySQL5.7新特性系列三 - <a href="http://mysql.taobao.org/monthly/2016/07/01/">2016/07/01/</a></li>
<li>5.7代价模型浅析 - <a href="http://mysql.taobao.org/monthly/2016/07/02/">2016/07/02/</a></li>
<li>innodb锁分裂继承与迁移 - <a href="http://mysql.taobao.org/monthly/2016/06/01/">2016/06/01/</a></li>
<li>MySQL5.7新特性系列二 - <a href="http://mysql.taobao.org/monthly/2016/06/02/">2016/06/02/</a></li>
<li>内部临时表 - <a href="http://mysql.taobao.org/monthly/2016/06/07/">2016/06/07/</a></li>
<li>MySQL5.7新特性系列一 - <a href="http://mysql.taobao.org/monthly/2016/05/02/">2016/05/02/</a></li>
<li>innodbbufferpool相关特性 - <a href="http://mysql.taobao.org/monthly/2016/05/04/">2016/05/04/</a></li>
<li>InnoDBtransactionhistory - <a href="http://mysql.taobao.org/monthly/2016/02/03/">2016/02/03/</a></li>
<li>线程池 - <a href="http://mysql.taobao.org/monthly/2016/02/09/">2016/02/09/</a></li>
<li>优化器MRR&amp;BKA - <a href="http://mysql.taobao.org/monthly/2016/01/04/">2016/01/04/</a></li>
<li>droptable的优化 - <a href="http://mysql.taobao.org/monthly/2016/01/07/">2016/01/07/</a></li>
<li>IndexConditionPushdown(ICP) - <a href="http://mysql.taobao.org/monthly/2015/12/08/">2015/12/08/</a></li>
<li>企业版特性一览 - <a href="http://mysql.taobao.org/monthly/2015/12/10/">2015/12/10/</a></li>
<li>StatementDigest - <a href="http://mysql.taobao.org/monthly/2015/11/02/">2015/11/02/</a></li>
<li>MDL实现分析 - <a href="http://mysql.taobao.org/monthly/2015/11/04/">2015/11/04/</a></li>
<li>跟踪Metadatalock - <a href="http://mysql.taobao.org/monthly/2015/10/02/">2015/10/02/</a></li>
<li>MySQL权限存储与管理 - <a href="http://mysql.taobao.org/monthly/2015/10/10/">2015/10/10/</a></li>
<li>5.6并行复制恢复实现 - <a href="http://mysql.taobao.org/monthly/2015/09/07/">2015/09/07/</a></li>
<li>5.6并行复制事件分发机制 - <a href="http://mysql.taobao.org/monthly/2015/09/09/">2015/09/09/</a></li>
<li>OnlineDDL工具gh-ost支持阿里云RDS - <a href="http://mysql.taobao.org/monthly/2018/05/02/">2018/05/02/</a></li>
<li>MariaDB10.2前瞻 - <a href="http://mysql.taobao.org/monthly/2016/09/03/">2016/09/03/</a></li>
<li>InnoDBPageCompression - <a href="http://mysql.taobao.org/monthly/2015/08/01/">2015/08/01/</a></li>
<li>MySQL5.6.26ReleaseNote解读 - <a href="http://mysql.taobao.org/monthly/2015/08/03/">2015/08/03/</a></li>
<li>MariaDBInnoDB表空间碎片整理 - <a href="http://mysql.taobao.org/monthly/2015/08/05/">2015/08/05/</a></li>
<li>MySQL内存分配支持NUMA - <a href="http://mysql.taobao.org/monthly/2015/07/06/">2015/07/06/</a></li>
<li>MariaDBRole体系 - <a href="http://mysql.taobao.org/monthly/2015/06/09/">2015/06/09/</a></li>
<li>5.6.23InnoDB相关Bugfix - <a href="http://mysql.taobao.org/monthly/2015/02/02/">2015/02/02/</a></li>
<li>MariaDB10.2GA - <a href="http://mysql.taobao.org/monthly/2017/06/10/">2017/06/10/</a></li>
<li>OracleOpenWorld2016见闻 - <a href="http://mysql.taobao.org/monthly/2016/10/02/">2016/10/02/</a></li>
<li>PerconaLive2016见闻 - <a href="http://mysql.taobao.org/monthly/2016/10/03/">2016/10/03/</a></li>
<li>MariaDBDeveloperMeeting2016 - <a href="http://mysql.taobao.org/monthly/2016/10/04/">2016/10/04/</a></li>
<li>OOW2015总结MySQL篇 - <a href="http://mysql.taobao.org/monthly/2015/11/01/">2015/11/01/</a></li>
<li>AliSQL那些事儿 - <a href="http://mysql.taobao.org/monthly/2016/09/01/">2016/09/01/</a></li>
<li>MySQL的那些网络超时错误 - <a href="http://mysql.taobao.org/monthly/2017/05/04/">2017/05/04/</a></li>
<li>备库Seconds_Behind_Master计算 - <a href="http://mysql.taobao.org/monthly/2016/03/09/">2016/03/09/</a></li>
<li>MySQL锁问题最佳实践 - <a href="http://mysql.taobao.org/monthly/2016/03/10/">2016/03/10/</a></li>
<li>mysqldumptips两则 - <a href="http://mysql.taobao.org/monthly/2016/02/10/">2016/02/10/</a></li>
<li>物理备份死锁分析 - <a href="http://mysql.taobao.org/monthly/2016/01/05/">2016/01/05/</a></li>
<li>GTID不一致分析 - <a href="http://mysql.taobao.org/monthly/2016/01/08/">2016/01/08/</a></li>
<li>MySQL优化器range的代价计算 - <a href="http://mysql.taobao.org/monthly/2015/11/07/">2015/11/07/</a></li>
<li>索引过滤性太差引起CPU飙高分析 - <a href="http://mysql.taobao.org/monthly/2015/10/03/">2015/10/03/</a></li>
<li>openfilelimits - <a href="http://mysql.taobao.org/monthly/2015/08/07/">2015/08/07/</a></li>
<li>外键删除bug分析 - <a href="http://mysql.taobao.org/monthly/2015/07/07/">2015/07/07/</a></li>
<li>浮点型的显示问题 - <a href="http://mysql.taobao.org/monthly/2015/07/10/">2015/07/10/</a></li>
<li>MySQLSort分页 - <a href="http://mysql.taobao.org/monthly/2015/06/04/">2015/06/04/</a></li>
<li>binlogevent中的errorcode - <a href="http://mysql.taobao.org/monthly/2015/06/05/">2015/06/05/</a></li>
<li>InnoDB预读VSOracle多块读 - <a href="http://mysql.taobao.org/monthly/2015/05/04/">2015/05/04/</a></li>
<li>setnames都做了什么 - <a href="http://mysql.taobao.org/monthly/2015/05/07/">2015/05/07/</a></li>
<li>binlog位点刷新策略 - <a href="http://mysql.taobao.org/monthly/2015/05/10/">2015/05/10/</a></li>
<li>UPDATE交换列单表和多表的区别 - <a href="http://mysql.taobao.org/monthly/2015/04/08/">2015/04/08/</a></li>
<li>GTID下auto_position=0时数据不一致 - <a href="http://mysql.taobao.org/monthly/2015/04/10/">2015/04/10/</a></li>
<li>并发Replaceinto导致的死锁分析 - <a href="http://mysql.taobao.org/monthly/2015/03/01/">2015/03/01/</a></li>
<li>usingfilesortVSusingtemporary - <a href="http://mysql.taobao.org/monthly/2015/03/04/">2015/03/04/</a></li>
<li>lower_case_table_names使用问题 - <a href="http://mysql.taobao.org/monthly/2015/03/07/">2015/03/07/</a></li>
<li>InnoDB丢失自增值 - <a href="http://mysql.taobao.org/monthly/2015/02/05/">2015/02/05/</a></li>
<li>5.5和5.6时间类型兼容问题 - <a href="http://mysql.taobao.org/monthly/2015/02/06/">2015/02/06/</a></li>
<li>binlogevent有序性 - <a href="http://mysql.taobao.org/monthly/2014/12/05/">2014/12/05/</a></li>
<li>server_id为0的Rotate - <a href="http://mysql.taobao.org/monthly/2014/12/06/">2014/12/06/</a></li>
<li>text字段数 - <a href="http://mysql.taobao.org/monthly/2014/10/02/">2014/10/02/</a></li>
<li>key分区算法演变分析 - <a href="http://mysql.taobao.org/monthly/2015/01/06/">2015/01/06/</a></li>
<li>5.6GTID和存储引擎那会事 - <a href="http://mysql.taobao.org/monthly/2014/12/02/">2014/12/02/</a></li>
<li>GTID和升级 - <a href="http://mysql.taobao.org/monthly/2017/05/08/">2014/09/02/</a></li>
<li>索引篇 - <a href="http://mysql.taobao.org/monthly/2017/02/05/">2017/02/05/</a></li>
</ol>
]]></content>
      <categories>
        <category>资源推荐</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>资源推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（二）：策略模式</title>
    <url>/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><blockquote>
<p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
</blockquote>
<p>策略模式旨在解决不同逻辑下相同的对象执行不同策略的问题。</p>
<p>当我们遇到同一个方法，里面会根据需要多个逻辑的分支，分支里的行为都不同，但是都服务于同一个功能，这个时候就可以使用策略模式，将行为抽象为一个策略接口中的抽象方法，由接口的实现类——也就是策略类——去实现各中具体的行为。</p>
<p>策略模式也是一种比较常见且好用的设计模式，线程池的拒绝策略就使用了策略模式。</p>
<h2><span id="一-简单实现">一、简单实现</span></h2><p>简单的拿一个根据情况需要导出不同文件的接口举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;excel&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 导出excel</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;word&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 导出word</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;pdf&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 导出pdf</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些分支里目的都是导出文件，但是各自有各的实现代码。换而言之，这些不同逻辑分支下的代码只有行为是不同的。现在我们将导出方法抽象成为一个策略接口中的抽象方法，将每个逻辑分支的处理代码都抽成实现策略接口的各个策略类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件导出接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">IExportFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">export</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportExcel</span> <span class="keyword">implements</span> <span class="title">IExportFile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 导出excel</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportWord</span> <span class="keyword">implements</span> <span class="title">IExportFile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 导出word</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportPdf</span> <span class="keyword">implements</span> <span class="title">IExportFile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 导出pdf</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用的时候直接将接口实现类作为参数传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改造原有方法，将策略接口的实现作为参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    IExportFile exportFile;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;excel&quot;</span>) &#123;</span><br><span class="line">        exportFile = <span class="keyword">new</span> ExportExcel();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;word&quot;</span>) &#123;</span><br><span class="line">        exportFile = <span class="keyword">new</span> ExportWord();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;pdf&quot;</span>) &#123;</span><br><span class="line">        exportFile = <span class="keyword">new</span> ExportPdf();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    exportFile.export();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，原本耦合在调用方法里的行为被解放出来了，通过为策略接口更换策略类，我们可以很方便的切换行为。</p>
<p><img src="http://img.xiajibagao.top/image-20201120131208948.png" alt="策略模式改进原有方法"></p>
<h2><span id="二-策略池与上下文对象">二、策略池与上下文对象</span></h2><p><strong>策略池</strong></p>
<p>根据上文的简单例子，我们将具体的策略通过策略接口与调用方法耦合了，但是我们不难发现，现在的<strong>实现仍然需要通过大量的 if-else 判断去选择执行策略</strong>。</p>
<p>实际上，我们可以这么考虑，代码被封装到实现类里以后，实际上一个<strong>策略跟对应的判断条件实际上就是一种 key 和 value 之间的映射关系</strong>了，我们可以根据这个思路，换一个更简洁一些的方式去替换 if-else 的代码：比如<strong>将条件字段与策略类放入 Map 集合实现的一个策略池中，直接通过 key 去获取对应的策略类</strong>。</p>
<p>还是基于上述导出接口的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略池</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;String,IExportFile&gt; exportStrategyPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;excel&quot;</span>, <span class="keyword">new</span> ExportExcel());</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;word&quot;</span>, <span class="keyword">new</span> ExportWord());</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;pdf&quot;</span>, <span class="keyword">new</span> ExportPdf());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!exportStrategyPool.containsKey(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    IExportFile exportFile = exportStrategyPool.get(type);</span><br><span class="line">    exportFile.export();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，通过策略池，我们直接简化了大量的 if-else 代码。</p>
<p>实际上，<strong>考虑到实现类是无状态的，那么策略类和策略池都应该是单例的</strong>，因此，这里使用了饿汉式去创建策略池，这里同样有许多优化的地方：比如可以手动创建改为通过反射自动装填策略类；可以创建枚举类或者将条件作为常量来规范策略的对应关系；如果在 spring 项目中，也可以考虑通过 spring 去创建……</p>
<p>这些的都可以根据需求进行优化的，但是核心仍然是在调用前<strong>建立条件与策略的映射关系</strong>。</p>
<p><img src="http://img.xiajibagao.top/image-20201120140547234.png" alt="策略池的实现"></p>
<p><strong>上下文对象</strong></p>
<p>现在，出于优化 if-else 的原因，我们为导出方法加入了策略池，但是这个类的其他方法未必用得到，为此我们不妨将整个策略池和导出方法都封装到另一个单独的类里，只提供一个带条件参数的方法。现在策略池归上下文对象管理了，那么这个<strong>上下文对象也应该是单例的</strong>，就个人观点，单独放到一个独立的 Service 和对应一个实现类，由 spring 管理应该是比较合适的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileExporter 屏蔽了方法的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,IExportFile&gt; exportStrategyPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exportStrategyPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;excel&quot;</span>, FileExporter::exportExcel);</span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;word&quot;</span>, FileExporter::exportWord);</span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;pdf&quot;</span>, FileExporter::exportPdf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exportStrategyPool.containsKey(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        IExportFile exportFile = exportStrategyPool.get(type);</span><br><span class="line">        exportFile.export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">new</span> FileExporter().exportFile(<span class="string">&quot;word&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过 FileExporter 这个承上启下的上下文对象，我们屏蔽了具体代码的实现，同时通过“人”去调用“行为”这个逻辑也更符合面向对象的思想。</p>
<p><img src="http://img.xiajibagao.top/image-20201120141054014.png" alt="上下文对象"></p>
<h2><span id="三-配合函数式接口使用">三、配合函数式接口使用</span></h2><p>策略模式+策略池的手段已经可以解决传统 if-else 的大多数问题了，但是他也随之带来了两个问题：</p>
<ul>
<li>一个方法要用到的策略会产生大量实现类；</li>
<li>业务逻辑被分散到了各个实现类，无法方便的总览。</li>
</ul>
<p>为此，JDK8 的函数式接口刚好能非常完美的解决这些痛点。</p>
<p>关于函数式接口，我已在<a href="https://blog.xiajibagao.top/2020/11/02/java/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JDK1.8新特性（三）：Lambda表达式</a>里介绍过了，这里就不再赘述，直接上手。</p>
<p>还是以上文的文件导出接口为例：</p>
<p>当我们完成这个功能以后，我们会在原来的基础上多处一个上下文对象，一个策略接口，<strong>以及 n 多个实现接口的策略类</strong>，一个策略对应一个策略实现类的问题是导致类数量膨胀的原因，因此我们可以将策略接口替换为函数式接口，这样就可以在需要的时<strong>直接通过 Lambda 表达式传入实现类，避免新建类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将原本的IExportFile改为函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IExportFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">export</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在策略池阶段直接放入匿名实现类</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;String,IExportFile&gt; exportStrategyPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;excel&quot;</span>, () -&gt; System.out.println(<span class="string">&quot;excel&quot;</span>));</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;word&quot;</span>, () -&gt; System.out.println(<span class="string">&quot;excel&quot;</span>));</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;pdf&quot;</span>, () -&gt; System.out.println(<span class="string">&quot;excel&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，实际工作中的方法肯定比区区一句 <code>System.out.println()</code>要复杂的多，我们不可能集中在策略池里写实现。这个问题也很好解决，我们可以将具体的方法抽出来放到一个实现类里，比 service 的实现类，或者上下文对象中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,IExportFile&gt; exportStrategyPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exportStrategyPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;excel&quot;</span>, <span class="keyword">this</span>::exportExcel);</span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;word&quot;</span>, <span class="keyword">this</span>::exportWord);</span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;pdf&quot;</span>, <span class="keyword">this</span>::exportPdf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exportStrategyPool.containsKey(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        IExportFile exportFile = exportStrategyPool.get(type);</span><br><span class="line">        exportFile.export();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 导出的策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出excel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出word&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportPdf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出pdf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，业务代码可以都放在一个类里面了，总览起来也非常方便。</p>
<h2><span id="四-总结">四、总结</span></h2><p>通过策略模式，我们可以做到：</p>
<ol>
<li>通过将行为抽象为一个策略接口，具体的行为作为接口的实现类，来分离方法和逻辑分支中的代码；</li>
<li>通过策略池来避免大量的 if-else 判断；</li>
<li>通过将策略池和方法封装到上下文对象来对外部屏蔽底层的实现；</li>
</ol>
<p>对于策略模式带来的策略类过多，业务逻辑分散的问题：</p>
<ol>
<li>将策略接口改为函数式接口，省去创建实现类，直接通过 Lambda 表达式直接传入匿名实现类；</li>
<li>在上述基础上，将实现方法统一写在一个类里，策略池在创建时通过 Lambda 表达式把类中的方法传入策略池。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（三）：代理模式</title>
    <url>/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><blockquote>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
</blockquote>
<p>策略模式旨在不改变被代理对象的基础上进行方法增强。</p>
<p>当我们一个原有的类不能满足功能，又处于职责或其他原因不便修改的时候，我们可以使用代理模式。通过代理类去调用被代理类的方法，在原方法的基础上进行各种加强，又不会改变原代码。</p>
<p>spring 中的 AOP 就运用了代理模式。</p>
<h2><span id="一-静态代理">一、静态代理</span></h2><p>为了简单的说明代理模式，我们举个例子：</p>
<p>首先有一个接口，叫做购房者，然后这个类地下有一个实现类，叫做小明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//购房者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 买房</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小明实现了购房者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> <span class="keyword">implements</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小明买了一套房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>买房子还要货比三家，小明没时间，于是就把买房子这件事情委托给中介</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intermediary</span> <span class="keyword">implements</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XiaoMing xiaoMing ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明把权限委托给了中介</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Intermediary</span><span class="params">(XiaoMing xiaoMing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.xiaoMing = xiaoMing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这基础上又添加了挑选方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;房中介先挑了最合适的房&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中介让XiaoMing这个类执行了购房的动作</span></span><br><span class="line">        xiaoMing.buy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这基础上又添加了抽成方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;买完房中介要那点抽成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\代码及jar包\学习记录\设计模式\小明买房（静态代理）.png" alt="小明买房（静态代理）"></p>
<p>在这个例子里：</p>
<ul>
<li>被代理对象是小明这个类，是我们最终要访问的；</li>
<li>代理对象就是中介这个类，他是被代理对象的加强，我们通过代理对象去访问目标对象，在这基础上对其进行加强。</li>
</ul>
<p>为了做到代理的效果，代理对象和目标对象<strong>需要实现同一个接口或者继承同一个类</strong>，以达到通过代理对象的方法去调用被代理对象的方法。这种方法叫做<strong>静态代理</strong>。</p>
<h2><span id="二-动态代理">二、动态代理</span></h2><p>通过静态代理，我们可以在不改变代理类代码的基础上进行方法增强，但是如果有很多这样的代理行为，那么就需要很多代理类或者代理类去实现很多接口的方法，这样做显然会来带麻烦，为此，我们可以选择只在需要的时候才生产代理对象，这就是动态代理。</p>
<p>针对动态代理，有两种实现方法：</p>
<ul>
<li>JDK 代理，通过 JDK 的 API 实现；</li>
<li>CGLib 代理，通过 CGLib 包实现。</li>
</ul>
<h3><span id="1-jdk代理">1. JDK代理</span></h3><p>JDK 代理仍然需要被代理去实现某个接口，因为 JDK 代理的方式本质仍然还是生成一个与被代理类继承同一个接口的类，去代替被代理类的方法提供调用，但是和静态代理不同，这个代理对象由代码在调用的时候动态生成。</p>
<p>我们可以先看看实现代理效果的核心方法<code>Proxy.newProxyInstance()</code>的注释：</p>
<blockquote>
<p>返回指定接口的代理类的实例，该实例将方法调用分派到指定的调用处理程序。 </p>
<p>参数：</p>
<p><code>ClassLoader loader</code>：指定加载被代理对象的类加载器</p>
<p><code>Class&lt;?&gt;[] interfaces</code>：被代理对象实现的接口的类型,使用泛型方式确认类型</p>
<p><code>InvocationHandler h</code>：事件处理,执行被代理对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
</blockquote>
<p>我们需要提供三个参数，被代理类的类的加载器，被代理类实现的结构，一个代理方法要实现的函数式接口。</p>
<p>对于函数式接口 <code>InvocationHandler</code>，我们不妨再看看他的参数：</p>
<blockquote>
<p><code>proxy</code>：在方法上调用方法的代理实例method-与在代理实例上调用的接口方法相对应的Method实例。 </p>
<p><code>Method</code>：对象的声明类将是在其中声明该方法的接口，它可能是代理类通过其继承该方法的代理接口的超接口。</p>
<p> <code>args</code> ：包含在代理实例的方法调用中传递的参数值的对象数组；如果接口方法不带参数，则为null。基本类型的参数包装在适当的基本包装器类的实例中，例如java.lang.Integer或java.lang.Boolean。</p>
</blockquote>
<p>可以说非常直观了，下面我们来简单实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    XiaoMing xiaoMing = <span class="keyword">new</span> XiaoMing();</span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    Buyers proxyBuyers = (Buyers) Proxy.newProxyInstance(</span><br><span class="line">        <span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">        xiaoMing.getClass().getClassLoader(),</span><br><span class="line">        <span class="comment">//获取被代理对象实现的接口</span></span><br><span class="line">        xiaoMing.getClass().getInterfaces(),</span><br><span class="line">        <span class="comment">//让代理对象实现被代理对象实现的接口</span></span><br><span class="line">        (proxy, method, params) -&gt; &#123;</span><br><span class="line">            <span class="comment">//只有对buy方法进行加强，如果不是buy方法就直接执行被代理对象的方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.getName() != <span class="string">&quot;buy&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(xiaoMing, params);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;中介帮小明找到了最合适的房源&quot;</span>);</span><br><span class="line">            method.invoke(xiaoMing, params);</span><br><span class="line">            System.out.println(<span class="string">&quot;中介抽了一笔中介费&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//通过代理对象买房</span></span><br><span class="line">    proxyBuyers.buy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">中介帮小明找到了最合适的房源</span><br><span class="line">小明买了一套房</span><br><span class="line">中介抽了一笔中介费</span><br></pre></td></tr></table></figure>



<h3><span id="2-cglib-代理">2. CGLib 代理</span></h3><p>对于动态代理，我们可以通过JDK的<code>Proxy.newProxyInstance()</code>方法动态的生成一个实现了被代理类指定接口的代理类，那么，如果<strong>被代理类没有实现任何接口</strong>，那我们该怎么办呢？答案就是使用 CGLib 代理。</p>
<p>CGLib 代理的原理就是在内存里创建一个被代理类的对象的子类，然后重写父类要加强的方法，而无需加强的方法就直接使用父类方法。</p>
<p>要使用 CGLib 代理，需要引入 jar 包 （ Spring 的动态代理就是基于 CGLib 实现的，所以 Spring 的依赖里默认就会引入）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XiaoMing xiaoMing = <span class="keyword">new</span> XiaoMing();</span><br><span class="line"><span class="comment">//获取代理对象</span></span><br><span class="line">Buyers proxyBuyers = (Buyers) Enhancer.create(</span><br><span class="line">    <span class="comment">//获取被代理对象的类</span></span><br><span class="line">    xiaoMing.getClass(),</span><br><span class="line">    <span class="comment">//实现代理逻辑切入类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o 代理类对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> method 要拦截的被代理类的方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> objects 被代理类的方法参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodProxy 要触发父类的方法对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName() != <span class="string">&quot;buy&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">//注意，这里参数是o，调用的是invokeSuper</span></span><br><span class="line">                <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;中介帮小明找到了最合适的房源&quot;</span>);</span><br><span class="line">            <span class="comment">//注意，这里参数是xiaoMing，调用的是invoke</span></span><br><span class="line">            methodProxy.invoke(xiaoMing, objects);</span><br><span class="line">            System.out.println(<span class="string">&quot;中介抽了一笔中介费&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">proxyBuyers.buy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般为了方便使用，我们会将代理过程整合到一个代理工厂类中。</p>
<p><strong>由于需要生成子类，所以要被代理的类最好不能用final修饰</strong></p>
<p><strong>如何选择代理模式</strong></p>
<ul>
<li>JDK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低。</li>
<li>如果是单例的代理，推荐使用CGLib</li>
</ul>
<p>也就是说，<strong>如果需要频繁的创建代理对象（多例），那么就该选择JDK代理，否则（单例）使用CGLib代理</strong></p>
<h2><span id="四-总结">四、总结</span></h2><p>对于两种代理模式：</p>
<ul>
<li>静态代理：被代理类和代理类需要实现相同接口，通过组合的方式，在代理类实例化时将被代理类作为参数传入；</li>
<li>动态代理：通过 JDK 自带的 <code>Proxy.newProxyInstance</code>，在需要的时候动态生成代理类，解决了静态代理需要创建大量代理类的缺点；</li>
<li>CGLib 代理：通过 CGLib 动态生成被代理类的子类来实现代理，解决了动态代理还需要被代理类去实现接口的缺点。</li>
</ul>
<p>对于动态代理中 JDK 代理和 CGLib 代理的选择：</p>
<ul>
<li>需要频繁的创建代理对象选择 JDK 代理</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次使用策略模式优化代码的经历</title>
    <url>/2020/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h2><span id="一-背景">一、背景</span></h2><p>之前接手了一个 springboot 项目。在我负责的模块中，有一块用户注册的功能，但是比较特别的是这个注册并不是重新注册，而是从以前的旧系统的数据库中同步旧数据到新系统的数据库中。由于这些用户角色来自于不同的系统，所以我需要在注册的时候先判断类型（这个类型由一个专门的枚举类提供），再去调用已经写好的同步方法同步数据。</p>
<p>伪代码大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String type, String userId, String projectId, String declareId)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断用户类型</span></span><br><span class="line">    <span class="keyword">if</span> (UserSynchronizeTyeEnum.A.type.equals(type)) &#123;</span><br><span class="line">        <span class="comment">// 同步A类型的数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UserSynchronizeTyeEnum.A.type.equals(type)) &#123;</span><br><span class="line">        <span class="comment">// 同步B类型的数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不存在的用户类型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于用户的类型比较多，所以当我接手的时候已经有8个 if-esle 了，由于这个项目会逐步的跟其他平台对接，要同步的用户类型会越来越多，而且也不能排除什么时候不新增，反而要取消一部分类型的同步情况。</p>
<p>就这个情况来说，一方面<strong>每一次新增或删除类型都需要修改 if-else 上逻辑分支</strong>，如果需要新增一些同步前的处理的步骤（根据经验这种情况几乎一定会出现的），<strong>大概率代码会直接被加在 if-else 方法里头</strong>；另一方面，这个业务的需求也有相对稳定的地方：<strong>同步方法会不一样，但是一定会根据类型来判断</strong>。出于以上考虑，我决定趁现在牵扯范围不大的时候重构一下。</p>
<h2><span id="二-思路">二、思路</span></h2><h3><span id="1抽取策略接口和策略类">1.抽取策略接口和策略类</span></h3><p>首先，由于每种用户类型的同步方法是由各模块自己提供的，其实已经算是抽出了策略，只是没有实现一个统一的策略接口。</p>
<p>但是我在这一步遇上了问题：</p>
<ul>
<li>各模块的同步方法的名称不全部一样；</li>
<li>由于年代久远，旧代码是不允许改的。</li>
</ul>
<p>代码不让改，就没法通过为旧实现类新增接口实现多态，方法名不一样，那么反射这条路子也走不通。我想到了装饰器，为每个实现类新增一个装饰器类，注册的时候通过装饰器去调用同步方法，但是这样缺点很明显，会引入一个装饰器接口+n多个装饰器类，为了优化这一个方法，反而要引入十几个类，这样反而违背初衷。</p>
<p>但是好在天无绝人之路，他们并不是完全没有相同点：</p>
<ul>
<li>虽然参数名不一样，但是<strong>每个同步方法都需要的参数数量和类型都是一样</strong>的；</li>
<li><strong>他们都返回一个布尔值</strong></li>
</ul>
<p>这让我想起了 JDK8 的函数式接口，将策略接口改造为函数式接口，由于同步方法的参数和返回值类型都是一样的，就可以直接以 Lambda 表达式的形式将各个模块的同步方法放进去，这样就不需要改动模块的代码了。</p>
<p>新增的接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserSynchronizeSerivice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sync</span><span class="params">(String userId, String projectId, String declareId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2策略池的实现">2.策略池的实现</span></h3><p>接着，为了实现原本 if-else 的逻辑，我需要一个策略池，能够建立起一个用户类型跟对应的同步策略的映射关系，一开始，我打算直接写在 <code>register()</code>方法所在的类中加入以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AUserService aUserService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> BUserService bUserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, UserSynchronizeTyeEnum.IUserSynchronizeService&gt; synchronizeServiceStrategy = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">strategyInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// spring容器启动后将策略装入策略池</span></span><br><span class="line">    <span class="comment">// A类型用户的同步方法叫synchronization，而B类型用户的叫sync</span></span><br><span class="line">    synchronizeServiceStrategy.put(UserSynchronizeTyeEnum.A.type, aUserService::synchronization);</span><br><span class="line">    synchronizeServiceStrategy.put(UserSynchronizeTyeEnum.B.type, bUserService::sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样在添加新的用户类型时，需要先去枚举类添加新枚举，然后再回到<code>register()</code>所在的类为策略池添加策略，这个两个逻辑上相连的过程被分散到了两个地方，而且仍然要修改<code>register()</code>所在类的代码。所以决定不用上述的代码，而是去对枚举类下手。</p>
<p>原本的枚举类是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老系统用户注册，用户类型与同步方法的枚举类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserSynchronizeTyeEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型A的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    A(<span class="string">&quot;a&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型B的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    B(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    UserSynchronizeTyeEnum(String type) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了保证逻辑能够集中，我决定将添加策略这一过程一起放到到枚举类里，在添加枚举的时候就把策略一起放进去：</p>
<blockquote>
<p>注：下文的 SpringUtils 实现了 BeanFactoryPostProcessor 接口，是一个用于从 ConfigurableListableBeanFactory 获取对象的工具类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老系统用户注册，用户类型与同步方法的枚举类</span></span><br><span class="line"><span class="comment"> * 添加新类型时，需要将模块对应的同步方法一并放入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserSynchronizeTyeEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型A的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    A(<span class="string">&quot;a&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同步前，可以对A类型的用户数据进行一些其他处理</span></span><br><span class="line">        <span class="keyword">return</span> SpringUtils.getBean(AUserService.class).synchronization(userId, projectId, declareId);</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型B的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    B(<span class="string">&quot;b&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同步前，可以对B类型的用户数据进行一些其他处理</span></span><br><span class="line">        <span class="keyword">return</span> SpringUtils.getBean(BUserService.class).sync(userId, projectId, declareId);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserSynchronizeService synchronizeService;</span><br><span class="line"></span><br><span class="line">    UserSynchronizeTyeEnum(String type, IUserSynchronizeService synchronizeService) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.synchronizeService = synchronizeService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于由于枚举类已经相当于之前策略池的 Map 集合了，所以我们直接在里面添加一个 <code>getSynchronizeService()</code>方法，用于直接获取同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据枚举值获取对应同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;IUserSynchronizeService&gt; <span class="title">getSynchronizeService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (UserSynchronizeTyeEnum tyeEnum : UserSynchronizeTyeEnum.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tyeEnum.type.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.of(tyeEnum.synchronizeService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，策略池已经基本完成了，我们对原本的 if-else 中的同步方法进行在次封装，现在如果需要在同步前做些其他的处理也可以直接卸载 Lambda 里头，同步策略的具体实现不再与 <code>register()</code>方法有关，它变回了纯粹的用户同步/注册的方法。</p>
<p>但是我们不难发现，现在为策略接口添加实现的地方也变成了枚举类中，策略接口 <code>IUserSynchronizeService</code> 一般也不会被用在其他地方，因此不妨<strong>把策略接口也一并引入枚举类中，让他成为一个枚举类的内部接口</strong>。</p>
<p>现在，枚举类是这样的：</p>
<p><img src="http://img.xiajibagao.top/image-20201121161017904.png" alt="策略模式的枚举类"></p>
<p>枚举类堆外只暴露根据类型获取方法的<code>IUserSynchronizeService()</code> 方法，以及 A 和 B 两个枚举。</p>
<p>完整的 <code>UserSynchronizeTyeEnum</code>枚举类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老系统用户注册，用户类型与同步方法的枚举类</span></span><br><span class="line"><span class="comment"> * 添加新类型时，需要将模块对应的同步方法一并放入。待用户注册时，会遍历枚举对象并根据类型获取对应的同步方法执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserSynchronizeTyeEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型A的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    A(<span class="string">&quot;a&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同步前，可以对A类型的用户数据进行一些其他处理</span></span><br><span class="line">        <span class="keyword">return</span> SpringUtils.getBean(AUserService.class).synchronization(userId, projectId, declareId);</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型B的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    B(<span class="string">&quot;b&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同步前，可以对B类型的用户数据进行一些其他处理</span></span><br><span class="line">        <span class="keyword">return</span> SpringUtils.getBean(BUserService.class).sync(userId, projectId, declareId);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> IUserSynchronizeService synchronizeService;</span><br><span class="line"></span><br><span class="line">    UserSynchronizeTyeEnum(String type, IUserSynchronizeService synchronizeService) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.synchronizeService = synchronizeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据枚举值获取对应同步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;IUserSynchronizeService&gt; <span class="title">getSynchronizeService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (UserSynchronizeTyeEnum tyeEnum : UserSynchronizeTyeEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tyeEnum.type.equals(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.of(tyeEnum.synchronizeService);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法需要符合函数式接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserSynchronizeService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">sync</span><span class="params">(String userId, String projectId, String declareId)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="三-使用">三、使用</span></h2><p>现在，改造完毕，可以开始使用了，对于原先的 <code>register()</code>方法，现在改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String type, String userId, String projectId, String declareId)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取同步方法，没有就抛异常</span></span><br><span class="line">    UserSynchronizeTyeEnum.IUserSynchronizeService synchronizeService = UserSynchronizeTyeEnum.getSynchronizeService(type)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">&quot;类型不存在&quot;</span>));</span><br><span class="line">    <span class="comment">// 同步用户数据</span></span><br><span class="line">    synchronizeService.sync(userId, projectId, declareId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要再添加一个 C 类用户的同步注册的时候，只需要前往枚举类添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型C的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">C(<span class="string">&quot;c&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> SpringUtils.getBean(CUserService.class).sync(userId, projectId, declareId);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>即可，<code>register()</code>方法就不需要再做修改了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工作见闻</tag>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（四）：模板方法模式</title>
    <url>/2020/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><blockquote>
<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
</blockquote>
<p>模板方法模式旨在为一些方法的主体部分提供骨架，将具体细节上的一些实现延迟到他的实现类。</p>
<p>JDBC 运用了模板模式。JDK 在实现 List 接口的过程中， AbstractCollection 和 AbstractList  也使用了模板模式。</p>
<h2><span id="一-简单实现">一、简单实现</span></h2><p>举个我在做项目的时候遇到的例子：</p>
<p>假设我们有一个简单的针对 Demo 类的文件导出类，他提供了 Excel 文档的基本导出功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoExcelExporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 导出excel</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Demo&gt; list = getData();</span><br><span class="line">        <span class="keyword">for</span>(Demo d : list) &#123;</span><br><span class="line">        	handle(d);</span><br><span class="line">        &#125;</span><br><span class="line">        excel(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.获取要到导出数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Demo&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2.处理数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Demo demo)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 3.导出的数据集为excel文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excel</span><span class="params">(List&lt;Demo&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要为 Demo2 和 Demo3 这两个类也添加一个导出 Excel 文档的功能，最简单是方式就是复制黏贴，把 Demo 换成 Demo2 和 Demo3。但是这显然不是我们想要的，根据模板模式，我们可以设置一个 ExcelExporter 抽象类作为模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelExporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 导出excel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; list = getData();</span><br><span class="line">        <span class="keyword">for</span>(T t : list) &#123;</span><br><span class="line">            handle(t);</span><br><span class="line">        &#125;</span><br><span class="line">        excel(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取要到导出数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.处理数据集，改为抽象方法，由子类去实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(T demo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.导出的数据集为excel文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excel</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后由子类去继承这个模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Demo类的ExcelExporter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoExcelExporter</span> <span class="keyword">extends</span> <span class="title">ExcelExporter</span>&lt;<span class="title">Demo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Demo demo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demo的处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">new</span> DemoExcelExporter().export();</span><br></pre></td></tr></table></figure>

<p>其他两个类也分别创建自己的 ExcelExporter 类，通过继承模板，他们都直接获得了已经实现了大部分的逻辑的<code>export()</code>方法了，只需要自己再根据需求实现一下 <code>handle</code>方法即可。</p>
<p><img src="http://img.xiajibagao.top/image-20201120171820576.png" alt="模板方法模式改进的ExcelExporter"></p>
<h2><span id="二-模板的继承">二、模板的继承</span></h2><p>模板模式的强大之处在于，模板和模板之间可以通过继承来进一步增强现有的方法。</p>
<p>比如我们现在希望 Demo3 不仅要导出 Excel 模板，还要导出美化排版，我们可以在 ExcelExporter 的基础上继续新增模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BeautifyExportExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span>  <span class="title">ExcelExporter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写了excel方法，在导出前可以先设置一些样式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excel</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        settingStyle();</span><br><span class="line">        <span class="keyword">super</span>.excel(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义要设置的样式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">settingStyle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 Demo3 不再继承 ExcelExporter ，而是去继承 BeautifyExporter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3ExcelExporter</span> <span class="keyword">extends</span> <span class="title">BeautifyExporter</span>&lt;<span class="title">Demo3</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Demo3 demo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demo的处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">settingStyle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置样式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，BeautifyExporter 对 ExcelExporter 定义的逻辑进行了一定的调整，添加了可以设置样式的抽象方法，Demo3ExcelExporter 通过继承了 BeautifyExporter 获得了经过调整之后的 ExcelExporter 的逻辑和方法。</p>
<p><img src="http://img.xiajibagao.top/image-20201120175032833.png" alt="调整之后的 ExcelExporter 的逻辑"></p>
<h2><span id="三-模板模式的特点">三、模板模式的特点</span></h2><h3><span id="1可以修改实现仍然复用逻辑">1.可以修改实现仍然复用逻辑</span></h3><p>实际上，大多数时候我们会选择抽取工具类，比如上述的第一个例子，我们可以把 Demo 换成泛型，这样 Demo2 和 Demo3 也可以复用了。</p>
<p>但是有一个关键的问题：Demo2 和 Demo3 并不是同一个类，他们字段不同，导出中间有些的处理过程也不同，<strong>尽管他们的整体过程大体相同，但是有些地方的处理过程是不一样的</strong>。比如说 <code>getData()</code>和 <code>excel()</code> 这三个类都可用，但是 Demo 的 <code>handle()</code> 方法却不能复用在 Demo2 和 Demo3 。</p>
<p>我们可以妥协一下，只把 <code>getData()</code>和 <code>excel()</code> 提取成公共类，但是实际上整个导出过程的三个方法是连贯的，只提取两个方法，尽管<code>export()</code>中调用的顺序是定死的，最后实现的时候还是需要重复写无数个相同逻辑的<code>export()</code>，也就是说，<strong>我们只复用的方法，而没有复用逻辑</strong>。</p>
<p>所以根据上述的分析，我们可以看出，模板模式最大的优点在于<strong>使子类可以不改变一个算法的结构即可重定义该算法的某些步骤，这使得模板模式可以复用代码逻辑结构</strong>。因为模板父类已经定义好了整个方法执行流程，构建好了骨架和一些关键的步骤，所以子类只需要实现一些关键的步骤，并且根据需求去重写一些父类方法以调整逻辑。</p>
<h3><span id="2扩展方便">2.扩展方便</span></h3><p>相对接口而言，如果接口是简答题，那么抽象类就是填空题。由于模板方法模式使用的是抽象类，业务的实现因此可以是“分步”的，整个功能是可以一层一层完善并且加强，或者做一些调整，这使得一套代码和逻辑可以在各个地方分层复用。</p>
<p>比如下图就是一个例子。</p>
<p><img src="http://img.xiajibagao.top/image-20201120180913712.png" alt="image-20201120180913712"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SpringCache做简单缓存</title>
    <url>/2019/07/23/Spring/%E4%BD%BF%E7%94%A8SpringCache%E5%81%9A%E7%AE%80%E5%8D%95%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>从 spring3 开始，spring 开始支持缓存组件，并提供了一系列非常方便的注解。</p>
<p>其中，Cache 接口定义了基本的增删改查方法，Spring 提供了一些默认的实现，比如 RedisCache 等。 CacheManager 接口则用于接入并获取 Redis 这样的缓存组件。</p>
<p>在 springboot 中，当我们启用缓存以后，需要如果要将接入 Redis 作为缓存，就需要配置 RedisCacheManager，其他缓存组件亦同。当没有自定义的缓存的时候，就会使用默认的 ConcurrentMapCacheManager，即将缓存存入本地的一个 Map 集合中。</p>
<h2><span id="一-配置">一、配置</span></h2><h3><span id="1添加依赖">1.添加依赖</span></h3><p>在创建项目的时候直接在 springboot 启动器中配置，或在项目中添加 Maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-启用注解">2. 启用注解</span></h3><p>在启动类或者配置类里添加 @EnableCaching 注解开启缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootCacheApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootCacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：由于 Spring 的 AOP 基于 CGLib 代理，所以如果在本类调用成员方法，因为不走代理所以缓存是不会生效的。</strong> </p>
<h2><span id="二-注解与-spel-表达式">二、注解与 SpEL 表达式</span></h2><h3><span id="1缓存注解">1.缓存注解</span></h3><table>
<thead>
<tr>
<th>注解</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>@EnableCaching</td>
<td>开启基于注解的缓存</td>
</tr>
<tr>
<td>@CacheConfig</td>
<td>统一配置本类的缓存注解的属性</td>
</tr>
<tr>
<td>@Cacheable</td>
<td>第一次调用方法后都将返回值存入缓存，下次则请求直接调用缓存</td>
</tr>
<tr>
<td>@CachePut</td>
<td>每次调用方法后都将返回值存入缓存，用于缓存更新</td>
</tr>
<tr>
<td>@CacheEvict</td>
<td>清除缓存</td>
</tr>
<tr>
<td>@Caching</td>
<td>组合注解，即给一个方法同时设置多个缓存方案</td>
</tr>
</tbody></table>
<h3><span id="2-spel-表达式">2. SpEL 表达式</span></h3><p>spring 表达式支持我们通过指定的明确获取参数或者方法的属性：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位置</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>methodName</td>
<td>root对象</td>
<td>当前被调用的方法名</td>
<td>#root.methodname</td>
</tr>
<tr>
<td>method</td>
<td>root对象</td>
<td>当前被调用的方法</td>
<td>#root.method.name</td>
</tr>
<tr>
<td>target</td>
<td>root对象</td>
<td>当前被调用的目标对象实例</td>
<td>#root.target</td>
</tr>
<tr>
<td>targetClass</td>
<td>root对象</td>
<td>当前被调用的目标对象的类</td>
<td>#root.targetClass</td>
</tr>
<tr>
<td>args</td>
<td>root对象</td>
<td>当前被调用的方法的参数列表</td>
<td>#root.args[0]<br>#root.参数名</td>
</tr>
<tr>
<td>caches</td>
<td>root对象</td>
<td>当前方法调用使用的缓存列表</td>
<td>#root.caches[0].name</td>
</tr>
<tr>
<td>Argument Name</td>
<td>执行上下文</td>
<td>当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数</td>
<td>#artsian.id</td>
</tr>
<tr>
<td>result</td>
<td>执行上下文</td>
<td>法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false）</td>
<td>#result</td>
</tr>
</tbody></table>
<p>因为默认对象即为 #root，所以写的时候可以直接省略 #root</p>
<p>此外，表达式同样支持运算符：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>关系</td>
<td>&lt;，&gt;，&lt;=，&gt;=，==，!=，lt，gt，le，ge，eq，ne</td>
</tr>
<tr>
<td>算术</td>
<td>+，- ，* ，/，%，^</td>
</tr>
<tr>
<td>逻辑</td>
<td>&amp;&amp;，||，!，and，or，not，between，instanceof</td>
</tr>
<tr>
<td>条件</td>
<td>?: (ternary)，?: (elvis)</td>
</tr>
</tbody></table>
<h2><span id="三-使用">三、使用</span></h2><h3><span id="1添加缓存">1.添加缓存</span></h3><p>@Cacheable 注解用于标记方法。第一次执行的时候，会将方法结果存入缓存，再次调用该方法，<strong>在执行前</strong>，如果 key 相同则直接返回缓存中的数据，不会再次执行方法。</p>
<p>他的主要属性有以下五种：</p>
<ul>
<li>value/cacheName：指定缓存命名空间，只有保证命名空间相同，key 才能找到对应的缓存。</li>
<li>key：指定缓存数据的键值对的key，默认为方法参数中的值；</li>
<li>Condition：指定缓存执行的条件；</li>
<li>unliss：指定缓存不执行的条件；</li>
<li>sync：指定缓存是否使用异步模式，默认同步，若异步则不支持 unless。这个主要是用来处理多线程环境下缓存更新导致数据出错的问题的。</li>
</ul>
<p>上述一些复杂的条件依赖于 sqEl 表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法调用给前进行检测，若存在 key 对应的数据则直接从缓存中返回结果，否则在执行后将返回值存入缓存</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;dept&quot;，key = &quot;targetClass&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;全查！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2缓存更新">2.缓存更新</span></h3><p>@CachePut 注解一般用于更新某个命名空间中的某条缓存数据。<strong>当方法调用结束以后</strong>，会根据注解将结果存入缓存，如果 key 已经存在，则会更新缓存。</p>
<p>他的主要属性同 @Cacheable 基本相同，但是由于是先执行才处理数据，所以 key 是可以获得 #root.result 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 调用方法后，再把返回值放入缓存</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CachePut(cacheNames = &quot;dept&quot;，key = &quot;#root.targetClass&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;增加！&quot;</span>);</span><br><span class="line">    mapper.insert(dept);</span><br><span class="line">    <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3清空缓存">3.清空缓存</span></h3><p>@CacheEvict 用于清空某个命名空间内某条、或全部缓存数据。</p>
<p>他的主要属性就两个：</p>
<ul>
<li><p>allEntries：是否清空全部缓存数据。默认 true，会忽略 key，否则只清除 key 对应的缓存；</p>
</li>
<li><p>beforeInvocation：是否要在方法执行前就清空缓存。默认为 false，即执行结束后才清空缓存。</p>
<p>注意：当发生异常时，是不会清空缓存的。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 清除缓存中的数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;dept&quot;, key = &quot;#root.targetClass&quot;, beforeInvocation = false)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer deptno)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除！&quot;</span>);</span><br><span class="line">    mapper.deleteByPrimaryKey(deptno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4多条件组合">4.多条件组合</span></h3><p>@Caching 是一个组合注解，可以在里面添加复数的以上三种注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 组合注解，三种注解以每种可有多个，以数组形式存储</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">    cacheable = &#123;</span></span><br><span class="line"><span class="meta">        //添加一个缓存</span></span><br><span class="line"><span class="meta">        @Cacheable(value = &quot;dept&quot;,key = &quot;#deptno&quot;)</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    put = &#123;</span></span><br><span class="line"><span class="meta">        //更新一个缓存</span></span><br><span class="line"><span class="meta">        @CachePut(value = &quot;emp&quot;，key = &quot;#root.targetClass&quot;)</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    evict = &#123;</span></span><br><span class="line"><span class="meta">        //清除一个缓存</span></span><br><span class="line"><span class="meta">        @CacheEvict(value = &quot;person&quot;，key = &quot;#deptno&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dept <span class="title">findById</span><span class="params">(Integer deptno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5统一命名空间">5.统一命名空间</span></h3><p>@CacheConfig 注解可以在类上统一命名空间，这样类中如果没有指定 cacheName 或者 value，那么默认会使用 @CacheConfig 指定的命名空间。当然，如果在方法上自己指定了另外的命名空间，则以方法上的注解为准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用@CacheConfig统一cacheName，如果在方法上仍写了value，则该方法值仍以value为准</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;dept&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptServiceImp</span> <span class="keyword">implements</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper mapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;targetClass&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;全查！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;targetClass&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加！&quot;</span>);</span><br><span class="line">        mapper.insert(dept);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;targetClass&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">delete</span><span class="params">(Integer deptno)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除！&quot;</span>);</span><br><span class="line">        mapper.deleteByPrimaryKey(deptno);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis在SpringBoot的基本使用</title>
    <url>/2020/11/24/Spring/Redis%E5%9C%A8SpringBoot%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2><span id="一-配置">一、配置</span></h2><h3><span id="1添加依赖">1.添加依赖</span></h3><p>在 springboot 启动器中直接添加依赖，或者创建后添加 Maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-boot-starter-data-redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，默认在springboot 1X 中默认使用的是 Jedis 客户端，而在 springboot 2X 默认使用的就是 Lettuce，我这里使用的是 2X 的版本，所以要添加 Jedis 的客户端依赖。</p>
<h3><span id="2配置连接池">2.配置连接池</span></h3><p>在 springboot 配置文件中配置连接信息：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment"># redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># 数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="comment">#- 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10000</span></span><br><span class="line">    <span class="comment"># jedis 线程池设置</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">        <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3><span id="3配置redistemplate">3.配置RedisTemplate</span></h3><p>其实这个时候已经可以使用 RedisTemplate 操作 redis了，因为 Spring 已经默认提供  <code>RedisTemplate&lt;Object, Object&gt;</code> 和 <code>RedisTemplate&lt;String, String&gt;</code> 这两个 <code>RedisTemplate&lt;K,V&gt;</code> 的两个子类供我们使用。但是前者要求作为 key 和 value 的类型必须实现 Serializable 接口，而后者需要我们在存入数据之前自己将 key 和 value 变成 string ，所以这默认的 RedisTemplate 并不是那么好用，最好自己再重新配置一个 <code>RedisTemplate&lt;String, Object&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池配置信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JedisPoolConfig <span class="title">jedisPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    <span class="comment">// 最大连接数</span></span><br><span class="line">    jedisPoolConfig.setMaxTotal(maxActive);</span><br><span class="line">    <span class="comment">// 当池内没有可用连接时，最大等待时间</span></span><br><span class="line">    jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">    <span class="comment">// 最大空闲连接数</span></span><br><span class="line">    jedisPoolConfig.setMinIdle(maxIdle);</span><br><span class="line">    <span class="comment">// 最小空闲连接数</span></span><br><span class="line">    jedisPoolConfig.setMinIdle(minIdle);</span><br><span class="line">    <span class="keyword">return</span> jedisPoolConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jedis连接工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jedisPoolConfig 上文配置的jedis连接池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> org.springframework.data.redis.connection.jedis.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/23 13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">(JedisPoolConfig jedisPoolConfig)</span> </span>&#123;</span><br><span class="line">    JedisClientConfiguration jedisClientConfiguration = JedisClientConfiguration.builder().usePooling()</span><br><span class="line">        .poolConfig(jedisPoolConfig).and().readTimeout(Duration.ofMillis(timeout)).build();</span><br><span class="line">    RedisStandaloneConfiguration redisStandaloneConfiguration = <span class="keyword">new</span> RedisStandaloneConfiguration();</span><br><span class="line">    redisStandaloneConfiguration.setHostName(host);</span><br><span class="line">    redisStandaloneConfiguration.setPort(port);</span><br><span class="line">    redisStandaloneConfiguration.setPassword(RedisPassword.of(password));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory(redisStandaloneConfiguration, jedisClientConfiguration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jackson2JsonRedisSerializer代替默认的序列化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer&lt;java.lang.Object&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/24 16:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jackson2JsonRedisSerializer&lt;Object&gt; <span class="title">jackson2JsonRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer =</span><br><span class="line">        <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    objectMapper.configure(MapperFeature.USE_ANNOTATIONS, <span class="keyword">false</span>);</span><br><span class="line">    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则会报java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX</span></span><br><span class="line">    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonRedisSerializer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置redisTemplate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jedisConnectionFactory 上文配置的jedis连接工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jackson2JsonRedisSerializer  上文配置的序列化类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> org.springframework.data.redis.core.RedisTemplate&lt;java.lang.String,java.lang.Object&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/24 16:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(JedisConnectionFactory jedisConnectionFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接工厂</span></span><br><span class="line">    RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(jedisConnectionFactory);</span><br><span class="line">    redisTemplate.setEnableTransactionSupport(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义key的序列化方式</span></span><br><span class="line">    StringRedisSerializer stringSerial = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 序列化方式使用stringSerial</span></span><br><span class="line">    redisTemplate.setKeySerializer(stringSerial);</span><br><span class="line">    <span class="comment">// value 序列化方式使用jackson</span></span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    <span class="comment">// hash key 序列化方式使用stringSerial</span></span><br><span class="line">    redisTemplate.setHashKeySerializer(stringSerial);</span><br><span class="line">    <span class="comment">// hash value 序列化方式使用jackson</span></span><br><span class="line">    redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：以上配置跟网上找到的大同小异，但是尤其要注意在 jackson2JsonRedisSerializer 中对 ObjectMapper 的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br></pre></td></tr></table></figure>

<p>如果不设置此项，ObjectMapper 会将 redis 返回的字符串反序列化为 <code>java.util.LinkedHashMap</code>，结果就是 Spring 做类型转换的时候报错：<code>java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX</code>。</p>
<h2><span id="二-使用">二、使用</span></h2><h3><span id="1封装为工具类">1.封装为工具类</span></h3><p>RedisTemplate 内部已经提供了一系列 API 供我们调用，但是使用起来也并不是很方便，因此基本都会再封装一层作为工具类使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="2使用">2.使用</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;template&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getByTemplate</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Object object = redisTemplate;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        redisUtils.set(key, <span class="string">&quot;这是一条来自缓存的数据！&quot;</span>);</span><br><span class="line">        object = <span class="string">&quot;已经存入缓存！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.success(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&quot;data&quot;: &quot;已经存入缓存！&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;data&quot;: &quot;这是一条来自缓存的数据&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2><span id="三-接入-springcache">三、接入 SpringCache</span></h2><p>SpringCache 是在 Spring3 版本开始加入的缓存接口，在配置 RedisCacheManager 之后，我们可以很方便通过注解实现方法级别的缓存。</p>
<p>具体的内容可以参考前文：<a href="https://www.cnblogs.com/Createsequence/p/11237426.html">使用SpringCache做简单缓存</a>。具体实例仍然同前文中一样，提因此只在上述配置的基础上再提供一个 RedisCacheManager 配置类。即可实现从 ConcurrentMapCacheManager 到 RedisCacheManager 的切换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RedisCacheConfig配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/24 13:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 配置CacheManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> template 在RedisConfig中定义的RedisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.cache.CacheManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2020/11/24 16:21</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate&lt;String, Object&gt; template)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置RedisCacheConfiguration</span></span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            <span class="comment">// 设置key为String</span></span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(template.getStringSerializer()))</span><br><span class="line">            <span class="comment">// 设置value 为自动转Json的Object</span></span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(template.getValueSerializer()))</span><br><span class="line">            <span class="comment">// 不缓存null</span></span><br><span class="line">            .disableCachingNullValues()</span><br><span class="line">            <span class="comment">// 缓存数据保存1小时</span></span><br><span class="line">            .entryTtl(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用RedisCacheConfiguration创建RedisCacheManager</span></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.RedisCacheManagerBuilder</span><br><span class="line">            <span class="comment">// Redis 连接工厂</span></span><br><span class="line">            .fromConnectionFactory(Objects.requireNonNull(template.getConnectionFactory()))</span><br><span class="line">            <span class="comment">// 缓存配置</span></span><br><span class="line">            .cacheDefaults(redisCacheConfiguration)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里有一个坑，就是<strong>在 SpringBoot 1X 中，RedisCacheManager 构造器传入的参数的 RedisTemplate，而在 SpingBoot 2X 中需要传入 RedisCacheConfiguration 作为配置对象</strong>，点开源码也能看得见，构造器里没有 RedisTemplate 类型的参数。否则获取的数据可能会出现乱码。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性（一）：Stream</title>
    <url>/2019/12/01/java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AStream/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。 </p>
<p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
<p>元素流在管道中经过中间操作的处理，最后由最终操作得到前面处理的结果。</p>
<p><img src="http://img.xiajibagao.top/%E6%8F%8F%E8%BF%B0stream.PNG"></p>
<h2><span id="二-举个例子">二. 举个例子？</span></h2><p>现在有一个字符串集合，我们需要过滤掉集合里头长度小于2的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strings)&#123;</span><br><span class="line">        <span class="comment">//如果长度大于2</span></span><br><span class="line">        <span class="keyword">if</span> (str.length() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//将字符串添加至新集合</span></span><br><span class="line">            stringList.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    strings = stringList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用stream实现一模一样的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    <span class="comment">//通过stream操作集合</span></span><br><span class="line">    strings = strings.stream()</span><br><span class="line">        <span class="comment">//去掉长度小于2的字符串</span></span><br><span class="line">        .filter(s -&gt; s.length() &gt;= <span class="number">2</span>)</span><br><span class="line">        <span class="comment">//转回集合</span></span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，使用streamAPI可以轻松写出更高效，更简洁，可读性更强的代码</p>
<h2><span id="三-如何使用stream">三. 如何使用stream？</span></h2><p>简单的说，分两步：生成流，操作流</p>
<h3><span id="1-生成流">1.  生成流</span></h3><p>Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， 不支持Map</p>
<p>1.1 Collection接口的stream()或parallelStream()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将Set或List集合直接转换为stream对象</span></span><br><span class="line">List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Stream&lt;Person&gt; personStream1 = personList.stream();<span class="comment">//生成串行流</span></span><br><span class="line">Stream&lt;Person&gt; personStream2 = set.parallelStream();<span class="comment">//生成并行流</span></span><br></pre></td></tr></table></figure>



<p>1.2 Stream.of()，Arrays.stream，Stream.empty()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArr = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream.empty()</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream.of() （方法内部调用的还是Arrays.stream）</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(strArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.stream</span></span><br><span class="line">Stream&lt;String&gt; stringStream2 = Arrays.stream(strArr);</span><br></pre></td></tr></table></figure>



<p>1.3 Stream.concat()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已有的对象</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.empty();</span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(strArr);</span><br><span class="line">Stream&lt;String&gt; stringStream2 = Arrays.stream(strArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个流</span></span><br><span class="line">Stream conStream1 = Stream.concat(stringStream,integerStream);</span><br><span class="line">Stream conStream2 = Stream.concat(stringStream,stringStream2);</span><br></pre></td></tr></table></figure>



<p>1.4 静态的Files.lines(path) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;D://test.txt&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; lines = Files.lines(file);</span><br></pre></td></tr></table></figure>



<h3><span id="2-操作流">2. 操作流</span></h3><p> Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，可以在后头跟上其他中间操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接下来的示例代码基于此集合</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>2.1 filter(Predicate：将结果为false的元素过滤掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去掉长度小于2的字符串</span></span><br><span class="line">strings = strings.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt;= <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings</span></span><br><span class="line">[ab, bc, cd, abcd, jkl]</span><br></pre></td></tr></table></figure>



<p>2.2 map(fun)：转换元素的值，可以引用方法或者直接用lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//为每个字符串加上“？？？”</span></span><br><span class="line">    .map(s -&gt; s += <span class="string">&quot;？？？&quot;</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings</span></span><br><span class="line">[ab？？？, ？？？, bc？？？, cd？？？, abcd？？？, ？？？, jkl？？？]</span><br></pre></td></tr></table></figure>



<p>2.3 limit(n)：保留前n个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//保留前3个</span></span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings</span></span><br><span class="line">[ab, , bc]</span><br></pre></td></tr></table></figure>



<p>2.4 skip(n)：跳过前n个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//跳过前2个</span></span><br><span class="line">    .skip(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings</span></span><br><span class="line">[bc, cd, abcd, , jkl]</span><br></pre></td></tr></table></figure>



<p>2.5 distinct()：剔除重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//过滤重复元素</span></span><br><span class="line">    .distinct()</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings(过滤掉了一个空字符串)</span></span><br><span class="line">[ab, , bc, cd, abcd, jkl]</span><br></pre></td></tr></table></figure>



<p>2.6 sorted()：通过Comparable对元素排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//按字符串长度排序</span></span><br><span class="line">    .sorted(</span><br><span class="line">        <span class="comment">//比较字符串长度</span></span><br><span class="line">        Comparator.comparing(s -&gt; s.length())</span><br><span class="line">	)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings(过滤掉了一个空字符串)</span></span><br><span class="line">[, , ab, bc, cd, jkl, abcd]</span><br></pre></td></tr></table></figure>



<p>2.7 peek(fun)：流不变，但会把每个元素传入fun执行，可以用作调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//为字符串增加“？？？”</span></span><br><span class="line">    .peek(s -&gt; s += <span class="string">&quot;???&quot;</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings，和map对比，实际并没有改变集合</span></span><br><span class="line">[ab, , bc, cd, abcd, , jkl]</span><br></pre></td></tr></table></figure>



<p>2.8 flatMap(fun)：若元素是流，将流摊平为正常元素，再进行元素转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将具有多重嵌套结构的集合扁平化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个两重集合</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;asd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bzxasdc&quot;</span>, <span class="string">&quot;cddsdsd&quot;</span>, <span class="string">&quot;adsdsg&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jvcbl&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lists.add(strings);</span><br><span class="line">lists.add(strings2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取将两重集合压成一层</span></span><br><span class="line">List&lt;String&gt; stringList = lists.stream()</span><br><span class="line">    <span class="comment">//将两重集合的子元素，即集合strings和strings2转成流再平摊</span></span><br><span class="line">    .flatMap(Collection::stream)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(stringList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印stringList</span></span><br><span class="line">[ab, , bc, cd, abcd, , jkl, asd, , bzxasdc, cddsdsd, adsdsg, , jvcbl]</span><br></pre></td></tr></table></figure>



<p>2.9 anyMatch(fun)，allMatch(fun)：判断流中的元素是否匹配 【最终操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//allMatch</span></span><br><span class="line">Boolean isAllMatch = strings.stream()</span><br><span class="line">    <span class="comment">//判断元素中是否有匹配“ab”的字符串，返回true或fals</span></span><br><span class="line">    <span class="comment">//判断元素中的字符串是否都与“ab”匹配，返回true或fals</span></span><br><span class="line">    .allMatch(str -&gt; str.equals(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(isMatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//anyMatch</span></span><br><span class="line">Boolean isAnyMatch = strings.stream()</span><br><span class="line">    <span class="comment">//判断元素中是否有匹配“ab”的字符串，返回true或fals</span></span><br><span class="line">    .anyMatch(str -&gt; str.equals(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;isAnyMatch：&quot;</span> + isAnyMatch);</span><br><span class="line">System.out.println(<span class="string">&quot;isAllMatch：&quot;</span> + isAllMatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">isAnyMatch：<span class="keyword">true</span></span><br><span class="line">isAllMatch：<span class="keyword">false</span></span><br></pre></td></tr></table></figure>



<p>2.10 forEach(fun)： 迭代流中的每个数据 【最终操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings.stream()</span><br><span class="line">    <span class="comment">//遍历每一个元素</span></span><br><span class="line">    .forEach(s -&gt; System.out.print(s + <span class="string">&quot;; &quot;</span>));</span><br></pre></td></tr></table></figure>



<p>2.11 collect()：返回结果集 【最终操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>



<h2><span id="四-使用intsummarystatistics类处理数据">四. 使用IntSummaryStatistics类处理数据</span></h2><h3><span id="1-intsummarystatistics类">1. IntSummaryStatistics类</span></h3><p>IntSummaryStatistics类，在 java8中配合Stream使用，是用于收集统计信息（例如计数，最小值，最大值，总和和*平均值）的状态对象。</p>
<p>这个类长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSummaryStatistics</span> <span class="keyword">implements</span> <span class="title">IntConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntSummaryStatistics</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        sum += value;</span><br><span class="line">        min = Math.min(min, value);</span><br><span class="line">        max = Math.max(max, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(IntSummaryStatistics other)</span> </span>&#123;</span><br><span class="line">        count += other.count;</span><br><span class="line">        sum += other.sum;</span><br><span class="line">        min = Math.min(min, other.min);</span><br><span class="line">        max = Math.max(max, other.max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCount() &gt; <span class="number">0</span> ? (<span class="keyword">double</span>) getSum() / getCount() : <span class="number">0.0d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(</span><br><span class="line">            <span class="string">&quot;%s&#123;count=%d, sum=%d, min=%d, average=%f, max=%d&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">this</span>.getClass().getSimpleName(),</span><br><span class="line">            getCount(),</span><br><span class="line">            getSum(),</span><br><span class="line">            getMin(),</span><br><span class="line">            getAverage(),</span><br><span class="line">            getMax());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2使用">2.使用</span></h3><p>这个类的理解起来很简单，内部有这几个方法：</p>
<p>2.1 获取总条数：getCount()，</p>
<p>2.2 获取和：getSum()，</p>
<p>2.3 获取最小值：getMin()，</p>
<p>2.4 获取最大值：getMax()，</p>
<p>2.5 获取平均值：getAverage()</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">75</span>, <span class="number">32</span>, <span class="number">54</span>);</span><br><span class="line"></span><br><span class="line">    IntSummaryStatistics sta = integerList</span><br><span class="line">        .stream()</span><br><span class="line">        <span class="comment">//将元素映射为对应的数据类型（int,double,long）</span></span><br><span class="line">        .mapToInt(i -&gt; i)</span><br><span class="line">        <span class="comment">//转换为summaryStatistics类</span></span><br><span class="line">        .summaryStatistics();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;总共有 : &quot;</span>+ sta.getCount());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + sta.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + sta.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + sta.getSum());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span> + sta.getAverage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">总共有 : <span class="number">7</span></span><br><span class="line">列表中最大的数 : <span class="number">75</span></span><br><span class="line">列表中最小的数 : <span class="number">3</span></span><br><span class="line">所有数之和 : <span class="number">221</span></span><br><span class="line">平均数 : <span class="number">31.571428571428573</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性（三）：Lambda表达式</title>
    <url>/2020/10/30/java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>JDK8 为我们带来了 Lambda 表达式和函数式接口，这一点在前文介绍 Stream 和 Collectors 的时候已有提及。通过使用这些特性，我们可以更简洁的创建匿名内部类，也可以将方法作为参数直接传入方法中调用。本文将就这两点简要的总结一下 Lambda 的使用。</p>
<h2><span id="一-函数式接口">一、函数式接口</span></h2><p>我们知道，java 中允许将接口作为方法的参数类型，但是我们只能传入其实现类。实际开发中，有些接口的仅有少数的方法，并且往往其实现类只在特定的地方使用，为此专门去创建一个新的实现类其实是有点繁琐的，为此 JDK8 引入了函数式接口。</p>
<p>函数式接口有且仅有一个抽象方法，抽象方法允许有一个默认实现（实际上接口的默认实现也是 JDK8 的新特性）。当我们调用方法时，<strong>可以直接通过 Lambda 表达式直接以匿名内部类的形式去实现他的方法</strong>。表现为直接在参数小括号中： <code>void test(param1, () -&gt; System.out.print(&quot;hello world&quot;))</code></p>
<p>当使用作为方法参数类型是，通过在接口上添加<code>@FunctionalInterface</code>注解来声明。</p>
<p>我们举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将接口作为方法参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(TestInterface testInterface)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 有且仅有一个抽象方法</span></span><br><span class="line">    testInterface.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">test(()-&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>我们可以看到，实现的代码非常的简洁，对于一些不复杂的功能用起来非常方便，而如果使用原本的实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestInterface testInterface = <span class="keyword">new</span> TestInterface() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">test(testInterface);</span><br></pre></td></tr></table></figure>

<p>Lambda 写法的方便简洁可见一斑。</p>
<h2><span id="二-lambda-表达式">二、Lambda 表达式</span></h2><h3><span id="1语法">1.语法</span></h3><p>Lambda 表达式，也可称为闭包。一个典型的表达式由一对圆括号和括号中的参数，一个横杠加箭头，和一对大括号组成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123; System.out.println(<span class="string">&quot;hello world&quot;</span>)) &#125;</span><br></pre></td></tr></table></figure>

<p>实际上，表达式并不是所有时候都需要写的那么标准：</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<h3><span id="2配合函数式接口使用">2.配合函数式接口使用</span></h3><p>Lambda 表达式需要配合函数式接口使用。</p>
<p>对于函数式接口，我们可以像上文举的例子一样，自己创建一个函数式接口，也可以使用 <code>java.util.function</code>包下已经提供好的函数式接口。</p>
<p><code>java.util.function</code>包提供了很多现成的接口，<a href="https://www.runoob.com/java/java8-functional-interfaces.html">菜鸟教程</a>上介绍的很详细，这里就不复制黏贴了。</p>
<p>现在，我们用用看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用自己的函数式接口</span></span><br><span class="line">TestInterface testInterface = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    System.out.println(i++);</span><br><span class="line">&#125;;</span><br><span class="line">testInterface.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 java.util.function 包的函数式接口</span></span><br><span class="line">IntFunction intFunction = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">System.out.println(intFunction.apply(<span class="number">15</span>));</span><br></pre></td></tr></table></figure>

<p>我们可以发现，对于我们自己的定义的接口，唯一的抽象方法是<code>test()</code>，所以放入实现以后实际上就是<code>test()</code>方法的实现，而 IntFunction 通过表达式实现的就是<code>apply()</code>方法。</p>
<p>其中，函数式接口总是有且仅有一个抽象方法，当作为参数使用的时候，通过 Lambda 表达式传入匿名方法默认就是实现这个唯一的抽象方法。另外，和正常的接口一样，函数式接口也允许拥有多个 default 修饰的默认实现方法。</p>
<h3><span id="3变量作用域">3.变量作用域</span></h3><p>Lambda 实际上可以理解为一个匿名的内部类，<strong>他可以访问外部的变量，但是不可以对变量做出改变</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">IntFunction intFunction = x -&gt; &#123;</span><br><span class="line">    <span class="comment">// lambda表达式中使用的变量应该是final</span></span><br><span class="line">    i++; </span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure>

<p>上述这段代码会报编译错误，他会提示 lambda 表达式中使用的变量应该是 final。当然，我们删去 <code>i++</code>这行代码，让方法返回 <code>i + 1</code>就没影响了。可以见我们并不需要加 final 也可以。以前 java 的匿名内部类在访问外部变量的时候，外部变量必须用 final 修饰。在JDK8 对这个限制做了优化，可以不用显示使用final修饰，编译器自己隐式当成 final 来处理。</p>
<h3><span id="4表达式的-this">4.表达式的 this</span></h3><p>我们可以通过一个简单的例子来了解一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">&quot;BeanA&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">private</span> String name = <span class="string">&quot;Runnable&quot;</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里的this指向匿名类:&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这里的this指向当前的ThisDemo类:&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 这里的this指向匿名类:Runnable</span></span><br><span class="line"><span class="comment">// 这里的this指向当前的ThisDemo类:张三</span></span><br></pre></td></tr></table></figure>

<p>匿名内部类的 this 指向的是内部类自己，而 Lambda 表达式里的 <strong>this 实际上指向的是离他最近的那一层的外部类</strong>。</p>
<p>之所以这样，是因为当要编译 Lambda 表达式的时候，JVM会把 Lambda 表达式编译为一个<strong>在本类中的以lambda$+数字的方法</strong>。</p>
<p>值得一提的是，我们知道静态方法通过类调用，所以静态方法是获取不到 this 实例的，而Lambda 表达式会被编译为一个方法，<strong>如果表达式中使用了 this，那么就会编译为一个非静态方法，而未使用 this，就会编译为一个带 static 关键字的静态方法</strong>。</p>
<h2><span id="三-方法引用">三、方法引用</span></h2><h3><span id="1语法">1.语法</span></h3><p>方法引用通过方法的名字来指向一个方法，他使 Lambada 更加简洁易懂。</p>
<p>方法引用的写法类似这样 <code>类/实例::方法名</code>：</p>
<ul>
<li>引用静态方法/成员方法：Class::StaticMethod 或 Class::Method</li>
<li>引用成员方法：Instance::Method</li>
</ul>
<p>下面举个例子来说明一下这些引用方式的差异：</p>
<p>假如我们有这么一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(BeanA a)</span> </span>&#123;</span><br><span class="line">        System.out.println(a.getName() + <span class="string">&quot;被staticMethod输出了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;被instanceMethod方法输出了！this指向&quot;</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过方法引用来使用这些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.引用静态方法</span></span><br><span class="line">Consumer&lt;BeanA&gt; c = BeanA::staticMethod;</span><br><span class="line">c.accept(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过类引用成员方法</span></span><br><span class="line">Consumer&lt;BeanA&gt; c2 = BeanA::instanceMethod;</span><br><span class="line">c2.accept(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过实例引用成员方法</span></span><br><span class="line">Supplier&lt;String&gt; c3 = a::instanceMethod;</span><br><span class="line">c3.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">张三被staticMethod输出了！</span><br><span class="line">张三被instanceMethod方法输出了！<span class="keyword">this</span>指向<span class="number">45721950</span></span><br><span class="line">张三被instanceMethod方法输出了！<span class="keyword">this</span>指向<span class="number">45721950</span></span><br></pre></td></tr></table></figure>

<h3><span id="2方法引用中的this">2.方法引用中的this</span></h3><p>我们可以在上述的例子中注意到一个很有趣的地方，<strong>成员方法使用了this，但是仍然可以通过跟静态一样的形式去调用，但是却需要传递一个方法参数，而通过实例去调用就不需要传入参数</strong>。</p>
<p><code>instanceMethod()</code>本身是个无参的方法，但是在第二中引用方式中却传递了 a 这个对象进去，我们是不是可以认为这就是被传入使用的 this？</p>
<p>我们再写一个方法作为对照：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入李四</span></span><br><span class="line">Consumer&lt;BeanA&gt; c2 = BeanA::instanceMethod;</span><br><span class="line">c2.accept(<span class="keyword">new</span> BeanA(<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="comment">// 传入张三</span></span><br><span class="line">Consumer&lt;BeanA&gt; c25 = BeanA::instanceMethod;</span><br><span class="line">c25.accept(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">李四被instanceMethod方法输出了！<span class="keyword">this</span>指向<span class="number">49685098</span></span><br><span class="line">张三被instanceMethod方法输出了！<span class="keyword">this</span>指向<span class="number">45721950</span></span><br></pre></td></tr></table></figure>

<p> 我们可以看到，同样一个方法，传入了不同的实例，this 就指向了不同的实例。我们可以进一步推测，是不是跟 python 中的类的成员方法中的 self 一样，java 的成员方法也有一个 this 作为参数，只是平时编译器帮我们省略了呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动添加一个 this</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">(BeanA <span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数this指向&quot;</span> + <span class="keyword">this</span>.hashCode() + <span class="string">&quot;,关键字的this指向&quot;</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时可以发现，并不需要传入 this 这个参数</span></span><br><span class="line">a.testMethod();</span><br></pre></td></tr></table></figure>

<p>至此问题就明朗了，this 其实也是一个方法参数。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（一）：Collection 与 AbstractCollection</title>
    <url>/2020/11/25/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACollection%E4%B8%8EAbstractCollection/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>我们知道，java 中容器分为 Map 集合和 Collection 集合，其中 Collection 中的又分为 Queue，List，Set 三大子接口。</p>
<p>其中， List 应该是日常跟我们打交道最频繁的接口了，按照 JavaDoc 的说明，List 是一种：</p>
<blockquote>
<p>有序集合（也称为序列）。此接口的用户可以精确控制列表中每个元素的插入位置。用户可以通过其整数索引（在列表中的位置）访问元素，并在列表中搜索元素。</p>
</blockquote>
<p>我们以 List 下 Vector，ArrayList，LinkedList 三大实现为主，下面是他们之间的一个关系图。其中，红色表示抽象类，蓝色表示接口。</p>
<p><img src="http://img.xiajibagao.top/image-20201126100539307.png" alt="List集合的实现类关系图"></p>
<p>根据上图的类关系图，我们研究一下源码中，类与类之间的关系，方法是如何从抽象到具体的。</p>
<h2><span id="一-iterable-接口">一、Iterable 接口</span></h2><p>Iterable 是最顶层的接口，继承这个接口的类可以被迭代。</p>
<p><img src="http://img.xiajibagao.top/image-20201125151935252.png" alt="Iterable 接口的方法"></p>
<ul>
<li><p><code>iterator()</code>：用于获取一个迭代器。</p>
</li>
<li><p><code>forEach()</code> ：JDK8 新增。一个基于函数式接口实现的新迭代方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>spliterator()</code>：JDK8 新增。用于获取一个可分割迭代器。默认实现返回一个<code>IteratorSpliterator</code>类。</p>
<p>这个跟迭代器类似，但是是用于并行迭代的，关于具体的情况可以参考一下掘金的一个讨论：<a href="https://segmentfault.com/q/1010000007087438">Java8里面的java.util.Spliterator接口有什么用？</a></p>
</li>
</ul>
<h2><span id="二-collection-接口">二、Collection 接口</span></h2><p><img src="http://img.xiajibagao.top/image-20201125154357523.png" alt="Collection 接口的方法"></p>
<p>Collection 是集合容器的顶级接口，他继承了 Iterable 接口，即凡是 Collection 的实现类都可以迭代，List 也是 Collection 的子接口，因此也拥有此特性。</p>
<p>可以看到，  Collection 接口提供了十九个抽象方法，这些方法的命名都很直观的反应的这些方法的功能。通过这些方法规定了 Collection的实现类的一些基本特性：<strong>可迭代，可转化为数组，可对节点进行添加删除，集合间可以合并或者互相过滤，可以使用 Stream 进行流式处理。</strong></p>
<h3><span id="1抽象方法">1.抽象方法</span></h3><p>我们可以根据功能简单的分类介绍一下 Collection 接口提供的方法。</p>
<p><strong>判断类：</strong></p>
<ul>
<li><code>isEmpty()</code>：判断集合是否不含有任何元素；</li>
<li><code>contains()</code>：判断集合中是否含有至少一个对应元素；</li>
<li><code>containsAll()</code>：判断集合中是否含另一个集合的所有元素；</li>
</ul>
<p><strong>操作类：</strong></p>
<ul>
<li><code>add()</code>：让集合包含此元素。如果因为除了已经包含了此元素以外的任何情况而不能添加，则必须抛出异常；</li>
<li><code>addAll()</code>：将指定集合中的所有元素添加到本集合；</li>
<li><code>remove()</code>：从集合移除指定元素；</li>
<li><code>removeAll()</code>：删除也包含在指定集合中的所有此集合的元素；</li>
<li><code>retainAll</code>：从此集合中删除所有未包含在指定集合中的元素；</li>
<li><code>clear()</code>：从集合中删除所有元素；</li>
</ul>
<p><strong>辅助类：</strong></p>
<ul>
<li><p><code>size()</code>：获取集合的长度。如果长度超过 Integer.MAX_VALU 就返回 Integer.MAX_VALU；</p>
</li>
<li><p><code>iterator()</code>：获取集合的迭代器；</p>
</li>
<li><p><code>toArray()</code>：返回一个包含此集合中所有元素的<strong>新数组实例</strong>。因为是新实例，所以对原数组的操作不会影响新数组，反之亦然；</p>
<p>它有一多态方法参数为<code>T[]</code>，此时调用 <code>toArray()</code>会将内部数组中的元素全部放入指定数组，如果结束后指定数组还有剩余空间，那剩余空间都放入null。</p>
</li>
</ul>
<h3><span id="2jdk8-新增抽象方法">2.JDK8 新增抽象方法</span></h3><p>此外，在 JDK8 中新增了四个抽象方法，他们都提供了默认实现：</p>
<ul>
<li><code>removeIf</code>：相当于一个<code>filter()</code>，根据传入的函数接口的匿名实现类方法来判断是否要删除集合中的某些元素；</li>
<li><code>stream()</code>：JDK8 新特性中流式编程的灵魂方法，可以将集合转为 Stream 流式进行遍历，配合 Lambda 实现函数式编程；</li>
<li><code>parallelStream()</code>：同 <code>stream()</code> ，但是是生成并行流；</li>
<li><code>spliterator()</code>：重写了 Iterable 接口的 <code>iterator()</code>方法。</li>
</ul>
<h3><span id="3equals-和-hashcode">3.equals 和 hashCode</span></h3><p>值得一提的是 Collection <strong>还重写了 Object 的 <code>equals()</code> 和 <code>hashCode()</code> 方法</strong>（或者说变成了抽象方法？），这样<strong>实现 Collection 的类就必须重新实现 <code>equals()</code> 和 <code>hashCode()</code> 方法</strong>。</p>
<h2><span id="三-abstractcollection-抽象类">三、AbstractCollection 抽象类</span></h2><p>AbstractCollection 是一个抽象类，他实现了 Collection 接口的一些基本方法。JavaDoc 也是如此描述的：</p>
<blockquote>
<p>此类提供了Collection接口的基本实现，以最大程度地减少实现此接口所需的工作。</p>
</blockquote>
<p>通过类的关系图，AbstractCollection 下面还有一个子抽象类 AbstractList ，进一步提供了对 List 接口的实现。 我们不难发现，这正是模板方法模式在 JDK 中的一种运用。</p>
<h3><span id="0不支持的实现">0.不支持的实现</span></h3><p>在这之前，需要注意的是，AbstractCollection 中有一些比较特别的写法，即实现了方法，但是默认一调用立刻就抛出 <code>UnsupportedOperationException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要使用这个方法，就必须自己去重写他。这个写法让我纠结了很久，网上找了找也没找到一个具体的说法。</p>
<p>参考 JDK8 新增的接口方法默认实现这个特性，我大胆猜测，这应该是针对一些实现 Collection 接口，但是又不想要实现 <code>add(E e)</code>方法的类准备的。<strong>在 JDK8 之前，接口没有默认实现，如果抽象类还不提供一个实现，那么无论实现类是否需要这个方法，那么他都一定要实现这个方法</strong>，这明显不太符合我们设计的初衷。</p>
<h3><span id="1isempty">1.isEmpty</span></h3><p>非常简短的方法，通过判断容器 size 是否为0判断集合是否为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2containscontainsall">2.contains/containsAll</span></h3><p>判断元素是否存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="comment">// 如果要查找的元素是null</span></span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>containsAll()</code>就是在<code>contains()</code>基础上进行了遍历判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c)</span><br><span class="line">        <span class="keyword">if</span> (!contains(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3addall">3.addAll</span></h3><p><code>addAll()</code>方法就是在 for 循环里头调用 <code>add()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4removeremoveall">4.remove/removeAll</span></h3><p><code>remove()</code>这个方法与 <code>contains()</code>逻辑基本一样，<strong>因为做了null判断，所以List是默认支持传入null的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5removeallretainall">5.removeAll/retainAll</span></h3><p><code>removeAll()</code>和 <code>retainAll()</code>的逻辑基本一致，都是通过 <code>contains()</code>方法判断元素在集合中是否存在，然后选择保存或者删除。由于 <code>contains()</code>方法只看是否存在，而不在意有几个，所以如果目标元素有多个，会都删除或者保留。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;?&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5toarray扩容">5.toArray（扩容）</span></h3><p>用于将集合转数组。有两个实现。一般常用的是无参的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// 创建一个和List相同长度的数字</span></span><br><span class="line">    Object[] r = <span class="keyword">new</span> Object[size()];</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果数组长度大于集合长度</span></span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="comment">// 用Arrays.copyOf把剩下的位置用null填充</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">        r[i] = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果数组长度反而小于集合长度，就扩容数组并且重复上述过程</span></span><br><span class="line">    <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，在 finishToArray(r, it) 这个方法里涉及到了一个扩容的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位运算，扩大当前容量的一半+1</span></span><br><span class="line"><span class="keyword">int</span> newCap = cap + (cap &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果扩容后的大小比MAX_ARRAY_SIZE还大</span></span><br><span class="line"><span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 使用原容量+1，去判断要直接扩容到MAX_ARRAY_SIZE，Integer.MAX_VALUE还是直接抛OutOfMemoryError异常</span></span><br><span class="line">    newCap = hugeCapacity(cap + <span class="number">1</span>);</span><br><span class="line">r = Arrays.copyOf(r, newCap);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>MAX_ARRAY_SIZE</code> 是一个常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>这里又通过<code>hugeCapacity()</code>方法进行了大小的限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经大到溢出就抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError</span><br><span class="line">        (<span class="string">&quot;Required array size too large&quot;</span>);</span><br><span class="line">    <span class="comment">// 容量+1是否还是大于允许的数组最大大小</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        <span class="comment">// 如果是，就把容量直接扩大到Integer.MAX_VALUE</span></span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    <span class="comment">// 否则就直接扩容到运行的数组最大大小</span></span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="6clear">6.clear</span></h3><p>迭代并且删除全部元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    it.next();</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="7tostring">7.toString</span></h3><p>AbstractCollection 重写了 toString 方法，这也是为什么调用集合的<code>toStirng()</code> 不是像数组那样打印一个内存地址的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">        sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="四-总结">四、总结</span></h2><p><strong>Collection</strong> </p>
<p>Collection 接口类是 List ，Queue，Set 三大子接口的父接口，他继承了 Iterable 接口，因而所有 Collection 的实现类都可以迭代。</p>
<p>Collection 中提供了规定了实现类应该实现的大部分增删方法，但是并没有规定关于如何使用下标进行操作的方法。</p>
<p>值得注意的是，他重规定了 <code>equlas()</code> 和 <code>hashCode()</code>的方法，因此 Collection 的实现类的这两个方法不再跟 Object 类一样了。</p>
<p><strong>AbstractCollection</strong> </p>
<p>AbstractCollection 是实现 Collection 接口的一个抽象类，JDK 在这里使用了模板方法模式，Collection 的实现类可以通过继承 AbstractCollection 获得绝大部分实现好的方法。</p>
<p>在 AbstractCollection 中，为<code>add()</code>抽象方法提供了不支持的实现：即实现了方法，但是调用却会抛出 <code>UnsupportedOperationException</code>。根据推测，这跟 JDK8 接口默认实现的特性一样，是为了让子类可以有选择性的去实现接口的抽象方法，不必即使不需要该方法，也必须提供一个无意义的空实现。</p>
<p>AbstractCollection 提供了对添加复数节点，替换、删除的单数和复数节点的方法实现，在这些实现里，因为做了null判断，因此是默认是支持传入的元素为null，或者集合中含有为null的元素，但是不允许传入的集合为null。</p>
<p>AbstractCollection 在集合转数组的 <code>toArrays()</code> 中提供了关于扩容的初步实现：一般情况下<code>新容量=旧容量 + (旧容量/2 + 1)</code>，如果新容量大于 MAX_ARRAY_SIZE，就会使用 <code>旧容量+1</code>去做判断，如果已经溢出则抛OOM溢出，大于 MAX_ARRAY_SIZE 就使用 Integer.MAX_VALUE 作为新容量，否则就使用 MAX_ARRY_SIZE。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性（四）：Optional类</title>
    <url>/2020/11/03/java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AOptional%E7%B1%BB/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>针对我们熟悉又深恶痛绝的空指针异常 <code>NullPointException</code>，JDK8 新增了一个用于处理可能出现的空对象的类 Optionalt ，也就意味着。他可以理解为对对象的包装类，对原本的类进行了增强，结合 Lambda 表达式和函数式接口，我们可以安心的操作一些可能是 null 的对象，避免繁琐的空值检验。</p>
<p>举个例子：</p>
<p>我们常见过一些处理对象的方法，有些时候经常能见到这样的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;TestBean&gt; <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;TestBean&gt; bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些时候可能是try-catch块的限制，或者一些其他什么原因，我们的方法可能会返回一个 null，这样对于调用方来说，如果没有做空值检验就很有可能报 NPE，使用 Optional，我们可以<strong>显示的声明返回值可能是 null，并且返回一个 Option 类，调用方可以直接使用内置的方法进行处理</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;TestBean&gt; <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;TestBean&gt; bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line">TestClass.getBean().isPresent();</span><br></pre></td></tr></table></figure>



<h2><span id="一-创建-optional-对象">一、创建 Optional 对象</span></h2><p>在开始了解如何创建 Optional 对象之前，我们要明确，和 Integer 一样，Option 分为类本身与成员变量 value，其中 value 是可能为 null。</p>
<p>创建 Optional 对象有三种方法：</p>
<ul>
<li><p><strong><code>Optional.empty()</code>方法</strong>：创建一个 value 为 null 的空值 Optional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Optional.of()</code>方法</strong>：创建一个有默认值的 Optional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; defaultOptional = Optional.of(<span class="string">&quot;这是一个默认值&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Optional.ofNullable()</code>方法</strong>：创建一个可能是空值的 Optional。当有值的时候等同于<code>Optional.of()</code>，无值的时候等同于<code>Optional.empty()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; nullableOption = Optional.ofNullable(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Optional 的构造器是私有的，即无法也不应该通过构造方法去创建一个 Optional 实例。</p>
<p>下文的示例将基于空值对象 emptyOptional，非空值对象 defaultOptional 进行演示，</p>
<h2><span id="二-optional-基本使用">二、Optional 基本使用</span></h2><h3><span id="1判空">1.判空</span></h3><ul>
<li><p><strong><code>isPresent()</code> 方法</strong>：判空用于判断 Optional 类所包装的 value <strong>是否非空</strong>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(emptyOptional.isPresent()); <span class="comment">// false</span></span><br><span class="line">System.out.println(defaultOptional.isPresent()); <span class="comment">// true</span></span><br><span class="line">System.out.println(nullableOption.isPresent()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>ifPresent()</code>方法</strong>：用于指定若值为不为空的情况下的处理方法，可以看做 <code>ifPresent()</code>用法的延伸</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">emptyOptional.ifPresent(s -&gt; System.out.println(<span class="string">&quot;这玩意不是null&quot;</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3><span id="2获取值">2.获取值</span></h3><p>获取值的方法：</p>
<ul>
<li><p><strong><code>orElse()</code>方法</strong>：参数是一个变量，允许传入空值而不会报 NPE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(emptyOptional.orElse(<span class="keyword">null</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(emptyOptional.orElse(<span class="string">&quot;这是空的&quot;</span>)); <span class="comment">// 这是空的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>orElseGet()</code>方法</strong>：参数是一个无参有返回值的函数式接口 Supplier，不允许传入空值，当传入空值的时候会报 NPE 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(emptyOptional.orElseGet(<span class="keyword">null</span>)); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">System.out.println(emptyOptional.orElseGet(() -&gt; <span class="string">&quot;aaa&quot;</span>)); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>

<p>由于Supplier是无参的，所以更推荐使用 <code>Class::method</code>这样形式的静态方法引用来传入方法。</p>
</li>
<li><p><strong><code>orElseThrow()</code>方法</strong>：与 <code>orElseGet()</code>方法有点像，不过在<strong>传入的一个抛出异常的方法</strong>，简而言之，就是如果空值就抛异常，传入 null 就抛出 NPE，否则就按传入的自定义异常的构造函数来跑异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(nullableOption.orElseThrow(<span class="keyword">null</span>)); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">System.out.println(nullableOption.orElseThrow(MyException::<span class="keyword">new</span>)); <span class="comment">// MyException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>get()</code>方法</strong>：Option 的 <code>get()</code>是一个奇葩，当 value 是 null 的时候，他不会抛出 NPE，但是会抛出 <code>NoSuchElementException</code>，实乃脱裤子放屁之举。所以一般不通过 <code>get()</code>去取值，只在内部用于其他方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(emptyOptional.get()); <span class="comment">// java.util.NoSuchElementException</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>orElse()</code>方法和 <code>orElseGet()</code>方法用法看起来有点相近，但是参数决定了两个方法使用场景的不同。</p>
<p>就我个人理解，<code>orElse()</code>适用于检验参数的非空，比如一些<strong>非必要参数可以通过该方法保证默认值</strong>；而<code>orElseGet()</code>因为传入的是一个函数式接口的实现，适用于在<strong>使用前需要对可能为空的值进行预选处理的场合</strong>，比如日志系统记录空查询这样的情况。</p>
<p>另外，值得一提的是，<code>toString</code>未尝不能看做是一种特别的取值行为。Optional 重写了 <code>toStirng()</code>方法，当 value 为 null 的时候返回的是字符串 “Optional.empty”，否则返回 “Optional[默认值]”形式的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空值打印 Optional.empty，否则打印 Optional[这是一个默认值]</span></span><br><span class="line">System.out.println(nullableOption.toString());</span><br></pre></td></tr></table></figure>

<h2><span id="三-optional-过滤和转换">三、Optional 过滤和转换</span></h2><h3><span id="1过滤">1.过滤</span></h3><p>Optional 提供了 <code>filter()</code>方法用于过滤数据。它和 Stream 的 <code>filter()</code>方法一样，都是使用了有一个参数返回boolean值的函数式接口 Predicate作为参数，通过 Lambda 表达式直接传入实现类，从而实现快速过滤的目的。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// emptyOptional里面字符串长度并没有大于5</span></span><br><span class="line">Optional&lt;String&gt; s = emptyOptional.filter(t -&gt; t.length() &gt; <span class="number">5</span>);</span><br><span class="line">System.out.println(s); <span class="comment">// Optional.empty</span></span><br><span class="line">System.out.println(s.isPresent()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于默认会进行一次判空，所以<code>filter</code>我们可以看成下面代码的简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (conditionStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (conditionStr.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        System.out.println(emptyStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2转换">2.转换</span></h3><p><code>map()</code>用于值的转换，这个方法同样与 Stream 的 <code>map()</code>异曲同工。通过传入拥有一个参数和一个返回值的函数式接口 Function 的实现类，从而实现 value 的转换。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defaultOptional的value为“这是一个默认值”</span></span><br><span class="line">Optional&lt;String[]&gt; s = defaultOptional.map(t -&gt; t.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">System.out.println(Arrays.toString(s.get())); <span class="comment">// [这, 是, 一, 个, 默, 认, 值]</span></span><br></pre></td></tr></table></figure>

<h2><span id="四-总结">四、总结</span></h2><p>网上对 Optional 类的评价有褒有贬，公司里因为有专门用于处理各种类型的参数的空值工具类，所以也不太常见到过它。但是我在知乎上曾经看到过一个对 Optional 类的很贴切的总结：</p>
<blockquote>
<p>Optional的核心思想就是<strong>我明确告诉你可能会返回null</strong>，你一定要处理。所以，现在模块间提供给其他人的接口，如果有可能返回为null都要声明为Optional。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性（二）：Collectors收集器类</title>
    <url>/2019/12/01/java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ACollectors%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>上文我们介绍了JDK8新添加的Stream流接口，借助Stream配合拉姆达表达式，我们可以很方便的处理流对象。</p>
<p>针对流的聚合操作，Stream有一个对应的收集器类Collectors，通过Stream中的collect和collectingAndThen方法，我们可以借助收集器类聚合流中的数据，例如将元素累积到集合中，并根据各种标准对元素进行汇总，分类等操作。</p>
<h2><span id="二-举个例子">二. 举个例子？</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取String集合</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">//通过stream操作集合</span></span><br><span class="line">List&lt;String&gt; stringList = strings.stream()</span><br><span class="line">    <span class="comment">//为集合中的每一个元素拼接“？？？”</span></span><br><span class="line">    .map(s -&gt; s += <span class="string">&quot;???&quot;</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>如代码所示，我们可以很方便的通过Collectors类对被处理的流数据进行聚合操作，包括并不仅限与将处理过的流转换成集合</p>
<h2><span id="三-如何使用collectors">三. 如何使用Collectors？</span></h2><h3><span id="1-collectors类中提供的方法">1. Collectors类中提供的方法</span></h3><p>总结一下，就是以下几类方法：</p>
<p>1.1 转换成集合：toList()，toSet()，toMap()，toCollection()</p>
<p>1.2 将集合拆分拼接成字符串：joining()</p>
<p>1.3 求最大值、最小值、求和、平均值 ：maxBy()，minBy()，summingInt()，averagingDouble()</p>
<p>1.4 对集合分组：groupingBy()，partitioningBy()</p>
<p>1.5 对数据进行映射：mapping()</p>
<h3><span id="2-collectors类方法源码">2. Collectors类方法源码</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Collectors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">                                                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接字符串，有多个重载方法                                  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter);   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                             CharSequence prefix,</span><br><span class="line">                                                             CharSequence suffix);      </span><br><span class="line">    <span class="comment">// 最大值、最小值、求和、平均值                                                         </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper);      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper);                   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组：可以分成true和false两组，也可以根据字段分成多组                                 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier);</span><br><span class="line">    <span class="comment">// 只能分成true和false两组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                                                          Collector&lt;? <span class="keyword">super</span> U, A, R&gt; downstream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                                                     Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                                                     BinaryOperator&lt;U&gt; op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="四-实例">四. 实例</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接下来的示例代码基于此集合</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;sd&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3><span id="1-将流数据转换成集合">1. 将流数据转换成集合</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换成list集合</span></span><br><span class="line">List&lt;String&gt; stringList = strings.stream().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成Set集合</span></span><br><span class="line">Set&lt;String&gt; stringSet = strings.stream().collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成Map集合</span></span><br><span class="line">Map&lt;String,Object&gt; stringObjectMap = strings.stream()</span><br><span class="line">    .collect(Collectors.toMap(k -&gt; k, v -&gt; v ));</span><br><span class="line"></span><br><span class="line">System.out.println(stringList);</span><br><span class="line">System.out.println(stringSet);</span><br><span class="line">System.out.println(stringObjectMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">[ab, s, bc, cd, abcd, sd, jkl]</span><br><span class="line">[ab, bc, cd, sd, s, jkl, abcd]</span><br><span class="line">&#123;sd=sd, cd=cd, bc=bc, ab=ab, s=s, jkl=jkl, abcd=abcd&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="2-将集合拆分拼接成字符串">2. 将集合拆分拼接成字符串</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//joining</span></span><br><span class="line">String str1 = strings.stream()</span><br><span class="line">    .collect(Collectors.joining(<span class="string">&quot;--&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//collectingAndThen</span></span><br><span class="line">String str2 = strings.stream()</span><br><span class="line">    .collect(Collectors.collectingAndThen(</span><br><span class="line">        <span class="comment">//在第一个joining操作的结果基础上再进行一次操作</span></span><br><span class="line">        Collectors.joining(<span class="string">&quot;--&quot;</span>), s1 -&gt; s1 += <span class="string">&quot;,then&quot;</span></span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">ab--s--bc--cd--abcd--sd--jkl</span><br><span class="line">ab--s--bc--cd--abcd--sd--jkl,then</span><br></pre></td></tr></table></figure>



<h3><span id="3-求最大值-最小值-求和-平均值">3. 求最大值、最小值、求和、平均值</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值</span></span><br><span class="line">Integer maxValue = list.stream().collect(Collectors.collectingAndThen(</span><br><span class="line">    <span class="comment">//maxBy需要Comparator.comparingInt来确定排序规则</span></span><br><span class="line">    Collectors.maxBy(Comparator.comparingInt(a -&gt; a)), Optional::get</span><br><span class="line">));</span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">Integer minValue = list.stream().collect(Collectors.collectingAndThen(</span><br><span class="line">    <span class="comment">//minBy需要Comparator.comparingInt来确定排序规则</span></span><br><span class="line">    Collectors.minBy(Comparator.comparingInt(a -&gt; a)), Optional::get</span><br><span class="line">));</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">Integer sumValue = list.stream().collect(Collectors.summingInt(i -&gt; i));</span><br><span class="line"><span class="comment">//平均值</span></span><br><span class="line">Double avgValue = list.stream().collect(Collectors.averagingDouble(i -&gt; i));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + maxValue);</span><br><span class="line">System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + minValue);</span><br><span class="line">System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + sumValue);</span><br><span class="line">System.out.println(<span class="string">&quot;平均数 : &quot;</span> + avgValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">列表中最大的数 : <span class="number">5</span></span><br><span class="line">列表中最小的数 : <span class="number">1</span></span><br><span class="line">所有数之和 : <span class="number">15</span></span><br><span class="line">平均数 : <span class="number">3.0</span></span><br></pre></td></tr></table></figure>

<p>虽然这样也可以，但是明显IntSummaryStatistics要更灵活点</p>
<h3><span id="4-对集合分组">4. 对集合分组</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; map = strings.stream()</span><br><span class="line">    <span class="comment">//根据字符串长度分组（同理，对对象可以通过某个属性分组）</span></span><br><span class="line">    .collect(Collectors.groupingBy(String::length));</span><br><span class="line"></span><br><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; map2 = strings.stream()</span><br><span class="line">    <span class="comment">//根据字符串是否大于2分组</span></span><br><span class="line">    .collect(Collectors.groupingBy(s -&gt; s.length() &gt; <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line">System.out.println(map2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">&#123;<span class="number">1</span>=[s], <span class="number">2</span>=[ab, bc, cd, sd], <span class="number">3</span>=[jkl], <span class="number">4</span>=[abcd]&#125;</span><br><span class="line">&#123;<span class="keyword">false</span>=[ab, s, bc, cd, sd], <span class="keyword">true</span>=[abcd, jkl]&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="5对数据进行映射">5.对数据进行映射</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = strings.stream().collect(Collectors.mapping(</span><br><span class="line">    <span class="comment">//先对集合中的每一个元素进行映射操作</span></span><br><span class="line">    s -&gt; s += <span class="string">&quot;,mapping&quot;</span>,</span><br><span class="line">    <span class="comment">//再对映射的结果使用Collectors操作</span></span><br><span class="line">    Collectors.collectingAndThen(Collectors.joining(<span class="string">&quot;;&quot;</span>), s -&gt; s += <span class="string">&quot;=====then&quot;</span> )</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">ab,mapping;s,mapping;bc,mapping;cd,mapping;abcd,mapping;sd,mapping;jkl,mapping=====then</span><br></pre></td></tr></table></figure>

<p>。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（二）：List与AbstractList</title>
    <url>/2020/11/27/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AList%E4%B8%8EAbstractList/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>上一篇文章基本介绍了 List 接口的上层结构，也就是 Iterable 接口，Collection 接口以及实现了 Collection 接口的抽象类的基本情况，现在在前文的基础上，我们将继续向实现前进，进一步的探索 List 接口与其抽象实现类 AbstractList 的源码，了解他是如何在三大实现类与 Collection 接口之间实现承上启下的作用的。</p>
<h2><span id="一-list-接口">一、List 接口</span></h2><p><img src="http://img.xiajibagao.top/image-20201125163518482.png" alt="List 接口的方法"></p>
<p>List 接口继承了 Collection 接口，在 Collection 接口的基础上增加了一些方法。相对于 Collection 接口，我们可以很明显的看到，List <strong>中增加了非常多根据下标操作集合的方法</strong>，我们可以简单粗暴的分辨一个方法的抽象方法到底来自 Collection 还是 List：参数里有下标就是来自 List，没有就是来自 Collection。</p>
<p>可以说，List 接口在 Collection 的基础上，<strong>进一步明确了 List 集合运允许根据下标快速存取的特性</strong>。</p>
<h3><span id="1新增的方法">1.新增的方法</span></h3><ul>
<li><code>get()</code>：根据下标获取指定元素；</li>
<li><code>replaceAll()</code>：参数一个函数式接口<code>UnaryOperator&lt;E&gt;</code>，这个方法允许我们通过传入的匿名实现类的方法去对集合中的每一个类做一些处理以后再放回去；</li>
<li><code>sort()</code>：对集合中的数据进行排序。参数是 <code>Comparator&lt;? super E&gt;</code>，这个参数让我们传入一个比较的匿名方法，用于数组排序；</li>
<li><code>set()</code>：用指定的元素替换集合中指定位置的元素；</li>
<li><code>indexOf()</code>：返回指定元素在此列表中首次出现的索引；如果此列表不包含该元素，则返回-1；</li>
<li><code>lastIndexOf()</code>：返回指定元素在此列表中最后一次出现的索引，否则返回-1；</li>
<li><code>listIterator()</code>：这个是个多态的方法。无参的 <code>listIterator()</code>用于获取迭代器，而有参的 <code>listIterator()</code>可以传入下标，从集合的指定位置开始获取迭代器。指定的索引指示首次调用next将返回的第一个元素。</li>
<li><code>subList()</code>：返回此列表中指定的两个指定下标之间的集合的视图。注意，这里说的<strong>是视图，因而对视图的操作会影响到集合，反之亦然。</strong></li>
</ul>
<h3><span id="2同名的新方法">2.同名的新方法</span></h3><ul>
<li><code>add()</code>：添加元素。List 中的 <code>add()</code> 参数的（int，E），而 Collection 中的 <code>add()</code> 参数是 E，<strong>因此 List 集合中同时存在指定下标和不指定下标两种添加方式</strong>；</li>
<li><code>remove()</code>：删除指定下标的元素。注意，List 的 <code>remove()</code> 参数是 int ，而 Collection 中的 ``remove()` 参数是 Objce，也就是说，<strong>List 中同时存在根据元素是否相等和根据元素下标删除元素两种方式</strong>。</li>
</ul>
<h3><span id="3重写的方法">3.重写的方法</span></h3><ul>
<li><code>spliterator()</code>：List 接口重写了 Collection 接口的默认实现，换成了根据顺序的分割。</li>
</ul>
<h2><span id="二-abstractlist-抽象类">二、AbstractList 抽象类</span></h2><p>AbstractList 类是一个继承了 AbstractCollection 类并且实现了 List 接口的抽象类，它相当于在 AbstractCollection 后的第二层方法模板。是对 List 接口的初步实现，同时也是 Collection 的进一步实现。</p>
<h3><span id="1不支持的实现">1.不支持的实现</span></h3><p>可以直接通过下标操作的<code>set()</code>，<code>add()</code>，<code>remove()</code>都是 List 引入的新接口，这些都 AbstractList 都不支持，要使用必须由子类重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2内部类们">2.内部类们</span></h3><p>跟 AbstractCollection 类不同，AbstractList 拥有几个特别的内部类，他们分别的迭代器类：Itr 和 ListItr，对应获取他们的方法是：</p>
<ul>
<li><code>iterator()</code>：获取 Itr 迭代器类；</li>
<li><code>listIterator()</code>：获取 ListItr 迭代器类。这是个多态方法，可以选择是否从指定下标开始，默认从下标为0的元素开始迭代；</li>
</ul>
<p>视图类 SubList 和 RandomAccessSubList：</p>
<ul>
<li><code>subList()</code>：获取视图类，会自动根据实现类是否继承 RandomAccess 而返回 SubList  或 RandomAccessSubList。</li>
</ul>
<p>这些内部类同样被一些其他的方法所依赖，所以要全面的了解 AbstractList 方法的实现，就需要先了解这些内部类的作用和实现原理。</p>
<h2><span id="三-sublist方法与内部类">三、subList方法与内部类</span></h2><p><code>subList()</code>算是一个比较常用的方法了，在 List 接口的规定中，这个方法应该返回一个当前集合的一部分的视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是实现了RandomAccess接口的类</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="comment">// 是就返回一个可以随机访问的内部类RandomAccessSubList</span></span><br><span class="line">            <span class="keyword">new</span> RandomAccessSubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex) :</span><br><span class="line">            <span class="comment">// 否则返回一个普通内部类SubList</span></span><br><span class="line">            <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到 RandomAccessSubList 和 SubList 这个内部类，其中，RandomAccessSubList 类是 SubList  类的子类，但是实现了 RandomAccess 接口。</p>
<h3><span id="1sublist-内部类">1.SubList 内部类</span></h3><p>我们可以简单的把 SubList 和 AbstractList 理解为装饰器模式的一种实现，就像 SynchronizedList 和 List 接口的实现类一样。SubList 内部类通过对 AbstractList 的方法进行了再一次的封装，把对 AbstractList 的操作转变为了对 “视图的操作”。</p>
<p>我们先看看 SubList 这个类的成员变量和构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 把外部类AbstractList作为成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; l;</span><br><span class="line">    <span class="comment">// 表示视图的起始位置（偏移量）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">// SubList视图的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;fromIndex = &quot;</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; list.size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;toIndex = &quot;</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line">                                               <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取外部类的引用</span></span><br><span class="line">        <span class="comment">// 这也是为什么操作视图或者外部类都会影响对方的原因，因为都操作内存中的同一个实例</span></span><br><span class="line">        l = list;</span><br><span class="line">        <span class="comment">// 获取当前视图在外部类中的起始下标</span></span><br><span class="line">        offset = fromIndex;</span><br><span class="line">        <span class="comment">// 当前视图的长度就是外部类截取的视图长度</span></span><br><span class="line">        size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以参考图片理解一下：</p>
<p><img src="D:\代码及jar包\学习记录\java相关\java集合\java集合初探：List综述\image-20201126114026855.png" alt="SubList与外部类的关系"></p>
<p>然后 subList 里面的方法就很好理解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 判断是存在并发修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 把元素添加到偏移量+视图下标的位置</span></span><br><span class="line">    <span class="keyword">return</span> l.set(index+offset, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法都差不多，这里便不再多费笔墨了。</p>
<h3><span id="2randomaccesssublist-内部类">2.RandomAccessSubList 内部类</span></h3><p>然后是 SubList 的子类 RandomAccessSubList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomAccessSubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    RandomAccessSubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">super</span>(list, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomAccessSubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看见，他实际上还是 SubList，但是实现了 RandomAccess 接口。关于这个接口，其实只是一个标记，实现了该接口的类可以实现快速随机访问（下标），通过 for 循环+下标取值会比用迭代器更快。</p>
<p>Vector 和 ArrayList 都实现了这个接口，而 LinkedList 没有。专门做此实现也是为了在实现类调用的 <code>subList()</code>方法时可以分辨这三者。</p>
<h2><span id="四-iterator方法与内部类">四、iterator方法与内部类</span></h2><p>在 AbstractList 里面，为我们提供了 Itr 和 ListItr 两种迭代器。</p>
<p>迭代器是 AbstractList 中很重要的一块内容，他是对整个接口体系的顶层接口，也就是 Iterable 接口中的 <code>iterator()</code> 方法的实现，源码中的很多涉及遍历的方法，都离不开内部实现的迭代器类。</p>
<h3><span id="1迭代器的-fast-fail-机制">1.迭代器的 fast-fail 机制</span></h3><p>我们知道，AbstractList 默认是不提供线程安全的保证的，但是为了尽可能的避免并发修改对迭代带来的影响，JDK 引入一种 fast-fail 的机制，即如果检测的发生并发修改，就立刻抛出异常，而不是让可能出错的参数被使用从而引发不可预知的错误。</p>
<p>对此，AbstractList 提供了一个成员变量 <code>modCount</code>，JavaDoc 是这么描述它的：</p>
<blockquote>
<p>已对该列表进行结构修改的次数。</p>
<p>结构修改是指更改列表大小或以其他方式干扰列表的方式，即正在进行的迭代可能会产生错误的结果。该字段由iterator和listIterator方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，则迭代器（或列表迭代器）将抛出ConcurrentModificationException，以响应下一个，移除，上一个，设置或添加操作。</p>
<p>面对迭代期间的并发修改，这提供了快速失败的行为，而不是不确定的行为。</p>
<p>子类对此字段的使用是可选的。如果子类希望提供快速失败的迭代器（和列表迭代器），则只需在其add（int，E）和remove（int）方法（以及任何其他覆盖该方法导致结构化的方法）中递增此字段即可）。</p>
<p>一次调用add（int，E）或remove（int）不得在此字段中添加不超过一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationExceptions。</p>
<p>如果实现不希望提供快速失败迭代器，则可以忽略此字段。</p>
</blockquote>
<p>这个时候我们再回去看看迭代器类 Itr 的一部分代码，可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代器认为后备列表应该具有的modCount值。如果违反了此期望，则迭代器已检测到并发修改。</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否发生并发操作</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合代码，我们就不难理解这个 fast-fail 机制是怎么实现的了：</p>
<p>AbstractList 提供了一个成员变量用于记录对集合结构性修改的次数，如果子类希望实现并发修改错误的检查，就需要结构性操作的方法里让<code>modCount</code>+1。这样。在获取迭代器以后，迭代器内部会获取当前的<code>modCount</code>赋值给<code>expectedModCount</code>。</p>
<p>当使用迭代器迭代的时候，每一次迭代都会检测<code>modCount</code>和<code>expectedModCount</code>是否相等。如果不相等，说明迭代器创建以后，集合结构被修改了，这个时候再去进行迭代可能会出现错误（比如少遍历一个，多遍历一个），因此检测到后会直接抛出 <code>ConcurrentModificationException</code>异常。</p>
<p>ListItr 继承了 Itr ，因此他们都有一样的 fast-fail机制。 </p>
<p>值得一提的是，<strong>对于启用了 fast-fail 机制的实现类，只有使用迭代器才能边遍历边删除</strong>，原因也是因为并发修改检测：</p>
<h3><span id="2itr-迭代器">2.Itr 迭代器</span></h3><p>现在，回到 Itr 的代码上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 后续调用next返回的元素索引</span></span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最近一次调用返回的元素的索引。如果通过调用remove删除了此元素，则重置为-1。</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器认为后备列表应该具有的modCount值。如果违反了此期望，则迭代器已检测到并发修改。</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            E next = get(i);</span><br><span class="line">            lastRet = i;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代方法</strong></p>
<p>除了并发修改检测外，迭代器迭代的方式也出乎意料。我们可以看看 <code>hasNext()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检验是否发生并发修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        E next = get(i);</span><br><span class="line">        lastRet = i;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个逻辑其实跟链表的遍历是一样的，只不过指针变成了数组的下标。以链表的方式去理解：</p>
<p>我们把循环里调用<code>next()</code>之后的节点叫做下一个节点，反正称为当前节点。假如现在有 a，b，c 三个元素：</p>
<ul>
<li>当初始化的时候，指向最后一次操作的的节点的指针 <code>lastRet=-1</code>，即当前节点不存在，当前游标 <code>cursor=0</code>，即指向下一个节点 a；</li>
<li>当开始迭代的时候，把游标的值赋给临时指针 i，然后通过游标获取并返回下一个节点 a，再把游标指向 a 的下一个节点 b，此时 <code>cursor=1</code>，<code>lastRet=-1</code>，<code>i=1</code>；</li>
<li>接着让<code>lastRet=i</code>，也就是当前指针指向新的当前节点 a，现在 lastRet=0<code>，</code>cursor=1`，完成了对第一个节点 a 的迭代；</li>
<li>重复上述过程，把节点中的每一个元素都处理完。</li>
</ul>
<p>现在我们知道了迭代的方式，<code>cursor</code>和 <code>lastRet</code> 的作用，也就不难理解 <code>remove()</code>方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用删除方法</span></span><br><span class="line">        AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">		   <span class="comment">// 因为删除了当前第i个节点，所以i+1个节点就会变成第i个节点，</span></span><br><span class="line">            <span class="comment">// 调用next()以后cursor会+1，因此如果不让cursor-1,就会,next()以后跳过原本的第i+1个节点</span></span><br><span class="line">            <span class="comment">// 拿上面的例子来说，你要删除abc，但是在删除a以后会跳过b直接删除c</span></span><br><span class="line">            cursor--;</span><br><span class="line">        <span class="comment">// 最近一个操作的节点被删除了，故重置为-1</span></span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 因为调用了外部类的remove方法，所以会改变modCount值，迭代器里也要获取最新的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于<code>hasNext()</code>方法没啥好说的，如果 <code>cursor</code>已经跟集合的长度一样长了，说明就已经迭代到底了。</p>
<h3><span id="2listitr-迭代器">2.ListItr 迭代器</span></h3><p>ListItr 继承了 Itr 类，并且实现了 ListIterator 接口。其中，ListIterator  接口又继承了 Iterator 接口。他们的类关系图是这样的：</p>
<p><img src="http://img.xiajibagao.top/image-20201126204925206.png" alt="ListIterator 的类关系图"></p>
<p>ListIterator 接口在 Iterator 接口的基础上，主要提供了六个新的抽象方法：</p>
<ul>
<li><code>hasPrevious()</code>：是否有前驱节点；</li>
<li><code>previous()</code>：向前迭代；</li>
<li><code>nextIndex()</code>：获取下一个元素的索引；</li>
<li><code>previousIndex()</code>：返回上一个元素的索引；</li>
<li><code>set()</code>：替换元素；</li>
<li><code>add()</code>：添加元素；</li>
</ul>
<p>可以看出来，实现了 ListIterator 的 ListItr 类要比 Itr 更加强大，不但可以向后迭代，还能向前迭代，还可以在迭代过程中更新或者添加节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 可以自己设置迭代的开始位置</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 下一节点是否就是第一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查并发修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 让游标指向当前节点</span></span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 使用AbstractList的get方法获取当前节点</span></span><br><span class="line">            E previous = get(i);</span><br><span class="line">            lastRet = cursor = i;</span><br><span class="line">            <span class="keyword">return</span> previous;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取下一节点的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点（下一个节点的上一个节点）的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="comment">// 往下一个节点的位置添加新节点</span></span><br><span class="line">            AbstractList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里比较不好理解的是下一节点还有当前节点这个概念，其实可以这么理解：<code>cursor</code>游标指定的必定是下一次 <code>next()</code>操作要得到的节点，因此<code>cursor</code>在操作前或者操作后指向的必定就是下一节点，因此相对下一节点，<code>cursor</code>其实就是当前节点，相对下一节点来说就是上一节点。</p>
<p>也就是说，假如现在有 a，b，c 三个元素，现在的 <code>cursor</code> 为2，也就是指向 b。调用 <code>next()</code>以后游标就会指向 c，而调用<code>previous()</code>以后游标又会指回 b。</p>
<p>至于<code>lastRet</code>这个成员变量只是用于记录最近一次操作的节点是哪个，跟方向性是无关。</p>
<h2><span id="五-abstractlist-实现的方法">五、AbstractList 实现的方法</span></h2><h3><span id="1add">1.add</span></h3><p>注意，现在现在 AbstractList 的 <code>add(int index, E e)</code>仍然还不被支持，<code>add(E e)</code>只是定义了通过 <code>add(int index, E e)</code>把元素添加到队尾的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不指定下标的add，默认逻辑为添加到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 AbstractList 和 AbstractCollection 中 <code>add()</code>方法之间的关系是这样的：</p>
<p><img src="http://img.xiajibagao.top/image-20201126110250536.png" alt="add方法的实现逻辑"></p>
<p>AbstractList 这里的 <code>add(E e)</code>就非常有模板方模式提到的“抽象类规定算法骨架”这个感觉了。AbstractCollection 接口提供了 <code>add(E e)</code>的初步实现（尽管只是抛异常），然后到了 AbstractList 中就完善了 <code>add(E e)</code>方法的逻辑——通过调用 <code>add(int index,E e)</code>方法把元素插到队尾，但是具体的  <code>add(int index,E e)</code>怎么实现再交给子类决定。</p>
<h3><span id="2indexoflastindexof">2.indexOf/LastIndexOf</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(size());</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (it.previous()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.previous()))</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3addall">3.addAll</span></h3><p>这里的<code>addAll</code>来自于List 集合的 <code>addAll</code>。参数是需要合并的集合跟起始下标：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>rangeCheckForAdd()</code>方法是一个检查下标是否越界的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不得小于0或者大于集合长度</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4removerange">4.removeRange</span></h3><p>这个方法是 AbstractList 私有的方法，一般被子类用于删除一段多个元素，实现上借助了 ListIter 迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="comment">// 从fromIndex的下一个开始，删到toIndex</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="六-abstractlist-重写的方法">六、AbstractList 重写的方法</span></h2><h3><span id="1equals">1.equals</span></h3><p><code>equals()</code>方法比较特殊，他是来自于 Collection 和 List 接口中的抽象方法，在 AbstractList 得中实现，但是实际上也是对 Object 中方法的重写。考虑到 <code>equals()</code>情况特殊，所以我们也认为它是一个重写的方法。</p>
<p>我们可以先看看 JavaDoc 是怎么说的：</p>
<blockquote>
<p>比较指定对象与此列表是否相等。当且仅当指定对象也是一个列表，并且两个列表具有相同的大小，并且两个列表中所有对应的元素对相等时，才返回true</p>
</blockquote>
<p>然后再看看源码是什么样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否同一个集合</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 是否实现了List接口</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取集合的迭代器并同时遍历</span></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="comment">// 两个集合中的元素是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否两个集合长度相同</span></span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码也可以看出，AbstractList 的 <code>equals()</code> 是要求两个集合绝对相等的：顺序相等，并且相同位置的元素也要相等。</p>
<h3><span id="2hashcode">2.hashCode</span></h3><p><code>hashCode()</code> 和 <code>equals()</code>情况相同。AbstractList 重新定义了 <code>hashCode()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : <span class="keyword">this</span>)</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的计算方式会获取集合中每一个元素的 hashCode 去计算集合的 hashCode，这可能是考虑到原本情况下，同一个集合哪怕装入的元素不同也会获得相同的 hashCode，可能会引起不必要的麻烦，因此重写了次方法。</p>
<p>我们可以写个测试看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(list1.hashCode()); <span class="comment">// 128</span></span><br><span class="line">list1.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(list1.hashCode()); <span class="comment">// 4067</span></span><br></pre></td></tr></table></figure>

<h2><span id="七-总结">七、总结</span></h2><p>List 接口继承了 Collection 接口，新增方法的特点主要体现在可以通过下标去操作节点，可以说大部分下标可以作为参数的方法都是 List 中添加的方法。</p>
<p>AbstractList 是实现了 List 的抽象类，他实现了 List 接口中的大部分方法，同时他继承了 AbstractCollection ，沿用了一些 AbstractCollection 中的实现。这两个抽象类可以看成是模板方法模式的一种体现。</p>
<p>他提供了下标版的 <code>add()</code>，<code>remove()</code>，<code>set()</code>的空实现。</p>
<p>AbstractList 内部提供两个迭代器，Itr 和 ListItr，Itr 实现了 <code>Iterator</code>接口，实现了基本的迭代删除，而 ListItr 实现了<code>ListIterator</code>，在前者的基础上增加了迭代中添加修改，以及反向迭代的相关方法，并且可以从指定的位置开始创建迭代器。</p>
<p>AbstractList 的 SubList 可以看成 AbstractList 的包装类，他在实例化的时候会把外部类实例的引用赋值给成员变量，同名的操作方法还仍然是调用 AbstractList  的，但是基于下标的调用会在默认参数的基础上加上步长，以实现一种类似“视图”的感觉。</p>
<p>AbstractList 引入了并发修改下 fast-fail 的机制，在内部维护一个成员变量 <code>modelCount</code>，默认为零，每次结构性修改都会让其+1。在迭代过程中会默认检查 <code>modelCount</code>是否符合预期值，否则抛出异常。值得注意的是，这个需要实现类的配合，在实现 <code>add()</code>等方法的时候要让 <code>modelCount</code>+1。对于一些实现类，在迭代中删除可能会抛出 <code>ConcurrentModificationExceptions</code>，就是这方面的问题。</p>
<p>AbstractList 重写了 <code>hashCode()</code>方法，不再直接获取实例的 HashCode 值，而遍历集合，根据每一个元素的 HashCode 计算集合的 HashCode，这样保证了内容不同的相同集合不会得到相同的 HashCode。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合初探（一）：HashMap</title>
    <url>/2020/08/16/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E5%88%9D%E6%8E%A2%EF%BC%9AHashMap/</url>
    <content><![CDATA[<h2><span id="概述">概述</span></h2><p>HashMap 可能是最经常用的Map接口的实现了，但是一直以来，对 HashMap 一些特性的实现原理我却知之甚少，今天特此结合源码，好好了解一下 HashMap 的底层实现。</p>
<p>话不多说，我们先看看HashMap类的注释：</p>
<blockquote>
<p>基于哈希表的Map接口实现。</p>
<p>这个实现提供了所有可选的映射操作，并<strong>允许空值和空键</strong>。（<strong>HashMap类与Hashtable大致相当，只是它是不同步的，并且允许为null</strong>）</p>
<p><strong>这个类对映射的顺序不做任何保证</strong>；特别是，它不保证顺序将随着时间的推移保持不变。<br>这个实现为基本操作（get和put）提供了恒定的时间性能，假设hash函数在bucket中适当地分散了元素。集合视图<strong>上的迭代所需的时间与HashMap实例的“容量”（bucket的数量）加上其大小（键值映射的数量）成比例</strong>。因此，如果迭代性能很重要，那么<strong>不要将初始容量设置得太高（或者负载系数太低），这一点非常重要。</strong><br>HashMap的实例有两个影响其性能的参数：初始容量和负载因子。capacity是哈希表中的bucket数，初始容量就是创建哈希表时的容量。加载因子是一个度量哈希表在容量自动增加之前可以达到的完整程度。<strong>当哈希表中的条目数超过加载因子与当前容量的乘积时，哈希表将重新哈希（即重建内部数据结构），使哈希表的存储桶数大约为原来的两倍</strong>。<br>一般来说，默认的负载系数（.75）在时间和空间成本之间提供了很好的折衷。较高的值会减少空间开销，但会增加查找开销（反映在HashMap类的大多数操作中，包括get和put）。在设置初始容量时，应考虑地图中的预期条目数及其荷载系数，以尽量减少再灰化操作的次数。如果初始容量大于最大入口数除以负载系数，则不会发生再吹灰操作。<br>如果要在一个HashMap实例中存储许多映射，那么以足够大的容量创建它将使映射的存储效率更高，而不是让它根据需要执行自动重新缓存以增加表。请注意，使用具有相同hashCode（）的多个键肯定会降低任何哈希表的性能。为了改善影响，当键是可比较的时，这个类可以使用键之间的比较顺序来帮助打破联系。<br>请注意<strong>，此实现不是同步的</strong>。如果多个线程同时访问一个哈希映射，并且至少有一个线程在结构上修改了该映射，则它必须在外部同步。（结构修改是指添加或删除一个或多个映射的任何操作；仅更改与实例已包含的键相关联的值不是结构修改。）这通常是通过对自然封装映射的对象进行同步来完成的。如果不存在这样的对象，则应该使用集合.synchronizedMap方法。最好在创建时执行此操作，以防止意外的不同步访问映射：</p>
<p><code>Map m = Collections.synchronizedMap(new HashMap(...));</code> </p>
<p>注意，迭代器的fail-fast行为不能得到保证，因为一般来说，在存在不同步的并发修改时，不可能做出任何明确保证。Fail fast迭代器在尽最大努力的基础上抛出ConcurrentModificationException。因此，<strong>编写一个依赖这个异常来保证其正确性的程序是错误的：迭代器的fail-fast行为应该只用于检测bug。</strong></p>
</blockquote>
<p>以下是HashMap的类关系：</p>
<p><img src="http://img.xiajibagao.top/HashMap%E7%9A%84%E7%B1%BB%E5%85%B3%E7%B3%BB.png" alt="HashMap的类关系"></p>
<blockquote>
<p>HashMap实现了Map接口，并继承 AbstractMap 抽象类，其中 Map 接口定义了键值映射规则。和 AbstractCollection抽象类在 Collection 族的作用类似， AbstractMap 抽象类提供了 Map 接口的骨干实现，以最大限度地减少实现Map接口所需的工作。</p>
</blockquote>
<p>对于HashMap，我们关注六个问题：</p>
<ul>
<li>HashMap的数据结构（实现结构，什么情况变红黑树，树化和链化的阈值）</li>
<li>HashMap构造函数（四个构造函数）</li>
<li>HashMap的put（哈希、异或与或运算获取下标，为什么初始容量是2的n次方）</li>
<li>HashMap的get（为什么重写equals方法需同时重写hashCode方法）</li>
<li>HashMap的扩容（JDK8为什么不需要重哈希）</li>
<li>HashMap为什么是线程不安全的？（1.7死循环，1.8数据覆盖）</li>
</ul>
<h2><span id="一-hashmap的数据结构">一、HashMap的数据结构</span></h2><h3><span id="1底层实现">1.底层实现</span></h3><p>既然HashMap叫这个名字，那他的实现必然是基于哈希表的，关于哈希表我在<a href="https://www.cnblogs.com/Createsequence/p/13234705.html">数据结构与算法（十）：哈希表</a>已有介绍。简而言之，哈希表就是一种结合数组与链表的一种数据结构，借助哈希算法快速获取元素下标以实现高效查找。</p>
<p>关于HashMap的底层的数据结构，我们需要了解两个成员变量以及一个内部类：</p>
<ul>
<li><code>transient Node&lt;K,V&gt;[] table;</code>：桶容器</li>
<li><code>Node&lt;K,V&gt;</code>：<code>entrySet</code>使用的，基于<code>Map.Entry&lt;K,V&gt;</code>接口实现的节点类，也就是同容器中的链表</li>
</ul>
<p>画图描述一下就是：</p>
<p><img src="http://img.xiajibagao.top/HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="HashMap的数据结构"></p>
<p>我们知道哈希表解决哈希冲突的方式有开放地址法和分离链表法，这里很明显使用的是分离链表法，也就是俗称的拉链法。</p>
<p>当我们存储一个键值对的时候，会通过哈希算法获得key对应的哈希值，通过哈希值去找到在桶中要存放的位置的下标，而有时候不同的key会计算出相同的哈希值，也就是哈希碰撞，那么节点就会接在第一个节点的身后形成一条链表。当查找的时候先通过key计算得到哈希值找到链表，然后再遍历链表找到key，因此如果哈希碰撞严重，会导致链表变的很长，会影响到查找效率。</p>
<p>按这角度思考，如果桶数组很大，那么同样的哈希算法能得到的位置就更多，换句话说就是发生哈希碰撞的概率就越小，但是过大的桶数组又会浪费空间，所以就后面提到的扩容算法来动态的调整容量。</p>
<h3><span id="2什么时候转为红黑树为什么">2.什么时候转为红黑树？为什么？</span></h3><p>另外，我们知道在JDK7中HashMap底层实现只是<strong>数组+链表</strong>，而到了JDK8就变成了<strong>数组+链表+红黑树</strong>。</p>
<p>红黑树是一种复杂的树结构，这里我们简单的理解为一种<strong>具有二叉排序树性质和一定平衡二叉树性质（不要求绝对平衡以避免频繁旋转）的二叉树</strong>。</p>
<p>我们知道发生哈希碰撞的节点会在桶中形成链表，查看树化方法<code>treeifyBin()</code>，我们可以发现当<strong>链表上的元素超过8个并且集合中元素大于等于64个的时候</strong>的时候就会转变成红黑树，否则只会单纯的扩容。这是因为同样深度的情况下，树可以储存比链表更多的元素，并且同时能保证良好的插入删除和查找效率。<strong>当元素小于6个的时候又会转回链表</strong>。</p>
<p>那么为什么会选择8和6这两个数字呢？</p>
<ul>
<li><p>效率问题：</p>
<p>红黑树的平均查找长度是lg(n)，而链表是n/2。按这个计算，lg(8)=3，6/2=3 -&gt; lg(4)=2， 4/2=2，我们可以看见当越小于8的时候红黑树和链表查找效率就越差不多，加上转化为红黑树还需要消耗额外的时间和空间的情况下，所以不如直接用链表。</p>
</li>
<li><p>防止频繁的转换：</p>
<p>8和6之间隔了一个7，如果转换为树和转换为链表的阈值是直接相邻，那么很可能出现频繁在树和链表的结构件转换的现象。</p>
</li>
</ul>
<h2><span id="二-hashmap的构造函数">二、HashMap的构造函数</span></h2><p>我们先来看看有关HashMap构建中可能涉及的成员变量：</p>
<ul>
<li><p><code>transient int size</code>：实际存储的key-value键值对的个数；</p>
</li>
<li><p><code>int threshold</code>：要调整大小的下一个大小值。</p>
<p>一般是容量 * 负载系数，但是构造函数执行后大小等于初始化容量，只有第一次添加元素后才会初始化；</p>
</li>
<li><p><code>final float loadFactor</code>：负载因子，代表了table的填充度有多少，默认是0.75。</p>
<p>加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。 所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32；</p>
</li>
<li><p><code>transient int modCount</code>：HashMap被改变的次数。</p>
<p>由于HashMap非线程安全，在对HashMap进行迭代时， 如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作）， 需要抛出异常ConcurrentModificationException</p>
</li>
</ul>
<h3><span id="1有初始容量和负载因子的构造方法">1.有初始容量和负载因子的构造方法</span></h3><blockquote>
<p>构造一个具有<strong>指定初始容量</strong>和<strong>负载因子</strong>的空HashMap。</p>
</blockquote>
<p>这里提到的负载因子，<strong>负载因子衡量的是一个散列表的空间的使用程度</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始容量必须大于0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//初始容量不能大于最大值</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化加载因子</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用的<code>tableSizeFor()</code>方法是个位运算，他的作用是：</p>
<blockquote>
<p>对于给定的目标容量，返回2的幂</p>
</blockquote>
<p>换而言之，<strong>初始化容量必须是2的n次方</strong>，这个地方与HashMap如何向集合高效添加元素的需求是直接相关的。</p>
<p>具体的分析可以参考：<a href="https://blog.csdn.net/fan2012huan/article/details/51097331">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a>。</p>
<p>接着我们可以看到初始容量处理后直接给了<code>threshold</code>，不直接使用<code>initialCapacity</code>而是这样做的原因是<strong>一开始的时候map的底层容器table尚未初始化，这个操作被放到了第一次put上</strong>，所以当我们第一次添加元素的时候，才会根据指定的初始大小去初始化容器。</p>
<h3><span id="2只有初始容量的构造方法">2.只有初始容量的构造方法</span></h3><blockquote>
<p>构造一个具有指定初始容量和默认负载因子（0.75）的空HashMap。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接调用 HashMap(int initialCapacity, float loadFactor)构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3无参构造方法">3.无参构造方法</span></h3><blockquote>
<p>构造一个具有指定初始容量（16）和默认负载因子（0.75）的空HashMap。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//全部使用默认值</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-有一个map类型的参数的构造方法">4、有一个Map类型的参数的构造方法</span></h3><blockquote>
<p>使用与指定Map相同的映射构造一个新的HashMap。使用默认的负载因子（0.75）和足以将映射保存在指定Map中的初始容量创建HashMap。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>putMapEntries()</code>方法，我们待会再细说，现在先简单里理解为根据一个已经存在的Map集合去创建一个新Map集合，有点类似于<code>Arrays.copyOf()</code>方法。</p>
<h2><span id="三-hashmap的put">三、HashMap的put</span></h2><p>我们从上文可以知道，当构造函数执行完毕以后，并没有真正的开辟HashMap的数据存储空间，而是等到第一次put的时候才会为table分配空间。</p>
<h3><span id="1put操作的实现">1.put操作的实现</span></h3><p>HashMap中有一个<code>put()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的注释是这样描述的：</p>
<blockquote>
<p><strong>将指定值与该映射中的指定键相关联</strong>。如果该映射先前包含该键的映射，则将<strong>替换旧值</strong>。</p>
</blockquote>
<p>简单的来说，就是两个功能：</p>
<ul>
<li>将值与建关联</li>
<li>如果新值对应的键已有旧值，则替换旧值</li>
</ul>
<p>我们可以看到，实际上这个方法通过<code>hash（）</code>和<code>putVal()</code> 两个方法来实现。</p>
<h3><span id="2计算桶容器下标">2.计算桶容器下标</span></h3><p>桶容器下标通过三个步骤来计算：<strong>获取哈希值，异或运算混合高低位得到新哈希，新哈希和长度与运算获取下标</strong>。</p>
<p>我们看看<code>hash()</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>hashCode()</code>方法是一个Native方法，原理是将对象的内存地址转为一个整数以获取对象哈希值。</p>
<p>这一个方法先调用了一个 <code>key.hashCode()</code>方法获取了key的哈希值，然后将哈希值与哈希值的高16位做异或运算。</p>
<p>而在下面的<code>putVal()</code>方法中，又通过类似下面三行代码进行取模：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n为新桶数组长度</span></span><br><span class="line">n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//进行与运算取模</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>

<p>从网上看到一张很形象的图：</p>
<p><img src="http://img.xiajibagao.top/%E9%AB%98%E4%BD%8D%E8%BF%90%E7%AE%97%E5%92%8C%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87.png" alt="通过高位运算和取模运算获取数组下标"></p>
<p>我们来理解一下：</p>
<ul>
<li><p>我们先看与运算取模。一方面位与运算运算快；<strong>另一方面由于长度必然是2的幂，所以转二进制有效位必然全是1，与运算的时候可以充分散列表</strong>。</p>
</li>
<li><p>异或运算混合高低位：<strong>为了将哈希值的高位和低位混合，以增加随机性</strong>。</p>
<p>比如数组table的<strong>长度比较小的时候（比如图中的长度就只有4），也能保证考虑到哈希值的高低位都参与计算中</strong>。</p>
</li>
</ul>
<p>为了更明确的说明<strong>长度取2的幂有助于充分散列避免哈希碰撞</strong>，这里举个特别明显的例子：</p>
<p>当HashMap的容量是16时，它的二进制是10000，(n-1)的二进制是01111，与hash值得计算结果如下：</p>
<p><img src="http://img.xiajibagao.top/20190331213412382.png" alt="img"></p>
<p>上面四种情况我们可以看出，不同的hash值，和(n-1)进行位运算后，能够得出不同的值，使得添加的元素能够均匀分布在集合中不同的位置上，避免hash碰撞。</p>
<p> 下面就来看一下HashMap的容量不是2的n次幂的情况，当容量为10时，二进制为01010，(n-1)的二进制是01001，向里面添加同样的元素，结果为：</p>
<p><img src="http://img.xiajibagao.top/2019033121364420.png" alt="img"></p>
<p>可以看出，有三个不同的元素进过&amp;运算得出了同样的结果（01001），严重的hash碰撞了。</p>
<h3><span id="3将元素加入桶数组">3.将元素加入桶数组</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//判断插入位置是否为空，是就插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果直接找到相同节点存在就直接覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//否则判断该链是否为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是链表，就遍历链表,并且记录遍历到的节点数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//找到尾节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//插入后链表长度大于8就转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在链表找到相同阶段就覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将新值覆盖旧值，返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="四-hashmap的get">四、HashMap的get</span></h2><h3><span id="1get操作的实现">1.get操作的实现</span></h3><p>我们看看<code>get()</code>方法的注释和源码：</p>
<blockquote>
<p>返回指定键所映射到的值；如果此映射不包含键的映射关系，则返回null。更正式地讲，如果此映射包含从键k到值v的映射，使得（key == null？k == null：key.equals（k）），则此方法返回v；否则，返回v。否则返回null。 （最多可以有一个这样的映射。）返回值null不一定表示该映射不包含该键的映射；它的返回值为0。映射也可能将键显式映射为null。 containsKey操作可用于区分这两种情况。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到实际上调用了<code>getNode()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//确保table不为空，并且计算得到的下标对应table的位置上有节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断第一个节点是不是要找的key</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//如果第一个节点就查找链表或者红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//红黑树上查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//链表上查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2为什么重写equals还要重写hashcode">2.为什么重写equals还要重写hashcode？</span></h3><p>首先，不被原本的的hashCode和equals是这样的</p>
<ul>
<li>hashCode值是根据内存地址换算出来的一个值</li>
<li>equals方法是判断两个对象内存地址是否相等</li>
</ul>
<p>我们回顾一下上文，可以看到无论<code>put()</code>还是<code>get()</code>都会有类似这样的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.hash == hash &amp;&amp; (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))</span><br></pre></td></tr></table></figure>

<p>当我们试图添加或者找到一个key的时候，方法会去判断哈希值是否相等和值是否相等，都相等的时候才会判断这个key就是要获取的key。也就是说，严格意义上，一个HashMap里是不允许出现相同的key的。</p>
<p>当我们使用对象作为key的时候，根据原本的hashCode和equals仍然能保证key的唯一性。但是当我们重写了equals方法而不重写hashCode()方法时，可能出现值相等但是因为地址不相等导致哈希值不同，最后导致出现两个相同的key的情况。</p>
<p>我们举个例子：</p>
<p>我们现在有一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-08-14 16:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：Student类，重写了equals方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写了equals方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Student student = (Student) obj;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.name == student.name) &amp;&amp; (<span class="keyword">this</span>.age == student.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Student,Integer&gt; map = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    map.put(student1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;这个key已经存在了吗？&quot;</span>+map.containsKey(student2));</span><br><span class="line"></span><br><span class="line">    System.out.println(map.get(student2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">这个key已经存在了吗？<span class="keyword">false</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>可以看到，因为<code>hashCode()</code>得到的值不同，在map中他们被当成了不同的key。</p>
<p>而当我们重写了Student类的<code>hashCode()</code>方法以后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果就变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这个key已经存在了吗？<span class="keyword">true</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可见重写equals还要重写hashcode的必要性。</p>
<p>参考：</p>
<blockquote>
<p> <a href="https://blog.csdn.net/Apeopl/article/details/88935422?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf">HashMap初始容量为什么是2的n次幂及扩容为什么是2倍的形式</a>;</p>
<p><a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">Java集合之一—HashMap</a></p>
<p>](<a href="https://blog.csdn.net/qq_40574571/article/details/97612100">https://blog.csdn.net/qq_40574571/article/details/97612100</a>)</p>
</blockquote>
<h2><span id="五-hashmap的扩容">五、HashMap的扩容</span></h2><h3><span id="1resize操作的实现">1.resize操作的实现</span></h3><p>话不多说，我们直接源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//旧桶容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//要扩容的大小</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果桶已经配初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果扩容到极限大小，就不再继续扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则就扩容到原来的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果未初始化，并且指定了初始容量，则初始容量即为第一次扩容的目标大小</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//否则使用默认初始容量，并且根据默认初始容量和加载因子计算得到下次扩容大小</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新下一次计算扩容大小</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将旧容器复制到新容器中</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//把每一个桶移动到新桶中</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//判断是否为红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//否则就遍历链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//哈希值与原长度进行与运算，如果多出来那一位是0，就保持原下标</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果多出来那一位是1，就移动到（原下标+原长度）对应的新位置</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//放回新桶的原位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//放回新位置</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2为什么jdk8不需要重哈希了">2.为什么JDK8不需要重哈希了？</span></h3><p>我们知道，如果桶数组扩容了，那么数组长度也就变了，那么put和get的时候根据长度与哈希进行与运算的时候计算出来的下标就不一样。在JDK7扩容移动旧容器的数据的时候，会进行重哈希获得新索引，而在JDK8进行了优化。</p>
<p>因为桶数组长度总是2的幂，所以扩容以后翻倍，转换为二进制的时候就会比原来多一位，如果我们假设桶数组为n，则有：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">n = <span class="number">16</span> -&gt; <span class="number">10000</span>;   		    (n<span class="number">-1</span>) - &gt; <span class="number">1111</span>;</span><br><span class="line">n = <span class="number">32</span> -&gt; <span class="number">100000</span>;   		(n<span class="number">-1</span>) - &gt; <span class="number">11111</span>;</span><br><span class="line">n = <span class="number">64</span> -&gt; <span class="number">1000000</span>;  		(n<span class="number">-1</span>) - &gt; <span class="number">111111</span>;</span><br><span class="line">n = <span class="number">128</span> -&gt; <span class="number">10000000</span>;		(n<span class="number">-1</span>) - &gt; <span class="number">1111111</span>;</span><br></pre></td></tr></table></figure>

<p>我们举例子验证一下，如下图：</p>
<p>（a）是n=16时，key1与key2跟（n-1）与运算得到的二进制下标；（b）是扩容后n=32时，key1与key2跟（n-1）与运算得到的二进制下标。</p>
<p><img src="http://img.xiajibagao.top/20190728110949685.png" alt="扩容后计算下标"></p>
<p>我们可以看到key2进了一位，多出来这一位相当于多了10000，转为十进制就是在原基础上加16，<strong>也就是加上了原桶数组的长度</strong>，反映到代码里，就是 <code>newTab[j + oldCap] = hiHead;</code>这一句代码；</p>
<p>现在在看看key1，我们看到key1的索引并没有移动，因为key多出来的那一位是0，所以与运算后还是0，最后得到的下标跟原来的一样。</p>
<p>所以我们可以总结一下：</p>
<ul>
<li><strong>哈希值与原长度（注意是n不是n-1）进行与运算，判断多出来的那一位是0还是1</strong></li>
<li><strong>如果是0就留在原来的位置</strong></li>
<li><strong>如果是1就移动到（原下标 + 原长度）对应下标的新位置</strong></li>
</ul>
<p>这样做的好处除了不需要重新计算哈希值以外；由于哈希值多处来的一位数可能是0也可能是1，这样就让原本在同一条链表的上元素有可能可以在扩容后移动到新位置，有效缓解了哈希碰撞。</p>
<h2><span id="六-hashmap线程不安全">六、HashMap线程不安全</span></h2><p>我们知道HashMap是线程不安全的，线程安全的Map集合是ConcurrentHashMap。事实上，HashMap的线程不安全在JDK7和JDK8表现不同：</p>
<ul>
<li>在JDK7因为resize过程使用了头插法，导致多线程环境下可能会产生<strong>死循环，数据覆盖和数据丢失</strong>等问题</li>
<li>JDK8解决了死循环问题，但是在扩后的添加中仍然会在多线程环境下出现<strong>数据覆盖</strong>的问题</li>
</ul>
<h3><span id="1jdk7头插法导致死循环">1.JDK7头插法导致死循环</span></h3><p>在JDK7中，错误出现在扩容方法<code>transfer</code>中，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            <span class="comment">//遍历链表，当前节点为e</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                <span class="comment">//获取当前节点的下一个节点next</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="comment">//重新计算哈希值</span></span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity</span><br><span class="line">                <span class="comment">//头插法</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从代码中我们可以看到，扩容后重新计算了元素的下标，并采用头插法将表元素移插到新链表上。</p>
<p>举个例子：</p>
<p>假设线程A线程B同时对下图集合扩容：</p>
<p>1.A先执行，在<code>newTable[i] = e</code>前时间片耗尽被挂起，此时<strong>e = 1，e.next = null，next = 2</strong></p>
<p><img src="http://img.xiajibagao.top/HashMap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF1.png" alt="HashMap的多线程下死循环1"></p>
<p>2.线程B执行数组扩容，扩容完以后对于线程A就是现在这样，此时<strong>next.next = 1，e.next = null，next = 2</strong>：</p>
<p><img src="http://img.xiajibagao.top/HashMap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF2.png" alt="HashMap的多线程下死循环2"></p>
<p>3.接着线程B挂起，线程A继续执行 <code>newTable[i] = e</code>以后的代码，执行完毕后<strong>e = 2，next = 2，e.next = 1</strong>：</p>
<p><img src="http://img.xiajibagao.top/HashMap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF3.png" alt="HashMap的多线程下死循环3"></p>
<p>4.线程A接着下一次循环，由于<code>e.next = 1</code>，于是<code>next = 1</code>，头插法把2插入newTable[i]中，执行完毕以后<strong>e = 1，next = e.next = null</strong>：</p>
<p><img src="http://img.xiajibagao.top/HashMap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF4.png" alt="HashMap的多线程下死循环4"></p>
<p>5.线程A执行最后一次循环，此时由于<code>e.next = newTable[i]</code>，所以e.next = 2，然后接着 <code>newTable[i] = e </code>，也就是说1又被插回newTable[i]的位置：</p>
<p>这个时候最危险的事情发生了：<strong>e = 1，e.next =2 ，e.next.next = 1，说明2和1已经形成了一个环形链表</strong>：</p>
<p><img src="http://img.xiajibagao.top/HashMap%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF5.png" alt="HashMap的多线程下死循环5"></p>
<p>在此之后会无线循环1和2的头插，造成死循环。</p>
<h3><span id="2jdk8数据覆盖">2.JDK8数据覆盖</span></h3><p>DK7中也有这个问题。</p>
<p>我们知道<code>put()</code>方法在插入时会对插入位置进行非空判断，如果两个线程都判断同一个位置为空，那么先执行插入的数据就会被后一个覆盖。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
