<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker安装</title>
    <url>/2019/08/28/docker/Docker%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一-安装docker">一. 安装docker</h2>
<h3 id="1-删除已安装的docker">1. 删除已安装的docker</h3>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">yum</span> <span class="string">remove docker \</span></span><br><span class="line">    <span class="meta">docker-client</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-client-latest</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-common</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-latest</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-latest-logrotate</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-logrotate</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-selinux</span> <span class="string">\</span></span><br><span class="line">    <span class="meta">docker-engine-selinux</span> <span class="string">\</span></span><br><span class="line">    <span class="attr">docker-engine</span></span><br></pre></td></tr></table></figure>
<h3 id="2-确定yum更新到最新版本">2. 确定yum更新到最新版本</h3>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo yum update -y</span></span><br></pre></td></tr></table></figure>
<h3 id="3-安装需要的软件包">3. 安装需要的软件包</h3>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">sudo yum install -<span class="symbol">y</span> yum-utils device-mapper-<span class="symbol">persistent</span>-data lvm2 -<span class="symbol">y</span></span><br></pre></td></tr></table></figure>
<h3 id="4-设置yum源">4. 设置yum源</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">yum-config-manager</span> <span class="string">--add-repo</span> <span class="string">https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line"><span class="comment">#若出现错误则改为阿里云yum源</span></span><br><span class="line"><span class="string">yum-config-manager</span>  <span class="string">--add-repo</span>  <span class="string">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span> </span><br></pre></td></tr></table></figure>
<h3 id="5安装docker">5.安装docker</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以查看所有仓库中所有docker版本，并选择特定版本安装</span></span><br><span class="line"><span class="string">yum</span> <span class="string">list</span> <span class="string">docker-ce</span> <span class="string">--showduplicates</span> <span class="string">|</span> <span class="string">sort</span> <span class="string">-r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">docker-ce-17.12.0.ce</span> <span class="string">-y</span></span><br></pre></td></tr></table></figure>
<h3 id="6-查看安装是否成功">6. 查看安装是否成功</h3>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> version</span><br><span class="line">docker <span class="literal">info</span></span><br></pre></td></tr></table></figure>
<h3 id="7-启动并加入开机启动">7. 启动并加入开机启动</h3>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">start</span> docker</span><br><span class="line">sudo systemctl <span class="keyword">enable</span> docker</span><br></pre></td></tr></table></figure>
<h2 id="二-设置阿里云镜像加速">二. 设置阿里云镜像加速</h2>
<p>由于国内访问DockerHub速度堪忧，所以需要使用国内的镜像，比如网易或者阿里云。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">阿里云：https://promotion.aliyun.com/ntms/act/kubernetes.html#application</span></span><br><span class="line"></span><br><span class="line"><span class="string">网易云：https://www.163yun.com/product/repo</span></span><br></pre></td></tr></table></figure>
<p>这里使用阿里云容器镜像服务，注册后开通服务，在主界面选择“镜像加速器”，再选择CenterOS即可。</p>
<h3 id="1-根据提示在配置文件中添加专属加速器地址配置">1 . 根据提示，在配置文件中添加专属加速器地址配置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果是CenterOS7+，则需要在/etc/docker/下手动建daemon.json文件</span></span><br><span class="line"><span class="string">vim</span> <span class="string">/etc/docker/daemon.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在里面配置加速器地址</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;:</span> [<span class="string">&quot;https://xxxqxz6.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-重新加载配置文件重启docker">2. 重新加载配置文件，重启docker</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重新加载配置文件</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="string">daemon-reload</span></span><br><span class="line"><span class="comment">#重启docker</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="string">restart</span> <span class="string">docker</span></span><br></pre></td></tr></table></figure>
<p>注：网易云和阿里云操作基本相同，相对推荐使用阿里云</p>
<h3 id="3-确认配置生效">3. 确认配置生效</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#确认配置生效时docker info显示信息中会含有以下内容</span></span><br><span class="line"><span class="comment">#Registry Mirrors:</span></span><br><span class="line"><span class="comment">#https://xxxxx.mirror.aliyuncs.com/</span></span><br></pre></td></tr></table></figure>
<p>==========================</p>
<p>参考：1.https://blog.csdn.net/deng624796905/article/details/86493330 ​参考：2.https://www.cnblogs.com/yufeng218/p/8370670.html</p>
<p>官网：https://www.docker.com/</p>
<p>===========================</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>java是值传递还是引用传递</title>
    <url>/2020/08/05/java/java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>以前一鳞半爪的了解过 java 的参数传递方式是什么样的，后面粗略的了解了一鳞半爪以后有了大概的印象：“传参数就是值传递，传对象就是引用传递”，今天同事说起这件事，他却说 java 只有值传递。抱着疑问，我专门查了相关资料和文章，发现我原来的理解确实有问题。</p>
<p>这里先放结论：</p>
<ul>
<li>java中参数的传递可以理解为<strong>都是值传递</strong></li>
<li>基础数据类型传递的是<strong>值的拷贝</strong></li>
<li>对象类型是共享对象传递，传递的是<strong>地址的拷贝</strong></li>
</ul>
<h2 id="一-形参和实参">一、形参和实参</h2>
<p>要理解参数的传递就必须先理解形参和实参：</p>
<ul>
<li><p>形参：就是形式参数，用于<strong>定义方法的时候使用的参数</strong>，是用来接收调用者传递的参数的。</p>
<p>形参只有在方法被调用的时候，虚拟机才会分配内存单元，在方法调用结束之后便会释放所分配的内存单元。</p>
<p>因此,<strong>形参只在方法内部有效</strong>，所以针对引用对象的改动也无法影响到方法外。</p></li>
<li><p>实参：就是实际参数，用于调用时<strong>传递给方法的参数</strong>。</p></li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    String string = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">//string是实际参数</span></span><br><span class="line">    sout(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//str为形式参数</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-值传递和引用传递与共享对象传递">二、值传递和引用传递与共享对象传递</h2>
<h3 id="1值传递和引用传递">1.值传递和引用传递</h3>
<p>理解了实参和形参，以及java对应的数据类型，我们就可以理解值传递和引用传递了。</p>
<ul>
<li><p>值传递：方法调用时，实际参数的<strong>值</strong>被传递给对应的形式参数，函数接收的是原始值的一个copy， 此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作<strong>都是对形参这个值的修改，不影响实际参数的值</strong>。</p></li>
<li><p>引用传递/址传递：方法调用时，实际参数的<strong>地址</strong>被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址。在方法执行中，<strong>形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象</strong>。</p></li>
</ul>
<p>对于这两种方式，网上有一个非常形象的图：</p>
<p><img src="http://img.xiajibagao.top/值传递还是引用传递.gif"></p>
<h3 id="2共享对象传递">2.共享对象传递</h3>
<p>但是java的传值策略有点类似于两者的结合，是<strong>共享对象传递</strong>：</p>
<ul>
<li>共享对象传递：先获取到实际参数的地址，然后将其复制，并把<strong>该地址的拷贝</strong>传递给被调函数的形式参数。因为参数的地址都指向同一个对象，所以我们称也之为"传共享对象"，所以，如果在被调函数中改变了形式参数的值，调用者是可以看到这种变化的。</li>
</ul>
<p><strong>这也是之所以说java也是值传递的原因，共享对象传递实际上也是对实参进行拷贝然后赋给形参，但是操作针对的对象不是值而是地址</strong>！</p>
<p>由于传递的是地址的拷贝，所以如果你在方法中将这个地址指向了新的对象，实际上是没有任何对方法外是没有任何作用的，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">&quot;main中：&quot;</span> + p.hashCode());</span><br><span class="line">    change(p);</span><br><span class="line">    System.out.println(<span class="string">&quot;main中：&quot;</span> + p.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">    person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(<span class="string">&quot;change中：&quot;</span> + person.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">main中：<span class="number">692404036</span></span><br><span class="line">change中：<span class="number">1554874502</span></span><br><span class="line">main中：<span class="number">692404036</span></span><br></pre></td></tr></table></figure>
<p>可以看到在<code>main</code>方法中输出的hashCode指向的都是同一个对象，而<code>change</code>中指向了另一个，可以这么理解：</p>
<ul>
<li>p为指向了第一个Person对象的地址</li>
<li>把p拷贝了一份得到p‘，这里的p’就是<code>change</code>方法中的形参p</li>
<li><code>change</code>中p指向了一个新的Person对象，在<code>change</code>这个函数范围里p指向的就是new出来的第二个Person对象的地址</li>
<li>由于<code>change</code>中的p实际上是<code>main</code>中p的拷贝p‘，所以在<code>change</code>里p'指向的改变对<code>main</code>中的p不会有任何影响</li>
</ul>
<h2 id="三-总结">三、总结</h2>
<blockquote>
<p>你在福建有座仓库，给自己配了一把钥匙</p>
</blockquote>
<p>1.三种传递：</p>
<ul>
<li>值传递：你建了一座一模一样的仓库给别人</li>
<li>引用传递：把你家仓库的钥匙给了别人</li>
<li>共享对象传递：把你家仓库钥匙复刻了一把给别人</li>
</ul>
<p>2.共享对象传递的特点：</p>
<ul>
<li>拷贝的地址与原地址指向同一个内存对象：别人用你复刻的钥匙一样能进出你的仓库</li>
<li>拷贝地址引用对象的改变不影响原地址的引用对象：老王在福建泉州也盖了个一模一样仓库，钥匙和你的一模一样，虽然你的仓库比较有名，但是唯独在泉州提到仓库大家都想到的是老王的仓库。你说这把钥匙能开仓库，在泉州大家想到是这把钥匙能开老王的仓库，在其他城市大家想到是能开你的仓库</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（一）：jvm内存结构</title>
    <url>/2020/08/09/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Ajvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id></h2>
<h2 id="概述">概述</h2>
<p>我们知道java代码先编译为.class文件，然后再将.class文件交由jvm执行。在程序运行的这一过程中，jvm会将其管理的内存空间划分为不同的区域，这些区域各有各的用途，我们将其分为五类：</p>
<ol type="1">
<li>方法区</li>
<li>堆</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
</ol>
<p>其中方法区和堆是线程共享的，随jvm启动和停止而创建和销毁；</p>
<p>而虚拟机栈、本地方法栈和程序计数器则是线程私有的，随线程的创建和结束而创建和销毁。</p>
<figure>
<img src="http://img.xiajibagao.top/jvm内存体系.png" alt="jvm内存体系"><figcaption aria-hidden="true">jvm内存体系</figcaption>
</figure>
<h2 id="一-线程隔离数据区">一、线程隔离数据区</h2>
<p>包括程序计数器，虚拟机栈，本地方法栈三部分，是线程私有的数据区。</p>
<h3 id="1程序计数器">1.程序计数器</h3>
<figure>
<img src="http://img.xiajibagao.top/程序计数器.png" alt="程序计数器"><figcaption aria-hidden="true">程序计数器</figcaption>
</figure>
<blockquote>
<p>程序计数器用于记录当前线程执行的字节码指令的地址。</p>
</blockquote>
<p>我们知道cup实现多线程操作是根据每个线程分配是时间片来决定处的，每一个时间片cup都只处理抢到那个时间片的线程，因此很可能出现线程1指令执行到一半，结果下一个时间片又去处理另一个线程了。</p>
<p>为了能够在线程切换后依然能恢复到正确的指令位置，<strong>每一个线程都需要一个独立的计数器去记录正在执行的字节码指令地址</strong>，我们可以简单的理解为一个记录执行到的指令行数的一个指示器。</p>
<p><strong>如果指向的是java方法，计数器记录执行的字节码的地址，如果是非java代码的Native方法，这计数器为空。</strong></p>
<p><strong>计数器是唯一一个没有规定<code>OutOfMemoryError</code>的区域。</strong></p>
<h3 id="2虚拟机栈">2.虚拟机栈</h3>
<figure>
<img src="http://img.xiajibagao.top/虚拟机栈.png" alt="虚拟机栈"><figcaption aria-hidden="true">虚拟机栈</figcaption>
</figure>
<blockquote>
<p>虚拟机栈是描述java方法执行的一个内存模型。</p>
</blockquote>
<p>每个方法执行的时候会常见一个栈帧，栈帧中会储存局部变量表。操作数栈、动态链接、方法出口信息等。比如方法的局部变量会插入局部遍历表，对局部变量的运算和传递则通过数栈等等。</p>
<p><strong>每个方法从调用到完成就是一个栈帧在虚拟机栈中入栈到出栈的一个过程</strong>。我们使用递归时提到的栈就是虚拟机栈。</p>
<p>虚拟机栈规定有两种异常：<code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></p>
<p>我们知道方法调用实际就是栈帧入栈，<strong>如果栈的深度超过规定，就会抛出<code>StackOverflowError</code>异常</strong>；</p>
<p>栈的大小可以规定也可以动态扩展，<strong>如果栈扩展大小时申请不到足够的内存，就会抛出<code>OutOfMemoryError</code>异常</strong>.</p>
<h3 id="3本地方法栈">3.本地方法栈</h3>
<figure>
<img src="http://img.xiajibagao.top/本地方法栈.png" alt="本地方法栈"><figcaption aria-hidden="true">本地方法栈</figcaption>
</figure>
<blockquote>
<p>本地方法栈是描述j非java的方法执行的一个内存模型。</p>
</blockquote>
<p>它与虚拟机栈功能一样，但是不同的是本地方法栈用于存放实现方法非java代码的方法。当一个java方法要调用的的时候，会将java栈帧入虚拟机栈，而当非java方法要调用的时候就会入本地方法栈。</p>
<p>实际上两种栈之间往往会互相调用对方的方法，比如java方法A调用了java方法B，java方法B调用了C++方法C，这个C++方法又调用了java方法D，描述一下过程就会是：</p>
<p><code>A =》虚拟机栈，B =》虚拟机栈，C =》本地方法栈，D =》虚拟机栈</code></p>
<h2 id="二-线程共享数据区">二、线程共享数据区</h2>
<h3 id="1堆">1.堆</h3>
<figure>
<img src="http://img.xiajibagao.top/java堆.png" alt="java堆"><figcaption aria-hidden="true">java堆</figcaption>
</figure>
<blockquote>
<p>堆用于存放对象实例、数组和字符串常量池</p>
</blockquote>
<p>堆用于存放类的实例对象、数组和字符串常量池、另外，由于实例对象存储于此区域，所以也是<strong>垃圾收集器管理的主要区域，故又称GC堆</strong>。</p>
<p>java对可以是固定大小，也可以是动态大小，如果<strong>堆中没有内存分配给新的实例对象的时候，就会抛出<code>OutOfMemoryError</code>异常</strong>。</p>
<h4 id="12字符串常量池">1.2字符串常量池</h4>
<p>这里稍微提一下字符串常量池，正由于字符串常量池的存在，当创建字符串常量时，<strong>首先检查字符串常量池是否存在该字符串，存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</strong>。</p>
<p>这也是为什么字符串明明是对象却可以直接使用 == 比较，因为同样的字符指向的都是常量池里同一个字符串对象。</p>
<h4 id="13内存分配策略">1.3内存分配策略</h4>
<p>另外值得一提的是，堆往往和垃圾回收问题一起出现，所以这里也简单的介绍一下内存分配的策略：</p>
<p>由于jvm内存回收机制采用了<strong>分代收集算法</strong>，所以java堆中还分为<strong>新生代和老年代</strong>，新生代中又分为占大部分控件的<code>eden</code>区域和占较小空间的<code>survivorSpace0</code>和<code>survivorSpace1</code>。</p>
<p>根据分代收集算法，堆中内存分配时一般遵循以下原则：</p>
<ul>
<li><p><strong>对象优先分配给<code>eden</code>区域</strong>。当eden区域没有足够弓箭时，发起一次GC。当垃圾回收时，根据复制算法：</p>
<p><code>eden</code>和一个<code>survivorSpace</code>中还存活的对象会复制到另一个<code>survivorSpace</code>中，然后清理原先的空间</p></li>
<li><p><strong>需要大量连续内存空间的大对象直接进入老年代</strong>。比如巨长的数组或者字符串，还有非常高的树之类的。</p></li>
<li><p><strong>长期存活的对象会进入老年代</strong>。对象在新生代活过一定次数GC后会移入老年代。</p></li>
<li><p><strong>动态对象年龄判定</strong>。如果在<code>survivorSpace</code>空间中相同年龄所有对象大小的总和大小大于<code>survivorSpace</code>空间的一半，年龄大于或等于该年龄的对象直接进入老年代</p></li>
</ul>
<p>当然，不同的垃圾收集器和不同的垃圾收集算法适应不同的程序运行情况，实际的内存回收机制要复杂的多，这里以后会在新随笔里另外再展开，这里就不再赘述了。</p>
<h3 id="2方法区">2.方法区</h3>
<blockquote>
<p>方法区主要用来存放类信息、类的静态变量、常量、运行时常量池等</p>
</blockquote>
<p>方法区和堆功能类似，主要用与存放类信息，常量和即时编译器编译后的代码等数据。</p>
<h4 id="22永久代">2.2永久代</h4>
<p>很多文章提到方法区的时候都会涉及到这个“永久代”这个词。实际上，<strong>方法区是jvm的一个规范，永久代是这种规范的另一种实现</strong>，类似的还有元空间，这也是方法区的一种实现。</p>
<p>jvm虚拟机分为很多种，比如HotSpot ，JRockit（Oracle）、J9（IBM）等等，但是只有HotSpot才有永久代这个说法。硬要说的话，方法区可以理解为一个接口，永久区是这个接口的实现类。</p>
<h4 id="23-运行时常量池">2.3 运行时常量池</h4>
<figure>
<img src="http://img.xiajibagao.top/运行时常量池.png" alt="运行时常量池"><figcaption aria-hidden="true">运行时常量池</figcaption>
</figure>
<p>类似的问题还有运行时常量池。运行时常量池是方法区的一部分，用于存储各种编译时以及运行时产生的新常量，类加载以后的数据就存放于此，还有字符串手动入池方法<code>intern()</code>。</p>
<p>这里的 “运行时常量池”同上文提到的方法区和永久代的关系一样，也是jvm的规范而不是实现，运行时常量必然会有一个专门的储存空间，但是放在哪就得看虚拟机各自的实现了。</p>
<p>不过这里要额外理解一下字符串常量池：</p>
<p>常量池分为两块，一块是堆中的字符串常量池，一块是方法区中的常量池。实际上<strong>JDK8之前字符串常量池也在方法区中的常量池里边，而在JDK8之后被单独分离出来放到了堆里</strong>。</p>
<figure>
<img src="http://img.xiajibagao.top/字符串常量池在JDK8被分离.png" alt="字符串常量池在JDK8被分离"><figcaption aria-hidden="true">字符串常量池在JDK8被分离</figcaption>
</figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis通用底层实现</title>
    <url>/2020/10/16/java/%E9%80%9A%E7%94%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>最近接触了一些项目，发现很多项目最开始的时候Service接口和实现类一个方法都没有，通过继承通用底层能够使用基本的增删改查操作了。这种骚操作以前听过但是着实没有亲手实现过，今天参考着自己实现一下。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200922091422581.png" alt="依赖关系图"><figcaption aria-hidden="true">依赖关系图</figcaption>
</figure>
<p>以最终我想要获得的自定义接口实现类DemoRStudentClassServicelImpl为例，以下是相关类之间的依赖关系图，不难看出，大体是分成通用的DAO层和建立在前者之上的通用的Service层两部分实现。</p>
<h2 id="一-通用dao实现">一、通用DAO实现</h2>
<h3 id="1通用底层对象basedo">1.通用底层对象BaseDO</h3>
<p>框架定义了一个基础对象BaseDO，提供一些通用属性，和通用方法，比如创建时间，修改时间等。</p>
<p>所有的对象都需要继承此类，以便在后续操作中使得定义的方法通过泛型接收对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String createBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date createDate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String updateBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date updateDate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Date</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRStudentDO</span> <span class="title">extend</span> <span class="title">BaseDO</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2通用底层ibasedao与自定义dao">2.通用底层IBaseDao与自定义Dao</h3>
<p>定义一个<strong>统一的通用底层IBaseDao接口</strong>，里面规定了一些基本的增删改查方法，通过接口泛型去规定接口下方法的返回值，这些自定义的业务对象类同样需要继承BaseDO类。</p>
<p>当我们创建了一个自定义底层DemoRStudentDao的时候，我们只需要让DemoRStudentDao接口直接继承IBaseDao接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用Dao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDO</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(String id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(T bpmClass)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(T bpmClass)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Dao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoRStudentDao</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">DemoRStudentDO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//直接获得IBaseDao中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就能直接获得基本的增删改查方法，其中XML文件的namespace依然直接映射到DemoRStudentDao，当有其他业务需求的时候，直接重写基本方法，或者在DemoRStudentDao中新增方法即可。</p>
<h2 id="二-通用service实现">二、通用Service实现</h2>
<h3 id="1通用服务接口ibaseservice">1.通用服务接口IBaseService</h3>
<p>跟IBaseDao一样，我们为通用的服务接口规定出一些基本的增删改查方法，这些方法的返回值同样通过接口泛型指定为任意一个继承了BaseDO的对象类。</p>
<p>然后自定义的service接口直接继承IBaseService，即可获得基本的增删改查方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseService</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDO</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(String id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">list</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(T entity)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoRStudentClassService</span> <span class="keyword">extends</span> <span class="title">IBaseService</span>&lt;<span class="title">DemoRStudentClassDO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//直接获得IBaseService中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2通用实现类baseservice">2.通用实现类BaseService</h3>
<p>为了避免还要重复实现基本的增删改查方法，我们需要一个BaseService类去实现IBaseService中的基本方法，自定义的Service通过继承它来获得实现好的基本方法。</p>
<p>因为无论如何，要操作数据就必须得有某个DAO实例，所以在BaseService接口中有一个抽象方法<code>getDao()</code>，这个抽象方法需要我们实现以后返回一个DAO实例，其他的方法都基于这个<code>getDao()</code>来获取DAO实例，有点像代理模式。</p>
<p>所以BaseService是一个抽象类，接口泛型既需要指定继承了BaseDO的对象类，又需要指定继承了IBaseDAO接口的DAO实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BaseDO</span>, <span class="title">K</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">IBaseService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由具体的自定义接口实现类去继承并且实现，注入操作依然放在具体的自定义实现类里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> K 返回一个IbaseDao的子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> K <span class="title">getDao</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDao().get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">list</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDao().list(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        entity.preInsert(String.valueOf(getUserId()));</span><br><span class="line">        <span class="keyword">return</span> getDao().save(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        entity.preUpdate(String.valueOf(getUserId()));</span><br><span class="line">        <span class="keyword">return</span> getDao().update(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDao().remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3使用自定义的xxxserviceimpl">3.使用自定义的XXXServiceImpl</h3>
<p>我们现在有了通用的底层，该去自己实现一个DemoRStudentClassService去使用它们了。</p>
<ul>
<li><p>首先，我们新建一个Service接口，叫做DemoRStudentClassService，接口继承IBaseService，获取基本的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoRStudentClassServiceService</span> <span class="keyword">extends</span> <span class="title">IBaseService</span>&lt;<span class="title">DemoRStudentClassDO</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后，我们新建一个实现类DemoRStudentClassServiceImpl，这个类需要实现DemoRStudentClassService，然后继承BaseService</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201016124611497.png" alt="接口与实现类的关系"><figcaption aria-hidden="true">接口与实现类的关系</figcaption>
</figure>
<p>如图所示，DemoRStudentClassService继承了IBaseService接口中的方法，DemoRStudentClassServiceImpl继承了BaseService类，而BaseService类又实现了IBaseService的方法，所以DemoRStudentClassServiceImpl只要继承BaseService就可以自动获得IBaseService的实现方法。</p></li>
<li><p>最后，实现BaseService中的<code>getDao()</code>抽象方法，返回注入的DAO实例，让BaseService中的方法有dao可用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoRStudentClassServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">DemoRStudentClassDO</span>, <span class="title">DemoRStudentClassDao</span>&gt; <span class="keyword">implements</span> <span class="title">XXXService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoRStudentClassDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DemoRStudentClassDao <span class="title">getDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>到目前为止，在IBaseService中规定的方法都可以直接使用了。如果有必要，可以在自己的Dao或者ServiceImpl类中去重写原方法，或者直接添加新方法。</p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（二）：垃圾回收机制</title>
    <url>/2020/08/10/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>我们知道自动的垃圾回收机制是Java语言一个特点，它让我们在写程序的时候不再需要考虑内存管理问题。内存管理实际上就是<strong>分配内存</strong>和<strong>回收内存</strong>这两个问题，在<a href="https://www.cnblogs.com/Createsequence/p/13447923.html">上一篇文章</a>我大概介绍了jvm是如何划分内存空间以合理的分配内存的，而这篇文章就介绍一下jvm是如何回收内存的。</p>
<p>对于线程私有的程序计数器，虚拟机栈和本地方法栈三块数据区域而言，生命周期是和线程绑定的，线程结束时自然就回收内存了；而对于栈，每一个方法代表每一个栈帧，方法结束的时候就出栈，这时内存也跟着回收了。这些区域的内存回收都是具有确定性的，而堆就不同。</p>
<p>我们知道，堆主要用与存放对象实例，而只有运行时才知道要创建那些对象，而只有对象完全不被使用时才能回收其占用的内存空间。对于这块内容，我们需要明确三个问题：</p>
<ul>
<li><strong>哪些对象可以回收？</strong>（引用计数法、可达性算法）</li>
<li><strong>这些内存什么时候回收？</strong>（新生代、老年代、永久代，MinorGC和FullGC）</li>
<li><strong>这些内存怎么回收？</strong>（三种垃圾收集算法和分代收集算法，七种垃圾收集器）</li>
</ul>
<h2 id="一-判断对象是否可回收">一、判断对象是否可回收</h2>
<p>我们要判断对象是否可以回收，最有效的方式就是判断这个对象是否正在被别的对象引用。针对这个问题，有两种算法：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p>
<h3 id="1引用计数算法">1.引用计数算法</h3>
<p><strong>引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收</strong>。</p>
<p>简单的来说，就是为每一个对象实例配置一个计数器：</p>
<ul>
<li>当一个实例被创建并分配一个对象引用的时候，计数器为1；</li>
<li>每当该对象被分配给一个对象实例的时候计数器就加一；</li>
<li>当对象实例的某个引用超过了生命周期或者被设置为别的实例时，计数器就减一</li>
<li>当计数器为0时实例就会被回收</li>
</ul>
<p>引用计数器实现简单而且效率高，但是<strong>无法解决循环引用问题</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    a.b = b;</span><br><span class="line">    b.a = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当A实例中引用了B实例，而B实例中又引用了A实例，他们的极速器就永远不能为0，也就无法回收。</p>
<h3 id="2可达性算法">2.可达性算法</h3>
<p><strong>可达性算法通过判断对象的引用链是否可达来判断对象是否可以被回收。</strong></p>
<p>通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>在java中，可以作为GC Roots的对象包括：</p>
<ul>
<li>虚拟机栈汇总引用的对象</li>
<li>方法区汇总静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中方法引用的对象</li>
</ul>
<figure>
<img src="http://img.xiajibagao.top/可达性分析算法.png" alt="可达性分析算法"><figcaption aria-hidden="true">可达性分析算法</figcaption>
</figure>
<h3 id="3强引用-软引用-弱引用-虚引用">3.强引用、软引用、弱引用、虚引用</h3>
<p>我们知道以上两种算法都需要判断对象是否被引用，实际上，如果reference类型的数据中<strong>存储的数值代表的是另外一块内存的起始地址</strong>，就称这块内存代表着一个引用，因此对象往往只有两种状态：被引用或者未被引用。</p>
<p>如果我们希望有这样一类对象：当内存空间足够时，能保留在内存中；如果内存空间在进行垃圾回收后还是非常紧张，就抛弃这些对象。比如一些系统缓存。</p>
<p>因此为了做出区分，JDK1.2之后Java的引用被分为强引用、软引用、弱引用、虚引用4种。这4种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用指类似<code>Object obj=new Object()</code>这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</li>
<li>软引用用来描述一些还有用但并非必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围中进行第二次回收。用SoftReference类实现。</li>
<li>弱引用也描述非必需对象，只能存活到下一次垃圾回收之前。用WeakReference类实现。</li>
<li>虚引用也被称为幽灵引用，为一个对象设置虚引用的唯一目的就是能在这个对象被垃圾回收时收到一个系统通知。用PhantomReference类实现。</li>
</ul>
<p>这块内容具体可以参考：<a href="https://www.cnblogs.com/gudi/p/6403953.html">Java 的强引用、弱引用、软引用、虚引用</a></p>
<h2 id="二-垃圾收集算法">二、垃圾收集算法</h2>
<p>要理解垃圾回收时机，我们需要理解分代算法，在这之前我们需要对四种垃圾收集算法有大概的印象：</p>
<h3 id="1标记清除算法">1.标记清除算法</h3>
<blockquote>
<p>首先标记出所有需要回收的对象，在标记完成之后统一回收所有比标记的对象。</p>
</blockquote>
<p>标记清除算法有两个问题：</p>
<ul>
<li>效率问题：标记和清除两个过程的效率都不高；</li>
<li>空间问题：标记清除之后会产生大量不连续的内存碎片</li>
</ul>
<h3 id="2复制算法">2.复制算法</h3>
<blockquote>
<p>把内存分为大小相等的两块，每次只用其中一块。当这一块的用完了，就把还存活的对象复制到另一块，然后再把已经用过的内存空间一次清理掉。</p>
</blockquote>
<p><strong>复制算法常用于回收新生代</strong>。</p>
<p>如我们之前在介绍堆的内存结构的时候，jvm会将堆分外新生代和老年代。</p>
<p>而将新生代内存又分为一块较大的<code>eden</code>空间和两块较小的<code>survivor</code>空间，每次使用<code>eden</code>和其中一块<code>survivor</code>。当回收时，将<code>eden</code>和<code>survivor</code>中还存活着的对象一次地复制到另外一块<code>survivor</code>空间上，最后清理掉<code>eden</code>和刚才用过的<code>survivor</code>空间。</p>
<h3 id="3标记-整理算法">3.标记-整理算法</h3>
<blockquote>
<p>与标记清除类似，但是不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
</blockquote>
<p><strong>标记-整理算法常用于老年代。</strong></p>
<p>复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<h3 id="4分代收集算法">4.分代收集算法</h3>
<blockquote>
<p>根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
</blockquote>
<p>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率：</p>
<ul>
<li>在新生代每次垃圾收集时都有大批对象死去，只有少量存活，所以使用复制算法；</li>
<li>在老生代中代中存活率高，使用标记清理或者标记整理算法来回收。</li>
</ul>
<h2 id="三-分代收集算法的内存回收策略">三、分代收集算法的内存回收策略</h2>
<figure>
<img src="http://img.xiajibagao.top/java堆.png" alt="java堆"><figcaption aria-hidden="true">java堆</figcaption>
</figure>
<p>正如之前所说，由于java对象实例存储于堆中，所以堆就是GC的主要场所。</p>
<p>根据分代收集算法，堆会分为新生代和老年代。</p>
<h3 id="1新生代和老年代">1.新生代和老年代</h3>
<blockquote>
<p><strong>新生代</strong>的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代发生的GC叫<strong>MinorGC</strong>。</p>
<p><strong>老年代</strong>存放的都是一些生命周期较长的对象，就在新生代中经历了N次垃圾回收后仍然存活的对象会被放到老年代中。老年代发生的GC叫<strong>FullGC</strong>。</p>
</blockquote>
<p>新生代内存按照 <code>8:1:1</code> 的比例分为一个<code>eden</code>区和两个<code>survivor(survivor0，survivor1)</code>区，大部分对象在<code>eden</code>区中生成。</p>
<p>在进行垃圾回收时：</p>
<ul>
<li>一般先将<code>eden</code>区存活对象复制到<code>survivor0</code>区，然后清空<code>eden</code>区；</li>
<li>当<code>survivor0</code>区也满了时，则将<code>eden</code>区和<code>survivor0</code>区存活对象复制到<code>survivor1</code>区，然后清空<code>eden</code>和这个<code>survivor0</code>区，此时<code>survivor0</code>区是空的，然后交换<code>survivor0</code>区和<code>survivor1</code>区的角色。下次垃圾回收时扫描<code>eden</code>区和<code>survivor1</code>区，然后再交换<code>survivor0</code>区和<code>survivor1</code>，如此反复；</li>
<li>当<code>survivor1</code>区也不足以存放<code>eden</code>区和<code>survivor0</code>区的存活对象时，就将存活对象直接存放到老年代。</li>
</ul>
<h3 id="2分代收集算法的内存分配策略">2.分代收集算法的内存分配策略</h3>
<p>这里再提一下内存分配策略：</p>
<ul>
<li><strong>对象优先分配给<code>eden</code>区域</strong>。当eden区域没有足够空间时，发起一次MinorGC。</li>
<li><strong>需要大量连续内存空间的大对象直接进入老年代</strong>。比如巨长的数组或者字符串，还有非常高的树之类的。</li>
<li><strong>长期存活的对象会进入老年代</strong>。对象在新生代活过一定次数GC（一般是15次）后会移入老年代。</li>
<li><strong>动态对象年龄判定</strong>。如果在<code>survivor</code>空间中相同年龄所有对象大小的总和大小大于<code>survivor</code>空间的一半，年龄大于或等于该年龄的对象直接进入老年代</li>
</ul>
<h2 id="四-垃圾收集器">四、垃圾收集器</h2>
<h3 id="1serial收集器">1.Serial收集器</h3>
<p>新生代收集器，单线程。</p>
<h3 id="2parnew收集器">2.ParNew收集器</h3>
<p>Serial收集器的多线程版本.</p>
<h3 id="3-serial-old收集器">3. Serial Old收集器</h3>
<p>Serial收集器用于老年代的多线程版本。</p>
<h3 id="4parallel-scavenge收集器">4.Parallel Scavenge收集器</h3>
<p>新生代收集器，多线程。它的关注点与其他收集器不同，其他的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标则是达到一个高吞吐量。</p>
<h3 id="5parallel-old收集器">5.Parallel Old收集器</h3>
<p>Parallel Scavenge收集器的老年代版本。</p>
<h3 id="6cms收集器">6.CMS收集器</h3>
<p>老年代并行，以获取最短回收停顿时间为特点的收集器。<strong>只有他用标记-清除算法</strong>。<strong>顶不住了就用Serial Old</strong>帮忙。</p>
<h3 id="7g1收集器">7.G1收集器</h3>
<p>G1收集器是JDK7提供的一个新收集器。</p>
<p>G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是<strong>整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代</strong>。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（四）：类加载器</title>
    <url>/2020/08/12/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>虚拟机设计团队把类加载阶段中的“<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。<strong>实现这个动作的代码模块称为类加载器。</strong></p>
<p>对于类加载，我们关注两个方面的问题：</p>
<ul>
<li>JVM定义的三个类加载器（Bootstrap，Extension，System）</li>
<li>双亲委派模型（机制，JDBC违背案例）</li>
</ul>
<h2 id="一-类加载器">一、类加载器</h2>
<p>JVM使用以下三种类型的类加载器：</p>
<ul>
<li><p><strong>启动类（Bootstrap）类加载器</strong>：</p>
<p>这个类存放在<java_home>，无法被Java程序直接引用；</java_home></p></li>
<li><p><strong>扩展（Extension）类加载器</strong>：</p>
<p>这个类加载器负责加载<java_home>，开发者可以直接使用；</java_home></p></li>
<li><p><strong>引用程序（Application）类加载器</strong>：</p>
<p>这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以<strong>一般也称它为系统类加载器</strong>，负责加载用户类路径上所指定的类库。开发者可以直接使用。</p></li>
</ul>
<p>从java虚拟机的角度来说，一种是启动类加载器，是JVM的一部分；另一种是其他类加载器，独立于JVM，全部继承自抽象类java.lang.ClassLoader。只有其他类加载器程序员才能自己使用。</p>
<h2 id="二-双亲委派模型">二、双亲委派模型</h2>
<h3 id="1什么是双亲委派模型">1.什么是双亲委派模型</h3>
<p>JVM在加载类时默认采用的是双亲委派机制。</p>
<p>通俗的讲，就是某个特定的类加载器在<strong>接到加载类的请求时，首先将加载任务委托给父类加载器</strong>，然后父类加载器再委托给它的父类......以此类推，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。</p>
<p><strong>只有父类加载器无法完成加载请求时，才会使用子类加载器去加载</strong>。</p>
<p>双亲委派模型的一个<strong>重要作用是为了保证类加载过程的安全性</strong>：</p>
<blockquote>
<ul>
<li>假设有一个开发者自己编写了一个名为 <code>java.lang.Object</code>的类，想借此欺骗JVM。现在他要使用自定义 <code>ClassLoader</code>来加载自己编写的 <code>java.lang.Object</code>类。</li>
<li>但是无论哪一个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，启动类加载器在其搜索范围内可以搜索到的只有<code>rt.jar</code>中的<code>java.lang.Object</code>类</li>
<li>这样就确保了Object类的唯一性，如果是String也是同理。</li>
</ul>
</blockquote>
<p>也因此，java判断类是否是同一个类，就是通过判断类的ClassLoader.class来判断的，举个简单的例子：只要不是一个爹妈生出来的，哪怕长的一模一样那也不是亲兄弟。</p>
<h3 id="2类的加载顺序">2.类的加载顺序</h3>
<p>我们打开<code>ClassLoader</code>类，找到<code>loadClass()</code>方法，可以在注释上看到如何按顺序搜索类的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*   Invoke &#123;@link #findLoadedClass(String)&#125; to check if the class</span><br><span class="line">*   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">*</span><br><span class="line">*   Invoke the &#123;@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method</span><br><span class="line">*   on the parent <span class="class"><span class="keyword">class</span> <span class="title">loader</span>.  <span class="title">If</span> <span class="title">the</span> <span class="title">parent</span> <span class="title">is</span> &lt;<span class="title">tt</span>&gt;<span class="title">null</span>&lt;/<span class="title">tt</span>&gt; <span class="title">the</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">*   <span class="title">loader</span> <span class="title">built</span>-<span class="title">in</span> <span class="title">to</span> <span class="title">the</span> <span class="title">virtual</span> <span class="title">machine</span> <span class="title">is</span> <span class="title">used</span>, <span class="title">instead</span>.  &lt;/<span class="title">p</span>&gt;&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="class">*</span></span><br><span class="line">*   Invoke the &#123;@link #findClass(String)&#125; method to find the</span><br><span class="line">*   class.</span><br></pre></td></tr></table></figure>
<p>即：</p>
<ul>
<li>使用<code>findLoadedClass()</code>方法检查类是否已经加载；</li>
<li>调用父类加载器的<code>loaderCalss()</code>方法。如果父类是null，就直接调用虚拟机内置的Bootstrap加载；</li>
<li>如果父类无法加载，使用自己<code>findClass()</code>加载。</li>
</ul>
<p>我们再看一下<code>loadClass()</code>方法的源码，更直观的展示了双亲委派模型下是如何加载类的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//线程安全，保证只有一个线程能对类初始化</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//1.检查类是否已经被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//2.如果没有被加载，判断是否存在父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//3.有就递归委派给父类加载器加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//4.否则就使用启动类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果到了启动类加载器还找不到类，则抛出ClassNotFoundException</span></span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">            <span class="comment">//如果父类加载器无法加载，就使用自身的findClass加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是为什么JDK在我们自定义类加载器的时候不推荐重写<code>loadClass()</code>只让我们重写<code>findClass()</code>方法的原因了，因为如果重写了方法，却不遵守双亲委派模型，就有可能导致不可预料的后果。</p>
<p>当然，不推荐归不推荐，如果有必要的话仍然可以重写<code>loadClass()</code>方法，比如<strong>JDBC、JNDI就打破了双亲委派模型</strong>。</p>
<h3 id="3三种类加载器的关系">3.三种类加载器的关系</h3>
<figure>
<img src="http://img.xiajibagao.top/三种类加载器的关系.png" alt="三种类加载器的关系"><figcaption aria-hidden="true">三种类加载器的关系</figcaption>
</figure>
<p>我们运行一下以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;应用程序加载器：&quot;</span>+ClassLoader.getSystemClassLoader());</span><br><span class="line">    System.out.println(<span class="string">&quot;应用程序加载器的父类：&quot;</span>+ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;扩展加载器的父类：&quot;</span>+ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">应用程序加载器：sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">应用程序加载器的父类：sun.misc.Launcher$ExtClassLoader@<span class="number">29453f</span>44</span><br><span class="line">扩展加载器的父类：<span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>由于启动类加载器是jvm内置的，我们无法直接调用，所以返回值是null。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（三）：类加载机制</title>
    <url>/2020/08/11/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>我们知道java代码会被编译为.class文件，这里class文件中的类信息最终还是需要jvm加载以后才能使用。</p>
<p>事实上，虚拟机把描述类的数据<strong>从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制</strong>。</p>
<p>对于jvm类的加载机制，我们主要关注两个问题：</p>
<ul>
<li>类的加载时机？(初始化的五种情况)</li>
<li>类的加载过程？（类的五个加载过程）</li>
</ul>
<h2 id="一-类的加载时机">一、类的加载时机</h2>
<h3 id="1类的生命周期">1.类的生命周期</h3>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>。其中验证、准备、解析统称为<strong>连接</strong>。</p>
<figure>
<img src="http://img.xiajibagao.top/类加载的时机.png" alt="类加载的时机"><figcaption aria-hidden="true">类加载的时机</figcaption>
</figure>
<p>值得一提的是，加载，验证，准备，初始化和卸载是固定的，<strong>但是解析阶段不是：它在一定情况下可以在初始化后再开始，以支持java语言的动态绑定</strong>。</p>
<p>这里解释一下动态绑定和静态绑定：</p>
<blockquote>
<p>静态绑定： 在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。</p>
<p>动态绑定： 后期绑定：在运行时根据具体对象的类型进行绑定。</p>
</blockquote>
<p>另外，类的加载过程必须按步骤“开始”，但是并不等前一个步骤完成后才进行下一个步骤，而是在前一个步骤进行时就开始下一个步骤。</p>
<h3 id="2类的加载时机">2.类的加载时机</h3>
<p><strong>这里的“加载”只是类加载过程的一个阶段</strong>，代表这“类的加载”的这一过程的开始，<strong>jvm并没有强制性约束在什么时候开始类加载过程</strong>。</p>
<p>一般我们说类的加载，指的是整个加载过程。过程完成后，代表jvm将java文件编译成class文件后，以二进制流的方式存放到运行时数据的方法区中，并在java的堆中创建一个java.lang.Class对象，用来指向存放在方法堆中的数据结构。</p>
<h3 id="3类的初始化时机">3.类的初始化时机</h3>
<p>首先我们得明确一下初始化和实例化的区别：</p>
<blockquote>
<p><strong>类的实例化</strong>是指创建一个类的实例(对象)的过程；</p>
<p><strong>类的初始化</strong>是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。</p>
</blockquote>
<p>初始化一般是类使用前的最后一个阶段，所以类初始化时机可以看成类的加载时机。</p>
<p>凡是有以下四种行为的成为对一个类进行<strong>主动引用</strong>，<strong>只有主动引用会触发类的初始化</strong>：</p>
<ul>
<li><strong>遇到四条字节码指令</strong>：
<ol type="1">
<li>new：使用new关键字实例化对象;</li>
<li>getstatic：获取一个不被final修饰的类的静态字段;</li>
<li>putstatic：设置一个不被final修饰的类的静态字段;</li>
<li>invokestatic：调用一个类的静态方法;</li>
</ol></li>
<li><strong>使用java.lang.reflect包中的方法对类进行反射调用时，如果类还没有初始化，则必须首先对其初始化;</strong></li>
<li><strong>当初始化一个类时，如果其父类还没有初始化，则必须首先初始化其父类;</strong></li>
<li><strong>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</strong></li>
<li><strong>当使用JDK7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。</strong></li>
</ul>
<p>除了以上五种方式以外引用类的方式成为<strong>被动引用</strong>，并不会触发初始化。</p>
<p>被动引用有以下几种代表性的例子：</p>
<p>假设我们有以下两种类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-08-08 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：Parent类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ParentAge = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Parent,我被初始化了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-08-08 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：Child类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> cons = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Child，我被初始化了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    System.out.println(Child.ParentAge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">我是Parent,我被初始化了！</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过数组定义引用类不会初始化；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Parent[] Parent = <span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有引用到定义常量的类，因此不会触发定义常量的类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    System.out.println(Child.cons);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4类的存放位置">4.类的存放位置</h3>
<p>当一个类被加载的时候，类的信息（有啥方法有啥遍历）会被存放到方法区，而常量会被存放到方法区里的常量池。完成这一切以后JVM会拷贝一份类的信息放到堆里方便使用。</p>
<h2 id="二-类的加载过程">二、类的加载过程</h2>
<h3 id="1加载">1.加载</h3>
<blockquote>
<p>加载”是由类加载器完成的“类加载过程”的第一个阶段，在初始化之前完成。</p>
</blockquote>
<p>加载阶段完成以下三件事：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>值得一提的是，二进制流可以从zip包中获取，这也是JAR或者WAR包格式也能部署项目基础。</p>
<p>另外，类的加载阶段涉及类加载器和双亲委派模型等知识点，此处将另起新随笔详细介绍，在本文就不多费笔墨了。</p>
<h3 id="2验证">2.验证</h3>
<blockquote>
<p>验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
</blockquote>
<p>验证阶段完成以下四件事：</p>
<ul>
<li><p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，</p>
<p>比如是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内、常量池的常量中是否有不被支持的常量类型等等；</p></li>
<li><p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，</p>
<p>比如父类是否继承了被final修饰的类，非抽象类是否都实现了父类或者接口的方法等等；</p></li>
<li><p><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；</p></li>
<li><p><strong>符号引用验证</strong>：对类自身以外的信息进行匹配性校验,</p>
<p>比如符号引用中通过字符串描述的全限定名是否能找到对应的类等等。</p></li>
</ul>
<h3 id="3准备">3.准备</h3>
<blockquote>
<p>准备阶段是正式为类被static修饰的变量（不包含实例变量）分配内存并设置类变量初始值的阶段。</p>
</blockquote>
<p>这里区分常量与普通静态变量：</p>
<p>对于<strong>普通静态变量</strong>，比如 <code>public staic int num = 1</code>，准备阶段赋值为0，而把value赋值为123的putstatic指令是程序被编译后，存放于虚拟机装载一个类初始化的时候调用的类构造器方法<code>&lt;clinit&gt;()</code>之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p>
<p>而对于<strong>常量类型</strong>，比如 <code>public static final int = 1</code>，准备阶段就会赋值为1。</p>
<h3 id="4解析">4.解析</h3>
<blockquote>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
</blockquote>
<p>这里我们需要理解一下符号引用和直接引用：</p>
<ul>
<li><strong>符号引用</strong>：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用目标并不一定已经加载到内存中</li>
<li><strong>直接引用</strong>：直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄，直接引用与虚拟机实现的内存布局相关，如果有了直接引用，引用目标必定已经加载到内存中</li>
</ul>
<p>我们举个简单的例子：</p>
<p>最开始jvm要加载People类，但是一开始并不知道People的内存地址，此时就用符号“People”先表示它的地址，等到类加载器加载完People类的时候，就可以知道People类的实际地址了，于是就将“People”符号换成People这个类的实际内存地址。</p>
<h3 id="5初始化">5.初始化</h3>
<blockquote>
<p>类初始化阶段是类加载过程的最后一步。在前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码(字节码)。</p>
</blockquote>
<p>这里我们可以回头看准备阶段，我们知道准备阶段会调用类构造器<code>&lt;clinit&gt;()</code>方法.</p>
<p>实际上，初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<h2 id="三-初始化时的类构造器">三、初始化时的类构造器</h2>
<p>我们在类加载的验证和初始化时都提到过类构造器 <code>&lt;clinit&gt;()</code>，这里稍微介绍一下。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块中的语句合并产生</strong>的。也就是说，如果一个类没有静态成员变量和静态块，是可以不执行类构造方法的。</p>
<h3 id="1父类子类类构造器的执行顺序">1.父类子类类构造器的执行顺序</h3>
<p>类构造器<code>&lt;clinit&gt;()</code>与实例构造器<code>&lt;init&gt;()</code>不同，它不需要程序员进行显式调用，虚拟机会保证在子类类构造器<code>&lt;clinit&gt;()</code>执行之前，父类的类构造<code>&lt;clinit&gt;()</code>执行完毕。这就导致了<strong>父类静态代码块比子类静态代码块先执行</strong>。</p>
<h3 id="2类构造器中的赋值操作">2.类构造器中的赋值操作</h3>
<p>对于静态块中的赋值操作，我们需要注意：<strong>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    System.out.println(i);<span class="comment">//在此处抛出错误：非法的向前引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3多线程环境下的类构造器">3.多线程环境下的类构造器</h3>
<p><strong>在多线程环境下，虚拟机会保证总是只有一个线程去执行类构造器 <code>&lt;clinit&gt;()</code>，其他线程会阻塞直到构造器执行完毕</strong>。而一个类只会进行一次初始化，这就保证了多线程下类的正确初始化。</p>
<p>事实上，这有点像在我<a href="https://www.cnblogs.com/Createsequence/p/12945908.html">关于多线程的这篇文章</a>中提到的双重检查单例模式，也是因为这点，我们可以巧妙的使用内部类来实现一个线程安全的单例模式。</p>
<p>由于实例化的时候其他线程会阻塞，所以如果在类的静态块中进行了耗时较长的工作时，可能就会导致多个线程在你不知道的情况下堵塞，造成不必要的性能消耗。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装jdk</title>
    <url>/2019/07/24/linux/linux%E4%B8%8B%E5%AE%89%E8%A3%85jdk/</url>
    <content><![CDATA[<h2 id="1上传并解压jdk">1.上传并解压jdk</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上传jdk至自己想要的文件夹，我的是/usr/local</span></span><br><span class="line"><span class="string">tar</span> <span class="string">-zxvf</span> <span class="string">jdk-8u221-linux-i586.tar.gz</span></span><br><span class="line"><span class="comment">#解压完后是名为jdk1.8.0_221的文件夹</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/jdk1.8.0_221/</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.xiajibagao.top/jdk路径.PNG"></p>
<h2 id="2配置环境变量">2.配置环境变量</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置变量</span></span><br><span class="line"><span class="string">vi</span>  <span class="string">/etc/profile</span></span><br><span class="line"><span class="comment">#添加</span></span><br><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/jdk1.8.0_221</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.xiajibagao.top/jdkexport.PNG"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#让配置生效</span></span><br><span class="line"><span class="string">.</span> <span class="string">/etc/profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#验证安装成功</span></span><br><span class="line"><span class="string">java</span> <span class="string">-version</span></span><br></pre></td></tr></table></figure>
<h2 id="3如果查看版本报错">3.如果查看版本报错</h2>
<p>当使用 <code>java -version</code> 的时候可能会报如下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/jdk1.8.0_144/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>这个安装libc库后就可以了</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">yum</span> <span class="string">install</span> <span class="string">glibc.i686</span></span><br></pre></td></tr></table></figure>
<h2 id="4查找已经安装的jdk">4.查找已经安装的jdk</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#which java</span></span><br><span class="line">[<span class="string">root@iZwz9ev02los7q1d71e7muZ</span> <span class="string">/</span>]<span class="comment"># which java</span></span><br><span class="line"><span class="string">/usr/bin/java</span></span><br><span class="line"><span class="comment">#ls -lrt /usr/bin/java</span></span><br><span class="line">[<span class="string">root@iZwz9ev02los7q1d71e7muZ</span> <span class="string">/</span>]<span class="comment"># ls -lrt /usr/bin/java </span></span><br><span class="line"><span class="string">lrwxrwxrwx</span> <span class="number">1</span> <span class="string">root</span> <span class="string">root</span> <span class="number">22</span> <span class="string">Jul</span> <span class="number">31</span> <span class="number">19</span><span class="string">:10</span> <span class="string">/usr/bin/java</span> <span class="string">-&gt;</span> <span class="string">/etc/alternatives/java</span></span><br><span class="line"><span class="comment">#ls -lrt /etc/alternatives/java</span></span><br><span class="line">[<span class="string">root@iZwz9ev02los7q1d71e7muZ</span> <span class="string">/</span>]<span class="comment"># ls -lrt /etc/alternatives/java</span></span><br><span class="line"><span class="string">lrwxrwxrwx</span> <span class="number">1</span> <span class="string">root</span> <span class="string">root</span> <span class="number">73</span> <span class="string">Jul</span> <span class="number">31</span> <span class="number">19</span><span class="string">:10</span> <span class="string">/etc/alternatives/java</span> <span class="string">-&gt;</span> <span class="string">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64/jre/bin/java</span></span><br><span class="line"><span class="comment">#获得路径</span></span><br><span class="line"><span class="comment">#/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64/jre/bin/java</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM初探（五）：类的实例化</title>
    <url>/2020/08/13/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>我们知道，一个对象在可以被使用之前必须要被正确地实例化。而实例化实际指的就是以一个java类为模板创建对象/实例的过程。比如说常见的 <code>Person = new Person()</code>代码就是一个将Person类实例化并创建引用的过程。</p>
<p>对于类的实例化，我们关注两个问题：</p>
<ul>
<li>如何实例化？（类的四种实例化方式）</li>
<li>什么时候实例化？（类的一个初始化过程和对象的三个初始化过程）</li>
</ul>
<h2 id="一-类的四种实例化方式">一、类的四种实例化方式</h2>
<h3 id="1使用new关键字">1.使用new关键字</h3>
<p>这也是最常见最简单的创建对象的方法。通过这种方法，我们可以借助类的构造函数实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent p = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>
<h3 id="2使用newinstance方法">2.使用newInstance()方法</h3>
<p>我们可以先通过类的全限定名获取类，然后通过Class类的<code>newInstance()</code>方法去调用类的<strong>无参构造方法</strong>创建一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class p = Class.forName(<span class="string">&quot;com.huang.Parent&quot;</span>);</span><br><span class="line">Parent parent = (Parent) p.newInstance();</span><br></pre></td></tr></table></figure>
<p>或者通过<code>java.lang.relect.Constructor</code>类里的<code>newInstance()</code>方法去构造对象，这个方法比起Class自带的更强大：</p>
<p>它可以调用类中<strong>有参构造方法</strong>和<strong>私有构造方法</strong>创建对象！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Parent私有的含参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Parent创建了！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Constructor调用</span></span><br><span class="line">Class p = Class.forName(<span class="string">&quot;com.huang.Parent&quot;</span>);</span><br><span class="line">Constructor&lt;Parent&gt; parentConstructor = p.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">Parent parent = (Parent) p.newInstance();</span><br></pre></td></tr></table></figure>
<h3 id="3使用clone方法">3.使用clone()方法</h3>
<p>当我们调用clone方法，JVM会帮我们创建一个新的、一样的对象，特别需要说明的是，用clone方法创建对象的过程中并不会调用任何构造函数。这里涉及到一个深拷贝和浅拷贝的知识点，我会另起一篇随笔介绍，这里就多费笔墨了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent();</span><br><span class="line">Parent p2 = (Parent) parent.clone();</span><br></pre></td></tr></table></figure>
<h3 id="4使用反序列化机制">4.使用反序列化机制</h3>
<p>当我们反序列化一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Parent parent = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写对象</span></span><br><span class="line">ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;parent.bin&quot;</span>));</span><br><span class="line">outputStream.writeObject(parent);</span><br><span class="line">outputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读对象</span></span><br><span class="line">ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">    <span class="string">&quot;parent.bin&quot;</span>));</span><br><span class="line">Parent parent2 = (Parent) inputStream.readObject();</span><br></pre></td></tr></table></figure>
<h2 id="二-类实例化的过程">二、类实例化的过程</h2>
<p>我们以 <code>Person p = new Person()</code>这条语句为例，当这条语句执行的时候，jvm进行了四步操作：</p>
<ul>
<li>先执行new语句，以Person类为模板，在堆中创建Person对象</li>
<li>为Person对象执行构造方法（如果有父类会先执行父类构造方法）</li>
<li>创建Person类的引用变量p</li>
<li>将引用变量p指向内存中Person对象</li>
</ul>
<p>我们不难看出，其实实例化的过程其实就是第一和第二步，在这两步里，jvm其实也进行了四步操作：</p>
<ul>
<li>Person<strong>类</strong>的初始化</li>
<li>Person<strong>对象变量</strong>的初始化（如果有父类会先执行父类变量的初始化）</li>
<li>Person<strong>对象代码块</strong>的初始化</li>
<li>Person<strong>对象构造函数</strong>的初始化（如果有父类会先执行父类初始化）</li>
</ul>
<h3 id="1类的初始化">1.类的初始化</h3>
<p><strong>对于第一次被实例化的对象，第一步是必定是类的初始化，所以静态变量和静态代码块中的代码必然被赋值和执行。</strong></p>
<p>这点在我<a href="https://www.cnblogs.com/Createsequence/p/13461108.html">关于类加载机制的文章</a>中已有解释，这里就不多费笔墨。</p>
<h3 id="2对象变量的初始化">2.对象变量的初始化</h3>
<p>我们在定义对象中的变量的同时，还可以<strong>直接对对象变量进行赋值。它们会在构造函数执行之前完成这些初始化操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的构造方法执行了！&quot;</span>);</span><br><span class="line">        j += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = k + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i:&quot;</span>+i);</span><br><span class="line">        System.out.println(<span class="string">&quot;j:&quot;</span>+j);</span><br><span class="line">        System.out.println(<span class="string">&quot;k:&quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;l:&quot;</span>+l);</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的构造方法执行了！&quot;</span>);</span><br><span class="line">        k += <span class="number">8</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;k:&quot;</span>+k);</span><br><span class="line">        System.out.println(<span class="string">&quot;l:&quot;</span>+l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Child child = <span class="keyword">new</span> Child();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">Parent的构造方法执行了！</span><br><span class="line">i:<span class="number">1</span></span><br><span class="line">j:<span class="number">12</span></span><br><span class="line">k:<span class="number">1</span></span><br><span class="line">l:<span class="number">2</span></span><br><span class="line">Child的构造方法执行了！</span><br><span class="line">k:<span class="number">9</span></span><br><span class="line">l:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们可以知道执行顺序是这样的：</p>
<ul>
<li><strong>父类的变量初始化</strong>：<code>i = 1,j=2</code>;</li>
<li><strong>执行父类的构造函数</strong>：<code>j = 2 + 10 = 12</code>;</li>
<li><strong>子类的变量初始化</strong>：<code>k = 1,l = 2</code>;</li>
<li><strong>执行子类构造函数</strong>：<code>k = 1 + 8 = 9</code></li>
</ul>
<p>这里有人认为父类的变量初始化了，而且父类的构造函数也执行了，那父类是不是也一起实例化了？</p>
<p>答案是没有，我们可以认为实例化的时候子类从父类一起拷贝了一份变量，构造函数的执行也是为了能让父类的变量初始化，最后实例化放到内存里的其实是子类+父类的一个混合体！</p>
<h3 id="3代码块的初始化">3.代码块的初始化</h3>
<p>我们一般指的代码块是构造代码块和静态代码块，静态代码块在类初始化时就执行，而<strong>构造代码块在类一创建就执行，也优先于构造方法</strong>。</p>
<p>我们举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的代码块被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent创建了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child创建了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的代码块被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Child child = <span class="keyword">new</span> Child();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Parent的代码块被执行了！</span><br><span class="line">Parent的构造方法执行了！</span><br><span class="line">Child的代码块被执行了！</span><br><span class="line">Child的构造方法执行了！</span><br></pre></td></tr></table></figure>
<p>我们可以知道执行顺序是这样的：</p>
<ul>
<li><strong>父类代码块</strong></li>
<li><strong>父类的构造方法</strong></li>
<li><strong>子类的代码块</strong></li>
<li><strong>子类的构造方法</strong></li>
</ul>
<h3 id="4构造函数的初始化">4.构造函数的初始化</h3>
<p>我们可以从上文知道，实例变量初始化与实例代码块初始化总是发生在构造函数初始化之前，那么我们下面着重看看构造函数初始化过程。众所周知，每一个Java中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。在编译生成的字节码中，这些构造函数会被命名成<code>&lt;init&gt;()</code>方法。</p>
<p>事实上，Java强制要求Object对象之外的所有对象构造函数的第一条语句必须是父类构造函数的调用语句，如果没有就会默认生成讴歌构造函数。这就保证了不管要实例化的类继承了多少父类，我们最终都能让实例继承到所有从父类继承到的属性。</p>
<h3 id="5小结">5.小结</h3>
<p>结合以上文，我们可以看出类的实例化其实是一个递归的过程。</p>
<p>从子类不断向上递归，然后一直递归到直到抵达基类Object，然后一层一层的返回，先完成类的初始化：</p>
<ul>
<li>如果有类未初始化就先初始化（初始化静态块）</li>
</ul>
<p>再回到Object类，往下一层一层的返回，完成对象的三个初始化：</p>
<ul>
<li>初始化变量</li>
<li>初始化代码块</li>
<li>初始化构造函数</li>
</ul>
<figure>
<img src="http://img.xiajibagao.top/类实例化是个递归过程.png" alt="类实例化的递归过程"><figcaption aria-hidden="true">类实例化的递归过程</figcaption>
</figure>
<p>所以最终我们可以总结出类初始化过程中类的各种代码块的执行顺序：</p>
<ul>
<li>父类静态块</li>
<li>子类静态块</li>
<li>父类代码块</li>
<li>父类构造函数</li>
<li>子类代码块</li>
<li>子类构造函数</li>
</ul>
<p>验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的静态块执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent的代码块被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的静态块执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child的代码块被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Child child = <span class="keyword">new</span> Child();</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Parent的静态块执行了！</span><br><span class="line">Child的静态块执行了！</span><br><span class="line">Parent的代码块被执行了！</span><br><span class="line">Parent的构造方法执行了！</span><br><span class="line">Child的代码块被执行了！</span><br><span class="line">Child的构造方法执行了！</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装mysql</title>
    <url>/2019/07/24/linux/linux%E4%B8%8B%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<h2 id="1安装">1.安装</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取安装用的Yum Repository</span></span><br><span class="line"><span class="string">wget</span> <span class="string">-i</span> <span class="string">-c</span> <span class="string">http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span></span><br><span class="line"><span class="string">yum</span> <span class="string">-y</span> <span class="string">install</span> <span class="string">mysql57-community-release-el7-10.noarch.rpm</span></span><br><span class="line"><span class="comment">#安装MySQL服务</span></span><br><span class="line"><span class="string">yum</span> <span class="string">-y</span> <span class="string">install</span> <span class="string">mysql-community-server</span></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-v</span></span><br><span class="line"><span class="comment">#启动mysql</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">start</span> <span class="string">mysqld.service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找回初始密码并登录  jWTAeq-DF9tJ</span></span><br><span class="line"><span class="string">grep</span> <span class="string">&#x27;temporary password&#x27;</span> <span class="string">/var/log/mysqld.log</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-uroot</span> <span class="string">-p</span></span><br><span class="line"><span class="comment">#注意;找不到初始密码及其他情况参考下文&quot;修改密码&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用初始密码登录后需要先修改一次密码后才能操作</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;localhost&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">BY</span> <span class="string">&#x27;新密码&#x27;</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为避免Repository每次yum操作都会自动更新</span></span><br><span class="line"><span class="string">yum</span> <span class="string">-y</span> <span class="string">remove</span> <span class="string">mysql57-community-release-el7-10.noarch</span></span><br></pre></td></tr></table></figure>
<h2 id="2修改密码">2.修改密码</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.找回密码</span></span><br><span class="line"><span class="string">grep</span> <span class="string">&#x27;temporary password&#x27;</span> <span class="string">/var/log/mysqld.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.强制修改密码</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">stop</span> <span class="string">mysqld</span> <span class="comment">#停止服务</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">set-environment</span> <span class="string">MYSQLD_OPTS=&quot;--skip-grant-tables&quot;</span> <span class="comment">#跳过密码</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">start</span> <span class="string">mysqld</span> <span class="comment">#启动服务</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-u</span> <span class="string">root</span> <span class="comment">#登录</span></span><br><span class="line"><span class="string">UPDATE</span> <span class="string">mysql.user</span> <span class="string">SET</span> <span class="string">authentication_string</span> <span class="string">=</span> <span class="string">PASSWORD(&#x27;新密码&#x27;)</span> <span class="string">WHERE</span> <span class="string">User</span> <span class="string">=</span> <span class="string">&#x27;root&#x27;</span> <span class="string">AND</span> <span class="string">Host</span> <span class="string">=</span> <span class="string">&#x27;localhost&#x27;</span><span class="string">;</span> <span class="comment">#设置新密码</span></span><br><span class="line"><span class="string">FLUSH</span> <span class="string">PRIVILEGES;</span> <span class="comment">#刷新权限</span></span><br><span class="line"><span class="string">quit</span> <span class="comment">#退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.用操作系统账号修改密码</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-uroot</span> <span class="string">-p</span> <span class="comment">#使用centos账号密码登录</span></span><br><span class="line"><span class="string">UPDATE</span> <span class="string">mysql.user</span> <span class="string">SET</span> <span class="string">authentication_string</span> <span class="string">=</span> <span class="string">PASSWORD(&#x27;新密码&#x27;)</span> <span class="string">WHERE</span> <span class="string">User</span> <span class="string">=</span> <span class="string">&#x27;root&#x27;</span> <span class="string">AND</span> <span class="string">Host</span> <span class="string">=</span> <span class="string">&#x27;localhost&#x27;</span><span class="string">;</span> <span class="comment">#设置新密码</span></span><br><span class="line"><span class="string">FLUSH</span> <span class="string">PRIVILEGES;</span> <span class="comment">#刷新权限</span></span><br><span class="line"><span class="string">quit</span> <span class="comment">#退出</span></span><br></pre></td></tr></table></figure>
<h2 id="3修改远程连接权限">3.修改远程连接权限</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选择mysql</span></span><br><span class="line"><span class="string">use</span> <span class="string">mysql;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#授权远程连接</span></span><br><span class="line"><span class="string">GRANT</span> <span class="string">ALL</span> <span class="string">PRIVILEGES</span> <span class="string">ON</span> <span class="string">*.*</span> <span class="string">TO</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">BY</span> <span class="string">&#x27;YYBrhr_2018&#x27;</span> <span class="string">WITH</span> <span class="string">GRANT</span> <span class="string">OPTION;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：如果navicat远程连接报1521错误</span></span><br><span class="line"><span class="string">GRANT</span> <span class="string">ALL</span> <span class="string">ON</span> <span class="string">*.*</span> <span class="string">TO</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;;</span> <span class="comment">#远程连接授权</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">BY</span> <span class="string">&#x27;password&#x27;</span> <span class="string">PASSWORD</span> <span class="string">EXPIRE</span> <span class="string">NEVER;</span> <span class="comment">#更改加密规则</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">WITH</span> <span class="string">mysql_native_password</span> <span class="string">BY</span> <span class="string">&#x27;123456&#x27;</span><span class="string">;</span> <span class="comment">#更改密码</span></span><br><span class="line"><span class="string">FLUSH</span> <span class="string">PRIVILEGES;</span> <span class="comment">#刷新权限</span></span><br></pre></td></tr></table></figure>
<p>注意，这一步需要小心，在自己的服务器或者内网的服务器就算了，如果是在外网的生产服务器上，务必先咨询同事。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装tomcat</title>
    <url>/2019/07/24/linux/linux%E4%B8%8B%E5%AE%89%E8%A3%85tomcat/</url>
    <content><![CDATA[<h2 id="1-安装">1. 安装</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#上传tomcat至自己想要的文件夹，我的是/usr/local</span></span><br><span class="line"><span class="string">tar</span> <span class="string">-zxvf</span> <span class="string">apache-tomcat-8.5.43.tar.gz</span></span><br><span class="line"><span class="comment">#解压完后是名为apache-tomcat-8.5.43的文件夹</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/apache-tomcat-8.5.43/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置tomcat环境变量</span></span><br><span class="line"><span class="comment">#用vim打开tomcat的bin目录下的setclasspath.sh</span></span><br><span class="line"><span class="string">vim</span> <span class="string">/usr/local/apache-tomcat-8.5.43/bin/setclasspath.sh</span></span><br><span class="line"><span class="comment">#添加JAVA_HOME变量</span></span><br><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/jdk1.8.0_221</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.xiajibagao.top/tomcatexport.PNG"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入bin目录，启动或关闭tomcat</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/apache-tomcat-8.5.43/bin</span></span><br><span class="line"><span class="string">./startup.sh</span> <span class="comment">#启动</span></span><br><span class="line"><span class="string">./shutdown.sh</span> <span class="comment">#关闭</span></span><br></pre></td></tr></table></figure>
<h2 id="2如果tomcat启动过慢">2.如果tomcat启动过慢</h2>
<blockquote>
<p>参考：https://www.liangzl.com/get-article-detail-2622.html</p>
<p>参考：https://www.liangzl.com/get-article-detail-2622.html</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果tomcat启动过慢</span></span><br><span class="line"><span class="comment">#进入jre的bin中（根据需要换成自己的路径，下同）</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/jdk1.8.0_221/jre/lib/security/</span></span><br><span class="line"><span class="comment">#修改java.security</span></span><br><span class="line"><span class="string">vim</span> <span class="string">java.security</span> </span><br><span class="line"><span class="comment">#将securerandom.source=file:/dev/random 替换为securerandom.source=file:/dev/./urandom</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.xiajibagao.top/java.security.PNG"></p>
<h2 id="3如果要直接使用tomcat的自带管理工具">3.如果要直接使用tomcat的自带管理工具</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置账号</span></span><br><span class="line"><span class="comment">#到conf目录 修改 tomcat-users.xml 配置文件(根据需要换成自己的路径，下同)</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/apache-tomcat-8.5.43/conf/</span></span><br><span class="line"><span class="string">vim</span> <span class="string">tomcat-users.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在文件加上如下内容 账号密码自己设置</span></span><br><span class="line"><span class="string">&lt;role</span> <span class="string">rolename=&quot;manager-gui&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;role</span> <span class="string">rolename=&quot;admin-gui&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;user</span> <span class="string">username=&quot;用户名&quot;</span> <span class="string">password=&quot;密码&quot;</span> <span class="string">roles=&quot;manager-gui,admin-gui&quot;/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#webapps/manager/META-INF 文件下修改 context.xml</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/usr/local/apache-tomcat-8.5.43/webapps/manager/META-INF</span></span><br><span class="line"><span class="string">vim</span> <span class="string">context.xml</span></span><br><span class="line"><span class="comment">#加入以下变量（如果以有，则注释后再添加）</span></span><br><span class="line"><span class="string">&lt;Valve</span> <span class="string">className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span>  </span><br><span class="line">         <span class="string">allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1|\d+\.\d+\.\d+\.\d+&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">#重启tomcat后即可</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.xiajibagao.top/屏幕截图%202020-10-27%20094521.png"></p>
<p>然后访问8080端口，出现默认展示界面，点击三个选项任意一个</p>
<p><img src="http://img.xiajibagao.top/屏幕截图%202020-10-27%20094834.png"></p>
<p>进入项目管理</p>
<p><img src="http://img.xiajibagao.top/tomcat项目管理.PNG"></p>
<p>在这个界面可以方便的部署本地项目，或者上传war包，也可以查看项目部署情况</p>
<h2 id></h2>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SpringCache做简单缓存</title>
    <url>/2019/07/23/spring/%E4%BD%BF%E7%94%A8SpringCache%E5%81%9A%E7%AE%80%E5%8D%95%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>从 spring3 开始，spring 开始支持缓存组件，并提供了一系列非常方便的注解。</p>
<p>其中，Cache 接口定义了基本的增删改查方法，Spring 提供了一些默认的实现，比如 RedisCache 等。 CacheManager 接口则用于接入并获取 Redis 这样的缓存组件。</p>
<p>在 springboot 中，当我们启用缓存以后，需要如果要将接入 Redis 作为缓存，就需要配置 RedisCacheManager，其他缓存组件亦同。当没有自定义的缓存的时候，就会使用默认的 ConcurrentMapCacheManager，即将缓存存入本地的一个 Map 集合中。</p>
<h2 id="一-配置">一、配置</h2>
<h3 id="1添加依赖">1.添加依赖</h3>
<p>在创建项目的时候直接在 springboot 启动器中配置，或在项目中添加 Maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-启用注解">2. 启用注解</h3>
<p>在启动类或者配置类里添加 <span class="citation" data-cites="EnableCaching">@EnableCaching</span> 注解开启缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootCacheApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootCacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：由于 Spring 的 AOP 基于 CGLib 代理，所以如果在本类调用成员方法，因为不走代理所以缓存是不会生效的。</strong></p>
<h2 id="二-注解与-spel-表达式">二、注解与 SpEL 表达式</h2>
<h3 id="1缓存注解">1.缓存注解</h3>
<table>
<thead>
<tr class="header">
<th>注解</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="citation" data-cites="EnableCaching">@EnableCaching</span></td>
<td>开启基于注解的缓存</td>
</tr>
<tr class="even">
<td><span class="citation" data-cites="CacheConfig">@CacheConfig</span></td>
<td>统一配置本类的缓存注解的属性</td>
</tr>
<tr class="odd">
<td><span class="citation" data-cites="Cacheable">@Cacheable</span></td>
<td>第一次调用方法后都将返回值存入缓存，下次则请求直接调用缓存</td>
</tr>
<tr class="even">
<td><span class="citation" data-cites="CachePut">@CachePut</span></td>
<td>每次调用方法后都将返回值存入缓存，用于缓存更新</td>
</tr>
<tr class="odd">
<td><span class="citation" data-cites="CacheEvict">@CacheEvict</span></td>
<td>清除缓存</td>
</tr>
<tr class="even">
<td><span class="citation" data-cites="Caching">@Caching</span></td>
<td>组合注解，即给一个方法同时设置多个缓存方案</td>
</tr>
</tbody>
</table>
<h3 id="2-spel-表达式">2. SpEL 表达式</h3>
<p>spring 表达式支持我们通过指定的明确获取参数或者方法的属性：</p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 8%">
<col style="width: 53%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>位置</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>methodName</td>
<td>root对象</td>
<td>当前被调用的方法名</td>
<td>#root.methodname</td>
</tr>
<tr class="even">
<td>method</td>
<td>root对象</td>
<td>当前被调用的方法</td>
<td>#root.method.name</td>
</tr>
<tr class="odd">
<td>target</td>
<td>root对象</td>
<td>当前被调用的目标对象实例</td>
<td>#root.target</td>
</tr>
<tr class="even">
<td>targetClass</td>
<td>root对象</td>
<td>当前被调用的目标对象的类</td>
<td>#root.targetClass</td>
</tr>
<tr class="odd">
<td>args</td>
<td>root对象</td>
<td>当前被调用的方法的参数列表</td>
<td>#root.args[0]<br>#root.参数名</td>
</tr>
<tr class="even">
<td>caches</td>
<td>root对象</td>
<td>当前方法调用使用的缓存列表</td>
<td>#root.caches[0].name</td>
</tr>
<tr class="odd">
<td>Argument Name</td>
<td>执行上下文</td>
<td>当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数</td>
<td>#artsian.id</td>
</tr>
<tr class="even">
<td>result</td>
<td>执行上下文</td>
<td>法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false）</td>
<td>#result</td>
</tr>
</tbody>
</table>
<p>因为默认对象即为 #root，所以写的时候可以直接省略 #root</p>
<p>此外，表达式同样支持运算符：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>关系</td>
<td>&lt;，&gt;，&lt;=，&gt;=，==，!=，lt，gt，le，ge，eq，ne</td>
</tr>
<tr class="even">
<td>算术</td>
<td>+，- ，* ，/，%，^</td>
</tr>
<tr class="odd">
<td>逻辑</td>
<td>&amp;&amp;，||，!，and，or，not，between，instanceof</td>
</tr>
<tr class="even">
<td>条件</td>
<td>?: (ternary)，?: (elvis)</td>
</tr>
</tbody>
</table>
<h2 id="三-使用">三、使用</h2>
<h3 id="1添加缓存">1.添加缓存</h3>
<p><span class="citation" data-cites="Cacheable">@Cacheable</span> 注解用于标记方法。第一次执行的时候，会将方法结果存入缓存，再次调用该方法，<strong>在执行前</strong>，如果 key 相同则直接返回缓存中的数据，不会再次执行方法。</p>
<p>他的主要属性有以下五种：</p>
<ul>
<li>value/cacheName：指定缓存命名空间，只有保证命名空间相同，key 才能找到对应的缓存。</li>
<li>key：指定缓存数据的键值对的key，默认为方法参数中的值；</li>
<li>Condition：指定缓存执行的条件；</li>
<li>unliss：指定缓存不执行的条件；</li>
<li>sync：指定缓存是否使用异步模式，默认同步，若异步则不支持 unless。这个主要是用来处理多线程环境下缓存更新导致数据出错的问题的。</li>
</ul>
<p>上述一些复杂的条件依赖于 sqEl 表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法调用给前进行检测，若存在 key 对应的数据则直接从缓存中返回结果，否则在执行后将返回值存入缓存</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;dept&quot;，key = &quot;targetClass&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;全查！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2缓存更新">2.缓存更新</h3>
<p><span class="citation" data-cites="CachePut">@CachePut</span> 注解一般用于更新某个命名空间中的某条缓存数据。<strong>当方法调用结束以后</strong>，会根据注解将结果存入缓存，如果 key 已经存在，则会更新缓存。</p>
<p>他的主要属性同 <span class="citation" data-cites="Cacheable">@Cacheable</span> 基本相同，但是由于是先执行才处理数据，所以 key 是可以获得 #root.result 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 调用方法后，再把返回值放入缓存</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CachePut(cacheNames = &quot;dept&quot;，key = &quot;#root.targetClass&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;增加！&quot;</span>);</span><br><span class="line">    mapper.insert(dept);</span><br><span class="line">    <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3清空缓存">3.清空缓存</h3>
<p><span class="citation" data-cites="CacheEvict">@CacheEvict</span> 用于清空某个命名空间内某条、或全部缓存数据。</p>
<p>他的主要属性就两个：</p>
<ul>
<li><p>allEntries：是否清空全部缓存数据。默认 true，会忽略 key，否则只清除 key 对应的缓存；</p></li>
<li><p>beforeInvocation：是否要在方法执行前就清空缓存。默认为 false，即执行结束后才清空缓存。</p>
<p>注意：当发生异常时，是不会清空缓存的。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 清除缓存中的数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;dept&quot;, key = &quot;#root.targetClass&quot;, beforeInvocation = false)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer deptno)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除！&quot;</span>);</span><br><span class="line">    mapper.deleteByPrimaryKey(deptno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4多条件组合">4.多条件组合</h3>
<p><span class="citation" data-cites="Caching">@Caching</span> 是一个组合注解，可以在里面添加复数的以上三种注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 组合注解，三种注解以每种可有多个，以数组形式存储</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">    cacheable = &#123;</span></span><br><span class="line"><span class="meta">        //添加一个缓存</span></span><br><span class="line"><span class="meta">        @Cacheable(value = &quot;dept&quot;,key = &quot;#deptno&quot;)</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    put = &#123;</span></span><br><span class="line"><span class="meta">        //更新一个缓存</span></span><br><span class="line"><span class="meta">        @CachePut(value = &quot;emp&quot;，key = &quot;#root.targetClass&quot;)</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    evict = &#123;</span></span><br><span class="line"><span class="meta">        //清除一个缓存</span></span><br><span class="line"><span class="meta">        @CacheEvict(value = &quot;person&quot;，key = &quot;#deptno&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dept <span class="title">findById</span><span class="params">(Integer deptno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5统一命名空间">5.统一命名空间</h3>
<p><span class="citation" data-cites="CacheConfig">@CacheConfig</span> 注解可以在类上统一命名空间，这样类中如果没有指定 cacheName 或者 value，那么默认会使用 <span class="citation" data-cites="CacheConfig">@CacheConfig</span> 指定的命名空间。当然，如果在方法上自己指定了另外的命名空间，则以方法上的注解为准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用@CacheConfig统一cacheName，如果在方法上仍写了value，则该方法值仍以value为准</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;dept&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptServiceImp</span> <span class="keyword">implements</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper mapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;targetClass&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;全查！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;targetClass&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">add</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加！&quot;</span>);</span><br><span class="line">        mapper.insert(dept);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;targetClass&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">delete</span><span class="params">(Integer deptno)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除！&quot;</span>);</span><br><span class="line">        mapper.deleteByPrimaryKey(deptno);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP知识小结</title>
    <url>/2020/08/19/spring/SpringAOP%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>提起Spring，必然就会联想到AOP（面向切面编程）和IOC（控制反转）这两个词，众所周知，Spring框架对这两种思想进行了很好的实现。</p>
<p>在这篇文章，我将大致的介绍Spring对AOP这思想的实现流程。</p>
<p>对于AOP，关注的两个问题：</p>
<ul>
<li>什么是是AOP/IOC？</li>
<li>AOP/IOC解决了什么问题？</li>
</ul>
<h2 id="一-什么是aop">一、什么是AOP</h2>
<blockquote>
<p>Aspect oriented programming 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续。</p>
</blockquote>
<p>我们知道，根据面向对象编程的思想，对于一些具有相同属性和方法的类，我们可以抽象出他们共同部分作为一个父类，然后这些子类通过继承来获得他们共同的属性。比如<code>Cat</code>类和<code>Dog</code>都有<code>eat()</code>方法，那么我们可以将<code>eat()</code>方法抽象到他们的父类<code>Animal</code>，让他们去继承父类。</p>
<p>我们管这个抽取成类的方法叫做<strong>纵向抽取</strong>。</p>
<p>而如果他们的父类的方法中有相同方法，那么就直接抽取成公共方法。，但是有一些一开始就耦合到业务逻辑里的重复代码，比如下面统计方法执行时间的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//计时</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;eat.....&quot;</span>);</span><br><span class="line">    <span class="comment">//结束计时</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行时长：&quot;</span> + (System.currentTimeMillis() - start)/<span class="number">1000f</span> + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这些方法实际上是难以抽离的，因为他们实际上已经耦合到了业务逻辑里。这部分代码，又叫做<strong>横切逻辑代码</strong>。</p>
<figure>
<img src="http://img.xiajibagao.top/横向切割.png" alt="横向切割"><figcaption aria-hidden="true">横向切割</figcaption>
</figure>
<p>我们可以看到，通过对方法增加一个进行一个<strong>横向抽取</strong>来抽取重复的方法。这个方式<strong>不会改变原有的业务逻辑代码</strong>。</p>
<p>现在就不难理解AOP为啥叫面向切面编程了：</p>
<ul>
<li>切指横切逻辑：原有业务代码不动，只操作横切逻辑代码；</li>
<li>以方法为线，横切逻辑代码为点，很多点构成了一个横切面。</li>
</ul>
<h2 id="二-aop的实现原理">二、AOP的实现原理</h2>
<h3 id="1静态代理">1.静态代理</h3>
<p>说到AOP，就得先理解一下什么叫代理模式：</p>
<blockquote>
<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>
</blockquote>
<p>我们举个例子，首先有一个接口，叫做购房者，然后这个类地下有一个实现类，叫做小明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//购房者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 买房</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小明实现了购房者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> <span class="keyword">implements</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小明买了一套房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>买房子还要货比三家，小明没时间，于是就把买房子这件事情委托给中介</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intermediary</span> <span class="keyword">implements</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XiaoMing xiaoMing ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明把权限委托给了中介</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Intermediary</span><span class="params">(XiaoMing xiaoMing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.xiaoMing = xiaoMing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这基础上又添加了挑选方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;房中介先帮吗挑了最合适的房&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中介让XiaoMing这个类执行了购房的动作</span></span><br><span class="line">        xiaoMing.buy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这基础上又添加了抽成方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;买完房中介要那点抽成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="http://img.xiajibagao.top/小明买房（静态代理）.png" alt="小明买房（静态代理）"><figcaption aria-hidden="true">小明买房（静态代理）</figcaption>
</figure>
<p>在这个例子里：</p>
<ul>
<li>被代理对象是小明这个类，是我们最终要访问的；</li>
<li>代理对象就是中介这个类，他是被代理对象的加强，我们通过代理对象去访问目标对象，在这基础上对其进行加强。</li>
</ul>
<p>为了做到代理的效果，代理对象和目标对象<strong>需要实现同一个接口或者继承同一个类</strong>，以达到通过代理对象的方法去调用被代理对象的方法。这种方法叫做<strong>静态代理</strong>。</p>
<p>通过静态代理，我们可以在不改变代理类代码的基础上进行方法增强，但是如果有很多这样的代理行为，那么就需要很多代理类或者代理类去实现很多接口的方法，这样做显然会来带麻烦，为此，我们可以选择只在需要的时候才生产代理对象，这就是动态代理。</p>
<p>针对动态代理，有两种实现方法：</p>
<ul>
<li>JDK 代理，通过 JDK 的 API 实现；</li>
<li>CGLib 代理，通过 CGLib 包实现。</li>
</ul>
<h3 id="2jdk代理">2.JDK代理</h3>
<p>JDK 代理仍然需要被代理去实现某个接口，因为 JDK 代理的方式本质仍然还是生成一个与被代理类继承同一个接口的类，去代替被代理类的方法提供调用，但是和静态代理不同，这个代理对象由代码在调用的时候动态生成。</p>
<p>我们可以先看看实现代理效果的核心方法<code>Proxy.newProxyInstance()</code>的注释：</p>
<blockquote>
<p>返回指定接口的代理类的实例，该实例将方法调用分派到指定的调用处理程序。</p>
<p>参数：</p>
<p><code>ClassLoader loader</code>：指定加载被代理对象的类加载器</p>
<p><code>Class&lt;?&gt;[] interfaces</code>：被代理对象实现的接口的类型,使用泛型方式确认类型</p>
<p><code>InvocationHandler h</code>：事件处理,执行被代理对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
</blockquote>
<p>我们需要提供三个参数，被代理类的类的加载器，被代理类实现的结构，一个代理方法要实现的函数式接口。</p>
<p>对于函数式接口 <code>InvocationHandler</code>，我们不妨再看看他的参数：</p>
<blockquote>
<p><code>proxy</code>：在方法上调用方法的代理实例method-与在代理实例上调用的接口方法相对应的Method实例。</p>
<p><code>Method</code>：对象的声明类将是在其中声明该方法的接口，它可能是代理类通过其继承该方法的代理接口的超接口。</p>
<p><code>args</code> ：包含在代理实例的方法调用中传递的参数值的对象数组；如果接口方法不带参数，则为null。基本类型的参数包装在适当的基本包装器类的实例中，例如java.lang.Integer或java.lang.Boolean。</p>
</blockquote>
<p>可以说非常直观了，下面我们来简单实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    XiaoMing xiaoMing = <span class="keyword">new</span> XiaoMing();</span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    Buyers proxyBuyers = (Buyers) Proxy.newProxyInstance(</span><br><span class="line">        <span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">        xiaoMing.getClass().getClassLoader(),</span><br><span class="line">        <span class="comment">//获取被代理对象实现的接口</span></span><br><span class="line">        xiaoMing.getClass().getInterfaces(),</span><br><span class="line">        <span class="comment">//让代理对象实现被代理对象实现的接口</span></span><br><span class="line">        (proxy, method, params) -&gt; &#123;</span><br><span class="line">            <span class="comment">//只有对buy方法进行加强，如果不是buy方法就直接执行被代理对象的方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.getName() != <span class="string">&quot;buy&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(xiaoMing, params);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;中介帮小明找到了最合适的房源&quot;</span>);</span><br><span class="line">            method.invoke(xiaoMing, params);</span><br><span class="line">            System.out.println(<span class="string">&quot;中介抽了一笔中介费&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//通过代理对象买房</span></span><br><span class="line">    proxyBuyers.buy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">中介帮小明找到了最合适的房源</span><br><span class="line">小明买了一套房</span><br><span class="line">中介抽了一笔中介费</span><br></pre></td></tr></table></figure>
<p>我们可以看看实现代理效果的核心方法<code>Proxy.newProxyInstance()</code>的注释：</p>
<blockquote>
<p>返回指定接口的代理类的实例，该实例将方法调用分派到指定的调用处理程序。</p>
<p>参数：</p>
<p><code>ClassLoader loader</code>：指定加载被代理对象的类加载器</p>
<p><code>Class&lt;?&gt;[] interfaces</code>：被代理对象实现的接口的类型,使用泛型方式确认类型</p>
<p><code>InvocationHandler h</code>：事件处理,执行被代理对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
</blockquote>
<h3 id="3cglib代理">3.CGLib代理</h3>
<p>对于动态代理，我们可以通过JDK的<code>Proxy.newProxyInstance()</code>方法动态的生成一个实现了被代理类指定接口的代理类，那么，如果<strong>被代理类没有实现任何接口</strong>，那我们该怎么办呢？答案就是使用 CGLib 代理。</p>
<p>CGLib 代理的原理就是在内存里创建一个被代理类的对象的子类，然后重写父类要加强的方法，而无需加强的方法就直接使用父类方法。</p>
<p>要使用 CGLib 代理，需要引入 CGLib 包（Spring的动态代理就是基于Cglib实现的，所以Spring的依赖里会有这个）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XiaoMing xiaoMing = <span class="keyword">new</span> XiaoMing();</span><br><span class="line"><span class="comment">//获取代理对象</span></span><br><span class="line">Buyers proxyBuyers = (Buyers) Enhancer.create(</span><br><span class="line">    <span class="comment">//获取被代理对象的类</span></span><br><span class="line">    xiaoMing.getClass(),</span><br><span class="line">    <span class="comment">//实现代理逻辑切入类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o 代理类对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> method 要拦截的被代理类的方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> objects 被代理类的方法参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodProxy 要触发父类的方法对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName() != <span class="string">&quot;buy&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">//注意，这里参数是o，调用的是invokeSuper</span></span><br><span class="line">                <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;中介帮小明找到了最合适的房源&quot;</span>);</span><br><span class="line">            <span class="comment">//注意，这里参数是xiaoMing，调用的是invoke</span></span><br><span class="line">            methodProxy.invoke(xiaoMing, objects);</span><br><span class="line">            System.out.println(<span class="string">&quot;中介抽了一笔中介费&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">proxyBuyers.buy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般为了方便使用，我们会将代理过程整合到一个代理工厂类中。</p>
<p><strong>由于需要生成子类，所以要被代理的类最好不能用 final 修饰</strong></p>
<h3 id="4如何选择代理模式">4.如何选择代理模式</h3>
<ul>
<li>JDK在创建代理对象时的性能要高于 CGLib 代理，而生成代理对象的运行性能却比 CGLib 的低。</li>
<li>如果是单例的代理，推荐使用 CGLib</li>
</ul>
<p>也就是说，<strong>如果需要频繁的创建代理对象（多例），那么就该选择JDK代理，否则（单例）使用CGLib代理</strong></p>
<h3 id="5其他aop实现">5.其他AOP实现</h3>
<p>除了代理模式以外，还有其他的实现：AspectJ，以及 JBoss API 等，其中 AspectJ 应该是知名度最高的，它常常以注解的形式出现在我们的代码中。</p>
<blockquote>
<p>AspectJ是<strong>语言级别</strong>的 AOP 实现，扩展了 Java 语言，定义了 AOP 语法，能够在<strong>编译期</strong>提供横切代码的织入，所以它有<strong>专门的编译器</strong>用来生成遵守Java字节码规范的 Class 文件。</p>
</blockquote>
<h2 id="三-aop">三、AOP</h2>
<h3 id="1aop的术语">1.AOP的术语</h3>
<ul>
<li><p>连接点（Join point）：SpringAOP基于动态代理实现，是方法拦截，也就是每一个成员方法都是连接点</p></li>
<li><p>切点（Poincut）：具体定位的连接点</p></li>
<li><p>增强/通知（Advice）：添加到切点的一段代码，并且定位切点的方位信息。</p>
<p>SpringAOP提供了<strong>前置，后置，返回，异常，环绕</strong>五种。</p></li>
<li><p>织入（weaving）：将增强/通知添加到连接点上的过程</p></li>
<li><p>引入/引介（Introduction）：允许我们向当前类<strong>添加新方法或者属性</strong>，是一种特色增强。</p></li>
<li><p>切面（Aspect）：切面由切点和增强/通知组成，它既包括了横切逻辑的定义、也包括了连接点的定义。</p></li>
</ul>
<blockquote>
<p>通知/增强包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知/增强被应用的具体位置。其中关键的是切点定义了哪些连接点会得到通知/增强。</p>
</blockquote>
<h3 id="2aop的使用方式">2.AOP的使用方式</h3>
<p>有三种：</p>
<ul>
<li>基于代理实现的AOP：需要实现接口手动创建</li>
<li>纯粹POJOO切面：使用XML配置AOP命名空间</li>
<li><span class="citation" data-cites="AspectJ驱动的切面">@AspectJ驱动的切面</span>：使用注解</li>
</ul>
<h3 id="3spring提供的增强方式">3.Spring提供的增强方式</h3>
<p>总共有五种：</p>
<figure>
<img src="http://img.xiajibagao.top/Spring五种增强类型.png" alt="Spring五种增强类型"><figcaption aria-hidden="true">Spring五种增强类型</figcaption>
</figure>
<h3 id="4切点类型">4.切点类型</h3>
<p>总共有六种：</p>
<figure>
<img src="http://img.xiajibagao.top/Spring提供的六种切点类型.png" alt="Spring提供的六种切点类型"><figcaption aria-hidden="true">Spring提供的六种切点类型</figcaption>
</figure>
<h3 id="5切面类型">5.切面类型</h3>
<p>三种：</p>
<ul>
<li>一般切面</li>
<li>切点切面</li>
<li>引介/引入切面</li>
</ul>
<figure>
<img src="http://img.xiajibagao.top/切面类继承关系.png" alt="切面类继承关系"><figcaption aria-hidden="true">切面类继承关系</figcaption>
</figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(一)：三大日志概述</title>
    <url>/2020/10/25/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 2、15节日志相关部分和网上一些相关文章的内容的总结</p>
</blockquote>
<h2 id="一-redo-log">一、redo log</h2>
<p><strong>redo log 又叫重做日志，提供的是数据丢失后的前滚操作。</strong></p>
<p><strong>redo log 是 innodb 引擎独有的日志</strong>，使用了 WAL 技术（Write-Ahead Logging），也就是预写日志。它的关键点就是<strong>先写日志，再写磁盘</strong>。对应到 mysql 中具体操作，就是每次更新操作，先写日志，然后更新内存数据，最后等系统压力小的时候再进行IO更新磁盘数据。避免了每一次更新都需要进行IO操作。<strong>redo log 是保证了事务持久性的关键</strong>。</p>
<p>redo log 一般用在数据库恢复的情况：</p>
<ol type="1">
<li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为<strong>脏页</strong>。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至<strong>与 redo log 毫无关系</strong>。</li>
<li>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会<strong>将它读到内存，然后让 redo log 更新内存内容</strong>。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</li>
</ol>
<p>另外，<strong>redo log 与 undo log 都被叫做事务日志</strong>。</p>
<p>redo log 是一个物理日志，我们知道数据库引擎加载是按“页”来的，redo log记录的就是每个“页”上的数据发生的变化。但是不像 binlog 那样，redo log 不记录 sql，而是以类似 session_id + date + file_id + block_id + 修改数据这样的格式去记录数据。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200930111506778.png" alt="image-20200930111506778"><figcaption aria-hidden="true">image-20200930111506778</figcaption>
</figure>
<p>redo log 的日志文件大小是根据配置固定的，如果有一组有四个文件，每个文件的大小是 1GB，那么总共就只能记录 4GB 的日志。</p>
<p>因为 redo log 是前滚日志，也就是说一旦事务成功提交且数据持久化落盘之后，此时日志中的对应事务数据记录就失去了意义。所以 redo log 类似一个环形链表，<strong>从前往后写，到底了就删除最前面的再回到开头往后写</strong>。</p>
<p><strong>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的并且在日志中有记录都数据可以找回，这个能力称为 crash-safe。</strong></p>
<h2 id="二-undo-log">二、undo log</h2>
<p>undo log 又叫<strong>回滚日志</strong>。事务未提交之前，undo log 保存了未提交之前的版本数据，可作为数据旧版本快照供其他并发事务进行快照读。</p>
<p>因此，他能够提供两个功能：</p>
<ul>
<li><p><strong>回滚</strong>：当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>简单的说：如果我们执行了insert操作，那么日志中就会新增一条相反的 delete 的 sql；</p></li>
<li><p><strong>多行版本控制(MVCC)</strong>：当读取的某一行被其他事务锁定时，它可以从 undo log 中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p></li>
</ul>
<p><strong>undo log 保证了事务的原子性。</strong></p>
<h2 id="三-binlog">三、binlog</h2>
<p>binlog 又叫二进制日志。是 Server 层特有的日志，无论哪个引擎都能使用。</p>
<p>它被用于记录 mysql 的数据更新（即使更新零条或者删除零条也会记录）。</p>
<p>binlog有三种工作模式：</p>
<ul>
<li>Row ：日志中会记录<strong>每一行数据被修改</strong>的情况，然后在slave端对相同的数据进行修改。</li>
<li>Statement：每一条<strong>被修改数据的sql</strong>都会记录到 master 的 binlog 中，slave 在复制的时候sql进程会解析成和原来 master 端执行过的相同的sql再次执行。</li>
<li>Mixed：结合了 Row 和 Statement 的优点，同时 binlog 结构也更复杂。</li>
</ul>
<p><strong>binlog 和 redo log 的区别如下</strong>：</p>
<ul>
<li>binlog 是 mysql 自带的，redo log 是 innodb 引擎自带的</li>
<li>binlog 记录的是每一行数据的变化或修改数据的 sql，redo log 记录的是数据页的变化</li>
<li>binlog 能够实现归档功能，通过 binlog 可以实现备份，redo log 是循环写的，历史日志不会一直保留</li>
<li>mysql 高可用基于 binlog，像主从等系统机制都依赖于 binlog</li>
</ul>
<h2 id="五-两阶段提交">五、两阶段提交</h2>
<h3 id="1概述">1.概述</h3>
<figure>
<img src="http://img.xiajibagao.top/image-20201011182232866.png" alt="image-20201011182232866"><figcaption aria-hidden="true">image-20201011182232866</figcaption>
</figure>
<p>当innodb执行修改时，会经历一个两阶段提交的过程：</p>
<ul>
<li>执行器根据sql写入新数据，然后新数据更新到内存里</li>
<li>将这个更新操作<strong>记录到 redo log 里面，此时 redo log 处于 prepare 状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器<strong>生成这个操作的 binlog，并把 binlog 写入磁盘</strong>。</li>
<li>执行器调用引擎的提交事务接口，<strong>引擎把刚刚写入的 redo log 改成提交（commit）状态</strong>，更新完成</li>
</ul>
<p>那么如果事务提交过程中出现了异常，数据库崩溃了，就会有以下几种情况：</p>
<ul>
<li><p><strong>写 binlog 前崩溃了</strong>：对于时刻A，redo log 还是 prepare，binlog 没写，此时崩溃后事务回滚。</p></li>
<li><p><strong>写 binlog 后崩溃了</strong>：对于时刻B，redo log 还是 prepare，binlog 已经写了，此时发生崩溃后情况如下：</p>
<ol type="1">
<li><p>如果redo log 已经标记为 commit，则提交事务，重做</p></li>
<li><p>如果redo log 还是 prepare，则去检查 binlog 记录的对应事务是否存在：</p>
<p>如果存在，就提交事务，重做</p>
<p>如果不存在，就回滚</p></li>
</ol></li>
</ul>
<h3 id="2为什么需要两阶段提交">2.为什么需要两阶段提交</h3>
<p>我们举个反例，说明一下他的必要性。假设我们要更新某条数据的A字段由0变为2：</p>
<ul>
<li>先 redo log 再 binlog，服务挂了：由于 redo log 还在，可以通过 redo log 恢复数据，A此时是2。但是如果后面要通过 binlog 恢复数据时，由于 binlog 中没有这次修改的记录，恢复后的数据库/备份库就会变为0，<strong>丢失了这次更新</strong>。</li>
<li>先 binlog 再 redo log，服务挂了：由于 redo log 没记录这次更新，所以恢复后这次事务无效，A此时是0。但是 binlog 已经有了“A从0变成2这个记录”，所以恢复以后等于<strong>多了一次事务</strong>。</li>
</ul>
<p>之所以这样做，<strong>归根结底是为了保证数据库事务的一致性</strong>：</p>
<p>因为不管是从库或者备份库都需要通过读取 binlog 来同步数据，所以为了保证保证和主库数据一致，binlog 里记录的每一条事务就必须是已经提交了的，也就是<strong>一定要保证往 binlog 里写入数据以后事务不能回滚</strong>。</p>
<h2 id="六-总结">六、总结</h2>
<ul>
<li>redo log保证更新不丢失，支持的是事务的持久性</li>
<li>undo log保证事务不成功可以回滚，支持的是事务的原子性</li>
<li>redo log和binlog的二次提交机制，为事务的一致性提供了一定的保证</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(三)：内存数据刷盘机制</title>
    <url>/2020/10/28/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的12节的学习笔记</p>
</blockquote>
<h2 id="一-mysql-的刷盘机制">一、mysql 的刷盘机制</h2>
<p>而之前提到过，mysql 使用了 WAL 技术，即更新的时候先更新内存中的数据，然后必要的时候再将内存中的数据刷入磁盘。我们把内存中这些被修改过，跟磁盘中的数据页不一致的数据页称为脏页。</p>
<p>其中，有四种情况会触发脏页的刷盘：</p>
<ol type="1">
<li>redo log 可写空间满了。</li>
<li>内存满了，需要淘汰的数据页恰好是脏页。</li>
<li>系统不繁忙的时候。</li>
<li>关闭数据库的时候。</li>
</ol>
<p>其中，第三种情况不会为系统带来过多影响的，第四中情况下不会在乎为系统带来的影响。所以我们只需要关注第一和第二种情况：</p>
<p>对于第二种情况，由于 mysql 的更新需要先写日志，所以<strong>当日志满了的情况下，所有的更新都会停止，一直到刷完盘日志腾出了空间为止</strong>；</p>
<p>而对于第二种情况，当查询的数据在内存中的数据页没有的时候，就需要淘汰旧页释放内存以读入新页，<strong>所以当一次查询导致需要淘汰的脏页过多的时候，就需要先等待较长的刷盘时间，然后才能获取响应</strong>。</p>
<p>为了避免上述两种情况，必须要控制脏页在内存中的比例。</p>
<h2 id="二-刷脏页的控制策略">二、刷脏页的控制策略</h2>
<p>首先，我们必须要知道主机磁盘的写入能力有多强，这样 innodb 才可以知道它刷脏页的速度最快应该是多快。</p>
<p>我们可以通过<strong>设置 <code>innodb_io_capacity</code> 这个参数来告诉 innodb 磁盘的写入速度</strong>。这个参数的值不宜过小，因为这会导致 innodb 错误的估计刷盘速度，最后导致刷脏页的速度跟不上脏页生成的速度。</p>
<p><code>innodb_io_capacity</code>规定了刷脏页速度的极限，但是实际上磁盘不可能只服务这么一个功能，所以还需要参考 <strong>redo log 的刷盘速度</strong>和<strong>允许的内存中的脏页</strong>比例。</p>
<p><strong>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限</strong>，默认值是 75%。innodb 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，这个公式是 <code>F1(M)</code> 。</p>
<p>而每次写入 redo log 的写入点 wp 都会有一个序号，innodb 会根据这个序号和上一次清理日志的界限 cp 之间的差值——我们假设为 N——计算得到一个范围在 0 到 100 之间的数字，这个公式是 <code>F2(N)</code></p>
<p>根据上述算得的 <code>F1(M)</code> 和 <code>F2(N)</code> 两个值，取其中较大的值记为 R，之后引擎就可以按照 <code>innodb_io_capacity</code> 定义的能力乘以 R% 来控制刷脏页的速度。</p>
<p>这一整个流程对应的图片是这样的：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201029164736099.png" alt="image-20201029164736099"><figcaption aria-hidden="true">image-20201029164736099</figcaption>
</figure>
<p>所以，我们需要关注内存中的脏页比例，让它尽量不要到75%，并且合理的设置 <code>innodb_io_capacity</code> 参数。</p>
<p>其中，针对脏页的比例，我们可以通过 <code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code>去设置。</p>
<p>另外，由于 mysql 存在这样一个机制：如果要刷盘的脏页相邻的数据页恰好也是脏页，就一起写入磁盘，如果邻居的邻居也是如此。在机械硬盘时代这个策略可以减少随机IO，但是如果使用固态硬盘的话随机IO的性能往往比较高，所以使用这个策略反而拖累了查询性能。因此可以通过 <code>innodb_flush_neighbors</code>关闭这个“连坐”的策略。</p>
<h2 id="三-总结">三、总结</h2>
<p>innodb 有四种情况会触发脏页的刷盘：</p>
<ul>
<li>redo log 可写空间满了；</li>
<li>内存满了，需要淘汰的数据页恰好是脏页；</li>
<li>系统不繁忙的时候；</li>
<li>关闭数据库的时候。</li>
</ul>
<p>innodb 通过的刷盘速度通过类似这样的公式计算：</p>
<blockquote>
<p><code>innodb_io_capacity * Max( F(innodb_max_dirty_pages_pct)， F(redo log的wp - redo log的cp) )</code></p>
<p>其中，<code>innodb_io_capacity</code>表示磁盘的最大IO能力；<code>innodb_max_dirty_pages_pct</code>表示允许脏页在内存中的占比，默认值为75%；</p>
</blockquote>
<p>当使用固态硬盘的时候，可以设置<code>innodb_flush_neighbors</code>关闭默认的刷新相邻脏页的策略。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(二)：日志的文件是如何保证不丢失的</title>
    <url>/2020/10/27/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%97%A5%E5%BF%97%E7%9A%84%E6%96%87%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的23节日志相关部分的学习总结</p>
</blockquote>
<h2 id="一-持久化的过程">一、持久化的过程</h2>
<p>从总的来看，日志一般分为两部分：内存中<strong>易遗失的缓存日志</strong>和磁盘上<strong>持久化的日志文件</strong>。</p>
<p>一次事务中，日志<strong>先被写入内存</strong>，存放在 cache/buffer 中，然后事务结束以后准备持久化：<strong>先写入磁盘的 page cache 中，这个过程叫做 write</strong> ，他仍然是内存操作，只不过从 mysql 的内存去了操作系统的内存，所以比较快；<strong>然后再调用操作系统的方法来写入磁盘，这个过程叫做 fsync ，是真正的持久化过程</strong>，比较耗费时间。</p>
<p>这个过程，我们可以简单的理解为下图：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201116192502318.png" alt="日志的持久化过程"><figcaption aria-hidden="true">日志的持久化过程</figcaption>
</figure>
<p>基于以上的概念，我们了解一下 binlog 和 redo log 的持久化策略。</p>
<h2 id="二-binlog-的持久化">二、binlog 的持久化</h2>
<h3 id="1文件结构">1.文件结构</h3>
<p>系统给 binlog cache 分配了一片内存，<strong>每个线程独享一块内存</strong>，参数 <code>binlog_cache_size</code> 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201116172850486.png" alt="binlog 写盘状态"><figcaption aria-hidden="true">binlog 写盘状态</figcaption>
</figure>
<p>每个线程有自己 binlog cache，但是共用同一份 binlog 文件。这样是因为 binlog 的执行是不允许打断的，事务必须完成后完整的写入日志，不能也不允许出现像 redo log 那样两阶段提交只完成了一个阶段就能刷盘的情况。</p>
<h3 id="2刷盘策略">2.刷盘策略</h3>
<p>当事务执行的时候，会<strong>先把日志写到内存里的 binlog cache 中，然后事务提交以后再调用 fsync 写入磁盘的 log file 上</strong>。由于一个事务的 binlog 不能拆开，因此每次写入都代表一次事务提交。</p>
<ul>
<li>图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。</li>
<li>图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync() 才占磁盘的 IOPS。</li>
</ul>
<p>write 和 fsync 的时机，是由参数 <code>sync_binlog</code> 控制的：</p>
<ol type="1">
<li>sync_binlog=0 的时候，表示每次提交事务都<strong>只 write，不 fsync</strong>；</li>
<li>sync_binlog=1 的时候，表示每次提交事务<strong>都会执行 fsync</strong>；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示<strong>每次提交事务都 write，但累积 N 个事务后才 fsync</strong>。</li>
</ol>
<p>因此，在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。</p>
<p>但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</p>
<h2 id="三-redo-log-的持久化">三、redo log 的持久化</h2>
<h3 id="1刷盘策略">1.刷盘策略</h3>
<p>和 binlog 相同，在事务未提交前，生成的日志也会先放在内存，不过不同于 <strong>binlog 存放在 binlog cache，redo log 存放在了 redo log buffer</strong>。</p>
<p>在 mysql 的运行过程中，redo log 的数据可能存在三种状态：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201116175630245.png" alt="image-20201116175630245"><figcaption aria-hidden="true">image-20201116175630245</figcaption>
</figure>
<p>这三种状态分别是：</p>
<ol type="1">
<li>红色：存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</li>
<li>黄色：写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</li>
<li>绿色：持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</li>
</ol>
<p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：</p>
<ol type="1">
<li>设置为 0 的时候，表示每次事务提交时都<strong>只是把 redo log 留在 redo log buffer 中</strong> ;</li>
<li>设置为 1 的时候，表示每次事务提交时<strong>都将 redo log 直接持久化到磁盘</strong>；</li>
<li>设置为 2 的时候，表示每次事务提交时都<strong>只是把 redo log 写到 page cache，由后台线程一秒sync一次</strong>。</li>
</ol>
<p>一般情况下，不建议设置为0，如果需要的话可以设置为2，因为实际上 redo log 写到 page cache 也很快，而且只留在 redo log buffer 中风险太大，万一数据库崩溃就没法起到重做的效果了。</p>
<h3 id="2未提交事务写入磁盘的情况">2.未提交事务写入磁盘的情况</h3>
<p>正如前文提到的，innodb 有一个两阶段提交机制，因此在事务未提交的时候，日志是有可能直接在 prepare 阶段就被 write 的：</p>
<ol type="1">
<li>InnoDB 有一个后台线程，<strong>每隔 1 秒，就会把 redo log buffer 中的日志刷盘</strong>；</li>
<li>redo log buffer 占<strong>用的空间即将达到 innodb_log_buffer_size 一半</strong>的时候，后台线程会主动刷盘；</li>
<li><strong>并发事务提交</strong>的时候，先提交的那个事务会将 redo log buffer 中的日志全部刷盘。这个行为取决于 <code>innodb_flush_log_at_trx_commit</code> 参数，<strong>当该参数为 1 的时候，就会发生这种情况</strong>。</li>
</ol>
<p>由于当数据库崩溃后一个事务要同时有 prepare 阶段的 redo log 和 binlog 的记录才会被重做，因此一般情况下，我们会同时设置 <code>sync_binlog</code> 和 <code>innodb_flush_log_at_trx_commit</code> 参数为1，也就是一次事务刷两次盘： binlog 一次，redo log 一次。</p>
<h3 id="3-组提交">3. 组提交</h3>
<p>按照上文的逻辑，当设置“双1”配置的时候，实际上要刷盘的次数就会两倍与看到的 TPS，但是事实并非如此。</p>
<p>当事务提交的时候，会通过<strong>日志逻辑序列号（LSN）</strong>来记录一条日志的长度，通过日志的长度确定事务的起始点和结束点。</p>
<p>假如我们现在有三个日志等待提交：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201116200506743.png" alt="image-20201116200506743"><figcaption aria-hidden="true">image-20201116200506743</figcaption>
</figure>
<figure>
<img src="http://img.xiajibagao.top/image-20201116200520213.png" alt="image-20201116200520213"><figcaption aria-hidden="true">image-20201116200520213</figcaption>
</figure>
<figure>
<img src="http://img.xiajibagao.top/image-20201116200601118.png" alt="image-20201116200601118"><figcaption aria-hidden="true">image-20201116200601118</figcaption>
</figure>
<p>以上三张图就是三个事务的提交过程。我们可以看到：</p>
<ul>
<li>trx1 是第一个到达的，会被选为这组的 leader；</li>
<li>等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；</li>
<li>trx1 去写盘的时候，<strong>带的就是 LSN=160</strong>，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；</li>
<li>这时候 trx2 和 trx3 就可以直接返回了。</li>
</ul>
<p>所以，<strong>一次组提交里面，组员越多</strong>，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。</p>
<p>在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。为此，mysql 在两阶段提交做了一个优化：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201116200841655.png" alt="image-20201116200841655"><figcaption aria-hidden="true">image-20201116200841655</figcaption>
</figure>
<p>我们可以看到，<strong>在 redo log 一阶段提交的时候，并没有在 write 完以后立刻就调用 fsync 刷盘，而是等到 binlog 的 write 结束以后才刷盘；binlog 则等 redo log 一阶段刷盘以后才刷盘</strong>，因此可以减少 IOPS 的消耗。</p>
<p>不过通常情况下第 3 步执行得会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p>
<p>如果你<strong>想提升 binlog 组提交的效果</strong>，可以通过设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 来实现。</p>
<ol type="1">
<li><code>binlog_group_commit_sync_delay</code> 参数，表示延迟多少微秒后才调用 fsync;</li>
<li><code>binlog_group_commit_sync_no_delay_count</code> 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>这两个条件是或的关系，也就是说<strong>只要有一个满足条件就会调用 fsync</strong>。</p>
<p>所以，当 <code>binlog_group_commit_sync_delay</code> 设置为 0 的时候，<code>binlog_group_commit_sync_no_delay_count</code> 也无效了。</p>
<h3 id="4-redo-log-提交策略的选择">4. redo log 提交策略的选择</h3>
<p>适当的刷盘策略可以降低 IO 带来的性能压力。结合以上的内容，我们可以有以下三种策略：</p>
<ol type="1">
<li>增大<code>binlog_group_commit_sync_no_delay_count</code>和<code>binlog_group_commit_sync_delay</code> 参数，减少 binlog 刷盘次数，提高组提交的效果，但是这样虽然不会丢失数据，却会增加响应的时间；</li>
<li>增大 <code>sync_binlog</code> ，但是这样万一数据库崩溃会丢失 binlog 日志；</li>
<li>将<code>innodb_flush_log_at_trx_commit</code> 设置为 2，但是这样数据库崩溃会丢失数据，无法重做。</li>
</ol>
<h2 id="四-总结">四、总结</h2>
<p><strong>持久化过程</strong></p>
<p>日志的持久化分为三步：</p>
<ul>
<li>写入内存里的 buffer/cache 中，此时仍然归于 mysql 进程；</li>
<li>从内存写入操作系统的 page cache，此操作为 write；</li>
<li>从 page cache 持久化到磁盘，此操作为 fsync，是真正持久化；</li>
</ul>
<p><strong>日志文件结构</strong></p>
<p>所有线程持久化同一个 binlog 日志文件，但是每个线程都有自己的 binlog cache，这是因为 binlog 必须保证每一次写入都是完整的事务。而 redo log 存在两阶段提交，并且需要 prepare 阶段的 redo log 来重做，所以允许未提交的事务被 write，因此线程共享一个 redo log buffer 和 redo log 日志文件。</p>
<p><strong>刷盘策略</strong></p>
<p>binlog 无论 <code>sync_binlog</code>参数怎么设置，都必须要 write：</p>
<ol type="1">
<li>sync_binlog=0 的时候，表示每次提交事务都<strong>只 write，不 fsync</strong>；</li>
<li>sync_binlog=1 的时候，表示每次提交事务<strong>都会执行 fsync</strong>；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示<strong>每次提交事务都 write，但累积 N 个事务后才 fsync</strong>。</li>
</ol>
<p>redo log 通过 <code>innodb_flush_log_at_trx_commit</code> 参数控制：</p>
<ol type="1">
<li>设置为 0 的时候，表示每次事务提交时都<strong>只是把 redo log 留在 redo log buffer 中</strong> ;</li>
<li>设置为 1 的时候，表示每次事务提交时<strong>都将 redo log 直接持久化到磁盘</strong>；</li>
<li>设置为 2 的时候，表示每次事务提交时都<strong>只是把 redo log 写到 page cache</strong>。</li>
</ol>
<p><strong>组提交</strong></p>
<p>mysql 通过日志逻辑序列号（LSN）去根据事务数据长度来记录事务在日志中的开始和结束位置。因此，假如有三个并发事务先后准备写入，第一个被 fsync 的日志可以作为 leader，直接携带从一号到三号事务的 LSN 去刷盘，这样后两个事务就不必再单独刷盘，减少的写磁盘的次数。</p>
<p>针对组提交，二阶段提交进行了优化，redo log 的 write 以后，会等到 binlog 的 wirte 后才调用 fsync，binlog 再等 redo log 的 fsync 完成后才进行 fsync。不过由于时间太短， binlog 的组提交效果不显著，可以通过增大：</p>
<ol type="1">
<li><code>binlog_group_commit_sync_delay</code> 参数，表示延迟多少微秒后才调用 fsync;</li>
<li><code>binlog_group_commit_sync_no_delay_count</code> 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>两个参数来提高组提交效率，不过这样会降低语句的响应时间。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(五)：数据库表空间的回收</title>
    <url>/2020/10/30/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间MySQL实战45讲第13节的笔记</p>
</blockquote>
<h2 id="一-表数据的存放位置">一、表数据的存放位置</h2>
<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 <code>innodb_file_per_table</code> 控制的：</p>
<ol type="1">
<li>OFF ：表的数据放在系统共享表空间，即跟数据字典放在一起；</li>
<li>ON ：表数据存储在一个以 .ibd 为后缀的文件中。（MySQL 5.6.6 默认为 ON）</li>
</ol>
<p>一般情况下，表单独存放的时候，可以通过 drop table 语句直接删除，而如果放在共享表空间，及时删除了表也无法回收空间。</p>
<h2 id="二-表数据的删除">二、表数据的删除</h2>
<p>一般情况下，很少有直接连结构带数据直接删掉表的情况，更多时候是只删除一些数据，但是这样往往会遇到这样的问题：<strong>表中的数据被删除了，但是表空间却没有被回收</strong>。</p>
<p>实际上，这与 innodb 中数据都以 B+ 树的结构存储有关：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201105203027271.png" alt="image-20201105203027271"><figcaption aria-hidden="true">image-20201105203027271</figcaption>
</figure>
<p>以上图为例，如果我们删除 R4 这条数据，则 innodb 会把 R4 这个位置标记为删除，之后如果插入一个在 300~600 的记录的时候，就会直接使用现在 R4 的位置。同理，如果我们清除这个 PageA，那么这个数据页都会被标记删除，等到下一个数据页加载的时候就可以直接使用这个空间。而当两个相邻的数据页上被删除了记录很多，也就是页的利用率都很低的时候，系统就会自动合并两个页的数据，并且标记其中一个为可复用。</p>
<p>值得一提的是，记录的空间被复用，必须限定位置，比如 R4 的空间被复用，就不能插入300 ~ 600之外的数据；而数据页的空间则可以被任意一页新加载的页复用。</p>
<p>综上所述，不难理解，<strong>我们使用 delete 删除的数据只是把这块空间标记为可复用，是一种逻辑上的删除，并没有实际减少磁盘空间的占用</strong>。</p>
<p>实际上，<strong>不止是删除数据会造成空洞，插入数据也会。</strong></p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201105204359077.png" alt="image-20201105204359077"><figcaption aria-hidden="true">image-20201105204359077</figcaption>
</figure>
<p>假如 PageA 已满，再插入一条550，PageA 就会不得不分离成两页，这就是页的分裂。当分裂完以后，PageA 就会留下一个空洞，新页 PageB 一样没有占满。</p>
<p>另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这很有可能破坏了索引的有序性，也是会造成空洞的</p>
<p>也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，<strong>如果能够把这些空洞去掉，就能达到收缩表空间的目的</strong>。</p>
<p>而重建表，就可以达到这样的目的。</p>
<h2 id="三-重建表">三、重建表</h2>
<h3 id="1重建表的流程">1.重建表的流程</h3>
<p>为了去掉表中的空洞，我们可以新建一个与表 A 结构相同的表 B，然后<strong>按照主键 ID 递增的顺序</strong>，把数据一行一行地从表 A 里读出来再插入到表 B 中。</p>
<p>由于表 B 是新建的表，所以表 A 主键索引上的空洞，在表 B 中就都不存在了。显然地，表 B 的主键索引更紧凑，数据页的利用率也更高。如果我们把表 B 作为临时表，数据从表 A 导入表 B 的操作完成后，用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。</p>
<p>可以使用 <code>alter table A engine=InnoDB</code> 命令来重建表。在 MySQL 5.5 版本之前，这个命令的执行流程跟我们前面描述的差不多，mysql 会自动完成全部操作。</p>
<h3 id="2优化">2.优化</h3>
<p>但是这个 DDL 语句不是 online 的，也就说，<strong>如果过程中有新的数据往 A 表插入，有可能不会被读到并且一起转移到 B 表，导致最后丢失更新</strong>。因此，在 5.6 版本以后，引入的 online DDL 对这个流程做了优化。</p>
<p>新的流程如下：</p>
<ol type="1">
<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>
<li>生成临时文件的过程中，<strong>将所有对 A 的操作记录在一个日志文件</strong>中；</li>
<li>临时文件生成后，<strong>将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件</strong>；</li>
<li>用临时文件替换表 A 的数据文件。</li>
</ol>
<p>因为过程中对表 A 的操作最后都会通过日志同步到临时文件，所以在整个 DDL 执行的过程不会影响对表 A 的增删改查。</p>
<h3 id="3inplace">3.inplace</h3>
<p>我们可以注意到，5.6 之前是创建临时表，而 5.6 以后则是创建了临时文件。这两者的区别在于：<strong>临时表是创建在 server 层的</strong>，<strong>临时文件是创建在 innodb 内部</strong>的，整个 DDL 过程都在 innodb 内部完成。对于 server 层来说，后者没有把数据移到临时表，相当于一个原地操作，所以叫 inplace。</p>
<p>也就是说，<code>alter table t engine=InnoDB</code> 这个 DDL 实际上相当于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=inplace;</span><br></pre></td></tr></table></figure>
<p>相对于创建临时表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>
<h3 id="4三种重建表方式的区别">4.三种重建表方式的区别</h3>
<ol type="1">
<li>从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认的就是上面图 4 的流程了；</li>
<li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；</li>
<li>optimize table t 等于 recreate + analyze。</li>
</ol>
<h2 id="四-总结">四、总结</h2>
<p>数据库表文件可以存在共享表空间里；也可以单独以 .ibd 文件存储。共享表空间中的表使用 drop table 无法清除。通过<code>innodb_file_per_table</code>参数的 off/on 可以控制存放策略。mysql 5.6.6 以后默认为 on。</p>
<p>innodb 中的删除只是标记空间为可复用，没有实际删除数据。当非有序的插增删改影响了索引上的数据的有序性时，可能产生“空洞”降低空间利用率。当内存中相邻表空间利用率都很低的时候，可能引起页的合并，反之，过满或者无序插入会引发页分裂。</p>
<p>通过拷贝数据到临时表，再有序将数据插入原表，即重建表可以收缩空间。可以使用 <code>alter table A engine=InnoDB</code>的 sql 实现。</p>
<p>5.5 之前版本拷贝过程中原表的正删改可能在重建后丢失，5.6 之后将对原表的正删改写入临时日志后再同步，实现了 online DDL。</p>
<p>5.6 之前重建操作为在server 层创建临时表，5.6 之后为在 innodb 内创建临时文件，他们的写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认为inplace</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>(,ALGORITHM=inplace);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(九)：关于元数据锁 online ddl插队问题</title>
    <url>/2020/11/11/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%20online%20ddl%E6%8F%92%E9%98%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的元数据锁相关部分问题的思考总结</p>
</blockquote>
<h2 id="一-读写锁堵塞">一、读写锁堵塞</h2>
<p>前面在锁这块介绍了元数据锁（MDL 锁）。元数据锁是一种读写锁，他的读读不互斥，读写和写写是互斥的。因此我们参考下面的时序图：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201111201636187.png" alt="image-20201111201636187"><figcaption aria-hidden="true">image-20201111201636187</figcaption>
</figure>
<p>现在等待队列中有四个 session 要获取锁：</p>
<ul>
<li>由于 sessionA 和 sessionB 都是读操作，读读不互斥，因此两个 session 都持有读锁；</li>
<li>sessionA 和 sessionB 还未释放，此时 sessionC 要获取写锁，由于读写互斥，此时 sessionC 发生堵塞；</li>
<li>由于写锁的获取优先级高于读锁，sessionC 的写锁没获取到，后面其他 session 的读锁也无法获取到。此时 sessionD 堵塞；</li>
</ul>
<p>上面是一个很典型的读写锁堵塞的场景。但是实际测试的时候，会出现 sessionC 和 sessionD 都堵塞了，但是将 sessionA 和 sessionB 提交以后，sessionC 仍然保持堵塞状态，必须等 sessionD 也提交以后，才会继续执行。也就说，sessionD 好像发生了一个插队的现象。</p>
<h2 id="二-锁降级">二、锁降级</h2>
<p>我们知道 mysql 有一个 online ddl，即 执行 ddl 的时候不会直接锁表导致无法执行其他查询的操作。其实这涉及到一个锁降级的概念。即原本流程是：</p>
<ul>
<li>拿写锁</li>
<li>做 DDL</li>
<li>释放锁</li>
</ul>
<p>其他查询语句必须等到 DDL完整的做完这三步以后才能拿到锁，引入锁降级以后，流程变成：</p>
<ul>
<li>先只拿读锁；</li>
<li>自己先申请内存执行 DDL，先把一些处理做好；</li>
<li>去拿写锁；</li>
<li>真正完成 DDL，替换表结构</li>
<li>释放锁</li>
</ul>
<p>原本一开始就拿写锁，现在换成了先拿读锁，保证在这期间没有其他 DDL 先执行去修改表，然后自己先把一些读写的过程完成，最后再去拿写锁，把表结构替换上去。相当于原本大家排队买票，轮到了一个人，但是他电话来了，由于他堵着窗口，大家都得等他接完电话才能继续买票。后面大家跟他商量了一些，他接电话的时候先出去，让后面的先继续买票，等他打完电话在回来直接插到最前面。但是这样做的好处在于，避免了修改数据的过程长时间的占用写锁，导致其他 DML 被堵塞。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(八)：间隙锁的加锁条件</title>
    <url>/2020/11/09/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%97%B4%E9%9A%99%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 21、30、40节锁相关部分的总结</p>
</blockquote>
<h2 id="间隙锁的加锁原则">间隙锁的加锁原则</h2>
<p>间隙锁加锁的情况，<strong>包含了两个“原则”、两个“优化”和一个“bug”。</strong></p>
<ol type="1">
<li>原则 1：加锁的基本单位是 next-key lock。即间隙锁+行锁（前开后闭区间）。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给<strong>唯一索引加锁</strong>的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<p>以下面的表为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>我们需要注意一下，c 是加了索引的，而 d 没有。直观点就是下图：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201108173043844.png" alt="image-20201108173043844"><figcaption aria-hidden="true">image-20201108173043844</figcaption>
</figure>
<h2 id="一唯一索引等值查询间隙锁">一.唯一索引等值查询间隙锁</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201108173614816.png" alt="等值查询的间隙锁"><figcaption aria-hidden="true">等值查询的间隙锁</figcaption>
</figure>
<p>由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<ol type="1">
<li>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li>
<li>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li>
</ol>
<p>所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</p>
<h2 id="二非唯一索引等值查询间隙锁">二.非唯一索引等值查询间隙锁</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201108173725306.png" alt="只加在非唯一索引下的锁"><figcaption aria-hidden="true">只加在非唯一索引下的锁</figcaption>
</figure>
<p>我们分析一下这个过程：</p>
<ol type="1">
<li>首先，根据原则1，会为（0,5] 范围加上 next-key lock；</li>
<li>由于 c 是普通索引，所以因此查到5以后不会停下，会向右遍历到第一个不符合条件的值，也就是10以后才会停下。所以锁的范围会扩张到（0,10]；</li>
<li>由于符合优化2，所以 next-key lock 会退化为间隙锁，也就是会变成（0,10）；</li>
<li>根据原则2，只有访问到的才加锁，也就是锁只加在c字段上，对主键索引是没关系的，所以 sessionB 可以更新成功。但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</li>
</ol>
<p>需要注意，在这个例子中，<strong>lock in share mode 只锁覆盖索引</strong>，但是如果是 for update 就不一样了。 <strong>执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</strong>。</p>
<p>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就<strong>必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段</strong>。比如，将 session A 的查询语句改成 <code>select d from t where c=5 lock in share mode</code>。</p>
<h2 id="三唯一索引范围锁">三.唯一索引范围锁</h2>
<p>假如现在有两条 sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>&gt;=<span class="number">10</span> <span class="keyword">and</span> <span class="keyword">id</span>&lt;<span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>在逻辑上，两条 sql 是等价的，但是加锁的情况是不一样的。以第二条 sql 为例：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201108175305570.png" alt="主键索引范围锁"><figcaption aria-hidden="true">主键索引范围锁</figcaption>
</figure>
<ol type="1">
<li>首先加了一个范围为 （5,10] 的 next-key lock，由于id 是唯一索引，根据优化1锁会退化为行锁，也就是只锁id=10；</li>
<li>由于是范围查找，会继续向右遍历，找到id=15的行发现第一条不符合 id&lt;10 的数据，然后加上（10，15]的锁。</li>
</ol>
<p>也就是说，最终 sessionA 会加上 [10,15] 的锁。</p>
<p>需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。也就是说，&gt;= 这个查询，<strong>实际上是等值+范围查询，两次锁的分别加上的</strong>。</p>
<h2 id="四非唯一索引范围锁">四.非唯一索引范围锁</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201108180453457.png" alt="非唯一索引范围锁"><figcaption aria-hidden="true">非唯一索引范围锁</figcaption>
</figure>
<ul>
<li>首先，由于 c&gt;=10 满足的第一条数据就是 c=10 的这行，因此会加上（5,10] 的 next-key lock，由于 c 不是唯一索引，所以不符合优化1的条件，所以最终加锁范围还是（5,10]</li>
<li>由于是范围查找，继续向右遍历，直到找到第一行不符合 c&lt;11 的数据，也就是 c=15 这行，加上（10，15] 的，由于后半段是范围查询，所以不符合优化2的条件，所以最终加锁范围还是（10,15]</li>
</ul>
<p>也就是说，最终 sessionA 会加上 （5,15] 的锁。</p>
<h2 id="五唯一索引范围锁-bug">五.唯一索引范围锁 bug</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201108181439263.png" alt="唯一索引范围锁 bug"><figcaption aria-hidden="true">唯一索引范围锁 bug</figcaption>
</figure>
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 加上 (10,15] 这个 next-key lock。并且因为 id 是唯一键，相比于情况三，id = 15的这条数据是存在的，所以循环判断到 id=15 这一行就应该停止了。</p>
<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。</p>
<h2 id="六两个相同的非唯一索引上的等值查询">六.两个相同的非唯一索引上的等值查询</h2>
<h3 id="1不加limit的情况">1.不加limit的情况</h3>
<p>现在已经有了（10,10,10）这条数据，再插入（30,10,30），也就是说，现在有两条 c = 10 的数据。但是由于非唯一索引上包含主键的值，所以两种是不可能完全相同的，这两条数据也有间隙。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201108182444617.png" alt="两个相同的非唯一索引上的间隙"><figcaption aria-hidden="true">两个相同的非唯一索引上的间隙</figcaption>
</figure>
<p>在上图的状态，执行sql：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201108182706835.png" alt="delete 示例"><figcaption aria-hidden="true">delete 示例</figcaption>
</figure>
<ol type="1">
<li>先找到第一条 c=10 的数据，也就是 id=10 的这行，加上（5,10] 的锁;</li>
<li>向右遍历，一直到第一个不符合条件的数据，也就是加上（10,15] 的锁。注意，这里指的是id，也就是现在这个区间的锁包含了id为（30,15,20）这三条数据和他们的间隙。由于这是等值查询，根据优化1，会退化为间隙锁，也就是变成（10,15）；</li>
</ol>
<p>也就是说，现在加锁的就会变成：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201108183431275.png" alt="相同索引的等值查询加锁范围"><figcaption aria-hidden="true">相同索引的等值查询加锁范围</figcaption>
</figure>
<h3 id="2加limit限制的情况">2.加limit限制的情况</h3>
<p>现在，在上文的 delete 的情况加上 limit：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201108183726684.png" alt="加了limit语句限制的情况"><figcaption aria-hidden="true">加了limit语句限制的情况</figcaption>
</figure>
<p>加锁的逻辑会有一点变化：</p>
<ol type="1">
<li>依然先加（5,10] 的锁；</li>
<li>向右遍历找到第二条符合条件的数据，即 id=30 的数据。由于加上了 limit ，已经找到两条了，所以就不必向后再找到一条不符合的数据了，也就不需要加上（30,15）的锁了。</li>
</ol>
<figure>
<img src="http://img.xiajibagao.top/image-20201108184255128.png" alt="加了limit语句限制的锁范围"><figcaption aria-hidden="true">加了limit语句限制的锁范围</figcaption>
</figure>
<p>可以看见，这样做减少了锁的范围。</p>
<p>这个例子对我们实践的指导意义就是，<strong>在删除数据的时候尽量加 limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<h2 id="七-间隙锁的扩大">七、间隙锁的扩大</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201109202937260.png" alt="间隙锁的扩大"><figcaption aria-hidden="true">间隙锁的扩大</figcaption>
</figure>
<p>我们来分析一下：</p>
<ol type="1">
<li>由于 id &lt;= 15 第一条满足的数据就是 id=15 这条数据，因此加上 (10,15] 的锁，因为 id &gt; 10，所以不必再理id=10之前的数据了。由于是一个等值查询，所以（10,15] 退化为间隙锁（10,15）；</li>
<li>sessionB 删除了 id=10 这行数据，由于没锁到 id=10，所以顺利删除了该数据；</li>
<li>由于缺少了10，所以原本（10,15）的间隙锁扩大为（5,15），因此插入语句被阻塞。</li>
</ol>
<p>类似的例子还有这个：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201109204020361.png" alt="间隙锁的扩大2"><figcaption aria-hidden="true">间隙锁的扩大2</figcaption>
</figure>
<ol type="1">
<li>sessionA 加上了 ( 5,supremum] 的锁；</li>
<li>sessionB 将 c=5 变成了 c=1，现在锁扩大到了（1,supremum]；</li>
<li>sessionB 试图将 c=5 变成 c=1，此时c=5已经在锁的范围了，因此更新的sql被堵塞。</li>
</ol>
<h2 id="八-总结">八、总结</h2>
<p>分析间隙锁的加锁原则：两个原则，两个优化，一个bug。</p>
<p>加锁的对象一般来说是索引，也就是说，只要更新使用的索引跟上锁的索引不一样，就不会影响到插入间隙的行为。除非使用 for update，这会为整段数据都加上锁。</p>
<p>加锁单位是 next-key lock，即间隙锁+行锁，是一个前开后闭的区间。也就是，访问到了A，那么锁就是（A-1，A]，即实际上加锁范围由间隙右边的节点决定。</p>
<p>有且仅在等值查询的过程，对于唯一索引，锁有可能退化为行锁也可能退化为间隙锁；但是对于非唯一索引，锁只可能退化为间隙锁。</p>
<p>如果删除了间隙锁的“边界”，会导致间隙锁的扩大。</p>
<p>对于唯一索引：</p>
<ol type="1">
<li>等值查询：先加本段的 next-key lock，即前面一段间隙锁加本行行锁。如果本行即使要查询的数据，就退化为行锁，否则就退化为间隙锁。</li>
<li>范围查询：同上，但是必然会向后查找到第一个不符合的数据，先加上后半段的 next-key lock，再退化为间隙锁。</li>
</ol>
<p>对于非唯一索引：</p>
<ol type="1">
<li>等值查询：先加本段的 next-key lock，不管要查找的值存不存在，必在查找值的基础上向后找到第一条不符合的数据，加上 next-key lock，再让后半段锁退化为间隙锁。</li>
<li>范围查询：同上，由于不是等值查询所以不符合优化2的条件，相比等值查询，他的后半段还是 next-key lock 而不会退化为间隙锁。</li>
<li>多个重复的索引值，不加 limit：可以看成特殊的范围查询，会把第一个索引位置的前半段加上 next-key lock，然后再为第一到最后一个索引位置的这段区域全加上 next-key lock，最后再向后查找到第一个不符合条件的值，并加上 next-key lock，由于也算等值查询，根据优化2后半段从 next-key lock退化为间隙锁。</li>
<li>多个重复的索引值，加 limit：同上，但是由于加了条数限制，所以不必再向后查找到第一个不符合条件的值，所以相比不加 limit 少加最后一个索引位置的之后的一段间隙锁。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(六)：数据库事务概述</title>
    <url>/2020/11/02/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 3、8、18、19节事务相关部分的总结</p>
</blockquote>
<h2 id="一-事务的启动方式">一、事务的启动方式</h2>
<p>mysql 主要有两种事务的启动方式：</p>
<ol type="1">
<li><code>begin</code> 或 <code>start transaction</code>显式启动事务。对应的提交语句是 <code>commit</code> ，回滚是 <code>rollback</code></li>
<li><code>set autocommit = 0</code>关闭自动提交，然后在执行第一条 sql 的时候启动事务，这个事务会一直持续到你主动 commit 或者 rollback，或者断开连接才会结束。</li>
</ol>
<p>有一些客户端连接框架会在连接成功后默认修改设置，这可能导致意外的长事务。因此，显示启动事务明显是比较安全的，但是对于一些需要频繁使用事务的业务，每次都需要调用 begin 然后再 commit。对于这种情况，可以使用 <code>commit work and chain</code>，当 <code>autocommit = 1</code>时，<strong>使用该语句可以在提交以后自动开启下一个新事务</strong>。</p>
<p>这样省去了再次执行 begin 语句的开销，而且可以明确地知道每个语句是否处于事务中。</p>
<p>除此之外，我们还可以使用 sql 去在 information_schema 库的 innodb_trx 这个表中查询长事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started)) &gt; <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>比如上面这条语句，就是用于查找持续时间超过 60s 的事务</p>
<h2 id="二-事务的隔离级别">二、事务的隔离级别</h2>
<p>我们知道事务有四大特性（ACID）：原子性，一致性，隔离性，持久性。</p>
<p>针对隔离性，我们有：</p>
<ol type="1">
<li><strong>读未提交</strong>：一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读已提交</strong>：一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong>：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化</strong>：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ol>
<p>简单的理解：</p>
<ol type="1">
<li><strong>读未提交</strong>：别人改数据的事务<strong>尚未</strong>提交，我在我的事务中<strong>也能读到</strong>。</li>
<li><strong>读已提交</strong>：别人改数据的事务<strong>已经提交</strong>，我在我的事务中<strong>才能读到</strong>。</li>
<li><strong>可重复读</strong>：别人改数据的事务<strong>已经提交</strong>，我在我的事务中<strong>也不去读</strong>。</li>
<li><strong>串行化</strong>：我的事务尚未提交，别人就别想改数据。</li>
</ol>
<p>以这张图为例：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200930144400423.png" alt="image-20200930144400423"><figcaption aria-hidden="true">image-20200930144400423</figcaption>
</figure>
<ol type="1">
<li><strong>读未提交</strong>： 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li>
<li><strong>读已提交</strong>：则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li>
<li><strong>可重复读</strong>：则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li>
<li><strong>串行化</strong>：则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li>
</ol>
<p>我们不难看出，读已提交和可重复读，最大的区别在于，当一个查询的事务尚未提交，另一个修改的事务的提交是否会影响到这次查询结果。</p>
<h2 id="三-事务隔离的实现">三、事务隔离的实现</h2>
<h3 id="1脏读幻读不可重复读">1.脏读，幻读，不可重复读</h3>
<p>说起事务，就不得不提到三种错误读：</p>
<ol type="1">
<li><strong>脏读（读到了RoolBack）</strong>：表示一个事务能够读取另一个事务中还未提交的数据。这个未提交数据就是脏读（Dirty Read）。</li>
<li><strong>幻读（读到了insert）</strong>：指同一个事务内多次查询返回的结果集不一样。</li>
<li><strong>不可重复读（读到了update</strong>）：是指在一个事务内，多次读同一数据。
<ul>
<li>第一类丢失更新：两个事务更新同一条数据资源，后做的事务撤销，发生回滚造成已完成事务的更新丢失</li>
<li>第二类丢失更新：两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失</li>
</ul></li>
</ol>
<h3 id="2事务隔离的实现">2.事务隔离的实现</h3>
<p>在实现上，数据库里面会创建一个视图，当访问的时候以视图的逻辑结果为准。</p>
<p>这里需要注意一下，这里的视图区别于我们自己创建的 View ：</p>
<blockquote>
<p>innodb 创建的，用于实现 MVCC 时的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别。</p>
</blockquote>
<ol type="1">
<li><strong>读未提交</strong>：直接返回记录上的最新值，没有视图概念；</li>
<li><strong>读已提交</strong>：这个视图是在每个 SQL 语句开始执行的时候创建的。</li>
<li><strong>可重复读</strong>：这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>
<li><strong>串行化</strong>：直接用加锁的方式来避免并行访问。</li>
</ol>
<p>这里单独对读已提交和可重复读的逻辑做一个区分：</p>
<ul>
<li>在可重复读隔离级别下，只需要在<strong>事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图</strong>；</li>
<li>在读提交隔离级别下，<strong>每一个语句执行前都会重新算出一个新的视图</strong>。</li>
</ul>
<table>
<thead>
<tr class="header">
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读未提交</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="even">
<td>读已提交</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>可重复读</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr class="even">
<td>串行化</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<h2 id="四-mvcc">四、MVCC</h2>
<h3 id="1概述">1.概述</h3>
<p>MVCC 即是并发版本控制。拿可重复读举个例子：</p>
<p>我们知道 innodb 有个 undo log ，每条记录在更新的时候都会在 undo log 中记录一条回滚操作，通过日志记录可以回滚到上一状态的值。</p>
<p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200930145105580.png" alt="image-20200930145105580"><figcaption aria-hidden="true">image-20200930145105580</figcaption>
</figure>
<p>当前的值是4，但是对于不同时间段启动的事务创建的视图ABC而言，分别为1，2，4，这时就算把4再改成5，对于ABC三个视图也不会有影响。</p>
<p><strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong>。</p>
<h3 id="2一致性读视图的实现">2.一致性读视图的实现</h3>
<p>当在可重复读隔离级别下时，事务在启动的时候就给整库“拍了个快照”，这个快照就是我们在事务的隔离提到过一致性读视图。这个视图是逻辑上的，用于描述事务之间的可见性。</p>
<p>在 innodb 里，每个事务都有独有的 transaction id，这是在事务开始的时候向系统申请的，是严格递增的。</p>
<p>而每行数据也有多个版本，每次事务更新数据的时候都会把 id 赋给对应版本数据的 row trx_id。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201023102713922.png" alt="image-20201023102713922"><figcaption aria-hidden="true">image-20201023102713922</figcaption>
</figure>
<p>如上图，我们可以看到这一行数据被三个事务进行了修改，现在有四个版本,每个版本更新前都会记录一条回滚的语句在 undo log。</p>
<p>事实上，V1，V2这些版本的数据并不是真实存在的，而是在需要的时候才通过 undo log 计算获取。比如需要 V2，就从 V4 经过 U3 和 U2 获得。</p>
<p>现在我们知道数据版本是如何跟事务绑定的，那么事务的隔离就很好理解了：<strong>当一个事务启动的时候，获取事务 id，事务id比他小的说明是在他之前就产生的，这些事务对应的版本就是被本事务承认的，反之，则这些数据是不被本事务承认的，要向前找到可以承认的数据版本。</strong></p>
<p>为此，innodb 会在事务启动的时候，为事务创建一个数组，这个数字里会存放所有当前启动了但是还没提交的事务的 id。这个数组里最小的视为低水位，最大的+1视为高水位，从低水位到高水位中间的这块区域，就是<strong>当前事务的一致性视图</strong>。这段操作是在锁保护性进行的。</p>
<h3 id="3数据版的一致性读">3.数据版的一致性读</h3>
<p>假如我们只在事务里面进行查询，而暂时不涉及到更新，那么基于一致性视图，当前事务就可以根据数据版本id，也就是 row trx_id 来判断当前数据版本对于自己而言是否可见：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201023104832814.png" alt="image-20201023104832814"><figcaption aria-hidden="true">image-20201023104832814</figcaption>
</figure>
<ol type="1">
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况
<ul>
<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>
<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ul></li>
</ol>
<p>当然，可能存在这么一种情况：如果有一个事务在未提交事务的区间，但是在当前事务获</p>
<p>仍然以上图为例，假如有一个事务，他的低水位是18，也就是说在他启动的时候，row trx_id 是17 的V3是最新的版本，在他查询的时候，而最新的版本变成了 row trx_id 是25的V4，那么对他而言V4是不可见的，于是通过 undo log U3 计算得到V3，V3低于他的低水位，所以V3是可见的，故对于该事务而言值就是V3的值。</p>
<p>可以看到，<strong>事务开始前和事务开始后读到的数据都一致的，这个就是一致性读</strong>。可重复读依赖这个隔离级别核心依赖于此。</p>
<h3 id="4数据的当前读">4.数据的当前读</h3>
<p>当事务里只进行查询的时候一致性读可以保证读取的正确性，但是如果进行的是更新，那么一致性读反而会导致错误。我们以下图为例：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201023110829190.png" alt="image-20201023110829190"><figcaption aria-hidden="true">image-20201023110829190</figcaption>
</figure>
<p>原本 k 是2，事务C进行了更新并且率先提交，对于事务C而言，此时k是3，但是事务B又进行了一次更新，那么等到提交的时候，k该是3还是4？</p>
<p>这里涉及到一个规则。<strong>因为更新总是需要先读后改，所以更新的读必须要读最新的数据，也就是当前读</strong>。</p>
<p>值得一提的是，如果是 select 语句，如果加了读锁或者写锁，也是当前读：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加读锁</span></span><br><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="comment"># 加写锁</span></span><br><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>然后，我们在前面了解了行锁，而行锁有一个两阶段锁的机制：<strong>事务里的有对某一行数据的更新，那么sql执行前就会去获取行锁，然后执行完sql之后不释放，等到事务提交之后才会去释放锁</strong>。由于事务C先获取了行锁，那么事务B的更新就会等待事务C释放锁以后才会得到锁。反映到执行上，就是事务B的 update 等到 事务C提交了才会继续进行。</p>
<p>也就说<strong>，而行锁的两阶段锁保证了更新的顺序进行，当前读机制保证的更新语句总是能拿到最新的数据。</strong></p>
<h3 id="5一致性视图与可重复读和读已提交">5.一致性视图与可重复读和读已提交</h3>
<p>MVCC 实现的核心在于一致性视图，可重复读和读已提交建立视图的机制决定了他们实现效果的不同：</p>
<ul>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ul>
<h3 id="6为什么要避免长事务">6.为什么要避免长事务</h3>
<ol type="1">
<li><strong>占用日志空间</strong>：因为一致性视图需要通过 undo log 去计算旧版本的数据，而 undo log 只有在没有比某条日志更早的一致性视图时才会删除。所以如果存在长事务，可能就会导致数据库的视图存在很长时间，直到这些视图删除前日志都会一直保留，这将会导致占用大量存储空间。</li>
<li><strong>影响版本控制计算性能</strong>：在可重复读这个隔离级别下，如果其他事务对某条数据进行了非常多次的操作，最后会导致本事务读取的时候必须要通过 undo log 计算非常多次才能找到最初的数据版本。</li>
<li><strong>占用锁资源</strong>：长事务还会可能会占用锁资源，比如只有等事务提交才能释放的行锁。</li>
</ol>
<h2 id="五-总结">五、总结</h2>
<p>1.<strong>事务的启动</strong>：</p>
<ul>
<li><code>begin</code> 或 <code>start transaction</code>显式启动事务。对应的提交语句是 <code>commit</code> ，回滚是 <code>rollback</code>；</li>
<li>set autocommit = 0`关闭自动提交，然后在执行第一条 sql 的时候启动事务，这个事务会一直持续到你主动 commit 或者 rollback，或者断开连接才会结束。</li>
</ul>
<p>2.<strong>事务的隔离级别</strong>：</p>
<ul>
<li>读未提交：别人改数据的事务<strong>尚未</strong>提交，我在我的事务中<strong>也能读到</strong>。会脏读，幻读，不可重复读；</li>
<li>读已提交：别人改数据的事务<strong>已经提交</strong>，我在我的事务中<strong>才能读到</strong>。会幻读，不可重复读；</li>
<li>可重复读：别人改数据的事务<strong>已经提交</strong>，我在我的事务中<strong>也不去读</strong>。会不可重复读；</li>
<li>串行化：我的事务尚未提交，别人就别想改数据。加锁，不会错误读。</li>
</ul>
<p>3.<strong>并发版本控制</strong>（MVCC）：</p>
<ul>
<li><p>每个事务的更新都会产生一个新版本数据，每个数据版本有自己的 row trx_id，对应更新他们的事务的 transaction id；</p></li>
<li><p>事务启动时 innodb 为事务创建一个数组，这个数字里会存放所有当前启动了但是还没提交的事务的 id。这个数组里最小的视为低水位，最大的+1视为高水位，从低水位到高水位中间的这块区域，就是<strong>当前事务的一致性视图</strong>。根据事务版本 id 从一致性视图中判断该版本对本事务是否可见；</p></li>
<li><p>可重复读和读已提交建立视图的机制决定了他们实现效果的不同：</p>
<p>在<strong>可重复读隔离级别</strong>下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</p>
<p>在<strong>读提交隔离级别</strong>下，每一个语句执行前都会重新算出一个新的视图。</p></li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(十一)：join</title>
    <url>/2020/11/13/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9Ajoin/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 34、35节join相关内容的笔记</p>
</blockquote>
<h2 id="一-join的查询流程">一、Join的查询流程</h2>
<p>假设我们有表 t1 和表 t2，他们都有字段 a，b，其中 t1 有 100条数据，而 t2 有1000条数据。</p>
<p>我们要执行这么一条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> t2.a = t1.a</span><br></pre></td></tr></table></figure>
<p>执行流程就是会这样的：</p>
<ol type="1">
<li>先取出 t1 的一条数据 R；</li>
<li>然后根据 R 的 a 字段 去 t2 表里找复合条件的数据；</li>
<li>找到以后，就和 R 的数据拼起来作为结果集的一部分；</li>
<li>重复以上步骤，直到遍历完 t1 最后一条数据。</li>
</ol>
<p>其中，被驱动表的关联条件是否有索引对性能有着很大的影响。</p>
<h2 id="二-关联条件有索引">二、关联条件有索引</h2>
<h3 id="1njl算法">1.NJL算法</h3>
<p>还是以上面的 sql 为例：</p>
<ol type="1">
<li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li>
<li>而对于每一行 R，根据 a 字段去表 t2 查找，<strong>走的是树搜索过程</strong>。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li>
<li>所以，整个执行流程，总扫描行数是 200。</li>
</ol>
<p>这个算法叫做<strong>NJL</strong>（Index Nested-Loop Join），由于从 t1 往 t2 查找的过程中使用了索引，所以关联查询的过程其实是一个查找树的过程：</p>
<blockquote>
<p>假设<strong>被驱动表的行数是 M</strong>。每次在被驱动表查一行数据，要先搜索索引 a，再搜索主键索引。每次搜索一棵树近似复杂度是以 2 为底的 M 的对数，记为 log2M，所以在被驱动表上查一行的时间复杂度是 2*log2M。</p>
<p>假设<strong>驱动表的行数是 N</strong>，执行过程就要扫描驱动表 N 行，然后对于每一行，到被驱动表上匹配一次。</p>
<p><strong>因此整个执行过程，近似复杂度是 <code>N + N * 2 * log2M</code>。</strong></p>
</blockquote>
<p>所以，对于有索引的情况下，<strong>需要让小表做驱动表</strong>。</p>
<h3 id="2mrr优化">2.MRR优化</h3>
<p>对于关联条件上有索引，但是查询条件没有实现索引覆盖的字段，仍然需要在获得了非主键索引后，进行回表获取数据。在这过程，回表需要一行一行的扫描主键索引树。</p>
<p>假设我们执行一条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">join</span> t4 <span class="keyword">on</span> t3.a = t4.a <span class="keyword">where</span> t3.a &gt; <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>由于 a 索引树是按 a 排序的，按照 a 的排序去回表，很可能对应主键索引树上的记录是无序的。比如 a 索引树上按顺序是a=1，a=2，a=3....而对应的主键索引树上，是id=1(a=2)，id=2(a=8)，id=3(a=1)....也就是说，可能会出现随机访问，性能较差。</p>
<p>针对这个问题，使用MRR（Multi-Range Read）这个过程优化为顺序读：</p>
<ol type="1">
<li>先查找 a 索引树，找到相关记录</li>
<li>在一块 read_rnd_buffer 内存中对 a 索引树的记录按 id 自增排序</li>
<li>回表，返回并且拼接复合条件的记录</li>
</ol>
<p>在这里，read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</p>
<p>MRR 能够提升性能的核心在于，这条<strong>查询语句在索引 a 上做的是一个范围查询</strong>，可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序读”的优势。</p>
<h3 id="3bka算法">3.BKA算法</h3>
<p>基于上面 MRR 优化的思想，MySQL 在 5.6 版本后开始引入的 批量索引访问（Batched Key Access）算法，针对关联条件有索引情况下的索引嵌套循环算法 NLJ 进行了优化。由于 NLJ 并没有像无索引条件下的块嵌套循环 BNL 算法那样，使用到 join_buffer，因此刚好将次内存区作为 MRR 优化的 read_rnd_buffer 。</p>
<p>如果要使用 BKA 优化算法的话，你需要在执行 SQL 语句之前，先设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>其中，前两个参数的作用是要启用 MRR。这么做的原因是，BKA 算法的优化要依赖于 MRR。</p>
<h2 id="三-关联条件无索引">三、关联条件无索引</h2>
<h3 id="1bnl算法">1.BNL算法</h3>
<p>在无索引的情况下，如果仍然使用索引循环嵌套的算法，那么每次关联 t2 的时候都需要对 t2 进行一次全表扫描，也就是说，如果执行联查的 sql，就需要查询 t2 100000次。这个算法叫做SNL（Simple Nested-Loop Join）</p>
<p>实际上，SNL 太过笨重了，Mysql 选择的是<strong>BNL</strong>（Block Nested-Loop Join）算法：</p>
<ol type="1">
<li>将 t1 读入线程内存 join buffer 中，<strong>如果放不下就分块进行</strong>；</li>
<li>全表扫描 t2 ，每扫描一行就和 t1的每一行进行比较；</li>
<li>把复合条件的数据返回结果集；</li>
</ol>
<p>这个做法和 SNL 需要扫描的次数一样，但是由于判断在内存进行，所以速度会快很多。</p>
<p>当 join_buffer_size 规定的 join buffer 大小能够装下 t1 时：</p>
<blockquote>
<p>假设小表的行数是 N，大表的行数是 M，那么在这个算法里：</p>
<ol type="1">
<li>两个表都做一次全表扫描，所以总的扫描行数是 M+N；</li>
<li>内存中的判断次数是 M*N。</li>
</ol>
</blockquote>
<p>可以看到，调换这两个算式中的 M 和 N 没差别，因此<strong>这时候选择大表还是小表做驱动表，执行耗时是一样的</strong>。</p>
<p><strong>但是，如果 join buffer 放不下 t1，这个过程就需要分块进行</strong>：</p>
<ol type="1">
<li>假如只放得下88行，那么就先将 t1 的前88行读入内存；</li>
<li>扫描 t2，每一行都比较88次，然后符合条件的放入结果集</li>
<li>清空 join buffer</li>
<li>重复以上步骤，处理完剩下的12行数据</li>
</ol>
<p>这种情况下，驱动表的选择是这么考虑的：</p>
<blockquote>
<p>假设，驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。</p>
<p>注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。</p>
<p>所以，在这个算法的执行过程中：</p>
<ol type="1">
<li>扫描行数是 <code>N + λ * N * M</code>；</li>
<li>内存判断 N*M 次。</li>
<li>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在 M 和 N 大小确定的情况下，N 小一些，整个算式的结果会更小。</li>
</ol>
</blockquote>
<p>所以结论是，<strong>还是应该让小表当驱动表</strong>。</p>
<p>当然，你会发现，在 N+λ<em>N</em>M 这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好，而决定了需要分几块的关键参数就在于 join buffer 的大小，join buffer 越大，一次性放入的数据就越多，需要分的块 K ——也就是 λ*N ——就越小。</p>
<p>所以，如果连表查询速度很慢，可以试着吧 join_buffer_size 调大。</p>
<h3 id="2bnl算法存在的问题">2.BNL算法存在的问题</h3>
<p>由于 InnoDB 对 Bufffer Pool 的 LRU 算法做了优化，即：第一次从磁盘读入内存的数据页，会先放在 old 区域。如果 1 秒之后这个数据页不再被访问了，就不会被移动到 LRU 链表头部，这样对 Buffer Pool 的命中率影响就不大。</p>
<p>但是，如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到 LRU 链表头部。</p>
<p>这种情况对应的，是冷表的数据量小于整个 Buffer Pool 的 3/8，能够完全放入 old 区域的情况。</p>
<p>如果这个冷表很大，就会出现另外一种情况：<strong>业务正常访问的数据页，没有机会进入 young 区域</strong>。</p>
<p>由于优化机制的存在，一个正常访问的数据页，要进入 young 区域，需要隔 1 秒后再次被访问到。但是，由于我们的 join 语句在循环读磁盘和淘汰内存页，进入 old 区域的数据页，很可能在 1 秒之内就被淘汰了。这样，就会导致这个 MySQL 实例的 Buffer Pool 在这段时间内，young 区域的数据页没有被合理地淘汰。</p>
<p>也就是说，这两种情况都会影响 Buffer Pool 的正常运作。</p>
<p><strong>大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</strong></p>
<p>为了减少这种影响，你可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数。</p>
<p>也就是说，BNL 算法对系统的影响主要包括三个方面：</p>
<ol type="1">
<li>可能会多次扫描被驱动表，占用磁盘 IO 资源；</li>
<li>判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；</li>
<li>可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。</li>
</ol>
<h3 id="3bnl算法的优化">3.BNL算法的优化</h3>
<p>假如我们要执行这样一条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> (t1.b=t2.b) <span class="keyword">where</span> t2.b&gt;=<span class="number">1</span> <span class="keyword">and</span> t2.b&lt;=<span class="number">2000</span>;</span><br></pre></td></tr></table></figure>
<p>其中，表 t1 有1000条数据，表 t2 中有100万条数据，但是经过 where 条件过滤后，需要参与 join 的只有 2000 行数据。</p>
<p>在 BNL 算法的逻辑下：</p>
<ol type="1">
<li>把 t1 存入 join_buffer</li>
<li>扫描 t2，每一条都去跟 t1 的数据对比，先判断 t1.b=t2.b ，再判断 t2.b&gt;=1和 t2.b&lt;=2000</li>
<li>返回满足条件的结果集</li>
</ol>
<p>按这个做法，每一条数据都必须要跟 join_buffer 里的每一条数据进行比对，也就是 1000*100 万 =10 亿次，显然很不明智。</p>
<p><strong>加索引</strong></p>
<p>要优化这个情况，<strong>最直接的方法仍然是查询条件加上索引，将默认的 BNL 算法转为 NLJ 算法</strong>。</p>
<p><strong>临时表</strong></p>
<p>当然，并不是所有情况下都时候给字段加上索引的，为此我们可以将整个查询过程分开来，<strong>使用临时表的策略</strong>：先将一部分数据筛选出来，出入临时表，然后在临时表上建立索引，最后再用临时表代替 t2 去跟 t1 联查。也就是这样的形式：</p>
<ol type="1">
<li>创建一张临时表，为关联字段加上索引</li>
<li>先从 t2 查出数据，然后插入临时表</li>
<li>让临时表代替 t2 去跟 t1 联查。</li>
</ol>
<p>对应的 sql 就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(b))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> b&gt;=<span class="number">1</span> <span class="keyword">and</span> b&lt;=<span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure>
<p><strong>Hash join</strong></p>
<p>当然，仔细想想，临时表中虽然数据少了很多，但是仍然摆脱不了对数据集的遍历，为此，最好的做法就是使用 hash join，1000*2000次查找换成1000次哈希查找。由于 mysql 并不支持 hash join，所以我们需要自己使用业务代码来实现：</p>
<ol type="1">
<li>先查出 t2 的数据，存入 HashMap 这样的结构</li>
<li>查出 t1 的数据，根据需要从数据结构中去获取值</li>
</ol>
<h2 id="四-总结">四、总结</h2>
<p>在默认情况下，最好做到以下两点：</p>
<ol type="1">
<li>尽量为被驱动表的连接条件加上索引；</li>
<li>使用小表作为驱动表（即查询行数少的，查询字段少的表）。</li>
</ol>
<p>在以上情况下，可以继续扩展的做法：</p>
<ol type="1">
<li>已经为关联字段建索引的情况：开启 MRR 支持，将 NJL 算法优化为 BKA 算法</li>
<li>还没有为关联字段建索引的情况：
<ul>
<li>加索引，将 BNL 算法优化为 NJL 算法；</li>
<li>使用临时表；</li>
<li>在业务代码中实现 hash join。</li>
</ul></li>
</ol>
<p>其中，对应没有给关键字建索引的情况，要注意根据情况调整 join_buffer_size 以减少对表的减少扫描次数：</p>
<ol type="1">
<li>一方面，可以提高查找效率；</li>
<li>另一方面，减少对了 Buffer Pool 的影响，尽可能避免影响内存命中率。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(十三)：自增主键，自增锁</title>
    <url>/2020/11/16/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%8C%E8%87%AA%E5%A2%9E%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的39节的学习笔记</p>
</blockquote>
<h2 id="一-自增值的保存方式">一、自增值的保存方式</h2>
<p>我们前面提到过，自增主键的连续性使得表在空间上排列的更紧密，提高了空间利用率，避免了页分裂。实际上，自增主键大部分情况下可以保证连续性，但是也有例外的时候。</p>
<p>当我们创建表的时候，表结构会存储在 .frm 文件中，但是并不会一起保存自增值。<strong>MyISAM 引擎将自增值保存在数据文件</strong>，而 innodb 在 mysql8.0 之前只会<strong>将自增值保存在内存</strong>。</p>
<p>也就是说，对于 innodb 引擎来说，每次重启后，都需要<strong>寻找表中最大的自增值 X，将 X+1 作为新的自增值</strong>，如果当前最大值为 10，自增值就会是11，如果删除了自增值为 10 的行，那么此时重启数据库，新插入的行自增值就会变成11，当自增值是主键的时候，相当于从新增变成了更新。</p>
<p><strong>而 8.0 以后，innodb 会将自增值的变更记录到 redo log，重启以后依靠日志重做</strong>。</p>
<h2 id="二-自增值的自增机制">二、自增值的自增机制</h2>
<p>在 mysql 中，如果字段 id 被定义为 AUTO_INCREMENT，那么插入时：</p>
<ol type="1">
<li>如果插入数据时 id 字段指定为 <strong>0、null 或未指定值</strong>，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>
<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。</p>
<ol type="1">
<li>如果 X&lt;Y，那么这个表的自增值不变；</li>
<li>如果 X≥Y，就需要<strong>把当前自增值修改为新的自增值</strong>。</li>
</ol>
<p>其中，有 <code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> ，分别表示自增值的<strong>初始值</strong>和自增的<strong>步长</strong>，一般默认为1，如果是在一些特殊的情况下：比如双 master 的结构下，就会将其中一个库的 <code>auto_increment_offset</code> 设置为2，让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数，避免两个库生成的主键发生冲突。</p>
<p>当需要自增的时候，会在<code>auto_increment_offset</code> 的基础上，累加<code>auto_increment_increment</code> ，直到找到第一个比插入值 X 大的数作为新的自增值。</p>
<h2 id="三-自增锁和释放策略">三、自增锁和释放策略</h2>
<p>为了在并发条件下维护自增值的有序性，mysql 引入自增锁。在 mysql 5.1.22 之前的版本，当有需要获取自增值的 sql ——而不是事务——要执行的时候，就会<strong>为计数器加一个表锁，在锁释放前这张表不会有新的 sql 能获得到新的值</strong>。很显然，这个和表的读写锁一样，在<strong>大量 sql 同时请求的时候比较容易发生堵塞</strong>。</p>
<p>mysql 在5.1.22 版本引入了一个新策略，新增参数 <code>innodb_autoinc_lock_mode</code>，默认值是 1。</p>
<ol type="1">
<li>设置为 0：表示采用之前 MySQL 5.0 版本的策略，即<strong>语句执行结束后才释放锁</strong>；</li>
<li>设置为 1：分两种情况
<ul>
<li><strong>普通 insert 语句，自增锁在申请之后就马上释放</strong>；</li>
<li>类似 insert … select 这样的<strong>批量插入数据的语句，自增锁还是要等语句结束后才被释放</strong>；</li>
</ul></li>
<li>设置为 2：所有的申请自增主键的动作都是<strong>申请后就释放锁</strong>。</li>
</ol>
<p>这个策略的疑问在于，为什么 insert ... select 不可以直接使用第三种策略，申请以后就释放？</p>
<p>假如现在有以下的时序图：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201112202134714.png" alt="自增锁的加锁策略"><figcaption aria-hidden="true">自增锁的加锁策略</figcaption>
</figure>
<p>假如在第三个时刻：</p>
<ol type="1">
<li>sessionB 已经写入了（1,1,1）和（2,2,2）；</li>
<li>此时 sessionA 写入了 （3,5,5）；</li>
<li>sessionB 继续写入（4,3,3）和（5,4,4）；</li>
</ol>
<p>也就是说，在表 t 上的数据应该是（1,1,1）（2,2,2）（3,3,3）（4,4,4），但是写到表 t2 变成了（1,1,1）（2,2,2）3,5,5）（4,3,3）（5,4,4）</p>
<p>考虑到 sessionB 的语义并没有强制要求 t2 与 t1 相同，所以这不是大问题，但是这样的行为反应到 binlog 就有问题了：</p>
<p>一般情况下，binlog 默认为 statement ，即记录 sql，在<strong>实际上两个 sql 是并行执行的，但是在 binlog 上是串行写入</strong>的，不管是谁先谁后，使用 binlog 恢复的备份里，<strong>表 t2 的数据都会和原来的数据库不一致</strong>。</p>
<p>发生这个问题的根本原因在于 <strong>sessionB 的 insert...select 这一条语句批量插入数据的 id 是不连续的</strong>，如果要避免这个问题，有两个办法：</p>
<ul>
<li>从根本上解决：让 insert...select 拿到的自增值一定是连续的，方案就是<strong>让锁等 sql 执行完才提交</strong>；</li>
<li>解决出问题的人：<strong>把 binlog 改为 row</strong>，直接记录数据的变化，避免恢复备份是数据出错。</li>
</ul>
<p>为了并发性能考虑，一般情况下，都选择 <strong><code>binlog_format = row</code></strong> + <strong><code>innodb_autoinc_lock_mode = 2</code></strong> 的模式。</p>
<h2 id="四-事务回滚导致自增不连续">四、事务回滚导致自增不连续</h2>
<p>一般情况下，以自增值为主键的表插入一条 id 为 null 的记录的过程如下：</p>
<ol type="1">
<li>执行器调用 innodb 引擎，写入一行；</li>
<li>innodb 发现没指定主键，获取要插入的表的自增值；</li>
<li>将自增值赋给要插入的新数据作为主键；</li>
<li>自增值自增；</li>
<li>完成插入。</li>
</ol>
<p>实际上，如果因为一些其他的情况，导致第五步没有执行，就会导致自增值增加了，但是上一个自增值却没有对应的数据。比如第五步的时候发现<strong>唯一索引冲突</strong>，或者插入完以后<strong>事务回滚</strong>。</p>
<p>实际上，事务回滚理论上应该回滚完全部的数据，但是却没有回滚自增值，是为了性能上的考虑：</p>
<p>假如事务A和事务B分别申请了2和3这两个值作为id，现在自增值为4，<strong>如果事务A发生回滚，而事务B提交了，此时就会出现自增值回滚为2，但是已经出现了id=3的数据</strong>，那么下一条插入的数据就会因此id=3这个主键冲突而插入失败。</p>
<p>如果要解决这个问题，那么方法有两种：</p>
<ol type="1">
<li>每次插入前扫描一下主键，是否存在同值，有就跳过；</li>
<li>把自增锁从语句级别扩大到事务级别，必须先等上一个事务提交，下一个事务的 sql 才能获取新的自增值；</li>
</ol>
<p>这两种方法都非常影响性能，所以 mysql 事务回滚不会回滚自增值，<strong>自增值只能保证递增有序，不能保证连续。</strong></p>
<h2 id="五-批量插入的申请策略">五、批量插入的申请策略</h2>
<p>insert..select 语句之所以需要加锁，是因为<strong>无法确定到底要插入多少条数据</strong>，对于 insert......values (),(),() 这样语句来说，由于一开始就能确定有多少条要插入，可以直接申请对应数量的自增值。</p>
<p>实际上，mysql 针对 insert...select 这样不确定数量的批量插入也有申请自增id的策略：</p>
<ol type="1">
<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>
<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>
<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>
<li>依此类推，同一个语句去申请自增 id，<strong>每次申请到的自增 id 个数都是上一次的两倍</strong>。</li>
</ol>
<p>我们举个例子：假如 sessionA 要执行 insert...select 语句，需要插入四次。在第三次申请 id 的时候，自增 id 就会变成 2 + 4 = 6，如果这个时候来了另一个 sessionB 要插入数据，就会直接插入 7，等到 sessionB 提交了以后，sessionA 第四次要申请的时候，自增id就会从8开始，也就说，<strong>4和5这个id就被跳过了，这也会导致出现自增主键的“空洞”</strong>。</p>
<h2 id="六-总结">六、总结</h2>
<h3 id="1自增主键保存和增长策略">1.自增主键保存和增长策略</h3>
<p>mysql 8.0 之前自增值保存在内存里，重启以后会获取表的最大值，在最大值基础上+1。8.0 之后可以通过 redo log 重做获得最新的自增值。</p>
<p><code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 分别表示自增值的初始值和自增的步长，当插入记录已经指明了自增值的时候，则会直接使用插入值，并且比较该值与最新初始值的大小，如果初始值小，则会累加步长直到比插入值大位置，反正就不改变初始值，下次插入还用它。</p>
<p>事务回滚不会回滚自增值，这样做是为了避免先进行的事务回滚，导致自增值回滚后小于最新数据自增id，下一次插入可能会出现主键冲突。</p>
<h3 id="2自增锁的加锁策略">2.自增锁的加锁策略</h3>
<p>mysql 针对自增锁有三种策略，根据<code>innodb_autoinc_lock_mode</code>设置：</p>
<ul>
<li>设置为 0 ：语句结束后释放自增锁；</li>
<li>设置为 1：普通 insert 申请后立刻释放； insert … select 这样批量插入的语句会等到执行完后才释放；</li>
<li>设置为 2：不分普通和批量插入，语句获取锁后都立刻释放锁；</li>
</ul>
<p>当有插入的 sql 和批量插入并发写的时候，可能会出现自增主键连续，但是 binlog 备份恢复出来的数据库跟原库不一致，这种情况最好选择 <code>statement + innodb_autoinc_lock_mode = 2</code></p>
<h3 id="3自增主键不一致的可能性">3.自增主键不一致的可能性</h3>
<p>mysql 针对确定数量的批量插入是可以直接申请一大批自增值的，但是针对不确定的插入，会每次插入都申请两倍于上一次插入申请的数量的自增主键。</p>
<p>综上，主键不自增有可能有两种情况：</p>
<ul>
<li>插入失败，事务回滚导致申请了的自增值没用上；</li>
<li>批量插入申请了大量主键，中途其他事务插入导致自增值被迫维持在最大值；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(十二)：order by</title>
    <url>/2020/11/15/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9Aorder%20by/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的16节order by相关内容的笔记</p>
</blockquote>
<h2 id="一-order-by-的执行流程">一、order by 的执行流程</h2>
<h3 id="1全字段排序">1.全字段排序</h3>
<p>假如此时有这么一张表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>现在要按姓名排序查询杭州1000个人的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>这条 sql 的执行流程如下：</p>
<ol type="1">
<li>在内存中初始化 sort_buffer，放入 city，name，age 三个字段</li>
<li>从 city 索引树找到 city = '杭州' 叶子节点存放的主键 id</li>
<li>回表根据主键 id 找到数据，取出全部字段放入 sort_buffer</li>
<li>重复上述过程，直到全部符合条件的数据都放入内存</li>
<li>在 sort_buffer 对数据按 name 进行排序</li>
<li>按照排序结果取前 1000 行返回</li>
</ol>
<p>因为先查了全部需要字段才排序，我们把这个叫做<strong>全字段排序</strong>。</p>
<p>不难看出，跟 join 有点像，排序也专门在内存里开辟了一块空间 sort_buffer。其中，<code>sort_buffer_size</code>参数的大小决定了 sort_buffer 的大小，<strong>如果 sort_buffer 放不下全部的字段，就必须在磁盘中创建临时文件辅助排序</strong>，这个排序使用的是归并排序，即先让分片变得有序，最后再总体进行排序。<strong>sort_buffer 越小，就会让临时文件越多</strong>。</p>
<h3 id="2rowid-排序">2.rowid 排序</h3>
<p>全字段排序的问题在于，如果需要查询返回的数据行数过多，那么就会导致少量的行数也会占满 sort_buffer 。</p>
<p>为此我们可以调整 <code>max_length_for_sort_data</code> 参数，即当单行的长度超过这个值，就会只在 sort_buffer 中放入主键 id 和需要排序的字段，其他的字段等到排完序再回表查询。</p>
<p>这个算法的执行流程如下：</p>
<ol type="1">
<li>在内存中初始化 sort_buffer，只放入 id，name 两个字段</li>
<li>从 city 索引树找到 city = '杭州' 叶子节点存放的主键 id</li>
<li>回表根据主键 id 找到数据，<strong>只取出 id 和 name 字段放入 sort_buffer</strong></li>
<li>重复上述过程，直到全部符合条件的数据都放入内存</li>
<li>在 sort_buffer 对数据按 name 进行排序</li>
<li>遍历排序结果，取前 1000 行，<strong>并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回</strong>。</li>
</ol>
<p>因为排序的时候只拿需要排序的字段，我们可以把这个叫做 rowid 排序</p>
<h2 id="二-优化">二、优化</h2>
<p>我们可以看到，rowid 排序只担心单行长度过大导致 sort_buffer 一次只能放入少量数据的时候使用，因为 rowid 排序完以后还需要回表进行一次查询，会造成磁盘读，因此不会是一个优先的选择。</p>
<p>这也是 mysql 优化查询过程中的原则，即<strong>能在内存里处理就尽量在内存里处理，避免回表</strong>。</p>
<p>排序是一个消耗颇大的操作，但是我们可以<strong>借助索引结构的有序性避免一些额外的排序过程</strong>。同样是上面的例子，我们建一个（city，name）联合索引，那么就可以保证在遍历过程中，只要 city=‘杭州’，那么 name 就一定是有序的。</p>
<p>这样一来，查询流程就是：</p>
<ul>
<li>从联合索引找到第一条city='杭州'的数据对应的主键</li>
<li>回表找到city，name，age三个数据加入数据集</li>
<li>重复上述过程直到查到第 1000 条记录，或者是不满足 city='杭州’条件时循环结束</li>
</ul>
<p>可以看到，由于索引已经确保的数据的有序性，索引就不需要加入内存中的临时表进行排序的过程了。</p>
<p>如果只查询 city 和 name，或者为联合索引再加上 age 字段，就能实现<strong>索引覆盖，甚至不需要回表</strong>。不过考虑到维护索引的代价，这个就需要根据业务取舍了。</p>
<h2 id="三-总结">三、总结</h2>
<p>mysql 的 order by 分全字段排序和 rowid 排序。</p>
<p>全字段排序需要先查出数据放入 sort_buffer ，然后在内存中排序后返回。如果数据超过了<code>sort_buffer_size</code>参数，就会在磁盘生成临时文件，辅助进行归并排序。</p>
<p>如果单行长度超过<code>max_length_for_sort_data</code> 参数，就会转为 rowid 排序。即只取 id 和排序字段放入内存，排序完后回表取出对应的数据。</p>
<p>通过索引结构天然有序，可以借助合适的索引避免额外的排序过程。如果实现了索引覆盖还可以避免回表。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(十)：count</title>
    <url>/2020/11/12/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9Acount/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的14节count相关内容的笔记</p>
</blockquote>
<h2 id="一-count的查询过程">一、count的查询过程</h2>
<p>count() 函数用于查询数据的数量，不同的引擎有不同的实现。</p>
<p>在 MySAM 引擎会专门记录表的总数；而在 innodb 中，由于 MVCC 的原因，在统计数量的时候需要一行一行的判断当前数据是否对查询的事务的可见的。此外，<code>show table status</code>的 Rows 字段也能获取表的总条数，但是这只是预估值，实际上并不准确。</p>
<p>因此，表的遍历是无法避免的，但是 innodb 也有针对此做出优化：</p>
<p>主键索引树的叶子节点是数据行，而普通索引树的叶子节点是主键，针对 count 操作遍历那颗树都是一样的，因此查询的时候回找到最小的那颗索引树进行遍历。</p>
<h2 id="二-计数操作的实现">二、计数操作的实现</h2>
<p>计数这个功能通过 redis 也可以实现，即在 redis 中设定一个值用于计数，但是在遇到异常停止服务后不免会遇到数据丢失的问题。</p>
<p>如果结合 mysql 来做，即 redis 更新数据后再变更数据库里的数据，读取的时候直接从 redis 读，这样虽然一定程度避免了数据丢失的问题，但是却有可能导致数据不一致。举个例子：</p>
<p>现在计数是5，我们要为计数+1</p>
<ul>
<li>先更新 redis 再更新 mysql：如果中间其他线程进行了一次查询，此时数据库是5，但是却查到了6</li>
<li>先更新 mysql 在更新 redis：如果中间其他线程进行了一次查询，此时数据库是6，但是却查到了5</li>
</ul>
<p>而如果使用 mysql，借助 innodb 可重复读下事务隔离的特性，我们就可以比较好的避免上述问题。</p>
<p>另外，值得一提的是，由于 innodb 的两阶段提交机制，<strong>更新获取的行锁会等到事务提交才释放，所以最好先插入再更新</strong>。</p>
<h2 id="三-不同-count-的区别">三、不同 count 的区别</h2>
<p>我们常见的 count 的用法一般有这三种：count(*)，count(1)，count(id)。下面就来描述一下这三种的区别。</p>
<p>count() 是一个聚合函数，他会判断括号中的条件是否为 null，不是就累加1。因此，对于 count(id) 这样涉及字段的操作，一般流程是这样的：</p>
<ul>
<li>遍历数据行</li>
<li>取出 id 字段的值并返回</li>
<li>判断 id 不为 null</li>
<li>计数+1</li>
</ul>
<p>而 count(1) 则是这样：</p>
<ul>
<li>遍历数据行</li>
<li>直接返回 1</li>
<li>判断 1 不为 null</li>
<li>计数+1</li>
</ul>
<p>count(*) 专门做了优化，流程与 count(1) 差不多。</p>
<p>因此，不难理解，由于需要去解析数据并且取出字段值，相对于不需要这些操作的 count(1) 和 count(*) 来说，速度是要慢一些的。而 count(字段) 相比起作为主键索引树上的 id，如果没有专门建索引，速度只会比 count(id) 更慢。</p>
<p>也就是说，他们速度是这样的：**count(字段) &lt; count(id) &lt;count(1) ≈ count(*)**</p>
<h2 id="四-总结">四、总结</h2>
<p>MySAM 会专门记录条数，查询的时候直接返回。innodb 由于 MVCC 机制， count 查询需要遍历数据以判断事务可见性。</p>
<p>redis 计数不能保证数据不丢失，redis + mysql 缓存和数据库数据可能会不一致，借助 innodb 的事务可以避免以上问题。</p>
<p>因为 innodb 的两阶段提交机制，最好先插入再更新。</p>
<p>查询速度：count(字段) &lt; count(id) &lt;count(1) ≈ count(*)</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（一）：队列</title>
    <url>/2020/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="一-什么是队列">一、什么是队列</h2>
<p>队列是一种特殊的<strong>线性表</strong>。</p>
<p>队列元素的进出遵循“<strong>先进先出</strong>”原则：即只允许在前端（front）也就是<strong>队头</strong>进行<strong>删除</strong>操作，而只能在后端（rear）也就是<strong>队尾</strong>进行<strong>插入</strong>操作。</p>
<p><img src="http://img.xiajibagao.top/20200614170712.png"></p>
<p>如图所示：</p>
<ul>
<li>队列的最大长度为MaxSize，最大下标为MaxSize-1</li>
<li>入队时队头下标不变而队尾下标改变，出队时则相反</li>
</ul>
<h2 id="二-模拟队列">二、模拟队列</h2>
<h3 id="1简单的使用数组模拟队列">1.简单的使用数组模拟队列：</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-11 16:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：用数组模拟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列最大长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line">    <span class="comment">//头指针，指向队头的元素的前一个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//尾指针，指向队尾的元素所在位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = size;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">        <span class="keyword">this</span>.front = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当头指针和尾指针相等时队列为空</span></span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当尾指针等于maxSize-1时队列满</span></span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 入队元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addQueue</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否已满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已满！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾指针后移</span></span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = item;</span><br><span class="line">        <span class="keyword">return</span> rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">quitQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//头指针后移</span></span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2解决内存溢出">2.解决“内存溢出”</h3>
<p>咋一眼看上去没问题，但是实际上随着入队和出队操作，头指针和尾指针会不断后移，最后都到达maxSize-1的位置，此时即使实际上有空闲空间也无法往里面添加数据了。</p>
<p>如果要解决这个问题，可以这样改进：</p>
<p>当入队的时候进行一次判断，如果尾指针已经移动到maxSize-1的位置，并且头指针不在-1位置，也就是队列仍然还有空位，就触发一次数据迁移。</p>
<p>打个比方，如果队列长度为6，现在头指针在3，尾指针在5，触发数据迁移后下标3-5的数据移动到0-2去，然后把头指针移到0，尾指针移到2。</p>
<p>基于这个逻辑，只需要改变一下<code>addQueue()</code>入队方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 入队元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addQueue</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断队列是已满还是只是尾指针到头</span></span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">        <span class="comment">//队列已满</span></span><br><span class="line">        <span class="keyword">if</span> (front == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已满！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//尾指针到头，触发数据迁移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; rear; i++) &#123;</span><br><span class="line">                arr[i - front] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移动指针</span></span><br><span class="line">            rear = rear - front;</span><br><span class="line">            front = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾指针后移</span></span><br><span class="line">    rear++;</span><br><span class="line">    arr[rear] = item;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然问题解决了，但是频繁的移动数据会消耗性能，为此仍需要加以改进：</p>
<p>当尾指针到头以后，如果头指针前还有空闲空间，尾指针应当能移动到头指针之前的位置，也就是队头元素出队了，空出的空间将可以放在队尾被元素入队。</p>
<p>打个比方，就相当于原本的队列是一条直线，走到头就没了，现在要把头和尾连接到一起，让它变成<strong>循环队列</strong>。</p>
<h2 id="三-循环队列">三、循环队列</h2>
<p><img src="http://img.xiajibagao.top/20200614170726.png" style="zoom: 67%;"></p>
<p>对于循环队列，有两个问题需要考虑，一个是下标，另一个是队空和队满的判断条件</p>
<h3 id="1环形队列的下标计算">1.环形队列的下标计算</h3>
<p>由于队头元素出队后空间即用于队尾元素入队，所以很可能出现长度5的队列，头指针在1，尾指针在4，这个时候在按照原来的思路用rear+1去入队就会下标越界，因此需要进行取余操作，也就是<code>（rear+1）% maxSize</code>，这样获取下标的问题就解决了。</p>
<h3 id="2环形队列的状态判断">2.环形队列的状态判断</h3>
<p>由于队列变为环形，所以front=rear即可能是队满也可能是队空，针对这个问题有两种思路：</p>
<p><strong>第一种</strong>是添加一个变量来记录队列中元素的数量，以区分front=rear时是队满还队空；</p>
<p><strong>第二种</strong>是在rear后预留一个空位，通过计算判断rear+1后是否等于front以判断队满还是队空；</p>
<p>这里先用第二种来实现一下：</p>
<ul>
<li><p>队空的时候就是<code>front=rear</code></p></li>
<li><p>队满的时候就是<code>rear+1=front</code>，考虑到多次操作后指针可能跑了不止一圈，rear和front可能会大于maxSize，故也需要进行取余操作，所以正确的公式是</p>
<p><code>(rear+1)%maxSize = front%maxSize</code></p></li>
</ul>
<h3 id="3代码实现">3.代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-14 16:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：环形队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CricleQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列最大长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line">    <span class="comment">//头指针，指向队头的元素的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//尾指针，指向队尾的元素的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CricleQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于需要在尾指针后空一位作为队满队空的区分，所以实际大小是maxSize+1</span></span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> Object[maxSize + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当头指针和尾指针相等时队列为空</span></span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//头尾指针+1并取余时相等时队列满</span></span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已满！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = item;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">quitQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object item = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（七）：迷宫回溯和八皇后问题</title>
    <url>/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%BF%B7%E5%AE%AB%E5%9B%9E%E6%BA%AF%E5%92%8C%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一-迷宫回溯问题">一、迷宫回溯问题</h2>
<h3 id="1问题">1.问题</h3>
<p>一个7*8的数组模拟迷宫，障碍用1表示，通路使用0表示，给定起点（1,1）和终点（6,5），要求给出起点到终点的通路</p>
<p><img src="http://img.xiajibagao.top/20200626224906.png"><img src="http://img.xiajibagao.top/20200626224701.png"></p>
<h3 id="2解题思路">2.解题思路</h3>
<ol type="1">
<li>首先，我们需要给程序一个寻向的基本策略，我们先假定寻向顺序为“下-右-上-左”，也就是说从起点出发，先往下走，往下走不通就往右.....以此类推</li>
<li>然后我们需要给走过的路一个标记，暂记为2</li>
<li>而当从一个方向走到一个只能原路返回的死胡同时，就给这段路标记为3</li>
<li>当抵达终点坐标（6,5）时程序结束</li>
</ol>
<h3 id="3代码实现">3.代码实现</h3>
<h4 id="31生成地图">3.1生成地图</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个二维数组,用于模拟8*7迷宫</span></span><br><span class="line"><span class="comment"> * 使用1表示不可通过的实心方块，0表示可通过砖块</span></span><br><span class="line"><span class="comment"> * （6,5）为默认终点，（1,1）为默认起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getMap()&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">    <span class="comment">//上下全置为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;<span class="number">7</span> ;i++)&#123;</span><br><span class="line">        map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右全置为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置挡板</span></span><br><span class="line">    map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出地图</span></span><br><span class="line">    System.out.println(<span class="string">&quot;地图的初始情况:&quot;</span>);</span><br><span class="line">    showMap(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示地图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMap</span><span class="params">(<span class="keyword">int</span>[][] map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">7</span>;j++)&#123;</span><br><span class="line">            System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="32-寻路逻辑的实现">3.2 寻路逻辑的实现</h4>
<p>对于这个寻路程序，我们可以看见，往四个方向走的过程实际上除了方向外动作上是一样的；而具体分析同一个方向，每走过一个坐标的动作也是一样的，我们对流程进行分析：</p>
<ol type="1">
<li>出发，先往下走，判断下一格有没有障碍（<code>int[x][y]==1</code>）</li>
<li>如果没有障碍，就继续往下走，然后重复步骤1到碰到障碍为止</li>
<li>如果有障碍，就按“下-右-上-左”的顺序，换个方向，然后重复步骤1到碰到障碍为止</li>
<li>如果找到了（6,5）就结束</li>
</ol>
<p>表现为代码实际上就是一个递归的过程：</p>
<ul>
<li>找路是方法体</li>
<li>找到了（6,5）或者死胡同是终止条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定起始点，根据地图找路</span></span><br><span class="line"><span class="comment"> * 使用2表示可以走通的路，使用3表示走过但是不通的路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 地图二维数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 起始点横坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y 起始点纵坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果走到了终点就终止</span></span><br><span class="line">    <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//只有为0的路才能通过</span></span><br><span class="line">        <span class="keyword">if</span> (map[y][x] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果该点可以走通就打上标记</span></span><br><span class="line">            map[y][x] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (findWay(map, x, y + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//向下递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, x + <span class="number">1</span>, y)) &#123;</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, x, y - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//向上递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, x - <span class="number">1</span>, y)) &#123;</span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//都走不通说明是死胡同</span></span><br><span class="line">                map[y][x] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不为0说明要么是死路要么是障碍</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="33-运行结果">3.3 运行结果</h4>
<p><img src="http://img.xiajibagao.top/20200626225137.png"><img src="http://img.xiajibagao.top/20200626225158.png"></p>
<p>将<code>findWay()</code>方法中的终止条件从<code>map[6][5] == 2</code>换成其他坐标即可更换终点位置，</p>
<p>棋盘大小和障碍物位置不影响<code>findWay()</code>方法寻路。</p>
<h2 id="二-八皇后问题">二、八皇后问题</h2>
<h3 id="1问题">1.问题</h3>
<p>皇后问题，一个古老而著名的问题，是<strong>回溯算法</strong>的典型案例。该问题由国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：</p>
<p>在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，求有多少种摆法？</p>
<p><img src="http://img.xiajibagao.top/20200626224753"></p>
<h3 id="2解题思路">2.解题思路</h3>
<ol type="1">
<li><p>首先，我们先使用一个长度为8数组来表示八皇后的摆放位置，<strong>数组下标+1即表示棋盘的第几行</strong>，<strong>数组下标对应的存放的数字+1即为棋盘的第几列</strong>。举个例子：</p>
<p>arr = {0,2,3,8,4,6,2,7}</p>
<p>其中，元素0下标为0，即表示<strong>第一行第一列</strong>；元素2下标为1，即表示<strong>第二行第三列</strong>......以此类推。</p></li>
<li><p>任意假设任意坐标分标为<code>(x1,y1)，(x2,y2)</code>，也就是用数组表示为<code>arr[x1]=y1，arr[x2]=y2</code>的两个皇后不允许在同一列，我们可以理解为：</p>
<p><code>arr[x1] != arr[x2]</code>;</p>
<p>而任意坐标的皇后不允许在同一斜线，即<code>(x2-x1)=(y2-y1)</code>，也就是斜率不应当相同，我们可以理解为：</p>
<p><code>Math.abs(x2-x1) != Math.abs(arr[x2]-arr[x1])</code></p>
<p>（注：<code>Math.abs()</code>为求绝对值方法）</p></li>
</ol>
<h3 id="3代码实现">3.代码实现</h3>
<h4 id="31-检查摆放位置的代码实现">3.1 检查摆放位置的代码实现</h4>
<p>在前面明确了如何用数组表示位置，以及如何检查皇后是否允许摆放后，我们有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示皇后位置的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查第n个皇后是否与前面摆放的皇后冲突</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查第n层之前的皇后位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// arr[i] == arr[n] 检查是否同一列</span></span><br><span class="line">        <span class="comment">// Math.abs(n - i) == Math.abs(arr[n] - arr[i]) 检查是否同一斜线</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] == arr[n] ||</span><br><span class="line">            Math.abs(n - i) == Math.abs(arr[n] - arr[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="32-完整代码">3.2 完整代码</h4>
<p>接着我们需要考虑如何使用递归方法来做到以下效果：</p>
<p>使用一个方法遍历第n行的每一列，检查每一列是否可以放置皇后：</p>
<ol type="1">
<li>如果可以放置皇后，将位置出入arr[n]中，然后递归调用自己，传入n+1开始遍历下一行.....以此类推</li>
<li>如果不可以放置皇后，就跳过该列检查下一列，如果可以就重复步骤1</li>
<li>若n行中全部位置都不合适，则结束本层返回上一层n-1层，重复步骤1</li>
<li>如果最后n=8，即八个皇后全部放置完毕，记一次完成摆放，然后结束递归返回第一层，继续检查第一层的下一列</li>
</ol>
<p>最终代码实现结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-26 20:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：八皇后问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueens</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightQueens eightQueens = <span class="keyword">new</span> EightQueens();</span><br><span class="line">        eightQueens.set(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共有摆法：&quot;</span> + eightQueens.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录八皇后有几种摆法</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示皇后位置的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 摆放皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第几个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果放置好了第8个皇后</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">8</span>)&#123;</span><br><span class="line">            show();</span><br><span class="line">            <span class="comment">//记录一种摆放方式</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//回到第一层继续递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历第n行的每一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//将该皇后放置在第n行第i列</span></span><br><span class="line">            arr[n] = i;</span><br><span class="line">            <span class="comment">//检查放置位置是否合适</span></span><br><span class="line">            <span class="keyword">if</span> (check(n))&#123;</span><br><span class="line">                <span class="comment">//如果位置合适，就递归找下一个（n+1）皇后的摆放位置</span></span><br><span class="line">                set(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果位置不合适，就跳过这一列检查下一列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查第n个皇后是否与前面摆放的皇后冲突</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查第n层之前的皇后位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// arr[i] == arr[n] 检查是否同一列</span></span><br><span class="line">            <span class="comment">// Math.abs(n - i) == Math.abs(arr[n] - arr[i]) 检查是否同一斜线</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[n] ||</span><br><span class="line">                Math.abs(n - i) == Math.abs(arr[n] - arr[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示某一摆法中八皇后的摆放位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（三）：双向链表</title>
    <url>/2020/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8F%8C%E5%90%91%E8%BF%9E%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一-双向链表">一、双向链表</h2>
<p>双向链表与单链表基本相似，但是最大的区别在于双向链表在节点中除了指向下一节点的next指针外，<strong>还有指向前一节点的prev指针</strong>，这使得双向链表在可以在任意节点<strong>从头尾两个方向进行遍历</strong>，是“双向”的。</p>
<p>和单链表相比，双向链表在删除和查询等方面明显在操作上更具有灵活性，但是会消耗更多的内存，需要根据使用条件进行取舍。</p>
<p>java中的LinkedHashMap的本质即是一个双向链表。</p>
<p><img src="http://img.xiajibagao.top/20200621114143.png"></p>
<h2 id="二-双向链表的简单实现">二、双向链表的简单实现</h2>
<p>修改原来的Node类，在里面添加一个新成员变量<code>Node prev</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点序号</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一节点</span></span><br><span class="line">    Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> num, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;num=&quot;</span> + num +</span><br><span class="line">            <span class="string">&quot;, data=&quot;</span> + data +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1添加">1.添加</h3>
<p>添加与单向链表代码逻辑一样，但是新节点在添加时需要修改prev指针指向原来的尾节点。</p>
<p>举个例子，对于无排序插入，原本有节点A，现在要插入一个B：</p>
<ol type="1">
<li>找到A，然后让<code>A.next</code>指向B</li>
<li>让<code>B.prev</code>指向A</li>
</ol>
<p>而对于排序插入，就是原有节点A，C，要在中间插入B：</p>
<ol type="1">
<li>找到A，让<code>B.prev</code>指向A</li>
<li>让<code>B.next</code>指向<code>A.next</code>，也就是让B的next指向C</li>
<li>让<code>A.next.prev</code>指向B，也就是让C的prev指向B</li>
<li>让<code>A.next</code>指向B</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点到链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是尾节点就继续遍历下一个节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将尾节点指向即将插入的新节点</span></span><br><span class="line">    temp.next = node;</span><br><span class="line">    node.prev = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按顺序添加节点到链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表到底了就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            node.prev = temp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num &gt; node.num)&#123;</span><br><span class="line">            <span class="comment">//如果后一节点比当新节点大，就插入当前节点</span></span><br><span class="line">            node.prev = temp;</span><br><span class="line">            node.next = temp.next;</span><br><span class="line"></span><br><span class="line">            temp.next.prev = node;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num == node.num)&#123;</span><br><span class="line">            <span class="comment">//如果后一节点等于新节点，抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;插入节点与已有节点序号重复！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果后一节点比当前节点小，就继续遍历</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2删除">2.删除</h3>
<p>由于相对单链表，双向链表的节点可以自己找到上一节点，所以删除的时候可以直接找到要删除的节点进行操作。</p>
<p>举个例子，假设有节点A，B，C，现在要删除B：</p>
<ol type="1">
<li>找到B，让<code>B.prev.next=B.next</code>，也就是让A的next指向C</li>
<li>让<code>B.next.prev=B.prev</code>，也就是让C的prev指向A</li>
</ol>
<p>如果要删除的节点已经是尾节点了，那就跟单链表一样了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要删除的节点编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表到底了</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了待删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">            <span class="comment">//判断待删除节点是否为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.prev.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.prev.next = temp.next;</span><br><span class="line">                temp.next.prev = temp.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续遍历下一节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3修改查询与单链表一致">3.修改，查询（与单链表一致）</h3>
<p>由于修改和查询与单链表基本一致，这里就不在赘述了，直接放代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp.toString());</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据序号获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要获取的节点序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要更新的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取要更新的节点序号</span></span><br><span class="line">    <span class="keyword">int</span> nodeNum = node.num;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果已经遍历完链表</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + temp.num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了该节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.num == nodeNum) &#123;</span><br><span class="line">            temp.data = node.data;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续遍历下一节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（九）：查找</title>
    <url>/2020/07/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="什么是查找">什么是查找？</h2>
<p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。</p>
<p>定义：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>
<p>分类：</p>
<ol type="1">
<li>静态查找和动态查找
<ul>
<li>静态查找：不对表的数据元素和结构进行任何改变。</li>
<li>动态查找：在查找过程同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</li>
</ul></li>
<li>无序查找和有序查找。
<ul>
<li>无序查找：被查找数列有序无序均可</li>
<li>有序查找：被查找数列必须为有序数列。</li>
</ul></li>
</ol>
<h2 id="一-线性查找">一、线性查找</h2>
<p>遍历数组并且依次对比值，相等时返回下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在给定数组中线性查找指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-二分查找">二、二分查找</h2>
<h3 id="1思路分析">1.思路分析</h3>
<ul>
<li>要查找数target，首先要在给定的有序数组中找到中间位置的数，定义为arr[mid]</li>
<li>比较target与arr[mid]大小：
<ol type="1">
<li>target &lt; arr[mid]：说明target元素的下标小于mid，向右查找</li>
<li>target &gt; arr[mid]：说明target元素的下标大于mid，向左查找</li>
<li>target = arr[mid]：即找到了</li>
</ol></li>
<li>递归重复以上步骤直到找到或者找不到元素为止</li>
</ul>
<h3 id="2代码实现">2.代码实现</h3>
<p>查找不含有重复数字的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找不重复目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 查找的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 查找目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于每次遍历右指针总是右移，左指针总是右移</span></span><br><span class="line">    <span class="comment">//所以当如果查找的是一个不存在的数时，即右指针小于左指针</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标比中位数小，向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">        <span class="comment">//如果目标表中位数打，向右递归</span></span><br><span class="line">        <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//中位数即为目标</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找含有重复数字的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找重复目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 查找的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 查找目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; targets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于每次遍历右指针总是右移，左指针总是右移</span></span><br><span class="line">    <span class="comment">//所以当如果查找的是一个不存在的数时，即右指针小于左指针</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left) &#123;</span><br><span class="line">        <span class="keyword">return</span> targets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标比中位数小，向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">        <span class="comment">//如果目标表中位数打，向右递归</span></span><br><span class="line">        <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果找到了</span></span><br><span class="line">        <span class="comment">//向左查找相同的数</span></span><br><span class="line">        <span class="keyword">int</span> tempIndex = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//到第一个数就不再继续找</span></span><br><span class="line">            <span class="keyword">if</span>(tempIndex &lt; <span class="number">0</span> || arr[tempIndex] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            targets.add(tempIndex);</span><br><span class="line">            tempIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放入中间值</span></span><br><span class="line">        targets.add(mid);</span><br><span class="line">        <span class="comment">//向右查找相同的数</span></span><br><span class="line">        tempIndex = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//到最后一个数就不再继续找</span></span><br><span class="line">            <span class="keyword">if</span>(tempIndex &gt; arr.length - <span class="number">1</span> || arr[tempIndex] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            targets.add(tempIndex);</span><br><span class="line">            tempIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-插值查找">三、插值查找</h2>
<p>插值查找与二分查找基本一致，但是不一样的是不再像二分那样总是将数组均匀分为两份，而是通过公式将分割的中间点自适应定在目标元素附近。</p>
<p><img src="http://img.xiajibagao.top/20200701214402.png"></p>
<p>即将原先的mid计算方式换成这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将原先的1/2换为(key-a[low])/(a[high]-a[low])</span></span><br><span class="line">mid=low+(high-low)*(key-a[low])/(a[high]-a[low])</span><br></pre></td></tr></table></figure>
<p>由于mid的计算方式改为由查找数动态计算，所以为了防止取arr[mid]时下标越界，我们需要新的边界条件：</p>
<ul>
<li>目标target不能小于有序数组最小数，即arr[0]</li>
<li>目标target不能大于于有序数组最大数，即arr[arr.length]</li>
</ul>
<p>所以代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插值查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 查找的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 查找目标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; targets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询大小目标必须在数组范围内，防止arr[mid]时下标越界</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; left || target &gt; arr[arr.length - <span class="number">1</span>] || target &lt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> targets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) * (target - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">    <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标比中位数小，向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (midVal &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &lt; target) &#123;</span><br><span class="line">        <span class="comment">//如果目标表中位数打，向右递归</span></span><br><span class="line">        <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果找到了</span></span><br><span class="line">        <span class="comment">//向左查找相同的数</span></span><br><span class="line">        <span class="keyword">int</span> tempIndex = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//到第一个数就不再继续找</span></span><br><span class="line">            <span class="keyword">if</span>(tempIndex &lt; <span class="number">0</span> || arr[tempIndex] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            targets.add(tempIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放入中间值</span></span><br><span class="line">        targets.add(mid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右查找相同的数</span></span><br><span class="line">        tempIndex = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//到最后一个数就不再继续找</span></span><br><span class="line">            <span class="keyword">if</span>(tempIndex &gt; arr.length - <span class="number">1</span> || arr[tempIndex] != target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            targets.add(tempIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-斐波那契查找">四、斐波那契查找</h2>
<p>斐波那契查找跟差值查找一样从中位数mid上下文章，但是又有不同之处，要想理解斐波那契查找的思路，需要先了解一下斐波那契数列：</p>
<p>举个例子， {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 就是一个斐波那契数列，他有两个特点：</p>
<ul>
<li>F[k] = F[k-1] + F[k-2]</li>
<li>相邻数之比无限接近黄金分割值0.618</li>
</ul>
<h3 id="1思路分析">1.思路分析</h3>
<ul>
<li><p>由于F[k] = F[k-1] + F[k-2]，我们能推出（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1，也就是说：</p>
<p>若数组的长度F[k]-1，则每一数组可以被分成<strong>长度为F[k-1]-1和F[k-2]-1的两段，两段的平分点mid即有mid=low+F[k-1]-1</strong></p>
<p><img src="http://img.xiajibagao.top/20200701214406.png"></p></li>
<li><p>但数组长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可</p>
<p>举个例子：延长{1,8, 10, 89, 1000, 1234}，得到{1,8, 10, 89, 1000, 1234, 1234, 1234}，</p></li>
</ul>
<h3 id="2代码实现">2.代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAXSIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得一个斐波那契数列，用于提供数组分割点位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getFibonacci() &#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[MAXSIZE];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXSIZE; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组第一位和最后一位下标</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//斐波那契数列下标</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生成的斐波那契数列</span></span><br><span class="line">    <span class="keyword">int</span>[] f = getFibonacci();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中间值</span></span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取离arr.length-1最近的分割点下标</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数组长度延长到f[k]</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">    <span class="comment">//将延长的那部分用原数组的最后一位填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = right + <span class="number">1</span>; i &lt; f[k]; i++) &#123;</span><br><span class="line">        temp[i] = arr[right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找目标数字</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//获取分割数组的中间点下标</span></span><br><span class="line">        mid = left + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果元素在分割点的左边</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; temp[mid]) &#123;</span><br><span class="line">            <span class="comment">//向分割点左边查找</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//中间点右移到前一个分割点</span></span><br><span class="line">            k--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; temp[mid]) &#123;</span><br><span class="line">            <span class="comment">//向分割点右边查找</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            k-=<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到要查找的数字</span></span><br><span class="line">            <span class="comment">//判断要返回的下标</span></span><br><span class="line">            <span class="keyword">if</span> (mid &lt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（五）：递归和栈实现简单计算器</title>
    <url>/2020/06/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="一-计算器的计算思路分析">一、计算器的计算思路分析</h2>
<p>我们以计算<code>3+8*2-6</code>这个算式为例：</p>
<ol type="1">
<li><p>将算式解析为数字和符号：<code>3，+，8，*，2，-，6</code></p></li>
<li><p>准备一个用于存放数字的数字栈numStack，还有一个存放运算符号的符号栈symbolStack，下面分别简称栈n和栈s</p></li>
<li><p>按顺序扫描解析后的数字和符号，</p>
<p>如果是数字，就直接入数栈n，</p>
<p>如果是符号，且如果<strong>符号栈s为空</strong>，就直接入栈，</p>
<p>如果s不为空，就需要比较栈顶符号与当前符号的优先级，再分两种情况：</p>
<ul>
<li>如果<strong>栈顶符号优先级比当前符号大</strong>，就从栈n弹出两个数字，从栈s弹出一个符号，然后进行运算，最后得出的结果再入栈n</li>
<li>如果<strong>栈顶符号优先级小于或等于当前符号</strong>，就将符号入栈s</li>
</ul></li>
</ol>
<p><img src="http://img.xiajibagao.top/20200625203947.png"></p>
<p>按照这个流程，扫描完后栈n会留下<code>3，16，6</code>这三个数，栈s会留下<code>+，-</code>这两个 符号，</p>
<p>然后按顺序，栈n弹出两个数字，栈s弹出一个符号，然后运算得到结果后再入栈n，重复此步骤，最后栈s清空，栈n只剩一个数字，即为运算结果。</p>
<h2 id="二-代码实现">二、代码实现</h2>
<p>我们先来实现一个加减乘除的数计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-25 16:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：使用栈实现一个计算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数字栈</span></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//符号栈</span></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;String&gt; symbolStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据计算公式运算并输出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression 计算公式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用于多位数拼接</span></span><br><span class="line">        String numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串里的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length() ; i++) &#123;</span><br><span class="line">            String ch = expression.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//检验是否数字</span></span><br><span class="line">            <span class="keyword">if</span> (ch.matches(<span class="string">&quot;[0-9]&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果该数字已经是最后一个字符就直接存入数字栈</span></span><br><span class="line">                <span class="keyword">if</span> (i == expression.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.valueOf(ch));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是字符串最后一个字符，就拼接入字符串</span></span><br><span class="line">                    numStr += ch;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是符号，就把之前拼接的多位数存入数字栈</span></span><br><span class="line">            numStack.push(Integer.valueOf(numStr));</span><br><span class="line">            numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果是符号就比较符号优先级</span></span><br><span class="line">            <span class="keyword">if</span> (isFrist(ch))&#123;</span><br><span class="line">                <span class="comment">//如果当前符号与符号栈栈栈顶符号优先或者平级就入栈</span></span><br><span class="line">                symbolStack.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则就从栈中取两数字和一个符号先计算</span></span><br><span class="line">                <span class="keyword">int</span> num = getCalculateResult();</span><br><span class="line">                <span class="comment">//再把计算结果入数栈</span></span><br><span class="line">                numStack.push(num);</span><br><span class="line">                <span class="comment">//再把当前符号入栈</span></span><br><span class="line">                symbolStack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当符号栈为空时，说明计算完成，此时数字栈唯一数字即为结果</span></span><br><span class="line">        <span class="keyword">while</span> (!symbolStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = getCalculateResult();</span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结束！结果为：&quot;</span> + numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据数字和符号运算并返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num1 后出栈的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num2 先出栈的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol 运算符号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculateResult</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据符号进行运算</span></span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = num1 - num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;只支持加减乘除运算！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(num1 + symbol + num2 + <span class="string">&quot;=&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接从数栈取两数字，符号栈取一符号进行计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculateResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = numStack.pop();</span><br><span class="line">        <span class="keyword">int</span> num2 = numStack.pop();</span><br><span class="line">        String symbol = symbolStack.pop();</span><br><span class="line">        <span class="keyword">int</span> result = getCalculateResult(num2, num1, symbol);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较符号和当前符号栈顶符号的优先级。</span></span><br><span class="line"><span class="comment">     * 如果当前符号优先级小于符号栈栈顶符号的优先级，就返回false，否则返回true</span></span><br><span class="line"><span class="comment">     * 如果当前符号栈为空，直接返回true</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFrist</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前符号栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (symbolStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出并放回栈顶符号</span></span><br><span class="line">        String stackSymbol = symbolStack.pop();</span><br><span class="line">        symbolStack.push(stackSymbol);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈顶符号的优先级</span></span><br><span class="line">        <span class="keyword">int</span> stackSymbolGrade = getSymbolGrade(stackSymbol);</span><br><span class="line">        <span class="comment">//当前符号的优先级</span></span><br><span class="line">        <span class="keyword">int</span> symbolgrade = getSymbolGrade(symbol);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> symbolgrade &gt; stackSymbolGrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据符号返回符号的优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加减返回0，乘除返回1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSymbolGrade</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> grade;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(symbol) || <span class="string">&quot;-&quot;</span>.equals(symbol)) &#123;</span><br><span class="line">            grade = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(symbol) || <span class="string">&quot;/&quot;</span>.equals(symbol)) &#123;</span><br><span class="line">            grade = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不支持的操作符类型：&quot;</span> + symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在输入运算公式调用<code>calculate()</code>函数即可得出结果，但是目前这个计算器仍然还有致命问题没有解决：</p>
<p>当连续乘除时无法识别，比如：<code>2*3*3+3</code>会被识别为<code>(2*3)*(3+3)</code>，</p>
<p>这个问题下面我们将用递归来解决。</p>
<h2 id="三-使用递归解决连乘问题">三.、使用递归解决连乘问题</h2>
<p>我们分析主函数<code>calculate()</code>中关于比较符号的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是符号就比较符号优先级</span></span><br><span class="line"><span class="keyword">if</span> (isFrist(ch))&#123;</span><br><span class="line">    <span class="comment">//如果当前符号与符号栈栈栈顶符号优先或者平级就入栈</span></span><br><span class="line">    symbolStack.push(ch);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//否则就从栈中取两数字和一个符号先计算</span></span><br><span class="line">    <span class="keyword">int</span> num = getCalculateResult();</span><br><span class="line">    <span class="comment">//再把计算结果入数栈</span></span><br><span class="line">    numStack.push(num);</span><br><span class="line">    <span class="comment">//再把当前符号入栈</span></span><br><span class="line">    symbolStack.push(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以知道主要问题在于运算符的比较只能进行一次，实际上可能会有连需乘除的情况。</p>
<p>举个例子，要计算<code>1*2*3*4+3</code>，+入栈前，数字栈有1234，符号栈有三个*：</p>
<ol type="1">
<li>加号入栈前，取出第一个乘号比较，发现乘法优先，于是取出4和3乘后得12，把12入数栈</li>
<li>此时数栈有1，2和12，符号栈有两个*，然后<strong>重复步骤1过程</strong>，再把乘号取出一个进行比较......</li>
<li>步骤2结束后数字栈有1和24，符号栈还有一个*，于是再重<strong>复步骤1过程</strong>.....</li>
<li>最终，符号栈没有比+更优先的符号了，于是加号入栈</li>
</ol>
<p>以此类推，无论有多少个乘号，实际上的代码都是<strong>重复执行步骤1</strong>，直到<strong>满足进入步骤4的条件时结束</strong>。</p>
<p>如果我们把步骤1提取成一个函数，让他执行结束后再调用自己，有几个乘号就让他自己调用几次，那么等到满足步骤4的条件时，也就说明套娃到底了，这时就可以结束调用返回结果。</p>
<p>按照这个思路，我们把原先的代码提取成一个递归方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归解决连乘或连除问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">compareAndOperation</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是符号就比较符号优先级</span></span><br><span class="line">    <span class="keyword">if</span> (isFrist(symbol))&#123;</span><br><span class="line">        <span class="comment">//如果当前符号与符号栈栈栈顶符号优先或者平级就入栈</span></span><br><span class="line">        symbolStack.push(symbol);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则就从栈中取两数字和一个符号先计算</span></span><br><span class="line">        <span class="keyword">int</span> num = getCalculateResult();</span><br><span class="line">        <span class="comment">//再把计算结果入数栈</span></span><br><span class="line">        numStack.push(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归，继续比较上一个是否与当前符号的优先级</span></span><br><span class="line">        compareAndOperation(symbol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就能计算连续乘除的情况了！</p>
<h2 id="四完整代码">四.完整代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-25 16:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：使用栈实现一个计算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数字栈</span></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//符号栈</span></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;String&gt; symbolStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据计算公式运算并输出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression 计算公式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用于多位数拼接</span></span><br><span class="line">        String numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字符串里的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length() ; i++) &#123;</span><br><span class="line">            String ch = expression.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//检验是否数字</span></span><br><span class="line">            <span class="keyword">if</span> (ch.matches(<span class="string">&quot;[0-9]&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果该数字已经是最后一个字符就直接存入数字栈</span></span><br><span class="line">                <span class="keyword">if</span> (i == expression.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.valueOf(ch));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是字符串最后一个字符，就拼接入字符串</span></span><br><span class="line">                    numStr += ch;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是符号，就把之前拼接的多位数存入数字栈</span></span><br><span class="line">            numStack.push(Integer.valueOf(numStr));</span><br><span class="line">            numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是符号就比较符号优先级并进行计算和入栈操作</span></span><br><span class="line">            compareAndOperation(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当符号栈为空时，说明计算完成，此时数字栈唯一数字即为结果</span></span><br><span class="line">        <span class="keyword">while</span> (!symbolStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = getCalculateResult();</span><br><span class="line">            numStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结束！结果为：&quot;</span> + numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用递归解决连乘或连除问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">compareAndOperation</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是符号就比较符号优先级</span></span><br><span class="line">        <span class="keyword">if</span> (isFrist(symbol))&#123;</span><br><span class="line">            <span class="comment">//如果当前符号与符号栈栈栈顶符号优先或者平级就入栈</span></span><br><span class="line">            symbolStack.push(symbol);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就从栈中取两数字和一个符号先计算</span></span><br><span class="line">            <span class="keyword">int</span> num = getCalculateResult();</span><br><span class="line">            <span class="comment">//再把计算结果入数栈</span></span><br><span class="line">            numStack.push(num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//递归，继续比较上一个是否与当前符号的优先级</span></span><br><span class="line">            compareAndOperation(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据数字和符号运算并返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num1 后出栈的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num2 先出栈的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol 运算符号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculateResult</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据符号进行运算</span></span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = num1 - num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;只支持加减乘除运算！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(num1 + symbol + num2 + <span class="string">&quot;=&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接从数栈取两数字，符号栈取一符号进行计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalculateResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = numStack.pop();</span><br><span class="line">        <span class="keyword">int</span> num2 = numStack.pop();</span><br><span class="line">        String symbol = symbolStack.pop();</span><br><span class="line">        <span class="keyword">int</span> result = getCalculateResult(num2, num1, symbol);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较符号和当前符号栈顶符号的优先级。</span></span><br><span class="line"><span class="comment">     * 如果当前符号优先级小于符号栈栈顶符号的优先级，就返回false，否则返回true</span></span><br><span class="line"><span class="comment">     * 如果当前符号栈为空，直接返回true</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFrist</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前符号栈是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (symbolStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出并放回栈顶符号</span></span><br><span class="line">        String stackSymbol = symbolStack.pop();</span><br><span class="line">        symbolStack.push(stackSymbol);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈顶符号的优先级</span></span><br><span class="line">        <span class="keyword">int</span> stackSymbolGrade = getSymbolGrade(stackSymbol);</span><br><span class="line">        <span class="comment">//当前符号的优先级</span></span><br><span class="line">        <span class="keyword">int</span> symbolgrade = getSymbolGrade(symbol);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> symbolgrade &gt; stackSymbolGrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据符号返回符号的优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加减返回0，乘除返回1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSymbolGrade</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> grade;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(symbol) || <span class="string">&quot;-&quot;</span>.equals(symbol)) &#123;</span><br><span class="line">            grade = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(symbol) || <span class="string">&quot;/&quot;</span>.equals(symbol)) &#123;</span><br><span class="line">            grade = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不支持的操作符类型：&quot;</span> + symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（二）：单链表</title>
    <url>/2020/06/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一-什么是链表">一、什么是链表</h2>
<p>链表是一种数据结构，跟数组不同，链表<strong>不需要连续的内存空间</strong>，而是<strong>通过指针将零散的内存块连接</strong>起来。</p>
<p>因此，链表的查找需要通过节点按顺序遍历，而增加与删除通过只需要操作指针指向，这也造成了相比数组，链表的<strong>查找性能消耗大</strong>而<strong>增加和删除消耗小</strong>的特点。</p>
<p>链表由节点组成，一般每个节点最少包含用于储存数据的data区和用于指向下一个节点的指针next，有的链表可能会有头结点或尾结点用于存储链表长度等信息。</p>
<p><img src="http://img.xiajibagao.top/20200620142817.png"></p>
<h2 id="二-链表的简单实现">二、链表的简单实现</h2>
<p>先来实现一个简单的节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点序号</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> num, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;num=&quot;</span> + num +</span><br><span class="line">            <span class="string">&quot;, data=&quot;</span> + data +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1插入节点">1.插入节点</h3>
<h4 id="11不按照排序的插入">1.1不按照排序的插入</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line">	<span class="comment">//默认初始化一个头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="string">&quot;我是头结点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是尾节点就继续遍历下一个节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将尾节点指向即将插入的新节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12按照排序插入">1.2按照排序插入</h4>
<p><img src="http://img.xiajibagao.top/20200620142813.png"></p>
<p>要想按顺序插入节点，需要确定节点的位置，也就是确定新节点的大小，以图为例：</p>
<p>遍历链表，我们把遍历到的节点叫A，A之前的节点叫A-1，A之后的节点叫A+1，要插入的节点叫B，有以下几种情况：</p>
<ol type="1">
<li>当A的序号<strong>大于</strong>B时，就把B插到A前，也就是原本的A和A-1之间</li>
<li>当A的序号<strong>等于</strong>B时，抛出异常禁止插入</li>
<li>当A的序号<strong>小于</strong>B时，就跳过这个节点，继续遍历，然后对比A+1和B的大小</li>
<li><strong>当A就是链表最后一个节点时，A还是小于B</strong>，那就直接让B插到A后，变成链表的尾节点</li>
</ol>
<p>按这个思路，我们在原来的类里新增一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按顺序添加节点到链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表到底了就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num &gt; node.num)&#123;</span><br><span class="line">            <span class="comment">//如果当前节点比当要插入的节点大，就把新节点插到当前节点之前</span></span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num == node.num)&#123;</span><br><span class="line">            <span class="comment">//如果有节点序号和要插入的节点重复就抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;插入节点与已有节点序号重复！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前节点比当要插入的节点小，就继续遍历</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2查找节点">2.查找节点</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 展示链表全部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp.toString());</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据序号获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要获取的节点序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是要获取的节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3修改节点">3.修改节点</h3>
<p>修改节点与按顺序插入逻辑相似，需要先遍历并找到要修改的节点，然后用新节点去替换旧节点，或者干脆直接修改节点内的信息</p>
<p><img src="http://img.xiajibagao.top/20200620142808.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要更新的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取要更新的节点序号</span></span><br><span class="line">    <span class="keyword">int</span> nodeNum = node.num;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果已经遍历完链表</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + temp.num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了该节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.num == nodeNum) &#123;</span><br><span class="line">            temp.data = node.data;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续遍历下一节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4删除节点">4.删除节点</h3>
<p><img src="http://img.xiajibagao.top/20200620142800.png"></p>
<p>因为在单向链表中，节点无法知道自己前一个节点的情况，以图为例：</p>
<p>如果我们想要删除节点A，那么就要找到A的前一个节点A-1，根据是否存在A后的节点A+1有以下几种情况：</p>
<ol type="1">
<li><p>A节点就是链表尾节点，此时只需让A-1节点的next指向null即可</p>
<p><code>nodeA-1.next = null</code></p></li>
<li><p>A节点后有A+1，此时让A-1节点指向A+1节点</p>
<p><code>nodeA-1.next = nodeA-1.next.next</code></p></li>
</ol>
<p>按这个思路，在类里新加一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 要删除的节点编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表到底了</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了待删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next.num == num) &#123;</span><br><span class="line">            <span class="comment">//判断待删除节点是否为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续遍历下一节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-完整实现代码">三、完整实现代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="string">&quot;我是头结点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是尾节点就继续遍历下一个节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将尾节点指向即将插入的新节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据序号获取节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要获取的节点序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按顺序添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果链表到底了就直接插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num &gt; node.num)&#123;</span><br><span class="line">                <span class="comment">//如果后一节点比当新节点大，就插入当前节点</span></span><br><span class="line">                node.next = temp.next;</span><br><span class="line">                temp.next = node;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.num == node.num)&#123;</span><br><span class="line">                <span class="comment">//如果后一节点等于新节点，抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;插入节点与已有节点序号重复！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果后一节点比当前节点小，就继续遍历</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要更新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取要更新的节点序号</span></span><br><span class="line">        <span class="keyword">int</span> nodeNum = node.num;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果已经遍历完链表</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + temp.num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了该节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.num == nodeNum) &#123;</span><br><span class="line">                temp.data = node.data;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要删除的节点编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果链表到底了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了待删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.num == num) &#123;</span><br><span class="line">                <span class="comment">//判断待删除节点是否为尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.next = temp.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-环形链表">四、环形链表</h2>
<p>循环链表是一种特殊单链表，他跟单链表的区别在于尾节点的尾指针指向了链表的头结点，也就是相当于将链表连接成了一个环形。</p>
<p>环形链表可以用于处理能描述为环形的数据，典型的比如约瑟夫问题。</p>
<p><img src="http://img.xiajibagao.top/20200623155928.png"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十一）：二叉树</title>
    <url>/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一-什么是二叉树">一、什么是二叉树</h2>
<h3 id="1概述">1.概述</h3>
<p>首先，需要了解树这种数据结构的定义：</p>
<blockquote>
<p>树：是一类重要的非线性数据结构，是以分支关系定义的层次结构。每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树</p>
</blockquote>
<p><img src="http://img.xiajibagao.top/20200711203743.PNG"></p>
<p>树的结构类似现实中的树，一个父节点有若干子节点，而一个子节点又有若干子节点，以此类推。</p>
<h3 id="2名词解释">2.名词解释</h3>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>根节点</td>
<td>树的顶端结点</td>
</tr>
<tr class="even">
<td>父节点</td>
<td>若一个节点含有子节点，则这个节点称为其子节点的父节点</td>
</tr>
<tr class="odd">
<td>子节点</td>
<td>具有相同父节点的节点</td>
</tr>
<tr class="even">
<td>兄弟节点</td>
<td>彼此都拥有同一个父节点的节点</td>
</tr>
<tr class="odd">
<td>叶子节点</td>
<td>即没有子节点的节点</td>
</tr>
<tr class="even">
<td>节点的权</td>
<td>即节点值</td>
</tr>
<tr class="odd">
<td>路节点的度</td>
<td>一个节点含有的子树的个数</td>
</tr>
<tr class="even">
<td>树的度</td>
<td>一棵树中，最大的节点的度称为树的度</td>
</tr>
<tr class="odd">
<td>深度</td>
<td><strong>根结点到这个结点</strong>所经历的边的个数</td>
</tr>
<tr class="even">
<td>层数</td>
<td>该节点的深度+1</td>
</tr>
<tr class="odd">
<td>高度</td>
<td><strong>结点到叶子结点</strong>的最长路径所经历的边的个数</td>
</tr>
<tr class="even">
<td>树高度</td>
<td>即根节点的高度</td>
</tr>
<tr class="odd">
<td>森林</td>
<td>由m（m&gt;=0）棵互不相交的树的集合称为森林</td>
</tr>
</tbody>
</table>
<h3 id="3二叉树">3.二叉树</h3>
<p>二叉树就是每个节点最多只有两颗子树的树：</p>
<p><img src="http://img.xiajibagao.top/二叉树.PNG"></p>
<p>对于二叉树有：</p>
<ul>
<li><p>满二叉树：所有的子节点都在最后一层，且节点总数与层数有<code>节点总数=2^n-1</code></p>
<p><img src="http://img.xiajibagao.top/满二叉树.png"></p></li>
<li><p>完全二叉树：从根节点到倒数第二层都符合满二叉树，但是最后一层节点不完全充填，叶子结点都靠左对齐</p>
<p><img src="http://img.xiajibagao.top/完全二叉树.png"></p></li>
</ul>
<h2 id="二-二叉树的遍历">二、二叉树的遍历</h2>
<p>二叉树遍历分为三种：</p>
<ul>
<li>前序遍历: 先输出父节点，再遍历左子树和右子树</li>
<li>中序遍历: 先遍历左子树，再输出父节点，再遍历右子树</li>
<li>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</li>
</ul>
<p>可见，根据父节点输出顺序即可以判断是哪一种遍历。</p>
<h3 id="1简单代码实现">1.简单代码实现</h3>
<p>先创建节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-11 17:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nodeNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode left;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> nodeNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nodeNum = nodeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BinaryTreeNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;nodeNum=&quot;</span> + nodeNum +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNodeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nodeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNodeNum</span><span class="params">(<span class="keyword">int</span> nodeNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nodeNum = nodeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreeNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现遍历方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-11 17:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;根节点不允许为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印节点</span></span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="comment">//向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrder(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印节点</span></span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="comment">//向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrder(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        postOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印节点</span></span><br><span class="line">        System.out.println(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2测试">2.测试</h3>
<p>对含有7个简单的满二叉树进行遍历的结果：</p>
<p><img src="http://img.xiajibagao.top/二叉树遍历例子.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前序遍历：</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">1</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">2</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">4</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">5</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">3</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">6</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">7</span>&#125;</span><br><span class="line">中序遍历：</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">4</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">2</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">5</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">1</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">6</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">3</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">7</span>&#125;</span><br><span class="line">后序遍历：</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">4</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">5</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">2</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">6</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">7</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">3</span>&#125;</span><br><span class="line">BinaryTreeNode&#123;nodeNum=<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-二叉树的查找">三、二叉树的查找</h2>
<p>大体逻辑同遍历，这里就不在赘述了，直接放代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">preSearch</span><span class="params">(<span class="keyword">int</span> num,BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    BinaryTreeNode result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前节点是否为查找节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getNodeNum() == num) &#123;</span><br><span class="line">        result = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断左节点是否为空，不为空就前序查找节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = preSearch(num, node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左树找到就返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就判断并递归前序查找右树</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = preSearch(num, node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">inSearch</span><span class="params">(<span class="keyword">int</span> num,BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    BinaryTreeNode result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左节点是否为空，不为空就中序查找节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = inSearch(num, node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左树找到就返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左树未找到就判断当前节点是不是</span></span><br><span class="line">    <span class="keyword">if</span> (node.getNodeNum() == num) &#123;</span><br><span class="line">        result = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就判断并递归前序查找右树</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = inSearch(num, node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">postSearch</span><span class="params">(<span class="keyword">int</span> num,BinaryTreeNode node)</span></span>&#123;</span><br><span class="line">    BinaryTreeNode result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左节点是否为空，不为空就后序查找节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = postSearch(num, node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左树找到就返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则就判断并递归后序查找右树</span></span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = postSearch(num, node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断右树是否找到</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果右树仍未找到就判断当前节点是不是</span></span><br><span class="line">    <span class="keyword">if</span> (node.getNodeNum() == num) &#123;</span><br><span class="line">        result = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-二叉树的删除">四、二叉树的删除</h2>
<p>对于二叉树的删除，有以下逻辑：</p>
<ul>
<li>由于树的节点和节点之间的联系是单向的，对于要删除的节点，需要找到他的父节点进行删除</li>
<li>从根节点开始遍历节点，判断节点的左右子节点是否为目标节点</li>
<li>如果是就删除并返回</li>
<li>否则就持续向右或左递归，直到找到目标节点，或者将树遍历完为止</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num, BinaryTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断删除的是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.getNodeNum() == num) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不允许删除根节点！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果子节点就是要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span> &amp;&amp; node.getLeft().getNodeNum() == num) &#123;</span><br><span class="line">        node.setLeft(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span> &amp;&amp; node.getRight().getNodeNum() == num) &#123;</span><br><span class="line">        node.setRight(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就往左树或右树遍历直到找到或遍历完为止</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        delete(num, node.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        delete(num,node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-顺序存储二叉树">五、顺序存储二叉树</h2>
<p>一般想到二叉树都会先想到较为形象的链式存储，即用含有左右指针的节点来组成树，实际上，通过计算，也可以使用数组来表示二叉树。</p>
<p>可以简单的理解：顺序存储二叉树是逻辑的上一棵树，而链式存储二叉树是物理上的一棵树。</p>
<p>以下图的树为例：</p>
<p><img src="http://img.xiajibagao.top/二叉树遍历例子.png"></p>
<p>假设数组为{1,2,3,4,5,6,7,}，我们可以知道：</p>
<ul>
<li>下标为n的元素的左节点为：<code>2*n+1</code></li>
<li>下标为n的元素的右节点为：<code>2*n+2</code></li>
<li>下标为n的元素的父节点为：<code>(n-1)/2</code></li>
</ul>
<p>如果给顺序存储二叉树写一个前序遍历急就是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出数组</span></span><br><span class="line">    System.out.println(arr[index]);</span><br><span class="line">    <span class="comment">//向左递归</span></span><br><span class="line">    <span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">        preOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右递归</span></span><br><span class="line">    <span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">        preOrder(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码的实现上和链式二叉树是差不多的，这里就不再一一列举了。</p>
<p>当然，由于顺序存储二叉树的性质，当树需要排序的情况下，顺序存储二叉树就会出现空间浪费的情况：</p>
<p><img src="http://img.xiajibagao.top/顺序存储和链式存储二叉树的区别.png"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（六）：递归</title>
    <url>/2020/06/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="一-什么是递归">一、什么是递归</h2>
<p>所谓递归，简单点来说，就是一个函数直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</p>
<p>引用知乎大佬的例子：</p>
<blockquote>
<p>我们可以把” 递归 “比喻成 “查字典 “，当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词。</p>
<p>可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。</p>
</blockquote>
<p>我们把查字典理解成一个函数<code>search()&#123;&#125;</code>，而“明白了”就是停止条件。</p>
<p>按这个思路，那这个流程就是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果明白了就停止函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;明白了&quot;</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没明白调用自己继续查</span></span><br><span class="line">    search();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们举个简单的例子：</p>
<p>要计算阶乘<code>1*2*3*.....*(n-1)*n</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件，当n=1时直接返回1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算n*(n-1).....</span></span><br><span class="line">    <span class="keyword">return</span> n * mult(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-递归和栈的关系">二、递归和栈的关系</h2>
<blockquote>
<p>递归的过程就是出入栈的过程</p>
</blockquote>
<p>递归的问题实际上都能拆分成出入栈问题，我们可以举上面计算<code>1*2*3*.....*(n-1)*n</code>这个例子来理解一下：</p>
<p>如果n=4，那么过程就是这样：</p>
<ol type="1">
<li>mult(4)调用了mult(3)</li>
<li>mult(3)调用了mult(2)</li>
<li>mult(2)调用了mult(1)</li>
<li>到了mult(1)时满足了终止条件，返回结果</li>
</ol>
<p>用出入栈的思维理解：</p>
<ol type="1">
<li>步骤1-3都是一个入栈过程，mult(4)计算得出结果后入栈，然后运行mult(3)得出结果，然后在入栈......以此类推</li>
<li>当到达n=1的停止条件时递归停止不再入栈，此时栈深度就是4，这也叫递归深度</li>
<li>满足停止条件后出栈，mult(1)的结果出栈，与mult(2)的结果出栈相乘，再与随后出栈的mult(3)的结果相乘.....以此类推</li>
</ol>
<p>递归的本质就是栈的出入过程，所以实际上当深度过深，超过了jvm规定允许的栈最大深度的时候，就会出现栈溢出的问题，也就是java里的<code>StackOverflowError</code></p>
<h2 id="三-递归的使用条件">三、递归的使用条件</h2>
<p>那么，我们是时候可以使用递归来解决问题呢：</p>
<ul>
<li>当问题可以拆分为子问题，并且子问题与原问题解决方法相同</li>
<li>有一个明确的程序停止条件</li>
</ul>
<p>比如<a href="https://www.cnblogs.com/Createsequence/p/13192879.html">之前的文章</a>中提到连续乘除问题就是一个典型的例子。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十七）：B树，B+树</title>
    <url>/2020/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9AB%E6%A0%91%EF%BC%8CB+%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一-什么是多路查找树">一、什么是多路查找树</h2>
<p>二叉树有诸多便利之处，但是当二叉树节点极多时，二叉树的构建速度就会受影响，而且过高的层数也会导致对树的操作效率降低。</p>
<p><img src="http://img.xiajibagao.top/过多节点的二叉树.png" alt="过多节点的二叉树" style="zoom:50%;"></p>
<p>对于树的查找而言，树的高度决定了查找的时间下限，但是同样数量的节点，如果要高度小那每一层容纳的节点就要多，而二叉树每一层固定的节点数导致的高度难以降低，为此每一个节点都能拥有多个子节点的<strong>多叉树(multi way tree)</strong>就出现了.</p>
<p><img src="http://img.xiajibagao.top/多叉树.png" alt="多叉树" style="zoom: 50%;"></p>
<p>B树，B+树都是多叉树</p>
<h2 id="二-b树">二、B树</h2>
<p>B树也称B-树,它是一颗多路平衡查找树。</p>
<p>2-3树是最简单的B树，它具有以下特点：</p>
<ul>
<li>2-3树的所有叶子节点都在同一层（只要是B树都满足该条件）</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。三节点本身包含两个数据项</li>
<li>有三个子节点的节点叫三节点<strong>，</strong>三节点要么没有子节点<strong>，</strong>要么有三个子节点。二节点本身包含一个数据项</li>
<li>2-3树是由二节点和三节点构成的树。</li>
</ul>
<p>我们以数列{16,24,12,32,14,26,34,10,8,28,38,20}构建2-3树为例：</p>
<figure>
<img src="http://img.xiajibagao.top/2-3树插入节点.png" alt="image-20200725183108854"><figcaption aria-hidden="true">image-20200725183108854</figcaption>
</figure>
<p>对于2-3树插入的特点，我们举几个具有代表性的例子：</p>
<ul>
<li>{16}插入24：由于24大于16，又16是一个二节点，他要么有两个值节点要么没有节点，所以只能插到16节点里，变成一个三节点</li>
<li>{16,24}插入12：由于12小于16，又[16|24]是一个三节点，所以将[16|12]拆开，以16为父节点，24为右子节点，12作为为左子节点插入</li>
<li>{16,24,12,32,14,26,34}插入10：按顺序找到[12|14]节点，将三节点拆开后，以12为父节点，14为左子节点，10作为为左子节点插入，由于插入10以后，树的所有叶子节点就不在同一层了，所以需要对其他子树进行调整，将[16|26]拆开，将26变为16的右子节点，原本的24与[32,34]节点变为24的左右子节点</li>
</ul>
<p>除了2-3树以外，还有一种2-3-4树也是B树的一种，相比2-3树，它多了一个包含能3个数据项与四个子节点的四节点：</p>
<figure>
<img src="http://img.xiajibagao.top/2-3-4树.png" alt="image-20200725185527418"><figcaption aria-hidden="true">image-20200725185527418</figcaption>
</figure>
<p><strong>由于B树的关键字集合可以分布在整颗树上，如果查找的数据离根节点很近，此时查找会比B+树快</strong></p>
<h2 id="三-b树">三、B+树</h2>
<figure>
<img src="http://img.xiajibagao.top/b+树.png" alt="image-20200725192414148"><figcaption aria-hidden="true">image-20200725192414148</figcaption>
</figure>
<p>B+树具有以下特点：</p>
<ul>
<li>B+树只有叶子节点存放数据（稠密索引），而非叶子节点只作为索引（稀疏索引），这使得非叶子节点所能保存的关键字大大增加</li>
<li>B+树的叶子节点存放的数据是有序的</li>
</ul>
<p><strong>相对B树，B+具有以下优点</strong>：</p>
<ol type="1">
<li>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同</li>
<li>B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高</li>
<li>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描</li>
</ol>
<p><strong>也由于这些优点，在mysql中，索引实现是基于B+树的。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十三）：赫夫曼树</title>
    <url>/2020/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一-什么是赫夫曼树">一、什么是赫夫曼树</h2>
<p>给定n个权值作为n个叶子节点，构造一课二叉树，若该树的带权路径长度和（wpl）达到最小，称这样的二叉树为<strong>最优二叉树</strong>，也就是<strong>赫夫曼树</strong>。</p>
<p>要理解这句话，我们需要了解几个关键词：</p>
<ul>
<li>路径：从一个节点往下一个节点之间的通路。若根节点层数为1，则根节点通往L层的节点路径长度为L-1</li>
<li>带权路径：权可以理解为节点值，而从根节点到某节点之间的路径长度与该点的权的成绩称为带权路径长度</li>
</ul>
<p>举个例子：</p>
<figure>
<img src="http://img.xiajibagao.top/赫夫曼树.png" alt="image-20200717165237484"><figcaption aria-hidden="true">image-20200717165237484</figcaption>
</figure>
<p>如上图所示，节点13到根节点的路径长度是2，而权是13，所以带权路径长度就是2*13=26，同理，节点7的带权路径长度是14，8是16,3是6，最终该树的带权路径长度之和（wpl）就是26+14+16+6=62。</p>
<figure>
<img src="http://img.xiajibagao.top/赫夫曼树2.png" alt="image-20200717165733984"><figcaption aria-hidden="true">image-20200717165733984</figcaption>
</figure>
<p>而该树与上图有相同的叶子节点，但是wpl却是13+16+21+9=59，这<strong>是拥有这几个相同叶子节点的树里面wpl最小的</strong>，所以这颗树就是一颗赫夫曼树。</p>
<p>我们不难看出，赫夫曼树最大的特点：<strong>权越大的节点越靠近根节点</strong></p>
<h2 id="二-如何构建赫夫曼树">二、如何构建赫夫曼树</h2>
<p>举个例子，我们要将{6,1,3,7,13,8,29}这一串数列组建为赫夫曼树</p>
<ol type="1">
<li><p>首先，我们对齐从小到大排序，得到{1,3,6,7,8,13,29}</p></li>
<li><p>取出1和3，并以两节点之和4为根节点组建树</p>
<figure>
<img src="http://img.xiajibagao.top/构建赫夫曼1.png" alt="image-20200717172110379"><figcaption aria-hidden="true">image-20200717172110379</figcaption>
</figure></li>
<li><p>取出6，并与4之和10为根节点构建树</p>
<figure>
<img src="http://img.xiajibagao.top/构建赫夫曼2.png" alt="image-20200717172201798"><figcaption aria-hidden="true">image-20200717172201798</figcaption>
</figure></li>
<li><p>取出7，并与10之和17为根节点构建树</p>
<figure>
<img src="http://img.xiajibagao.top/构建赫夫曼3.png" alt="image-20200717172314477"><figcaption aria-hidden="true">image-20200717172314477</figcaption>
</figure></li>
<li><p>重复以上步骤最终得到赫夫曼树</p></li>
</ol>
<figure>
<img src="http://img.xiajibagao.top/构建赫夫曼4.png" alt="image-20200717172440901"><figcaption aria-hidden="true">image-20200717172440901</figcaption>
</figure>
<h2 id="三-代码实现">三、代码实现</h2>
<p>首先先写一个节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-17 17:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：赫夫曼树使用的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父节点的构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.val = left.val + right.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;val=&quot;</span> + val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现排序接口，从大到小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(<span class="keyword">this</span>.val - o.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现一个构造赫夫曼树的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-17 17:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：赫夫曼树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建赫夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组元素拆分成节点</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建树</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出最小的两个数构建树</span></span><br><span class="line">            Node left = nodes.get(nodes.size() - <span class="number">1</span>);</span><br><span class="line">            Node right = nodes.get(nodes.size() - <span class="number">2</span>);</span><br><span class="line">            Node parant = <span class="keyword">new</span> Node(left, right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//删除两个节点</span></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将根节点添加至集合</span></span><br><span class="line">            nodes.add(parant);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十二）：堆排序</title>
    <url>/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="一-什么是堆排序">一、什么是堆排序</h2>
<h3 id="1堆堆排序">1.堆，堆排序</h3>
<p>对于“<strong>堆</strong>”我们可以理解为具有以下性质的<strong>完全二叉树</strong>：</p>
<ul>
<li>每个结点的值都<strong>大于或等于</strong>其左右孩子结点的值，称为<strong>大顶堆</strong></li>
<li>每个结点的值都<strong>小于或等于</strong>其左右孩子结点的值，称为<strong>小顶堆</strong></li>
</ul>
<p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
<p>在排序时，一般<strong>升序</strong>采用大顶堆，<strong>降序</strong>采用小顶堆。</p>
<h3 id="2大顶堆">2.大顶堆</h3>
<p><img src="http://img.xiajibagao.top/大顶堆.png"></p>
<p>我们可以看到，层数从小到大，节点的数字是越来越小的，映射到数组有：<code>&#123;50,45,40,20,25,35,30,10,15&#125;</code></p>
<p>特点是<code>arr[i] &gt;= arr[2*i+1] &amp;&amp; arr[i] &gt;= arr[2*i+2]</code></p>
<h3 id="3小顶堆">3.小顶堆</h3>
<figure>
<img src="http://img.xiajibagao.top/小顶堆.png" alt="image-20200714202759899"><figcaption aria-hidden="true">image-20200714202759899</figcaption>
</figure>
<p>跟大顶堆相反，层数从小到大，节点的数字是越来越大，映射到数组：<code>&#123;10,20,15,25,50,30,40,35,45&#125;</code></p>
<p>特点是：<code>arr[i] &lt;= arr[2*i+1] &amp;&amp; arr[i] &lt;= arr[2*i+2]</code></p>
<h2 id="二-堆排序的思路分析">二、堆排序的思路分析</h2>
<h3 id="1概述">1.概述</h3>
<ul>
<li>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li>
<li>遍历构建大顶堆，在这过程中元素的个数逐渐减少，直到最后得到一个有序序列了.</li>
</ul>
<h3 id="2举个例子">2.举个例子</h3>
<p>对数组{4,6,8,5,9}进行排序。</p>
<h4 id="第一遍排序">第一遍排序</h4>
<ol type="1">
<li><p>我们从最后一个非叶子结点开始排序。第一个非叶子结点为<code>arr.length/2-1=5/2-1=1</code>，也就是元素6.，我们对他进行对比并调整位置；</p>
<p><img src="http://img.xiajibagao.top/堆排序1.png"></p></li>
<li><p>在{6,5,4}中，5比6小，而9比6大，所以9和6交换位置；</p>
<figure>
<img src="http://img.xiajibagao.top/堆排序2.png" alt="image-20200716171927431"><figcaption aria-hidden="true">image-20200716171927431</figcaption>
</figure></li>
<li><p>接着找到第二个非叶子节点4，由于9是{9,4,8}这个树中最大的，故9与4交换位置</p>
<figure>
<img src="http://img.xiajibagao.top/堆排序3.png" alt="image-20200716172640232"><figcaption aria-hidden="true">image-20200716172640232</figcaption>
</figure></li>
<li><p>由于9与4交换位置打乱了原先{9,5,6}这棵树顺序，所以继续对新树{4,5,6}进行排序</p>
<figure>
<img src="http://img.xiajibagao.top/堆排序4.png" alt="image-20200716172926921"><figcaption aria-hidden="true">image-20200716172926921</figcaption>
</figure></li>
<li><p>由此得到了一个大顶堆，然后将堆顶元素9与末尾元素4进行交换，得到数组{4,6,8,5,9}</p>
<figure>
<img src="http://img.xiajibagao.top/堆排序5.png" alt="image-20200716173427122"><figcaption aria-hidden="true">image-20200716173427122</figcaption>
</figure></li>
</ol>
<p><strong>至此，第一遍排序已经完成，我们确定了最大元素9的位置</strong></p>
<h4 id="第二遍排序">第二遍排序</h4>
<p>第二遍排序开始时，最大元素9的位置已经确定，实际上要排序的数组变成了{4,6,8,5}</p>
<ol type="1">
<li><p>继续从6开始比较，{6,5}排序正常，所以接着比较{4,6,8}，8是最大的，所以与4交换位置</p>
<figure>
<img src="http://img.xiajibagao.top/堆排序6.png" alt="image-20200716184743652"><figcaption aria-hidden="true">image-20200716184743652</figcaption>
</figure></li>
<li><p>由此得到了一个大顶堆，然后将堆顶元素8与末尾元素5进行交换，得到数组{8,6,4}</p>
<figure>
<img src="http://img.xiajibagao.top/堆排序7.png" alt="image-20200716184933083"><figcaption aria-hidden="true">image-20200716184933083</figcaption>
</figure></li>
</ol>
<p><strong>至此，第一遍排序已经完成，我们确定了最第二大元素8的位置</strong></p>
<h4 id="第三遍~第n遍排序">第三遍~第n遍排序</h4>
<p>第二遍排序开始时，最大元素9和第二大元素8的位置已经确定，实际上要排序的数组变成了{5,6,4}</p>
<p>重复比较-排序-交换堆顶和队尾元素位置这一过程，直到最终获得有序数列</p>
<figure>
<img src="http://img.xiajibagao.top/堆排序8.png" alt="image-20200716185250532"><figcaption aria-hidden="true">image-20200716185250532</figcaption>
</figure>
<h2 id="三-代码实现">三、代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-16 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组进行堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">//将无序数组构建成一个大/小顶堆</span></span><br><span class="line">        <span class="comment">//有几个非叶子节点就排序几次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sortHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//交换数组头尾元素，将最大的元素排沉到队尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//交换头尾元素</span></span><br><span class="line">            temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.交换完后，此时最大的元素在arr[0]，最小的元素在arr[i]，即确定了本次排序范围最大的数</span></span><br><span class="line">            <span class="comment">//2.然后对0~i-1的范围进行排序，重新获得的数组最小的元素在arr[0]，最大的元素在arr[i-1]</span></span><br><span class="line">            sortHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3.接着进入下一次循环，重复步骤1，2，每次循环排序范围都缩小一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将以非叶子节点i为根节点的树调整为一个大顶堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 要调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 非叶子结点在数组中的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 要调整的数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortHeap(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数列必须至少有一个元素！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取根节点值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左节点开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span> + <span class="number">1</span>; j &lt; length; j = j * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//比较左右节点大小，将j指向值大的节点</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; arr[j + <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较将左右节点与父节点大小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">                <span class="comment">//如果子节点大于父节点，交换两节点位置</span></span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                <span class="comment">//然后继续从该子节点向下遍历</span></span><br><span class="line">                i = j;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束循环时，arr[i]已经存放了以原arr[i]为根节点的树的最大值</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十八）：图</title>
    <url>/2020/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="一-什么是图">一、什么是图</h2>
<h3 id="1概述">1.概述</h3>
<p>首先，我们已经在之前学习过了树这种数据结构，树能反映一对多的关系，但是却无法反映多对多的关系，因此我们引入了图这种数据结构。</p>
<p>对于图，其节点也可以叫做<strong>顶点</strong>，每个节点具有<strong>零或者多个相连节点</strong>，每个节点之间的连接称为<strong>边</strong>，从一个节点到达另一个节点路线都称为<strong>路径</strong>。</p>
<figure>
<img src="http://img.xiajibagao.top/图.png" alt="image-20200804155639505"><figcaption aria-hidden="true">image-20200804155639505</figcaption>
</figure>
<p>以上图为例，其中：</p>
<ul>
<li>无向图：顶点之间连接没有方向。比如从A到C，可是A -&gt; B -&gt; C，也可以是A -&gt; D -&gt; B -&gt; C。</li>
<li>有向图：顶点之间连接有方向。如果A到B，必须是A -&gt; B，不能是B -&gt; A</li>
<li>带权图：边带有权值。</li>
</ul>
<h3 id="2树与图的关系">2.树与图的关系</h3>
<p>实际上，对于有向图还分为两种情况，即图中含环或者图中不含环的单向图，其中含环的图可以从某个顶点出发最终返回原点。</p>
<p>结合对图的定义，我们不难发现，<strong>树也可以理解为不含有环的单向图</strong>，是图的子集。</p>
<p>两者的区别在于：</p>
<ul>
<li>图中每个节点可以有任意数量的边，而树两个节点间仅仅只有一条边</li>
<li>图没有根节点，而树有</li>
<li>图中可以存着环，而树不行</li>
<li>如果有n个节点，图最多有n*(n-1)条边，而树最多有n-1条边</li>
</ul>
<h2 id="二-图的表示与构建">二、图的表示与构建</h2>
<p>图的表示就是边与边关系的表示，有二维数组（邻接矩阵）和链表（邻接表）两种表示方法。</p>
<h3 id="1邻接矩阵">1.邻接矩阵</h3>
<figure>
<img src="http://img.xiajibagao.top/邻接矩阵表示图.png" alt="image-20200804161211188"><figcaption aria-hidden="true">image-20200804161211188</figcaption>
</figure>
<p>我们建立一个二维数组（矩阵），第一维表示顶点，而第二维表示与该顶点相连接的点。</p>
<p>比如说0号点与1,2,3,4相连，与0（自己）和5不相连，表示为<code>[0][011110]</code>，其中，二维数组中的1表示与0号点相连，0表示与0号点不相连</p>
<h3 id="2邻接表">2.邻接表</h3>
<figure>
<img src="http://img.xiajibagao.top/邻接表表示图.png" alt="image-20200804161802498"><figcaption aria-hidden="true">image-20200804161802498</figcaption>
</figure>
<p>邻接表相比邻接矩阵，只表示关联的边而不表示不关联的表，相对邻接矩阵而言更简洁也更节省空间</p>
<h3 id="3代码实现">3.代码实现</h3>
<p>我们使用邻接矩阵的方式来示范如何使用代码构建一个图。</p>
<p>为了方便理解，我们使用两个数组来表示节点与节点之间的对应关系：</p>
<figure>
<img src="http://img.xiajibagao.top/构建一个图.png" alt="image-20200804172225850"><figcaption aria-hidden="true">image-20200804172225850</figcaption>
</figure>
<p>如上图，上图的节点之间的对应关系通过两个数组来表示就是<code>&#123;0,0,0,0,1&#125; -&gt; &#123;1,2,3,4,2&#125;</code>，即 <code>0-&gt;1,0-&gt;2,,0-&gt;3,,0-&gt;4,,1-&gt;2</code>，可见要创建的图有5个节点。</p>
<p>对应实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-08-04 16:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点与节点间的相连关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] node1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] node2;</span><br><span class="line">    <span class="comment">//有几个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="comment">//边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sideNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] graph;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span>[] node1, <span class="keyword">int</span>[] node2, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node1 = node1;</span><br><span class="line">        <span class="keyword">this</span>.node2 = node2;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.sideNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        CreateGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取二维数组，一维表示节点，二维表示节点的相邻节点</span></span><br><span class="line">        graph = <span class="keyword">new</span> <span class="keyword">int</span>[num][num];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            graph[i] = Arrays.copyOf(graph[i], num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node1.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//统计边数</span></span><br><span class="line">            <span class="keyword">if</span> (graph[node1[i]][node2[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                sideNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            graph[node1[i]][node2[i]] = <span class="number">1</span>;</span><br><span class="line">            graph[node2[i]][node1[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] n1 : graph) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n2 : n1) &#123;</span><br><span class="line">                System.out.print(n2 + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;有&quot;</span> + num + <span class="string">&quot;个节点，&quot;</span> + sideNum + <span class="string">&quot;条边&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">有<span class="number">5</span>个节点，<span class="number">5</span>条边</span><br></pre></td></tr></table></figure>
<h2 id="三-图的深度优先搜索">三、图的深度优先搜索</h2>
<p>图的遍历有两种策略：<strong>深度优先搜索</strong>（DFS）和<strong>广度优先搜索</strong>（BFS）。</p>
<p>以下的演示我们仍基于第二部分创建的图为示例：</p>
<figure>
<img src="D:\代码及jar包\学习记录\数据结构\图\构建一个图.png" alt="image-20200804172225850"><figcaption aria-hidden="true">image-20200804172225850</figcaption>
</figure>
<h3 id="1思路分析">1.思路分析</h3>
<p>dfs的搜索大体思路是这样的：</p>
<blockquote>
<p>首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，然后重复以上步骤直到完成遍历。</p>
</blockquote>
<p>这个思路如果学过树的遍历会感觉非常熟悉。由前面知道，树就是一种特殊的图，所以<strong>树的前、中、后序遍历其实就是树的dfs</strong>。</p>
<h3 id="2代码实现">2.代码实现</h3>
<p>将思路转换为代码实现的步骤：</p>
<ul>
<li>访问第一个节点v，并且将其标记为已访问</li>
<li>查找第一个节点的邻接节点w：
<ol type="1">
<li>如果w节点不存在，则继续查找v的下一个邻接节点</li>
<li>如果w存在，并且未访问，则将w当成下一个v，进行递归</li>
</ol></li>
</ul>
<p>第一步，我们需要在<code>Graph类</code>中添加<code>isVisted</code>公共变量用于标记节点是否被访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录节点是否被访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisted;</span><br></pre></td></tr></table></figure>
<p>第二步，我们需要查找节点是否存在相连节点方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找邻接节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果当前节点存在邻接节点就返回下标</span></span><br><span class="line">        <span class="keyword">if</span> (graph[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找下一个邻接节点的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index2 + <span class="number">1</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果当前节点存在邻接节点就返回下标</span></span><br><span class="line">        <span class="keyword">if</span> (graph[index1][index2] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，借助访问标记和查找邻接节点方法实现dfs</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dsf</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//访问节点</span></span><br><span class="line">    System.out.print(index + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//标记已访问节点</span></span><br><span class="line">    isVisted[index] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//获取第一个邻接节点</span></span><br><span class="line">    <span class="keyword">int</span> w = getNeighbor(index);</span><br><span class="line">    <span class="comment">//如果邻接节点存在</span></span><br><span class="line">    <span class="keyword">while</span> (w != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//并且该邻接节点未访问</span></span><br><span class="line">        <span class="keyword">if</span> (!isVisted[w]) &#123;</span><br><span class="line">            dsf(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该节点已被访问,就访问当前节点的邻接节点的下一个邻接节点</span></span><br><span class="line">        w = getNextNeighbor(index, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对所有节点进行dfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="comment">//如果该节点仍未被访问才进行dfs</span></span><br><span class="line">        <span class="keyword">if</span> (!isVisted[i]) &#123;</span><br><span class="line">            dsf(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;</span><br></pre></td></tr></table></figure>
<h2 id="四-图的广度优先搜索">四、图的广度优先搜索</h2>
<h3 id="1思路分析">1.思路分析</h3>
<p>bfs的大题思路是这样的：</p>
<blockquote>
<p>首先创建一个队列，把第一个邻接节点入队，然后队列元素出队，把该元素的邻接节点入队，然后出队.....重复该步骤，一层一层的遍历同级节点</p>
</blockquote>
<p>如果我们按这个思路，将4作为起始节点，那么第一个4入队，然后4出队，把4的邻接节点0入队，接着0出队，把0的邻接节点1,2,3,入队；同理如果将0作为起始节点，那么第一次0入队，然后0出队，把0的邻接节点1,2,3入队......</p>
<h3 id="2代码实现">2.代码实现</h3>
<p>将思路转换为代码实现的步骤：</p>
<ul>
<li>访问初始节点v，标记并入队</li>
<li>当队列不为空时，将队头节点u出队，否则跳过本次循环</li>
<li>查找u的第一个邻接节点w，如果不存在就重复步骤2，否则：
<ol type="1">
<li>若w未被访问，则标记并入队</li>
<li>查找u继w后的下一个邻接节点，重复步骤3</li>
</ol></li>
</ul>
<p>这里继续复用上文dfs中使用的 <code>getNeighbor()</code>、<code>getNextNeighbor()</code>和 <code>isVisted[]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    LinkedList queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问节点</span></span><br><span class="line">    System.out.print(index + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//标记已访问节点</span></span><br><span class="line">    isVisted[index] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//节点入队</span></span><br><span class="line">    queue.addLast(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环直到遍历完所有队列中的节点</span></span><br><span class="line">    <span class="keyword">int</span> u, w = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//取出队列头结点下标</span></span><br><span class="line">        u = (<span class="keyword">int</span>) queue.removeFirst();</span><br><span class="line">        <span class="comment">//获取出队节点的邻接节点</span></span><br><span class="line">        w = getNeighbor(u);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果为被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisted[w]) &#123;</span><br><span class="line">                <span class="comment">//访问节点并标记</span></span><br><span class="line">                System.out.print(u + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                isVisted[w] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将节点入队</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接着查找下一个邻接节点</span></span><br><span class="line">            w = getNextNeighbor(u, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.isVisted = <span class="keyword">new</span> <span class="keyword">boolean</span>[num];</span><br><span class="line">    <span class="comment">//对所有节点进行bfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="comment">//如果该节点仍未被访问才惊喜dfs</span></span><br><span class="line">        <span class="keyword">if</span> (!isVisted[i]) &#123;</span><br><span class="line">            bfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;</span><br></pre></td></tr></table></figure>
<p>值得一提是，虽然上文的例子不太直观，但是bfs也常常用于<strong>树的层次遍历</strong>，比如</p>
<figure>
<img src="http://img.xiajibagao.top/bfs用于层次遍历.png" alt="bfs用于层次遍历"><figcaption aria-hidden="true">bfs用于层次遍历</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试数据</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span>[] u = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span>-&gt;<span class="number">8</span>-&gt;</span><br></pre></td></tr></table></figure>
<p>可以很明显的看出，是一层一层遍历的，这也很直观的反应了bfs的执行逻辑。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十六）：平衡二叉树</title>
    <url>/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一-什么是平衡二叉树">一、什么是平衡二叉树</h2>
<h3 id="1概述">1.概述</h3>
<p>平衡二叉树（AVL树）是一种带有平衡条件的二叉搜索树。它的特性如下：</p>
<ul>
<li>AVL树的左右两个子树的高度差的绝对值不超过1</li>
<li>AVL树的左右两个子树都是一棵平衡二叉树</li>
</ul>
<figure>
<img src="http://img.xiajibagao.top/平衡二叉树.png" alt="image-20200722173142958"><figcaption aria-hidden="true">image-20200722173142958</figcaption>
</figure>
<p>举个例子，如上图所示：</p>
<ul>
<li>第一棵树左树高2，右树高1，差值为1，是一颗AVL树；</li>
<li>第二棵树左树高2，右树高2，差值为0，是一颗AVL树；</li>
<li>第三棵树左树高3，右树高1，差值为2，不是一颗AVL树；</li>
</ul>
<p>红黑树就是一直AVL树。</p>
<h3 id="2为什么需要平衡二叉树">2.为什么需要平衡二叉树</h3>
<p>当我们使用二叉排序树的时候，当连续插入顺序的节点的时候就会出现问题。比如，我们插入{1,2,3,4,5}这样一个数组：</p>
<figure>
<img src="http://img.xiajibagao.top/效率低下的顺序二叉树.png" alt="image-20200722173840094"><figcaption aria-hidden="true">image-20200722173840094</figcaption>
</figure>
<p>可见该树左树节点全为空，比起树更像单链表，这也导致了该树的插入和查询速度明显的下降，查询速度甚至因为每次多处一个比较左树的操作导致还不如单链表。为了避免这种情况，我们引入的AVL树。</p>
<h2 id="二-avl树左旋转">二、AVL树左旋转</h2>
<h3 id="1思路分析">1.思路分析</h3>
<p>AVL为了避免左右树高度差超过1，在可能导致这种情况的插入或者删除操作时会进行旋转。</p>
<p>我们举个例子，现在有数列{4,3,6,5,7}，当插入8后，现在的得到的排序树如下图：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200723175058126.png" alt="image-20200723175058126"><figcaption aria-hidden="true">image-20200723175058126</figcaption>
</figure>
<p>明显不再是一个AVL树，所以需要进行<strong>左旋转</strong>：</p>
<ol type="1">
<li><p>我们以当前根节点值再创建一个新节点<code>newNode</code></p></li>
<li><p>让新节点的左子节点指向根节点的左子节点</p>
<p><code>newNode.left = root.left</code></p></li>
<li><p>让新节点的右子节点指向根节点的右子节点的左子节点</p>
<p><code>newNode.right = root.right.left</code></p>
<figure>
<img src="http://img.xiajibagao.top/AVl左旋转1.png" alt="image-20200723183026891"><figcaption aria-hidden="true">image-20200723183026891</figcaption>
</figure></li>
<li><p>把根节点的值换成右子节点的值</p>
<p><code>root.val = root.right.val</code></p></li>
<li><p>把根节点的右子节点指向其右子节点的右子节点</p>
<p><code>root.right = root.right.right</code></p></li>
<li><p>让根节点的左子节点指向新节点（根节点的右子节点成为了新的根节点）</p>
<p><code>root.left = newNode</code></p>
<figure>
<img src="http://img.xiajibagao.top/AVl左旋转2.png" alt="image-20200723183950837"><figcaption aria-hidden="true">image-20200723183950837</figcaption>
</figure></li>
</ol>
<p>我们调整一下图片样式，就可以直观的看到左旋转后树的样子：</p>
<figure>
<img src="http://img.xiajibagao.top/AVl左旋转3.png" alt="image-20200723184527438"><figcaption aria-hidden="true">image-20200723184527438</figcaption>
</figure>
<p>网上看到一个非常形象直观的动图：</p>
<p><img src="http://img.xiajibagao.top/二叉树左旋转.gif"></p>
<p>不难理解：<strong>左旋的目的是降低左子树的高度</strong></p>
<h3 id="2代码实现">2.代码实现</h3>
<p>由于AVL树是基于BST改进的一种数据结构，所以这里的AVL树类继承了BST的方法和代码，使用同一个节点类，这里具体的代码可以参考<a href="https://www.cnblogs.com/Createsequence/p/13346146.html#_label1">之前的文章</a>。</p>
<p>我们先创建一个继承BST的AVL树类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-23 19:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：平衡二叉树</span></span><br><span class="line"><span class="comment"> * 由于是在二叉排序树的基础上改进，这里直接继承了二叉排序树类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> <span class="keyword">extends</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLTree</span><span class="params">(BinarySortTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于旋转的条件是左右子树高度差大于1，所以我们需要有几个方法来判断树的高度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前节点的右子树高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightHeight</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前节点的左子树高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftHeight</span><span class="params">(BinarySortTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取以当前节点为根节点的树高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前节点的左/右节点是否为空，是返回0，否则遍历返回当前节点的左右树最高值</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(node.left == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.left), node.right == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们需要一个让树左旋的代码，步骤同思路分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序树左旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建新节点，与根节点值相同</span></span><br><span class="line">    BinarySortTreeNode node = <span class="keyword">new</span> BinarySortTreeNode(root.val);</span><br><span class="line">    <span class="comment">//2.让新节点左子节点指向根节点左子节点</span></span><br><span class="line">    node.left = root.left;</span><br><span class="line">    <span class="comment">//3.让新节点的右子节点指向根节点的右子节点的左子节点</span></span><br><span class="line">    node.right = root.right.left;</span><br><span class="line">    <span class="comment">//4.让根节点的值变为其右子节点的值</span></span><br><span class="line">    root.val = root.right.val;</span><br><span class="line">    <span class="comment">//5.把根节点的右子节点指向其右子节点的右子节点</span></span><br><span class="line">    root.right = root.right.right;</span><br><span class="line">    <span class="comment">//6.让根节点的左子节点指向新节点</span></span><br><span class="line">    root.left = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再原先旧的添加方法上进行改进：</p>
<p>当添加完一个节点后，我们判断左右子树的高度差是否大于1，如果是就进行左旋</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写二叉排序树的节点添加方法，当添加完节点后左子树与右子树高度差大于1时，让树进行左旋转，若情况相反则进行右旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.add(node);</span><br><span class="line">    <span class="comment">//添加完节点后，判断左子树与右子树高度差是否大于1</span></span><br><span class="line">    <span class="keyword">int</span> disparity = getRightHeight(root) - getLeftHeight(root);</span><br><span class="line">    <span class="keyword">if</span> (disparity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高度差:&quot;</span> + disparity + <span class="string">&quot;,左旋转！&quot;</span>);</span><br><span class="line">        <span class="comment">//左子树与右子树高度差大于1就左旋</span></span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>截止目前，仅仅只对左子树高度较高的情况作了处理！</strong></p>
<h2 id="三-avl树的双旋转">三、AVL树的双旋转</h2>
<p>左旋转是为了降低左子树的高度，但是如果是右子树高度过高，我们就需要右旋，事实上，一个完整的AVL树，应当是能够双旋的。</p>
<p>右旋的步骤与左旋基本一致，但是方向不同：</p>
<ol type="1">
<li><p>我们以当前根节点值再创建一个新节点<code>newNode</code></p></li>
<li><p>让新节点的<strong>右子节点</strong>指向根节点的<strong>右子节点</strong></p>
<p><code>newNode.right = root.right</code></p></li>
<li><p>让新节点的<strong>左子节点</strong>指向根节点的<strong>左子节点</strong>的<strong>右子节点</strong></p>
<p><code>newNode.left = root.left.right</code></p></li>
<li><p>把根节点的值换成<strong>左子节点</strong>的值</p>
<p><code>root.val = root.left.val</code></p></li>
<li><p>把根节点的<strong>左子节点</strong>指向其<strong>左子节点</strong>的<strong>左子节点</strong></p>
<p><code>root.left = root.left.left</code></p></li>
<li><p>让根节点的右子节点指向新节点（根节点的左子节点成为了新的根节点）</p>
<p><code>root.right = newNode</code></p></li>
</ol>
<p><img src="http://img.xiajibagao.top/二叉树右旋转.gif"></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序树右旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建新节点，与根节点值相同</span></span><br><span class="line">    BinarySortTreeNode node = <span class="keyword">new</span> BinarySortTreeNode(root.val);</span><br><span class="line">    <span class="comment">//2.让新节点右子节点指向根节点右子节点</span></span><br><span class="line">    node.right = root.right;</span><br><span class="line">    <span class="comment">//3.让新节点的左子节点指向根节点的左子节点的右子节点</span></span><br><span class="line">    node.left = root.left.right;</span><br><span class="line">    <span class="comment">//4.让根节点的值变为其左子节点的值</span></span><br><span class="line">    root.val = root.left.val;</span><br><span class="line">    <span class="comment">//5.把根节点的左子节点指向其左子节点的左子节点</span></span><br><span class="line">    root.left = root.left.left;</span><br><span class="line">    <span class="comment">//6.让根节点的右子节点指向新节点</span></span><br><span class="line">    root.right = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在为排序树的add方法添加右旋的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写二叉排序树的节点添加方法，当添加完节点后左子树与右子树高度差大于1时，让树进行左旋转，若情况相反则进行右旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.add(node);</span><br><span class="line">    <span class="comment">//添加完节点后，判断左右树高度差是否大于1</span></span><br><span class="line">    <span class="keyword">int</span> disparity = getRightHeight(root) - getLeftHeight(root);</span><br><span class="line">    <span class="keyword">if</span> (disparity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高度差:&quot;</span> + disparity + <span class="string">&quot;,左旋转！&quot;</span>);</span><br><span class="line">        <span class="comment">//左子树与右子树高度差大于1就左旋</span></span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (- disparity &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//右子树与左子树高度差小于1就左旋</span></span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十）：哈希表</title>
    <url>/2020/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一-什么是哈希表">一、什么是哈希表</h2>
<h3 id="1概述">1.概述</h3>
<blockquote>
<p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做<strong>散列表</strong>。</p>
</blockquote>
<p><img src="http://img.xiajibagao.top/20200704134654.png"></p>
<p>通俗的理解一下：</p>
<ul>
<li>如果我们有n个元素要存储，那我们就用l个内存单元来存储他们</li>
<li>然后我们有一个哈希函数f(x)，我们把<strong>元素n用函数计算得到哈希值</strong>，也就是f(n)</li>
<li><strong>f(n)就是存储元素n的那个内存单位的位置</strong>，也就是元素在l中的下标</li>
</ul>
<h3 id="2为什么哈希表查询速度快">2.为什么哈希表查询速度快</h3>
<p>理解了哈希表的基本思路，我们也就不难理解为什么哈希表查询效率高了：</p>
<p>由于每个元素都能通过哈希函数直接计算获得地址，所以查找消耗时间非常少。</p>
<p>举个例子：</p>
<p>我们有哈希函数f(n)=n%3，现有元素{1,2,3}，我们使用哈希函数分别获得其哈希值，并把哈希值作为下标存入一个数组，</p>
<p>也就是放f(1)=1，f(2)=2，f(3)=0，如果使用传统线性查找，需要遍历四次，而使用哈希函数计算并查找，只需要一步就能找到，</p>
<p>可以看得出，理想情况下，哪怕数列再长，找到某个元素都只需要一步。</p>
<h3 id="3哈希冲突">3.哈希冲突</h3>
<p>按照上文的例子，数列{1,2,3}通过哈希函数f(n)=n%3可以计算出哈希值，但是如果出现两个元素的哈希值相同就会出现哈希冲突，</p>
<p>比如f(1)和f(4)都会算出1，这个时候显然不可能上上面一样通过一个一维数组直接存储。</p>
<p>对此我们有两种方法，即开放地址法和分离链表法：</p>
<ul>
<li><p>开放地址法：如果某一哈希值对应的位置已经被占用了，就找另一个没被占用的位置。</p>
<ol type="1">
<li>开放地址法容易产生堆积问题；不适于大规模的数据存储</li>
<li>插入时可能会出现多次冲突的现象，而删除时如果元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂</li>
<li>结点规模很大时会浪费很多空间</li>
</ol>
<p>注：关于开放地址法，具体可以参考<a href="https://blog.csdn.net/wxy941011/article/details/80740716">这篇文章</a></p></li>
<li><p>分离链表法：将散列表的每一个单元都扩展成为一个链表，相同哈希值的元素会被存储在同一个链表中。</p>
<ol type="1">
<li>分离链表法处理冲突简单，且无堆积现象，平均查找长度短</li>
<li>链表中的结点是动态申请的</li>
<li>相对开放地址法更加节省空间</li>
<li>插入与删除结点比较方便</li>
</ol></li>
</ul>
<p>在jdk8中，使用的就是分离链表法，当哈希冲突超过一点的限制，链表会转为红黑树。</p>
<h2 id="二-代码实现">二、代码实现</h2>
<p>在这里我们实现一个基于分离链表法的哈希表：</p>
<h3 id="1节点类">1.节点类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点序号</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> + <span class="string">&quot;num=&quot;</span> + num + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2单链表">2.单链表</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是尾节点就继续遍历下一个节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将尾节点指向即将插入的新节点</span></span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据序号获取节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要获取的节点序号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.num == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要更新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取要更新的节点序号</span></span><br><span class="line">        <span class="keyword">int</span> nodeNum = node.num;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果已经遍历完链表</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;编号为&quot;</span> + temp.num + <span class="string">&quot;的节点不存在！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了该节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.num == nodeNum) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 要删除的节点编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果链表到底了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到了待删除节点的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.num == num) &#123;</span><br><span class="line">                <span class="comment">//判断待删除节点是否为尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.next = temp.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一节点</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3哈希表">3.哈希表</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：黄成兴</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-04 11:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//用于存放数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> SingleLinkList[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        arr = <span class="keyword">new</span> SingleLinkList[size];</span><br><span class="line">        <span class="comment">//初始化链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> SingleLinkList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item % <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hashCode = getHashCode(item);</span><br><span class="line">        <span class="comment">//判断哈希值是否超过数组范围</span></span><br><span class="line">        <span class="keyword">if</span> (hashCode &gt;= size || hashCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;哈希值：&quot;</span> + hashCode + <span class="string">&quot;超出初始化长度！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该元素在链表中不存在就插入</span></span><br><span class="line">        <span class="keyword">if</span> (arr[hashCode].isEmpty() || arr[hashCode].get(item) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//插入元素</span></span><br><span class="line">            arr[hashCode].add(<span class="keyword">new</span> Node(item));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就更新</span></span><br><span class="line">            arr[hashCode].update(<span class="keyword">new</span> Node(item));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hashCode = getHashCode(item);</span><br><span class="line">        <span class="comment">//判断哈希值是否超过数组范围</span></span><br><span class="line">        <span class="keyword">if</span> (hashCode &gt;= size || hashCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查找元素</span></span><br><span class="line">        <span class="keyword">return</span> arr[hashCode].get(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hashCode = getHashCode(item);</span><br><span class="line">        <span class="comment">//删除元素</span></span><br><span class="line">        arr[hashCode].delete(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示某个哈希值对应链表的全部数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hashCode = getHashCode(item);</span><br><span class="line">        arr[hashCode].show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示哈希表的所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//只展示非空链表</span></span><br><span class="line">            <span class="keyword">if</span> (!arr[i].isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;条链表：&quot;</span>);</span><br><span class="line">                arr[i].show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（四）：栈</title>
    <url>/2020/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A0%88/</url>
    <content><![CDATA[<h2 id="一-什么是栈">一、什么是栈</h2>
<p>栈（stack）是一种<strong>先进后出</strong>的有序列表，其中的元素只能在<strong>线性表的同一端进出</strong>，</p>
<p>允许元素插入和删除的一端被称为<strong>栈顶</strong>（top），固定的另一端被称为<strong>栈底</strong>（button）。</p>
<p><img src="http://img.xiajibagao.top/20200623214705.png"></p>
<h2 id="二-数组简单实现栈">二、数组简单实现栈</h2>
<p>由于栈是只在一端进出，也就是说相比队列实际上只需要有一个栈顶指针top即可：</p>
<ol type="1">
<li>当栈空时top为-1</li>
<li>入栈后top+1</li>
<li>出栈后top-1</li>
</ol>
<p>根据思路我们可以用数组实现一个简单的栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-23 16:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：使用数组模拟栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否已满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        top = top + <span class="number">1</span>;</span><br><span class="line">        arr[top] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object item = arr[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历并打印栈中元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack&quot;</span> + i + <span class="string">&quot;：&quot;</span> + arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-链表简单模拟栈">三、链表简单模拟栈</h2>
<p>数组可以比较简单的实现一个栈，但是缺点的数组随着元素的增加会需要扩容，如果初始化申请的存储空间太大，会造成空间的浪费，如果申请的存储空间太小，后期会经常需要扩充存储空间，为此我们可以用链表实现的栈来避免这个问题。</p>
<p>假设现有头结点，一号元素A，我们需要往里面插入或弹出B，，由于要实现“先进后出”的效果：</p>
<ol type="1">
<li>入栈时，B需要插入头结点和A之间，取代A的位置：
<ul>
<li><code>B.next = head.next</code>，也就是B指向A</li>
<li><code>head.next = B.next</code>，也就是让头结点指向B</li>
</ul></li>
<li>出栈时，B需要从头结点和A之间移除：
<ul>
<li><code>head.next = A</code>，也就是让头结点直接指向A即可</li>
</ul></li>
</ol>
<p><img src="http://img.xiajibagao.top/20200623214702.png"></p>
<p>按照这个思路，我们先写一个节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-20 10:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后简单实现一个链表栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-06-23 21:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：链表栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="string">&quot;我是头结点&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否空栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点到链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 要插入的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(item);</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//如果空栈就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不是空栈就插到头结点头面</span></span><br><span class="line">        node.next = temp.next;</span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素出栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出栈元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        head.next = node.next;</span><br><span class="line">        <span class="keyword">return</span> node.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.data);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>资源推荐：数据结构可视化网站</title>
    <url>/2020/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>最近偶然发现一个神奇的网站，来自美国南弗罗里达大学计算机科学系的一个在线的数据结构可视化的网站。</p>
<p>里面提供了各种数据结构与算法的动态演示，可以调整动画速度，或者根据输入的参数动态展示数据结构或者算法的整个变化过程。</p>
<p>比如这个红黑树的演示: <a href="Red/Black%20Tree">Red/Black Tree</a></p>
<figure>
<img src="http://img.xiajibagao.top/image-20201223170637182.png" alt="image-20201223170637182"><figcaption aria-hidden="true">image-20201223170637182</figcaption>
</figure>
<p>这里是完整的功能目录：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></p>
]]></content>
      <categories>
        <category>资源推荐</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>资源推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot使用swagger2生成Api文档</title>
    <url>/2020/02/23/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/Springboot%E4%BD%BF%E7%94%A8swagger2%E7%94%9F%E6%88%90Api%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>之前开发项目的时候，需要写API文档，项目小接口少的时候一份word就能简单应付，但是随着项目的API的增加，对API文档的维护工作就会越来越繁琐，为此引入能自动生成RESTful接口文档的Swagger2框架就变得理所当然。</p>
<p>作为一个能够自动生成API文档的框架，其最大的优点有两个：</p>
<ol type="1">
<li>接口文档在线能够自动生成，文档随接口变动实时更新，节省维护成本</li>
<li>支持类似spring RESTful插件那样的在线接口测试，不依赖第三方工具</li>
</ol>
<h2 id="一-举个例子">一、举个例子？</h2>
<p>假设现在有一个TestController接口，里面有几个简单的API，通过swagger的注解添加接口描述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;Api-test&quot;, description = &quot;测试接口&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test/&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiOperation(&quot;获取回复&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;aiTalk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        str.replace(<span class="string">&quot;吗？&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ... ... <span class="comment">//下同，不再赘述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动项目后访问特定页面即可看到以Controller分类的API文档，点击展开以，根据注解的详细程度，会有传入参数，返回类型等详细说明，除此之外，还会有类似springREST插件那样的在线测试功能</p>
<p><img src="http://img.xiajibagao.top/swagger2.jpg"></p>
<h2 id="二-如何在项目中引入swagger2">二、如何在项目中引入swagger2？</h2>
<h3 id="1引入maven依赖">1.引入Maven依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2在springboot配置使用swagger">2.在springboot配置使用Swagger</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-02-23 13:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：配置swagger2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">adminApiConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .groupName(<span class="string">&quot;huangApi&quot;</span>)</span><br><span class="line">            .apiInfo(adminApiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            .paths(Predicates.and(PathSelectors.regex(<span class="string">&quot;/.*&quot;</span>)))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">adminApiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">            .title(<span class="string">&quot;简单课程表-API文档&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;本文档描述了简单课程表系统的接口定义&quot;</span>)</span><br><span class="line">            .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3访问页面">3.访问页面</h3>
<p>启动项目，访问 http://localhost:8080/swagger-ui.html#/ 即可</p>
<h2 id="三-swagger2注解">三、swagger2注解</h2>
<h3 id="1api注解">1.@Api注解</h3>
<p><strong>用在请求的类上，表示对类的说明</strong></p>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>描述类的作用</td>
</tr>
<tr class="even">
<td>tags</td>
<td>说明该类的作用，非空时将覆盖value的值</td>
</tr>
<tr class="odd">
<td>protocols</td>
<td>设置特定协议，例：http， https， ws， wss</td>
</tr>
<tr class="even">
<td>hidden</td>
<td>默认为false， 配置为true 将在文档中隐藏</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;Api-test&quot;, tags = &quot;测试接口&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test/&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-apioperation注解">2. <span class="citation" data-cites="ApiOperation注解">@ApiOperation注解</span></h3>
<p><strong>用在请求的方法上，说明方法的用途、作用</strong></p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 85%">
</colgroup>
<thead>
<tr class="header">
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>描述方法的作用</td>
</tr>
<tr class="even">
<td>tags</td>
<td>说明该方法的作用，非空时将覆盖value的值</td>
</tr>
<tr class="odd">
<td>response</td>
<td>返回对象类型（如果该对象类有@ApiModel属性会在文档的Model中列出）</td>
</tr>
<tr class="even">
<td>httpMethod</td>
<td>指定HTTP方法，"GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS" and "PATCH"</td>
</tr>
<tr class="odd">
<td>hidden</td>
<td>默认为false， 配置为true 将在文档中隐藏</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;获取课程表&quot;,response = CourseSchedule.class, httpMethod = &quot;GET&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.GET, path =  &quot;getCourseSchedule&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CourseSchedule <span class="title">getCourseSchedule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CourseSchedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-apiimplicitparams注解">3. <span class="citation" data-cites="ApiImplicitParams注解">@ApiImplicitParams注解</span></h3>
<p><span class="citation" data-cites="ApiImplicitParam注解">@ApiImplicitParam注解</span>，用在@ApiImplicitParams注解中，表示一组参数的说明</p>
<p><span class="citation" data-cites="ApiParam注解">@ApiParam注解</span>，用在单个参数上，是对单个参数的说明</p>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>参数的说明</td>
</tr>
<tr class="even">
<td>name</td>
<td>参数名，参数名称可以覆盖方法参数名称，路径参数必须与方法参数一致</td>
</tr>
<tr class="odd">
<td>required</td>
<td>参数是否必须传，默认为false(路径参数必填)</td>
</tr>
<tr class="even">
<td>defaultValue</td>
<td>参数的默认值</td>
</tr>
<tr class="odd">
<td>paramType</td>
<td>参数应该怎么传给接口：<br>1.“header”对应spring@RequestHeader注解标记的参数；<br>2.“query”对应spring@RequestParam注解标记的参数；<br>3.“path”对应spring@PathVariable注解标记的参数；<br></td>
</tr>
<tr class="even">
<td>dataType</td>
<td>参数类型</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;str&quot;, value = &quot;字符串&quot;, required = false, dataType = &quot;String&quot;, paramType = &quot;query&quot;),</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;id&quot;, required = true, dataType = &quot;Integer&quot;, paramType = &quot;query&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@GetMapping(path =  &quot;call&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@ApiParam(name = &quot;str&quot;, value = &quot;字符串&quot;, required = false)</span> String str,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@ApiParam(name = &quot;id&quot;, value = &quot;id&quot;, required = true)</span> Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;吱一声以表示项目运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-apimodel注解">4. <span class="citation" data-cites="ApiModel注解">@ApiModel注解</span></h3>
<p><strong>用在请求的类上，表示对类的说明</strong></p>
<p><strong><span class="citation" data-cites="ApiModelProperty注解">@ApiModelProperty注解</span></strong></p>
<p><strong>用在被@ApiModel标记了的类的属性上，用于描述类的属性</strong></p>
<p>注：此注解一般用于响应类上，比如使用@RequestBody注解直接接收对象作为参数的时候，多用于创建或更新</p>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>value</td>
<td>此属性的简要说明</td>
</tr>
<tr class="even">
<td>name</td>
<td>允许覆盖属性名称</td>
</tr>
<tr class="odd">
<td>allowableValues</td>
<td>限制参数的可接受值，有以下几种：<br>1.以逗号分隔的列表<br>2.范围值<br>3.设置最小值/最大值</td>
</tr>
<tr class="even">
<td>example</td>
<td>属性的示例</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：huang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2019-12-11 12:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：考试安排实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiModel(&quot;考试安排实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamSchedule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;课程名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;考场&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String examClassroom;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;考试时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String examDate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;当前时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;当前学期&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nowDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果被标记的类有被 <span class="citation" data-cites="ApiOperation注解的response属性引用的话">@ApiOperation注解的response属性引用的话</span>，在文档页面的Model可以看到</p>
<p><img src="http://img.xiajibagao.top/model.jpg"></p>
<h2 id="四-使用knife4j对swagger进行增强">四、使用knife4j对swagger进行增强</h2>
<h3 id="1什么是knife4">1.什么是knife4？</h3>
<p>knife4j是为JavaMVC框架集成Swagger生成Api文档的增强解决方案 ，在Swagger的基础上进行了各方面的增强，比如接口排序，一键导出markdown，word，pdf等功能，以及一个逻辑更加清晰而美观的功能，最重要的是，这些实用功能不需要改动任何原有的注释或者代码，只需要加一个依赖！tql！！！</p>
<p>地址： https://doc.xiaominfo.com/</p>
<h3 id="2简单使用">2.简单使用</h3>
<p>在原有swagger2依赖下引入knife4j依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用knife4j对swagger进行增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后就可以用了！</p>
<p>没错，原本的 http://localhost:8080/swagger-ui.html#/ 页面访问完全不受影响，但是通过http://localhost:8080/doc.html即可访问knife4j加强后的页面，效果如下：</p>
<p><img src="http://img.xiajibagao.top/knife.jpg"></p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>next5主题自定义摘要</title>
    <url>/2020/12/21/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/next5%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>最近 next6 折腾了一段时间，最后还是回到了 next5，但是添加阅读全文按钮以后，默认的摘要生成不太方便，于是就把注意打到了 js 上。</p>
<p>这里整理一下 next5 生成摘要的方法。</p>
<h2 id="一-yaml">一、yaml</h2>
<p>这个是 hexo 自带的，通过直接在 yaml 里面配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">next5主题自定义摘要</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-12-21</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">杂七乱八</span>]</span><br><span class="line"><span class="attr">categories:</span> [<span class="string">杂七乱八</span>]</span><br><span class="line"><span class="attr">description:</span> <span class="string">这里是一段摘要</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>不过加完以后， next 会默认在文章详情页面的发布信息下也生成摘要，个人觉得不是很美观。</p>
<h2 id="二-文章截断">二、文章截断</h2>
<p>这个是 next 自带的，可以通过在文章中插入：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- more --&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在标签之前的部分会作为文章摘要展示，优点是文章详情页面不会再另外展示，比较没关，但是缺点是需要手动一个一个添加，有些老文章没有加摘要还需要手动添加，不太方便。</p>
<h2 id="三-自动截断">三、自动截断</h2>
<p>在 hexo 的配置文件中添加如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>即可自动生成文章摘要。这种方式优点在于方便，但是长度不固定，而且因为带样式的缘故，可能页面会不是很协调。</p>
<p>在 next6 以后这种方式就不是默认支持的了，需要另外安装插件使用。</p>
<h2 id="四-js-截取摘要">四、js 截取摘要</h2>
<p>顾名思义，自己写 js 截断，这种方法和自动截断差不多，但是相对比较自由。个人比较习惯博客园那样不带样式的自动摘要，但是折腾来折腾去貌似都没弄出来这个效果于是决定用自己的渣渣 js 写一个。</p>
<p>首先根据渲染出来的页面，写好对应截取文本的 js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getAbstract();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 截取摘要</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAbstract</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> posts = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;posts&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;article&#x27;</span>).length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;不在主页！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arts = posts.getElementsByClassName(<span class="string">&quot;post-body&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> dom = arts[i];</span><br><span class="line">        <span class="keyword">let</span> content = dom.innerText</span><br><span class="line">            .substring(<span class="number">0</span>, <span class="number">250</span>)  + <span class="string">&quot;......&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> readAll = dom.getElementsByClassName(<span class="string">&quot;post-button&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        dom.innerHTML = content;</span><br><span class="line">        dom.appendChild(readAll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该文件命名为 abstract.js，并且放在 <code>themes\next\source\js\src</code>下。</p>
<p>然后找到 <code>\themes\next\layout</code>目录下的 <code>_layout.swig</code>文件，会看到很多通过 include 语法引入的组件，拉到最底下，在 body 标签之前添加 script ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入目录截取js --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/abstract.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当然，这个也可以写在那些被 include 引入的组件里头，效果是一样的。</p>
<p>最后 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>三连查看效果即可。</p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用七牛云图床</title>
    <url>/2020/06/04/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/Typora%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>最早之前博客一直是用有道云笔记写的，后面接触了 markdown 后改用 Typora 方便了不少，但是上传的时候图片仍然还要另外上传，着实麻烦。于是决定用七牛云自己搭一个图床。</p>
<h2 id="一-创建并上传文件到存储空间">一、创建并上传文件到存储空间</h2>
<h3 id="1注册七牛账号并且实名认证">1.注册七牛账号，并且实名认证</h3>
<h3 id="2创建储存空间">2.创建储存空间</h3>
<p>打开侧边栏，选择对象存储</p>
<p><img src="http://img.xiajibagao.top/20200604140435.png"></p>
<p>选择新建空间</p>
<p><img src="http://img.xiajibagao.top/20200604141608.png"></p>
<ul>
<li>存储空间名称：按规则随便取</li>
<li>存储区域：选择离靠近的地区</li>
<li>访问控制：选择<strong>公开</strong>，否则<strong>外网无法访问，没法作为图床</strong></li>
</ul>
<h3 id="3上传文件">3.上传文件</h3>
<figure>
<img src="http://img.xiajibagao.top/20200604141529.png" alt="image-20200604115247758"><figcaption aria-hidden="true">image-20200604115247758</figcaption>
</figure>
<ul>
<li><p>选择文件管理，点击上传文件即可上传</p></li>
<li><p>不绑定私有域名时默认外链域名即为官方分配的30天有效临时域名，</p>
<p>如果绑定私有域名可以选择私有域名</p></li>
<li><p>点击详情即可预览图片</p></li>
<li><p>点击更多，选中复制外链即可获得图片外链</p>
<p><img src="http://img.xiajibagao.top/20200604140440.png"></p></li>
</ul>
<p>获取外链之后直接输入浏览器网址栏，或者在代码里引用就行了！</p>
<h2 id="二-创建二级域名并解析到七牛云cname">二、创建二级域名并解析到七牛云CNAME</h2>
<p>七牛云默认会每隔30天重新分配一个临时的测试域名，也就是说，过了30天域名重置以后，之前的外链就全部失效，为了预防这种情况，我们需要绑定一个自己的私人域名。</p>
<p>如果没有私人域名的话参考这个方案：</p>
<p><a href="https://blog.csdn.net/qinglianchen0851/article/details/84257005">七牛：测试域名过期？自己域名又没备案？这里有一招完美解决你烦恼</a></p>
<p>如果有的话可以继续往下看</p>
<h3 id="1设置存储空间域名绑定">1.设置存储空间域名绑定</h3>
<p><img src="http://img.xiajibagao.top/20200604141616.png"></p>
<ul>
<li><p>选择自定义域名，添加一条你要绑定的子域名，其他设置不需要动，添加完保存即可</p>
<p>子域名格式需要为：主机记录.域名，比如<code>img.xxxxx.com</code>这样</p></li>
<li><p>配置完成后鼠标移至CNAME按钮上，复制<code>CNAME</code></p>
<p>比如我的配置就是<code>img-xxxxx-top-idvc2rp.qiniudns.com</code></p></li>
</ul>
<h3 id="2前往域名服务商创建二级域名">2.前往域名服务商创建二级域名</h3>
<p>以阿里云为例：</p>
<p>进入控制台打开侧边栏 --》选择域名解析 --》选择要创建二级域名的根域名 --》 解析设置</p>
<figure>
<img src="http://img.xiajibagao.top/20200604141622.png" alt="image-20200604133425532"><figcaption aria-hidden="true">image-20200604133425532</figcaption>
</figure>
<p>进入解析设置后选择添加记录以创建二级域名</p>
<p><img src="http://img.xiajibagao.top/20200604140441.png"></p>
<ul>
<li><p>记录类型，创建子域名，类型选择<code>CNAME</code>，</p>
<p>因为之后图床会绑定子域名，需要直接将子域名解析到图床去</p></li>
<li><p>主机记录：即二级域名，之前存储仓库填什么这里就填什么</p>
<p>比如之前如果填的<code>img.xxxx.com</code>，这里主机记录就填<code>img</code></p></li>
<li><p>记录值：这里直接黏贴之前存储仓库复制的CNAME</p></li>
</ul>
<h3 id="3使用二级域名代替默认测试域名">3.使用二级域名代替默认测试域名</h3>
<p>先测试看看是否已经解析成功：</p>
<p>打开cmd，然后输入<code>nslookup 二级域名</code>，看看第一条是否解析到配置的CNAME值</p>
<p><img src="http://img.xiajibagao.top/20200604141627.png"></p>
<p>如果有说明解析已经成功了。</p>
<figure>
<img src="http://img.xiajibagao.top/20200604141630.png" alt="image-20200604132815077"><figcaption aria-hidden="true">image-20200604132815077</figcaption>
</figure>
<p>回到存储仓库，此时外链域名可以选自己添加的二级域名了，切换到二级域名，然后保存为默认域名，之后引用的图片外链就会变成<code>二级域名/图片文件名</code>的格式了</p>
<h2 id="三-下载并安装picgo">三、下载并安装PicGo</h2>
<p>现在图床基本可以使用了，但是为了能更方便的管理，最重要的是能跟Typora无缝衔接，我们还需要PicGo辅助，</p>
<p>PicGo<a href="https://github.com/Molunerfinn/PicGo/tags">下载地址</a>，选择版本并且根据自己的操作系统选择对应的安装包即可。</p>
<p>安装好后打开界面是这样的：</p>
<figure>
<img src="http://img.xiajibagao.top/20200604141634.png" alt="image-20200604134354105"><figcaption aria-hidden="true">image-20200604134354105</figcaption>
</figure>
<p>选择图床设置里的七牛图床：</p>
<figure>
<img src="http://img.xiajibagao.top/20200604141636.png" alt="image-20200604132153288"><figcaption aria-hidden="true">image-20200604132153288</figcaption>
</figure>
<ul>
<li>设定AK和SK：前往七牛云个人中心 --》密匙管理复制黏贴即可</li>
<li>设定储存空间名：和七牛存储空间名称一致</li>
<li>设定访问网站：即你的二级域名，这里<strong>需要在域名之前加上http://</strong></li>
</ul>
<p>然后点确认保存设置，回到上传区选项即可上传图片到图床。</p>
<ul>
<li>上传图片成功后剪贴板会自动获取图片引用的外链</li>
<li>在相册可以查看通过PicGo上传过的图片</li>
</ul>
<p>然后我们需要打开Server：</p>
<figure>
<img src="http://img.xiajibagao.top/20200604141547.png" alt="image-20200604132637321"><figcaption aria-hidden="true">image-20200604132637321</figcaption>
</figure>
<figure>
<img src="http://img.xiajibagao.top/20200604140447.png" alt="image-20200604134431620"><figcaption aria-hidden="true">image-20200604134431620</figcaption>
</figure>
<p>开启端口监听后确认即可。</p>
<h2 id="四-typora配置图片上传">四、Typora配置图片上传</h2>
<h3 id="1配置上传服务设定">1.配置上传服务设定</h3>
<p>设置好PicGo后来到Typora进行配置：</p>
<figure>
<img src="http://img.xiajibagao.top/20200604140448.png" alt="image-20200604134151633"><figcaption aria-hidden="true">image-20200604134151633</figcaption>
</figure>
<p>打开偏好设置 --》图像 --》 上传服务设定</p>
<ul>
<li>上传服务：选择PicGo</li>
<li>PicGo路径：选择PicGo安装根目录的.exe文件</li>
</ul>
<h3 id="2上传图片">2.上传图片</h3>
<p>上传图片有三种方式：</p>
<ul>
<li><p>加入图片时直接上传</p>
<p>在偏好设置 --》图像 --》插入图片时 设置</p></li>
<li><p>对图片右键上传</p></li>
<li><p>在格式 --》图像 --》 上传所有本地图片</p></li>
</ul>
<p>如果出现报错，一般是端口被占用，可以打开PicGo的server看看端口是否还是36677，改变了的话改回来就好了。</p>
<p>如果还出现其他报错，可以参考这篇文章：</p>
<p><a href="https://www.jianshu.com/p/4cd14d4ceb1d">手把手教你用Typora自动上传到picgo图床【教程与排坑】</a></p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>博客园自定义代码块样式</title>
    <url>/2020/07/14/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h2 id></h2>
<p>一直都用博客园写博客，后面自己曾经想自己写一个博客项目，但是因为各种各样的事情最后做了一半就没能继续做下去。但是中间定制markdawn样式的时候接触到的代码高亮插件highlight.js倒是给我留下了很深的影响，今天有时间于是决定利用当初的经验重新diy一下博客园的代码块样式，算是对夭折的博客项目的一个弥补吧。</p>
<h2 id="一-下载highlightjs">一、下载highlight.js</h2>
<p>可以去<a href="https://highlightjs.org/">highlight.js官网</a>直接下载。</p>
<p>下载完的文件里有highlight.pack.js，决定你的代码哪里高亮，而styles文件夹存放各种样式，决定你的代码怎么样高亮。</p>
<p>按照官网文档引入三行代码即可生效：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--选择你想要的引入的样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/path/to/styles/default.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入highlight.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/path/to/highlight.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>hljs.initHighlightingOnLoad();<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以自己建一个页面试一试，样式有很多种，我个人比较喜欢darcula.css这个样式，接下来就以这个样式为例。</p>
<h2 id="二-将样式引入博客园">二、将样式引入博客园</h2>
<p>首先自定义css需要开通自定义权限，这个跟着流程来即可，我就不再赘述了。</p>
<p>打开你想要引入的css样式，复制代码黏贴到“页面定制css代码”，</p>
<p><strong>注意：这里要直接把css文件的代码复制过来，而不是引用！</strong></p>
<figure>
<img src="http://img.xiajibagao.top/image-20200713160332026.png" alt="image-20200713160332026"><figcaption aria-hidden="true">image-20200713160332026</figcaption>
</figure>
<p>然后将js添加到“博客园侧边栏公告”</p>
<p><strong>注意：这里不需要引入css！</strong></p>
<p><img src="http://img.xiajibagao.top/image-20200713160421251.png"></p>
<p>这里js文件资源我直接放到了博客园自带的文件仓库了，要放自己的静态资源仓库，或者引用第三方都行，</p>
<p>然后保存以后代码样式就会发生变化。</p>
<p><strong>但是仍然还会有各种各样的小问题</strong>，比如字体和背景颜色不对之类的。</p>
<h2 id="三-修复冲突的字体或背景颜色">三、修复冲突的字体或背景颜色</h2>
<p>一般主要问题都是字体或者背景颜色不对，我们直接覆盖<code>.cnblogs-markdown .hljs</code>的样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 替换背景和字体颜色 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#2b2b2b</span> <span class="meta">!important</span>;</span><br><span class="line">    color: #bababa !important;;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 代码块不换行 */</span></span><br><span class="line">    <span class="selector-tag">white-space</span>: <span class="selector-tag">pre</span>;</span><br><span class="line">    <span class="selector-tag">word-break</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据自己的需求修改代码，然后把代码添加到“页面定制css代码”就可以了</p>
<h2 id="四-修改字体样式或者代码块样式">四、修改字体样式或者代码块样式</h2>
<p>用chrome浏览器按F12查看你的文章页面元素，然后可以发现：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200713161507669.png" alt="image-20200713161507669"><figcaption aria-hidden="true">image-20200713161507669</figcaption>
</figure>
<p><code>.cnblogs-markdown .hljs, .cnblogs-post-body .hljs</code>这块就是控制代码块字体和边距的样式，你可以直接根据自己的需求调整样式然后直接黏贴到“页面定制css代码”里就行了。</p>
<p>博客园代码块默认边距是5，字体大小是12，行高是1.5，我想让换个好看的字体，顺便行距大小啥的都大点：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    	<span class="attribute">font-family</span>: consola;</span><br><span class="line">    	<span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;http://static.xxxxx.top/consola.ttf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-class">.hljs</span>, <span class="selector-class">.cnblogs-post-body</span> <span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: consola <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.7</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-前后样式对比">五、前后样式对比</h2>
<p>原本的样式：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200713162724416.png" alt="image-20200713162724416"><figcaption aria-hidden="true">image-20200713162724416</figcaption>
</figure>
<p>保存之后的新样式：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200713162145863.png" alt="image-20200713162145863"><figcaption aria-hidden="true">image-20200713162145863</figcaption>
</figure>
<p>明显比默认的样式好看多了</p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>算法时间复杂度</title>
    <url>/2020/06/27/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>衡量一个算法的好坏，最简单的标准就是他的时间复杂度。</p>
<blockquote>
<p>算法的<strong>时间复杂度</strong>（Time complexity）是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。</p>
<p>时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。</p>
<p>例如，如果一个算法对于任何大小为 <em>n</em> （必须比 <em>n0</em> 大）的输入，它至多需要 5<em>n</em>3 + 3<em>n</em> 的时间运行完毕，那么它的渐近时间复杂度是 O(<em>n</em>3).</p>
</blockquote>
<h2 id="一-时间频度">一、时间频度</h2>
<p>要理解时间复杂度，需要先理解时间频度，而时间频度简单的说，就是<strong>算法中语句的执行次数</strong>。</p>
<p>举个例子：</p>
<p>要计算1+2+...+100，现在有两种算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        total+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = (<span class="number">1</span> + n)*n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看见，对于<code>fun1()</code>这个方法，不管n多大，永远需要执行n+1次，也就是说他的时间频度是T(n)=n+1,</p>
<p>而对与<code>fun2()</code>来说，不管n多大都只需要执行1次，所以他的时间频度T(n)=1。</p>
<p><strong>当n趋向无穷大时，有三个忽略</strong>：</p>
<h3 id="1忽略常数项">1.忽略常数项</h3>
<p>比如T(n)=2n+1，当n趋向无穷大时，可以忽略常数项1；</p>
<p>参见下图：</p>
<ul>
<li>2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略</li>
<li>3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略</li>
</ul>
<p><img src="http://img.xiajibagao.top/20200627133030.png"></p>
<h3 id="2忽略低次项">2.忽略低次项</h3>
<p>比如T(n)=2n+3n^8，当n趋向无穷大时，可以忽略低次项及其系数2n；</p>
<p>参见下图：</p>
<ul>
<li>2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10<br>
</li>
<li>n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20</li>
</ul>
<p><img src="http://img.xiajibagao.top/20200627133038.png"></p>
<h3 id="3忽略系数">3.忽略系数</h3>
<p>比如T(n)=2n^8，当n趋向无穷大时，可以忽略系数2。</p>
<p>参见下图：</p>
<ul>
<li>随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5和3可以忽略。</li>
<li>而n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键</li>
</ul>
<p><img src="http://img.xiajibagao.top/20200627133027.png"></p>
<h2 id="二-时间复杂度">二、时间复杂度</h2>
<p>我们现在理解了时间频度的T(n)的含义，假设当有一个辅助函数f(n)，使得<strong>当n趋近无穷大时</strong>，T(n)/f(n)的极限值为不等于0的常数，就叫f(n)为T(n)的同量级函数，记作T(n)=O(f(n))，</p>
<p>称O(f(n))为算法的<strong>时间渐进复杂度</strong>，也就是<strong>时间复杂度</strong>。</p>
<p>又根据时间频度T(n)的“三个忽略”原则，我们可以知道时间复杂度是这样得到的：</p>
<ol type="1">
<li>忽略所有常数</li>
<li>只保留函数中的最高阶项</li>
<li>去掉最高阶项的系数</li>
</ol>
<p>举个例子：</p>
<p>某算法T(n)=2n^3+4n-5，按步骤走：</p>
<ol type="1">
<li>T(n)=2n^3+4n</li>
<li>T(n)=2n^3</li>
<li>T(n)=n^3</li>
</ol>
<p>即可得该算法时间复杂度为O(n^3)</p>
<h2 id="三-常见时间复杂度">三、常见时间复杂度</h2>
<p>这里按复杂度从低到高列举常见的时间复杂度：</p>
<ol type="1">
<li><p>常数阶O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对数阶O(log2n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据公式有 n = 2^x，也就是 x = log2n，x即为循环代码执行次数，所以时间复杂度为O(log2n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        i = i *<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线性阶O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般来说，只要代码里只有一个循环结构，即输入规模和执行次数呈线性相关，那这个代码的时间复杂度就都是O(n) 。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        n+=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线性对数阶O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以简单理解为对数阶的程序被放入了循环结构中，也就是n*O(logn)，下面的代码的复杂度就是O(nlog2n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            j = j *<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>平方阶O(n²)，立方阶O(n<sup>3)，K次方阶O(n</sup>k)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平方阶可以简单理解为线性阶中嵌套一个线性阶，也就是O(logn)*O(logn)，下面的代码复杂度就是O(n^2)</span></span><br><span class="line"><span class="comment">// 立方阶同理，就是三个线性阶的嵌套，K次方阶同理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; i++)&#123;</span><br><span class="line">			i=i+j;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="四-复杂度的四个概念">四、复杂度的四个概念</h2>
<ol type="1">
<li>最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。</li>
<li>最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。</li>
<li>平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示</li>
<li>均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</li>
</ol>
<p>举个例子：</p>
<p>长度为n的数组查找一个给定元素k</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == k)&#123;</span><br><span class="line">            <span class="comment">//找到了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法，最好的情况下元素k就在数组第一位，复杂度为O(1)，但是最坏的情况下，元素k在数组最后一位，复杂度为O(n)。</p>
<p>同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，我们引入这4个概念，当然，在大多数时候我们是不用特意区分这四种情况的。</p>
<h2 id="五-总结">五、总结</h2>
<p>总结一下如何快速判断程序的时间复杂度：</p>
<ul>
<li>只关注循环最多的那部分代码</li>
<li>总复杂度等于量级最大的那段代码的复杂度</li>
<li>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ul>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决next5主题目录无法跳转的问题</title>
    <url>/2020/12/17/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3next5%E4%B8%BB%E9%A2%98%E7%9B%AE%E5%BD%95%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>目前使用的 next 版本是 5.1.4 ，文章左侧的目录一直不能跳转也不能展开，按网上的办法一直没法解决，今天自己琢磨了一阵总算搞定了。</p>
<p>由于发现遇到这个问题的人不少，特此总结一下。</p>
<p>一般分为两种情况：渲染错误和超链接乱码。</p>
<h2 id="一-渲染错误">一、渲染错误</h2>
<h3 id="1问题描述">1.问题描述</h3>
<p>最典型的特征就是目录上的超链接为 <code>undefined</code>，或者点击的时候报错： <code>Cannot read property 'replace' of null</code>。</p>
<p>前一情况 GitHub 中已有相应的 Issues：<a href="https://github.com/Haojen/hexo-theme-Anisina/issues/34">根据 markdown 生成的 TOC 锚点的内容是 undefined</a></p>
<p>这个情况一般是 <code>markdown-it</code> 渲染出错，渲染时候把应该加在标题的锚点加到了标题内的 sapn 标签里，导致生成目录的时候获取不到对应的锚点。</p>
<p>比如原本 <code>##一级标题</code> 应该是渲染成 <code>&lt;h2 id="一级标题"&gt;一级标题&lt;/h2&gt;</code>，然后生成目录的时候扫描所有 <code>h2</code> 标签获取 id 作为链接，但是实际上 marked-it 渲染出来的是这样的： <code>&lt;h2&gt;&lt;span id="一级标题"&gt;一级标题&lt;/span&gt;&lt;/h2&gt;</code></p>
<h3 id="2解决方案">2.解决方案</h3>
<p><strong>方案一：调整渲染引擎</strong></p>
<p>最直白的解决方案就是更换渲染引擎。</p>
<p>如果一定要使用 <code>markdown-it</code>的话，可以为 <code>markdown-it</code> 安装 <code>markdown-it-named-headings</code>插件。具体的过程可以参考 <code>markdown-it</code>的 Issues：<a href="https://github.com/hexojs/hexo-renderer-markdown-it/issues/40">Cannot render headings with ids？</a></p>
<p><strong>方案二：修改代码</strong></p>
<p>如果安装插件仍然不行，那就只能手动更改目录渲染的 js 代码，具体过程可以参考这个大佬的：<a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">Hexo 博客踩坑</a>。</p>
<h2 id="二-超链接乱码">二、超链接乱码</h2>
<h3 id="1问题描述">1.问题描述</h3>
<p>这个问题的特征是渲染没问题，也就是不会有上面那种情况，但是点击目录链接会在控制台报错：<code>Cannot read property 'top' of undefined</code>。</p>
<p>我们打开控制台，查看目录的的超链接标签，会看到 href 是一串乱码：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201217163920205.png" alt="image-20201217163920205"><figcaption aria-hidden="true">image-20201217163920205</figcaption>
</figure>
<p>我们去找他对应的标题：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201217164207627.png" alt="image-20201217164207627"><figcaption aria-hidden="true">image-20201217164207627</figcaption>
</figure>
<p>实际上直接点击这个超链接是可以跳转的，但是点目录却不行。这是因为标题 id 是中文，但是目录的连接是中文乱码，代码里头的 JQuery 选择器拿着乱码是没法找到对应 id 的标题的。</p>
<h3 id="2解决方案">2.解决方案</h3>
<p>这个错误很明显，因为控制台已经告诉我错误代码在 <code>post-details.js</code>里了，顺着提示找到 <code>themes\next\source\js\src\post-details.js</code>，找到第 73 行为目录绑定点击事件的方法，会看到：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201217170155109.png" alt="image-20201217170155109"><figcaption aria-hidden="true">image-20201217170155109</figcaption>
</figure>
<p><code>targetSelector</code>就是对应标题的 id，我们在他被塞到选择器之前重新编码一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对获取到的url进行重编码</span></span><br><span class="line">targetSelector = <span class="built_in">decodeURI</span>(<span class="built_in">this</span>.getAttribute(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>然后 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> 重新跑一下，发现目录就正常了。</p>
<p>另外，在next6 里这个问题被修复了：<a href="https://github.com/theme-next/hexo-theme-next/issues/1547">点击文章中文目录跳转无法实现 #1547</a>。</p>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>进程线程，并行并发，同步异步，阻塞费阻塞</title>
    <url>/2020/06/27/%E6%9D%82%E4%B8%83%E4%B9%B1%E5%85%AB/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E8%B4%B9%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>最近接触了 java 并发编程，其中接触到了挺多的新名词：进程，线程，并行，并发，同步，异步，阻塞，非阻塞。其中大部分是其实是操作系统的概念，在这里先简单的提前了解一下，做一下区分。算是为操作系统做个预习。</p>
<h2 id="一-串行并行并发">一、串行，并行，并发</h2>
<h3 id="1名称解释">1.名称解释</h3>
<ul>
<li><p>串行：程序<strong>按顺序</strong>执行，同一时间只能执行一个程序，前一个执行完毕后才轮到后一个</p></li>
<li><p>并行：多个程序可以<strong>同时</strong>执行，宏观和微观上看程序都是同时执行</p></li>
<li><p>并发：同一时刻只有一条程序执行，但是多<strong>个进程被快速轮换</strong>执行，宏观上看是同时执行，微观上看只是把时间分成若干段，使多个进程快速交替的执行</p></li>
</ul>
<p><strong>并发与并行关注的是程序是否在同一时间内同时被执行</strong></p>
<p><img src="http://img.xiajibagao.top/并发与并行.png"></p>
<h3 id="2举个例子">2.举个例子</h3>
<ul>
<li>串行：你吃饭吃到一半，电话来了，你一直到吃完了以后才去接</li>
<li>并发：你吃饭吃到一半，电话来了，你接了电话聊了两句，停下来吃了两口饭，又拿起电话聊了两句</li>
<li>并行：你吃饭吃到一半，电话来了，你一边打电话一边吃饭</li>
</ul>
<p>另外：</p>
<blockquote>
<p>当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发（Concurrent）。</p>
<p>当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行（Parallel）。</p>
</blockquote>
<h2 id="二-进程与线程">二、进程与线程</h2>
<h3 id="1名称解释">1.名称解释</h3>
<ul>
<li>进程：程序程序的一次执行，<strong>是系统进行资源分配</strong>的基本单位，是操作系统结构的基础</li>
<li>线程：有时被称为轻量级进程，是程序执行流的最小单元。线程是进程中的一个实体，<strong>是被系统独立调度和分派的基本单位</strong></li>
</ul>
<p><strong>进程之间资源不共享，而线程之间资源共享（故引入锁以处理资源分配问题）</strong></p>
<h3 id="2举个例子">2.举个例子</h3>
<ul>
<li>进程：你开了一个迅雷，又开了一个QQ，这分别是两个进程</li>
<li>线程：你在QQ分别和好友a还有好友b聊天，这是QQ这个进程里的两个线程</li>
</ul>
<h2 id="三-同步与异步">三、同步与异步</h2>
<h3 id="1名称解释">1.名称解释</h3>
<ul>
<li><p>同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</p></li>
<li><p>异步，当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p></li>
</ul>
<p><strong>同步和异步关注的是消息通信机制</strong></p>
<h3 id="2举个例子">2.举个例子</h3>
<ul>
<li>同步：你去书店买本书，老板说帮你找一下，然后开始找，等到找到了再告诉你结果为止（返回结果）</li>
<li>异步：你去书店买本书，老板说帮你找一下找到再给你打电话（不返回结果），等他找到的就打电话给你（回调）</li>
</ul>
<h2 id="四-阻塞和非阻塞">四、阻塞和非阻塞</h2>
<h3 id="1名词解释">1.名词解释</h3>
<ul>
<li>阻塞：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</li>
<li>非阻塞：调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</li>
</ul>
<p><strong>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态</strong></p>
<h3 id="2举个例子">2.举个例子</h3>
<ul>
<li>阻塞：你去书店买书，立即买到了，或者没有立刻就走了，这就是非阻塞</li>
<li>非阻塞：你去书店买书，如果恰好书店没有，你就等一直等到书店有了这本书买到了才走，然后后排的人必须等你走了以后才能买书</li>
</ul>
]]></content>
      <categories>
        <category>杂七乱八</category>
      </categories>
      <tags>
        <tag>杂七乱八</tag>
      </tags>
  </entry>
  <entry>
    <title>《趣谈网络协议》读书笔记（一）：网络分层，IP与MAC</title>
    <url>/2020/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%EF%BC%8CIP%E4%B8%8EMAC/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>此文为极客时间<a href="https://time.geekbang.org/column/intro/85">趣谈网络协议</a>第一模块“通信协议综述”的学习笔记。</p>
<p>主要内容包括数据包在如何在层间传输， IP 地址与 MAC 地址的介绍，IP 地址的设置与分配。</p>
<h2 id="一-网络分层">一、网络分层</h2>
<h3 id="1数据包如何在层间流转">1.数据包如何在层间流转</h3>
<p>分层是一个复杂程序的必然趋势，因而复杂的网络协议就会有分层的要求。</p>
<p>以下图为例，下图描述了我们输入网址并回车后，整个大体的请求流程：</p>
<p><img src="http://img.xiajibagao.top/5c00f6e610f533d17fb4ad7decacc776.jpg" alt="img" style="zoom: 25%;"></p>
<p>我们知道，按 TCP/IP 的四层模型，HTTP 协议属于应用层。假设用伪代码代表不同层级间对数据包的处理流程，当我们从应用层发起请求时：</p>
<ul>
<li>从应用层进入传输层。经过 <code>send_tcp()</code>的处理，会加上 TCP 头，里面有端口；</li>
<li>从传输层进入网络层，经过 <code>send_layer3()</code>的处理，加上 IP 头；</li>
<li>从网络层进入数据链路层，经过 <code>send_layer()</code>的处理，加上目标 MAC 或网关 MAC。</li>
</ul>
<p>经过数据链路层传到目标主机后：</p>
<ul>
<li>从数据链路层进入网络层，经过 <code>process_layer2()</code>处理，解析获取目标 MAC；</li>
<li>若 MAC 符合，就从网络层进入传输层，经过 <code>process_layer3()</code>处理，解析获取 IP；</li>
<li>若 IP 符合，就从传输层进入应用层，经过 <code>process_tcp()</code>处理，解析获取 TCP 头，将数据包转发给 TCP 头中的端口；</li>
<li>监听端口的引用收到数据包，开始真正处理数据。</li>
</ul>
<h3 id="2如何理解分层">2.如何理解分层</h3>
<p>一个数据包被发出的过程从顶层到底层会不断的被打包，而接受的过程会不断的被拆包，这一过程其实就是添加信息和校验信息的过程。有点像包装商品，出厂包装写上名称和产地，然后发快递再装进纸箱，表明收件人和发件人，快递小哥根据目的地送到你家，然后再拆开纸箱确认东西是你要的。</p>
<h2 id="二-ip地址">二、IP地址</h2>
<h3 id="1如何获取ip">1.如何获取IP</h3>
<p>在 windows 中，通过 <code>ipconfig</code>可以获取 ip 地址，而在 Linux 中则是 <code>ifconfig</code>，此外，还可以通过 <code>ip addr</code>命令获取网卡信息，然后查看网卡对应的 ip 地址。</p>
<p>在一些精简的 Linux 系统中可能没有安装 net-tools 和 iproute2 工具，因此以上的命令都需要先安装该工具后才可以执行。</p>
<h3 id="2什么是-ip">2.什么是 IP</h3>
<p>IP 协议是 TCP/IP 协议中的核心，我们一般所说的 IP 即是指 IP 地址。在 TCP/IP 体系中，IP 地址就相当于网卡在网络中的通讯地址。</p>
<p>以 <code>10.100.122.2</code> 为例，我们最常见到的 IPv4 地址通常都是这样的的结构。</p>
<p>IP 地址由点分为4段，每段是8个 bit，因此一串 IP 地址就是 32位，由于后来联网设备越来越多，传统的32位的 IPv4 地址不够用，于是就有了 128 位的 IPv6 地址，他的格式是这样的：<code>fe80::f816:3eff:fec7:7975/64</code>，共 128 位。</p>
<h3 id="3ip地址的构成">3.IP地址的构成</h3>
<p><img src="http://img.xiajibagao.top/fa9a00346b8a83a84f4c00de948a5b5e.jpg" alt="img" style="zoom:33%;"></p>
<p>IP 地址被分为五类，其中 ABC 都由两部分组成：网络号+主机号。网络号表示网段，而主机号代表主机，加起来一串 IP 地址就是主机在某一网段内的地址。</p>
<p>但是实际上，由于位数的不同，决定了同一网段下最多第地址数量，换句话说，如果超过这个数量主机就拿不到 IP，就不能联网。其中，A 类最多可有 16777214 个地址，B 类可有 65534 个地址，而 C 类只可有最多 254 个地址。</p>
<p><img src="http://img.xiajibagao.top/6de9d39a68520c8e3b75aa919fadb24c.jpg" alt="img" style="zoom:33%;"></p>
<h3 id="4无类型域间选路cidr">4.无类型域间选路（CIDR）</h3>
<p>对于 A 类和 B 类地址，一般企业达不到这样的规模，地址会出现闲置，而 C 类地址又太少。因此就有了一个无类型域间选路（CIDR），也就是不再直接按固定类型划分 IP，而是通过斜杠来分割网络号与主机号，比如<code>10.100.122.2/24</code>这样的 IP，<strong>斜杠后24的意思是，在32位的地址中，前24位是网络号，后8位是主机号</strong>。</p>
<p>与 CIDR 一起出现的，是广播地址 <code>10.100.122.255</code>和子网掩码 <code>255.255.255.0</code>。</p>
<p><strong>广播地址就是如果发送数据到这个地址，那么统一网段下的所有地址都能收到</strong>。</p>
<p>而<strong>子网掩码则是用于通过与运算根据 IP 计算网络号</strong>。255转为二进制就是8个1，也就是1111111，换句话说，<code>255.255.255.0</code>转为二进制，前24位都为1，后8位都为0，将其与二进制的 IP 地址进行与运算，由于与运算要求都为1才为1，运算后第8位就一定会是0，最后得到的就是存粹的网络号。</p>
<h3 id="5共有ip和私有ip">5.共有IP和私有IP</h3>
<p>在局域网里面，我们可以自己分配 IP，因为 IP 只在局域网内使用，因此不同的局域网允许同时存在相同的 IP，但是从外部是无法访问私有的 IP 的，因为这个 IP 只在局域网有效，就像拿中国的地址去美国找人，是肯定找不到的。如果要是真正可以在任何地方都能访问的到的地址，需要去 IANA 申请。</p>
<p>一般，在局域网里，第一个地址往往就是出口设备的 IP 地址。比如 wifi 提供的家庭局域网通常地址是 <code>192.168.0.x</code>，这个一眼就能看出 <code>192.168.0.0</code>就是网络号，因而第一个 IP ，也就是 <code>192.168.0.1</code>一般就会是路由器地址，而<code>192.168.0.255</code>就会是广播地址。</p>
<p>我们在 Linux 上使用 <code>ip addr</code>命令，会出现如下显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:16:3e:06:5d:0f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.31.234/18 brd 172.17.63.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 289791687sec preferred_lft 289791687sec</span><br></pre></td></tr></table></figure>
<p>其中，eth0 网卡的 IP 后面有一个 scope global，表示 IP 作用范围是全局，外部可以通过该 IP 访问本机。而 lo 网卡的 scope 是 host，也就是仅能在在本机通讯。因此，lo 全程 loopback，又称回环接口，经操作系统内部处理后直接返回，不会在外部网络中出现。</p>
<h2 id="三-mac">三、MAC</h2>
<h3 id="1什么是mac">1.什么是MAC</h3>
<p>我们可以看到，<code>ip addr</code>命令展示的网卡信息里，eth0 的 IP 地址上有 <code>link/ether 00:16:3e:06:5d:0f brd ff:ff:ff:ff:ff:ff</code>一行，这个就是网卡的 MAC 地址，用十六进制，6 个 byte 表示。</p>
<p>MAC 的全程是 Media Access Control Address ，即媒体访问控制。它是网卡的物理地址，从生产的时候就带着这个地址，是唯一的。不过虽然如此，MAC 是不能取代 IP 的，因为 MAC 并没有导航定位功能，就像一个人的身份证，而你是不可能在寄快递的时候直接填收件人的身份证。</p>
<p>MAC 地址的<strong>主要作用是在局域网中作为设备的唯一标识</strong>，换句话说，只在一个子网内是可以光凭 MAC 找到对应设备的，比如从 <code>192.168.0.2/24</code> 访问 <code>192.168.0.3/24</code> 但是跨网络就不行了，比如去访问 <code>192.168.1.2/24</code> 。这就像你在一个房间里可以直接通过身份证找到人，放大到一个城市里就不行了。</p>
<h3 id="2网络设备的状态标识">2.网络设备的状态标识</h3>
<p><strong>网络设备状态标识</strong></p>
<p>还是上述的 <code>ip addr</code>展示的信息，我们可以在 eth0 看到 <code>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</code>，这个叫做<code>net_device flags</code>，即网络设备的状态标识。</p>
<ul>
<li>UP：表示网卡处于启动状态；</li>
<li>BROADCAST：表示网卡有广播地址，可以发送广播；</li>
<li>MULTICAST：表示网卡可以发送多播包；</li>
<li>LOWER_UP：表示 L1 是启动的，即插着网线；</li>
</ul>
<p><strong>最大传输单元</strong></p>
<p>除此之外，还能看到 <code>mtu 1500</code>，即最大传输单元 MTU 为 1500，这是以太网的默认值。</p>
<p><strong>排队规则</strong></p>
<p>即 <code>qdisc pfifo_fast state</code>，内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。</p>
<p>qdisc 又分为两类：</p>
<ul>
<li>pfifo：不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列；</li>
<li>pfifo_fast：分为三个 band，按优先级分别是 band0 到 band2，若数据包中有高优先级的就只处理高优先级的。数据包根据 IP 头中的 TOS（Type of Service） 字段分配到相应的 band 中。</li>
</ul>
<h2 id="四-如何配置ip">四、如何配置IP</h2>
<h3 id="1随意配置ip会带来什么问题">1.随意配置IP会带来什么问题</h3>
<p>还是在 Linux 系统中，假如我们可以自己设置 IP，然后使用以下命令配置网卡：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo ifconfig eth1 10.0.0.1/24;</span><br><span class="line">sudo ifconfig eth1 up;</span><br></pre></td></tr></table></figure>
<p>实际上，配置的 IP 是不一定能上网的。比如本机在 <code>192.168.0.x</code>网段，但是却设置为了 <code>10.168.0.5</code>，现在要发送给 <code>192.168.1.4</code>这台设备，实际上是发不出去的。</p>
<p>在 Linux 中，当我们要发送数据的时候，Linux 会先检测源 IP 与目标 IP 是否在同一网段，如果在同一网段，就会发送 ARP 请求获取 MAC 地址，但是如果不在同一网段，就会先先获取网关的 MAC 地址，然后将数据发给本网段的网关，然后本网段的网关转发给外网网关，网关上有 IP 与 MAC 的路由表，它根据路由表再把 MAC 填上，转发给对应的主机，主机收到后确认 MAC 是自己的，于是就接受数据包。</p>
<p>而在上面的例子中，因为本机在 <code>192.168.0.X</code>网段，因而网关必然也在该网段，设置为 <code>10.168.0.5</code>后，Linux 就会去 <code>10.168.0.x</code>网段找网关，<strong>然而这个网关实际上是不存在的，因此这次请求一直找不到目标 MAC，也就一直都没法发到目标主机</strong>。</p>
<h3 id="2什么是dhcp">2.什么是DHCP</h3>
<p>实际上，如果每次设备接入设备都需要手动配置 IP 是很不方便的，因此就有了动态分配 IP 的动态主机配置协议（DHCP）：管理员设置好一个网段，然后接入的机器就会直接获取一个 IP。</p>
<h2 id="五-dhcp的工作方式">五、DHCP的工作方式</h2>
<p><img src="http://img.xiajibagao.top/image-20201223162722289.png" alt="image-20201223162722289" style="zoom: 67%;"></p>
<h3 id="1主机发起申请">1.主机发起申请</h3>
<p>当一台主机加入网络时，它仍然未获取一个可用的 IP 地址，因此此时它的 IP 为 <code>0.0.0.0</code>。</p>
<p>首先，主机通过广播地址 <code>255.255.255.255</code>发送一个封装了 UDP 协议的广播包以申请可用 IP，这个 UDP 协议里头封装了 BOOTP 协议。我们管这个<strong>申请 IP 的请求叫做 Boot Request</strong></p>
<p>现在，本次请求的数据包格式是这样的：</p>
<p><img src="http://img.xiajibagao.top/90b4d41ee38e891031705d987d5d8481.jpg" alt="img" style="zoom:33%;"></p>
<h3 id="2server响应申请">2.Server响应申请</h3>
<p>如果管理员配置了 DHCP Server 的话，它就会响应这次请求，分配一个可用 IP，并且记录申请 IP 的主机的 MAC 以及 MAC 和 IP 的对应关系，以防止下一个主机申请到相同的 IP。</p>
<p>现在，DHCP Server 要发送数据包给申请 IP 的主机，这个数据包中会包括分配给主机的 IP，IP 的租用期限，子网掩码，网关等信息。我们管这个 <strong>DHCP Server 回复主机的响应叫做 Boot Offer</strong></p>
<p><img src="http://img.xiajibagao.top/a52c8c87b925b52059febe9dfcd6be6b.jpg" alt="img" style="zoom:33%;"></p>
<p><strong>注意，现在的 Boot Offer 可能会广播也可能会直接发送给主机，这取决于 IP 的数据头中的 BROADCAST 位是1还是0，1表示能接受，则单发，否则就广播</strong>。</p>
<h3 id="3主机回复响应">3.主机回复响应</h3>
<p>主机会收到 DHCP Server 发送的 Boot Offer，如果有多个 DHCP Server 则会受到多个 Boot Offer。一般主机会选择第一个接收到的 Boot Offer，并且在接受到以后继续通过 <code>255.255.255.255</code>广播发送 Boot Request，里面会有主机接受的 IP，MAC，提供 IP 的 DHCP Server 的 IP 等。</p>
<h3 id="4server接受响应">4.Server接受响应</h3>
<p>被拒绝的 DHCP Server 会取消分配的 IP 以供下一次使用，而被接受的 DHCP Server 会返回一个 DHCP ACK 消息包，表明收到主机同意的消息。</p>
<p><img src="http://img.xiajibagao.top/cca8b0baa4749bb359e453b1b482e1a9.jpg" alt="img" style="zoom:33%;"></p>
<h3 id="5主机设置ip">5.主机设置IP</h3>
<p>最终，主机收到了 DHCP Server 的响应，将自己的 IP 以及子网掩码等数据变更为 Server 提供的。</p>
<p>不过 IP 的租用是有期限的，当租期过去50%的时候，主机会主动发送 request，向 Server 申请新的配置数据。</p>
<h2 id="六-总结">六、总结</h2>
<p><strong>网络分层</strong></p>
<p>数据包发送的时候会从高层到底层一层一层的封装，而接收的时候会从最外层一层一层的拆解，一个完整的数据包，必然由外层协议包含内层协议。</p>
<p><strong>IP 地址</strong></p>
<p>IP 地址表示主机在网络中的位置，一般常见的 IPv4 地址表现为被点分割为4部分的12位数字，对应为32位二进制字符，即 <code>xxx.xxx.xxx.xxx</code>。</p>
<p>IP 地址由网络号与主机号构成，网络号表示同一网段，而主机号表示主机在子网中的位置，根据网络号长度分为 ABCDE 五类 IP。</p>
<p>由于默认分类使用不便，因而一般使用无类型的 CIDR IP 地址。CIDR 在 IP 尾端使用<code>/n</code>表示 IP 的后多少位为主机号，其余部分为网络号，比如 <code>xxx.xxx.xxx.xxx/8</code>即表示前24位为网络号，后8位为主机号。</p>
<p>CIDR 带来了子网掩码与广播地址。广播地址默认为网络号+255，比如<code>xxx.xxx.xxx.255/8</code>。而子网掩码默认为 255 + 0，比如 <code>255.255.255.0</code>就是 <code>xxx.xxx.xxx.255/8</code>的子网掩码，因为掩码与 IP 与运算后就能得到网络号。</p>
<p><strong>MAC 地址</strong></p>
<p>MAC 地址是网卡出厂自带的唯一物理标识，主机间发送数据需要同时有 IP 与 MAC，通过 IP 可以找到主机的网络位置并发送数据包，但是只有目标 MAC 与目标主机 MAC 相同才会真正的被接收。</p>
<p><strong>DHCP</strong></p>
<p>DHCP 用于动态分配 IP。当新机器加入时，默认 IP 为 <code>0.0.0.0</code>，先广播发送 boot request 获取 Server 的响应，Server 接收响应返回带有预分配的 IP 的 boot offer，主机接收后返回响应，Server 确认响应后再次发送相应数据，表明通过申请并记录信息，主机接收到 Server 确认响应后将 IP 改为申请 IP。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《趣谈网络协议》读书笔记（二）：局域网与交换机</title>
    <url>/2020/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>此文为极客时间<a href="https://time.geekbang.org/column/intro/85">趣谈网络协议</a>第二模块“从第二层到第三层”中，第一和第二节的学习笔记。</p>
<p>主要内容包括局域网 LAN 的建立，以及局域网间如何通过交换机建立拓补结构。</p>
<h2 id="一-如何建立一个局域网">一、如何建立一个局域网</h2>
<p>局域网 LAN 的全称为 Local Area Network，它其实就是一个小型的计算机网络系统，当我们搭建一个局域网，我们需要考虑这四个问题：</p>
<ul>
<li>设备间要怎么互相发送数据？</li>
<li>多个设备同时发送数据，那么发送顺序怎么安排？</li>
<li>如果数据发生过程中出现错误怎么办？</li>
<li>设备怎么知道数据是发送给自己的？</li>
</ul>
<h3 id="1物理层连接网线">1.物理层连接网线</h3>
<p>目前的网线一般有八根线组成，其中1,2起接收数据的作用，而3,6起发送数据的作用，我们将网线一端的1与3换位子，2与6换位子，然后将水晶头两端连接到电脑上，理论上两台电脑就具备了互相通信的物理基础（现在的电脑都具备自动适配的功能，理论上不换水晶头也不会有什么影响）。</p>
<p>当然，有了<strong>物理基础，我们还需要配置 IP 地址，子网掩码和默认网关，当配置好以后，两台电脑就会组成一个最小的局域网，即 LAN</strong>。</p>
<p>如果是多台设备，就需要一个交换机（相当于大学里头用的集线器）。多台设备连接到一个交换机上，当一个电脑发出数据的时候，Hub 会获取数据包并且广播给其他电脑。</p>
<p><strong>现在解决了“设备间要怎么互相发送数据”问题。</strong></p>
<h3 id="2mac策略控制发送顺序">2.MAC策略控制发送顺序</h3>
<p>现在我们有了一个局域网，两台电脑之间可以通过广播给另一台电脑发送数据。</p>
<p>但是如果有多台电脑，就需要一个中转站，也就是交换机。<strong>交换机处于数据链路层，这是一个第二层设备，我们发出的包在抵达网络层之前，需要在数据链路层封装 MAC 地址，因而第二层也叫 MAC 层</strong>。</p>
<p>广播频道是有限的，就需要区分一个先来后到，确定谁先发生数据，谁先等会。MAC 全称 Medium Access Control，即<strong>媒体访问控制。他主要解决设备之间数据发送顺序的问题</strong>。</p>
<p>假如将设备发送数据比作汽车上路，有三种策略：</p>
<ul>
<li><strong>信道划分</strong>：划分车道，你走你的，我走我的；</li>
<li><strong>轮流协议</strong>：限单双号，今天单号，明天双号；</li>
<li><strong>随机接入</strong>：先出门，发现堵车就回去，错峰出门。（以太网使用的就是随机接入策略。）</li>
</ul>
<p><strong>这样，就解决了“多个设备数据发送顺序”问题。</strong></p>
<h3 id="3循环冗余检测防止发生出错">3.循环冗余检测防止发生出错</h3>
<p>对于以太网，第二层的最后面是 CRC，也就是循环冗余检测。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误，</p>
<p><strong>这样，就解决了"数据发生过程中出现错误"问题</strong></p>
<h3 id="4网卡根据mac接收数据包">4.网卡根据MAC接收数据包</h3>
<p>现在，我们可以发送数据，并且也能确定好发送顺序了，接下来我们要解决接收问题。</p>
<p>现在，<strong>我们需要发送数据必然是知道目标 IP 的，而 IP 处于第三层，也就是网络层。</strong></p>
<p>一般有两种情况，即发送设备知道目标设备 MAC 地址与发送设备不知道目标 MAC 地址两种情况。</p>
<p><strong>发送设备知道目标设备 MAC 地址</strong></p>
<p>当数据通过广播进入数据链路层的时候，应当携带对应的链路层地址，也就是 MAC 地址。在网络包中，应当包含目标 MAC 地址和源 MAC 地址：</p>
<p><img src="http://img.xiajibagao.top/8072e4885b0cbc6cb5384ea84d487e41.jpg" alt="img" style="zoom:33%;"></p>
<p><strong>有了目标 MAC 地址，当数据包在链路上广播的时候，网卡发现目标 MAC 和自己的 MAC 相同，就会接收数据包</strong>，接着打开 IP 包，如果 IP 也是自己的，就再打开 TCP 包......依次直到转发给应用层的引用处理为止。</p>
<p>反之，如果机器要做出响应，就要反过来重复这个过程：数据封装的 TCP 包，TCP 包封到 IP 包，IP 包封装到 MAC 包，然后发送出去，接收机器的网卡根据 MAC 确认是不是自己的.......直到应用层处理完为止。</p>
<p><strong>发送设备不知道目标 MAC 地址</strong></p>
<p>当设备知道目标 IP，但是不知道目标 MAC 的时候，可以通过 ARP 协议来通过目标 IP 获取 MAC 地址。</p>
<p>而 <strong>ARP 协议就是广播设备目标设备的 IP，并且获得目标设备返回的 MAC</strong>，对应的，<strong>有一个功能相反的 RARP 协议，作用是广播 MAC 获取 IP</strong>。</p>
<p>现在通过 ARP 协议设备可以知道目标设备的 IP 了，而为了避免频繁的发起 ARP 请求，<strong>设备自己也会在请求后缓存 ARP 信息</strong>。由于机器可能会下线，因此 IP 与 MAC 的对应关系不一定不变，因此 ARP 缓存有一定的有效时间，过了会过期再请求一次。</p>
<p><strong>这样，就解决了"设备怎么知道数据是发送给自己的"问题</strong></p>
<h3 id="5路由器">5.路由器</h3>
<p>实际上，按照上面这些环节是可以建立一个局域网的，但是由于原始的交换机是无条件广播的，没有办法根据 IP 或者 MAC 定向发送数据，这样当设备一多，就会占用带宽，降低效率。并且，如果网络存在闭环，当一个设备发起 ARP 请求的时候，请求有可能再次回到交换机，然后进一步广播，如此反复形成广播风暴。</p>
<p>为此，我们需要交换机具有学习能力，就像路由器一样。<strong>而路由器是一个网络层设备，他可以直接记忆 IP 和 MAC 的对照关系，假如一个交换机可以做到这点，那么它其实就可以看做一个网络层设备，因此也叫三层交换机</strong>。我们以路由器为例，说明这个“学习”的流程：</p>
<p>在最开始的时候，机器发起 ARP 请求需要广播，把包发给所有连接路由器的机器，但是一次请求后它就会记住 MAC 来自于哪一个口，再发送请求的时候就不需要广播，而是定向发送。</p>
<p>当所有的机器都发送过 ARP 请求后，路由器就会记住整个网络结构，将网口和 MAC 的对应关系记录在具有一定过期时间的转发表中，过期时间内，所有的请求都可以得到定向转发，不必再广播。</p>
<h2 id="二-交换机与vlan">二、交换机与VLAN</h2>
<h3 id="1交换机与拓补结构">1.交换机与拓补结构</h3>
<p>在公司这样的场合，多个局域网一般会由多个交换机互相连接形成拓补结构：</p>
<p><img src="http://img.xiajibagao.top/0867321c36cc52bd3dd4d7622583fa29.jpg" alt="img" style="zoom: 25%;"></p>
<p>假如现在机器1需要发送消息给机器4，现在它只知道机器4的 IP，那么它就需要通过 ARP 请求获得机器4的 MAC。</p>
<ul>
<li>现在机器1发起了 ARP 请求，机器2收到了，但是 IP 不是它的，所以它没有动作；然后交换机 A 收到了这个 ARP 请求，现在它也不知道 IP 对应的 MAC 是多少，于是它把请求广播给其他设备或交换机。</li>
<li>现在 LAN2 中的机器3收到了，但是 IP 不是它的，因而它也没有动作。</li>
<li>然后交换机 B 收到了，他也不知道 IP 对应的 MAC，于是又在 LAN3 中进行广播，机器5没有动静，但是机器4发现要找的就是自己的 IP，于是发出响应，给出了 MAC，现在响应经过了交换机 A 和交换机 B，然后到达了机器1，于是一个 ARP 请求成功完成了。</li>
</ul>
<p>在响应过程中，<strong>交换机 A 和交换机 B 就知道了机器1和机器4的 IP 与 MAC对应关系，还有他们所在的位置</strong>。</p>
<p>假如现在机器2要请求机器1，由于交换机 A 已经知道机器1在 LAN1 中，因此只会在 LAN1 中广播。</p>
<p>随着 ARP 请求，交换机会逐渐了解整个拓补结构，减少不必要的广播，从而提高转发效率。</p>
<h3 id="2环路问题">2.环路问题</h3>
<p>当我们把两台交换机相连的时候，可能就会导致环路问题，比如机器1请求机器2：</p>
<p><img src="http://img.xiajibagao.top/1f909508a8253d4842ffe962883421ea.jpg" alt="img" style="zoom:25%;"></p>
<ul>
<li>机器1请求到达交换机 A，交换机 A 广播至 LAN2；</li>
<li>交换机 B 也在 LAN2，因此他也收到了广播，接着转发至 LAN1；</li>
<li>交换机 A 也在 LAN1，因此他也收到了广播，再次转发至 LAN2。至此，形成了循环</li>
</ul>
<p>同理，交换机 B 也会形成这个过程，因此一份请求会不断的在循环中变多。</p>
<p>实际上，交换机“记忆”拓补结构的能力在这里是失效的：</p>
<ul>
<li>当机器1请求机器2，请求先到达交换机A，此时交换机A记住了机器1在左边的网口；接着请求到达交换机B，交换机B也记住了机器1在左边的网口；</li>
<li>接着，交换机 A 广播请求到 LAN2，交换机 B 也收到了广播，因而认为机器1在右边的网口；然后交换机 B 广播到 LAN1，交换机 A 收到后也认为机器1 在左边。至此，形成了循环。</li>
</ul>
<h3 id="3stp协议解决环路问题">3.STP协议解决环路问题</h3>
<p>STP 即最小生成树，假如我们有一张无向量的图，每个节点之间的路径有不同的权重，我们打破图的环状结构，将其变为一课树，如果有一课树上节点之间所有路径的权重之和最小，那么这个树就是最小权重生成树，简称最小生成树。</p>
<p>我们比较熟悉的普利姆和克鲁斯卡算法就是用来生成最小生成树的，具体可以参考大佬的博文：<a href="https://blog.csdn.net/qq_35644234/article/details/59106779">数据结构--最小生成树详解</a>。</p>
<p>当交换机并入网络的时候回被分配到一个 ID，ID 有优先限级，当交换机节点相遇的时候，会互相发送 BPDU（网桥协议数据单元）比较优先级，优先级大的节点会成为优先级第的节点的父节点，反复比较后，最终会得到一个根节点。</p>
<p>根据此原则，有以下四种情况：</p>
<ul>
<li>父级节点相遇：优先级低的节点带领子级节点成为优先级高的父级节点的子级节点（收入门下）；</li>
<li>父级节点遇到自己的子级节点：说明形成了环，如果是该节点是孙子或者更低级的节点，并且该点直接到达父级节点的路径权值和小于通过他的上级节点到达父节点的路径权值，就会提升它的等级，将其直接变为自己的子节点；</li>
<li>父级节点遇到其他父级节点的子级节点：子节点会找到自己的父节点，最后跟这个父节点比较，然后走父节点相遇的流程；</li>
<li>子级节点相遇：子级节点相遇，会找到自己的父节点然后互相比较，走父级节点相遇的流程。</li>
</ul>
<p><strong>通过 STP 协议，我们就打破了环路，将原本的图状网络变为了树状</strong>。</p>
<p>不过 STP 虽好，但是也有问题：<strong>如果接入的机器非常多，或者网络请求比较慢，就会导致整个树生成的时间较长，如果生成树以后某个父级节点挂了，或者加入了新的节点，在等待重新生成 STP 的过程中是没法上网的</strong>。</p>
<h3 id="4局域网的隔离">4.局域网的隔离</h3>
<p>机器之间通过交换机互相连接形成 LAN，但是总有一些信息不方便完全共享，因此需要将一个大的 LAN 分割成多个小的 LAN。</p>
<p>隔离有两种方式，一种是<strong>物理隔离，即直接将局域网和交换机摘出去，改为通过路由器连接</strong>。</p>
<p>第二种是<strong>虚拟隔离，即虚拟局域网 VLAN，将一个连接在一个交换机上的机器划分为多个虚拟的局域网</strong>。</p>
<p>方法同一个 VLAN 里的机器，在发送数据包的时候会在 MAC 层的头中加上Tag，里面有一个 VLAN ID，默认为 12 位，也就是一个 VLAN 中最多允许 <code>2^12 = 4096</code> 个 IP。当交换机支持使用 VLAN 的时候，包经过 MAC 层转发到交换机，<strong>交换机会解析 Tag，只有 VLAN 相同的包才会互相转发</strong>。</p>
<p><img src="http://img.xiajibagao.top/ba720f6988558f95c381f4deaab11660.jpg" alt="img" style="zoom: 33%;"></p>
<p>而交换机之间有一个特殊的网口，叫做 Trunk 口，这两个口会转发所有的 VLAN 的包。</p>
<p><img src="http://img.xiajibagao.top/5c207a6e2c1c9881823b04e648f4ba4a.jpg" alt="img" style="zoom: 25%;"></p>
<h2 id="三-总结">三、总结</h2>
<p><strong>局域网的建立</strong></p>
<ul>
<li>物理层：首先，物理层的支持是必不可少的，比如网线。</li>
<li>数据链路层：当一台设备发送请求的时候，需要经过数据链路层——也就是 MAC 层的处理。数据包将在 MAC 层在头上添加源 MAC 与目标 MAC；设备发送数据需要确定先后顺序，这根据 MAC 层采用的三种 MAC 策略决定。在这之后，会进行循环冗余检测确保数据包是否成功发出。</li>
<li>网络层：假如一切顺利，那么数据包就会进入网络层，若不知道目标 IP 的 MAC，就需要先通过 ARP 请求获取目标 IP，再重复上述过程——比较需要注意的是， ARP 协议也是一个网络层协议。</li>
</ul>
<p>数据包会被路由器广播到各个 LAN，接着机器根据目标 MAC 是否是自己的来决定是否要接收数据包。</p>
<p><strong>交换机与路由器</strong></p>
<p>由于 ARP 需要在 LAN 中广播，若每次发送数据包都要进行 ARP 请求效率会非常低，因此交换机会在 ARP 请求后记录源机器和目标机器的位置与信息，当下次发起请求时，不再全局广播 ARP 请求，而是定向发送。</p>
<p><strong>环路问题与STP协议</strong></p>
<p>一般来说，公司的局域网都是以多台交换机组成的拓补结构，但是随着网络结构复杂程度的上升，可能会出现环路，对应的解决方法是将形成环的图结构根据 STP 协议转为最小生成树。不过在节点过多的时候生成 STP 可能会花费较多时间，而且如果每当新节点加入都需要重新生成 STP。</p>
<p><strong>VLAN</strong></p>
<p>要将一个大局域网分为多个小局域网，一种是划分物理局域网，一种是划分虚拟局域网，即 VLAN。</p>
<p>当一些机器处于 VLAN 中时，发送的数据包会在 MAC 层会在头中添加 Tag，而 Tag 中又包含了 VLAN ID，支持划分 VLAN 的路由器在转发数据包的时候，只会广播给 VLAN ID 相同的机器，而路由器间通过 Trunk 口互相连接，这个网口会广播所有的 VLAN 的包。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基本知识</title>
    <url>/2020/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>本文为阅读《趣谈网络协议》之前需要了解的一些基本概念与知识，包括 OSI 七层模型与 TCP/IP 四层模型，不同层级的作用，不同层级之间的主要协议等。</p>
<h2 id="一-为什么需要网络协议">一、为什么需要网络协议</h2>
<p>网络协议为计算机网络中进行数据交换而建立的规则、标准或约定的集合。</p>
<p>例如，网络中一个微机用户和一个大型主机的操作员进行通信，由于这两个数据终端所用字符集不同，因此操作员所输入的命令彼此不认识。为了能进行通信，规定每个终端都要将各自字符集中的字符先变换为标准字符集的字符后，才进入网络传送，到达目的终端之后，再变换为该终端字符集的字符。</p>
<h2 id="二-网络的分层模型">二、网络的分层模型</h2>
<h3 id="1网络的分层模型">1.网络的分层模型</h3>
<p>根据 OSI 提出的模型，计算机网络体系结构的通讯协议应当分为七层，而除了标准的 OSI七层模型以外，常见的网络层次划分还有 TCP/IP 四层协议以及 TCP/IP 五层协议，它们之间的关系如下：</p>
<p><img src="http://img.xiajibagao.top/image-20201223110909686.png" alt="image-20201223110909686" style="zoom: 67%;"></p>
<h3 id="2tcpip模型与osi模型">2.TCP/IP模型与OSI模型</h3>
<p>首先，<strong>TCP/IP 协议既不是 TCP 协议也不是 IP 协议，它是网络通信协议，即包括 TCP 协议和 IP 协议在内的一个网络协议体系</strong>，也是目前实际使用的通用网络协议体系。</p>
<p>OSI 提出了七层模型，而 TCP/IP 借鉴了并提出了自己的四层模型。</p>
<p>针对两者做一个区分：</p>
<ul>
<li><strong>从先后关系看</strong>：OSI 先引入了服务、接口、协议、分层的概念，TCP/IP 借鉴了 OSI 的这些概念建立 TCP/IP 模型。</li>
<li><strong>从使用上看</strong>：OSI 是一种理论下的模型，而 TCP/IP 模型被已被 TCP/IP 协议体系广泛使用，成为网络互联事实上的标准。</li>
</ul>
<h2 id="三-七层模型">三、七层模型</h2>
<h3 id="1功能划分">1.功能划分</h3>
<p>从下往上有：</p>
<ul>
<li><strong>物理层</strong>：物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输； <code>eg：RJ45等将数据转化成0和1；</code></li>
<li><strong>数据链路层</strong>：数据链路层通过物理网络链路􏰁供数据传输。不同的数据链路层定义了不同的网络和协 议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控; <code>可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；</code></li>
<li><strong>网络层</strong>：网络层负责在源和终点之间建立连接; <code>可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！</code></li>
<li><strong>传输层</strong>：传输层向高层提供可靠的端到端的网络数据流服务。 <code>可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；</code></li>
<li><strong>会话层</strong>：会话层建立、管理和终止表示层与实体之间的通信会话； <code>建立一个连接（自动的手机信息、自动的网络寻址）;</code></li>
<li><strong>表示层</strong>:：表示层提供供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息 可以被另一个系统应用层识别; <code>可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；</code></li>
<li><strong>应用层</strong>：OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等; <code>规定数据的传输协议；</code></li>
</ul>
<h3 id="2实际使用">2.实际使用</h3>
<p>假如我们有主机 A 和主机 B，现在他们需要发起通讯，现在根据七层模型有如下流程：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201223110933627.png" alt="主机之间发送数据"><figcaption aria-hidden="true">主机之间发送数据</figcaption>
</figure>
<p>可以看到，一个网络包从应用层开始，会一层一层的根据协议添加对应的数据，最后将网络包通过物理层传输到达另一主机，接着再从物理层开始，一层一层的解析网络包，最终发送给应用层。</p>
<h3 id="3不同层级对应的协议">3.不同层级对应的协议</h3>
<figure>
<img src="http://img.xiajibagao.top/image-20201223111234415.png" alt="来自https://www.cnblogs.com/Robin-YB/p/6668762.html"><figcaption aria-hidden="true">来自https://www.cnblogs.com/Robin-YB/p/6668762.html</figcaption>
</figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>趣谈网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次使用策略模式优化代码的经历</title>
    <url>/2020/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h2 id="一-背景">一、背景</h2>
<p>之前接手了一个 springboot 项目。在我负责的模块中，有一块用户注册的功能，但是比较特别的是这个注册并不是重新注册，而是从以前的旧系统的数据库中同步旧数据到新系统的数据库中。由于这些用户角色来自于不同的系统，所以我需要在注册的时候先判断类型（这个类型由一个专门的枚举类提供），再去调用已经写好的同步方法同步数据。</p>
<p>伪代码大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String type, String userId, String projectId, String declareId)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断用户类型</span></span><br><span class="line">    <span class="keyword">if</span> (UserSynchronizeTyeEnum.A.type.equals(type)) &#123;</span><br><span class="line">        <span class="comment">// 同步A类型的数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UserSynchronizeTyeEnum.A.type.equals(type)) &#123;</span><br><span class="line">        <span class="comment">// 同步B类型的数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不存在的用户类型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于用户的类型比较多，所以当我接手的时候已经有8个 if-esle 了，由于这个项目会逐步的跟其他平台对接，要同步的用户类型会越来越多，而且也不能排除什么时候不新增，反而要取消一部分类型的同步情况。</p>
<p>就这个情况来说，一方面<strong>每一次新增或删除类型都需要修改 if-else 上逻辑分支</strong>，如果需要新增一些同步前的处理的步骤（根据经验这种情况几乎一定会出现的），<strong>大概率代码会直接被加在 if-else 方法里头</strong>；另一方面，这个业务的需求也有相对稳定的地方：<strong>同步方法会不一样，但是一定会根据类型来判断</strong>。出于以上考虑，我决定趁现在牵扯范围不大的时候重构一下。</p>
<h2 id="二-思路">二、思路</h2>
<h3 id="1抽取策略接口和策略类">1.抽取策略接口和策略类</h3>
<p>首先，由于每种用户类型的同步方法是由各模块自己提供的，其实已经算是抽出了策略，只是没有实现一个统一的策略接口。</p>
<p>但是我在这一步遇上了问题：</p>
<ul>
<li>各模块的同步方法的名称不全部一样；</li>
<li>由于年代久远，旧代码是不允许改的。</li>
</ul>
<p>代码不让改，就没法通过为旧实现类新增接口实现多态，方法名不一样，那么反射这条路子也走不通。我想到了装饰器，为每个实现类新增一个装饰器类，注册的时候通过装饰器去调用同步方法，但是这样缺点很明显，会引入一个装饰器接口+n多个装饰器类，为了优化这一个方法，反而要引入十几个类，这样反而违背初衷。</p>
<p>但是好在天无绝人之路，他们并不是完全没有相同点：</p>
<ul>
<li>虽然参数名不一样，但是<strong>每个同步方法都需要的参数数量和类型都是一样</strong>的；</li>
<li><strong>他们都返回一个布尔值</strong></li>
</ul>
<p>这让我想起了 JDK8 的函数式接口，将策略接口改造为函数式接口，由于同步方法的参数和返回值类型都是一样的，就可以直接以 Lambda 表达式的形式将各个模块的同步方法放进去，这样就不需要改动模块的代码了。</p>
<p>新增的接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserSynchronizeSerivice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sync</span><span class="params">(String userId, String projectId, String declareId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2策略池的实现">2.策略池的实现</h3>
<p>接着，为了实现原本 if-else 的逻辑，我需要一个策略池，能够建立起一个用户类型跟对应的同步策略的映射关系，一开始，我打算直接写在 <code>register()</code>方法所在的类中加入以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AUserService aUserService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> BUserService bUserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, UserSynchronizeTyeEnum.IUserSynchronizeService&gt; synchronizeServiceStrategy = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">strategyInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// spring容器启动后将策略装入策略池</span></span><br><span class="line">    <span class="comment">// A类型用户的同步方法叫synchronization，而B类型用户的叫sync</span></span><br><span class="line">    synchronizeServiceStrategy.put(UserSynchronizeTyeEnum.A.type, aUserService::synchronization);</span><br><span class="line">    synchronizeServiceStrategy.put(UserSynchronizeTyeEnum.B.type, bUserService::sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样在添加新的用户类型时，需要先去枚举类添加新枚举，然后再回到<code>register()</code>所在的类为策略池添加策略，这个两个逻辑上相连的过程被分散到了两个地方，而且仍然要修改<code>register()</code>所在类的代码。所以决定不用上述的代码，而是去对枚举类下手。</p>
<p>原本的枚举类是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老系统用户注册，用户类型与同步方法的枚举类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserSynchronizeTyeEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型A的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    A(<span class="string">&quot;a&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型B的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    B(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    UserSynchronizeTyeEnum(String type) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了保证逻辑能够集中，我决定将添加策略这一过程一起放到到枚举类里，在添加枚举的时候就把策略一起放进去：</p>
<blockquote>
<p>注：下文的 SpringUtils 实现了 BeanFactoryPostProcessor 接口，是一个用于从 ConfigurableListableBeanFactory 获取对象的工具类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老系统用户注册，用户类型与同步方法的枚举类</span></span><br><span class="line"><span class="comment"> * 添加新类型时，需要将模块对应的同步方法一并放入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserSynchronizeTyeEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型A的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    A(<span class="string">&quot;a&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同步前，可以对A类型的用户数据进行一些其他处理</span></span><br><span class="line">        <span class="keyword">return</span> SpringUtils.getBean(AUserService.class).synchronization(userId, projectId, declareId);</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型B的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    B(<span class="string">&quot;b&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同步前，可以对B类型的用户数据进行一些其他处理</span></span><br><span class="line">        <span class="keyword">return</span> SpringUtils.getBean(BUserService.class).sync(userId, projectId, declareId);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserSynchronizeService synchronizeService;</span><br><span class="line"></span><br><span class="line">    UserSynchronizeTyeEnum(String type, IUserSynchronizeService synchronizeService) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.synchronizeService = synchronizeService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于由于枚举类已经相当于之前策略池的 Map 集合了，所以我们直接在里面添加一个 <code>getSynchronizeService()</code>方法，用于直接获取同步方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据枚举值获取对应同步方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;IUserSynchronizeService&gt; <span class="title">getSynchronizeService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (UserSynchronizeTyeEnum tyeEnum : UserSynchronizeTyeEnum.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tyeEnum.type.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.of(tyeEnum.synchronizeService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，策略池已经基本完成了，我们对原本的 if-else 中的同步方法进行在次封装，现在如果需要在同步前做些其他的处理也可以直接卸载 Lambda 里头，同步策略的具体实现不再与 <code>register()</code>方法有关，它变回了纯粹的用户同步/注册的方法。</p>
<p>但是我们不难发现，现在为策略接口添加实现的地方也变成了枚举类中，策略接口 <code>IUserSynchronizeService</code> 一般也不会被用在其他地方，因此不妨<strong>把策略接口也一并引入枚举类中，让他成为一个枚举类的内部接口</strong>。</p>
<p>现在，枚举类是这样的：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201121161017904.png" alt="策略模式的枚举类"><figcaption aria-hidden="true">策略模式的枚举类</figcaption>
</figure>
<p>枚举类堆外只暴露根据类型获取方法的<code>IUserSynchronizeService()</code> 方法，以及 A 和 B 两个枚举。</p>
<p>完整的 <code>UserSynchronizeTyeEnum</code>枚举类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老系统用户注册，用户类型与同步方法的枚举类</span></span><br><span class="line"><span class="comment"> * 添加新类型时，需要将模块对应的同步方法一并放入。待用户注册时，会遍历枚举对象并根据类型获取对应的同步方法执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">UserSynchronizeTyeEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型A的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    A(<span class="string">&quot;a&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同步前，可以对A类型的用户数据进行一些其他处理</span></span><br><span class="line">        <span class="keyword">return</span> SpringUtils.getBean(AUserService.class).synchronization(userId, projectId, declareId);</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型B的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    B(<span class="string">&quot;b&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 在同步前，可以对B类型的用户数据进行一些其他处理</span></span><br><span class="line">        <span class="keyword">return</span> SpringUtils.getBean(BUserService.class).sync(userId, projectId, declareId);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> IUserSynchronizeService synchronizeService;</span><br><span class="line"></span><br><span class="line">    UserSynchronizeTyeEnum(String type, IUserSynchronizeService synchronizeService) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.synchronizeService = synchronizeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据枚举值获取对应同步方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;IUserSynchronizeService&gt; <span class="title">getSynchronizeService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (UserSynchronizeTyeEnum tyeEnum : UserSynchronizeTyeEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tyeEnum.type.equals(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.of(tyeEnum.synchronizeService);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法需要符合函数式接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserSynchronizeService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">sync</span><span class="params">(String userId, String projectId, String declareId)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三-使用">三、使用</h2>
<p>现在，改造完毕，可以开始使用了，对于原先的 <code>register()</code>方法，现在改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String type, String userId, String projectId, String declareId)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取同步方法，没有就抛异常</span></span><br><span class="line">    UserSynchronizeTyeEnum.IUserSynchronizeService synchronizeService = UserSynchronizeTyeEnum.getSynchronizeService(type)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">&quot;类型不存在&quot;</span>));</span><br><span class="line">    <span class="comment">// 同步用户数据</span></span><br><span class="line">    synchronizeService.sync(userId, projectId, declareId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要再添加一个 C 类用户的同步注册的时候，只需要前往枚举类添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型C的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">C(<span class="string">&quot;c&quot;</span>, (userId, projectId, declareId) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> SpringUtils.getBean(CUserService.class).sync(userId, projectId, declareId);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>即可，<code>register()</code>方法就不需要再做修改了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工作见闻</tag>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（二）：策略模式</title>
    <url>/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<blockquote>
<p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
</blockquote>
<p>策略模式旨在解决不同逻辑下相同的对象执行不同策略的问题。</p>
<p>当我们遇到同一个方法，里面会根据需要多个逻辑的分支，分支里的行为都不同，但是都服务于同一个功能，这个时候就可以使用策略模式，将行为抽象为一个策略接口中的抽象方法，由接口的实现类——也就是策略类——去实现各中具体的行为。</p>
<p>策略模式也是一种比较常见且好用的设计模式，线程池的拒绝策略就使用了策略模式。</p>
<h2 id="一-简单实现">一、简单实现</h2>
<p>简单的拿一个根据情况需要导出不同文件的接口举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;excel&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 导出excel</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;word&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 导出word</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;pdf&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 导出pdf</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些分支里目的都是导出文件，但是各自有各的实现代码。换而言之，这些不同逻辑分支下的代码只有行为是不同的。现在我们将导出方法抽象成为一个策略接口中的抽象方法，将每个逻辑分支的处理代码都抽成实现策略接口的各个策略类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件导出接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">IExportFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">export</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportExcel</span> <span class="keyword">implements</span> <span class="title">IExportFile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 导出excel</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportWord</span> <span class="keyword">implements</span> <span class="title">IExportFile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 导出word</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportPdf</span> <span class="keyword">implements</span> <span class="title">IExportFile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 导出pdf</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用的时候直接将接口实现类作为参数传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改造原有方法，将策略接口的实现作为参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    IExportFile exportFile;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;excel&quot;</span>) &#123;</span><br><span class="line">        exportFile = <span class="keyword">new</span> ExportExcel();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;word&quot;</span>) &#123;</span><br><span class="line">        exportFile = <span class="keyword">new</span> ExportWord();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;pdf&quot;</span>) &#123;</span><br><span class="line">        exportFile = <span class="keyword">new</span> ExportPdf();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    exportFile.export();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，原本耦合在调用方法里的行为被解放出来了，通过为策略接口更换策略类，我们可以很方便的切换行为。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201120131208948.png" alt="策略模式改进原有方法"><figcaption aria-hidden="true">策略模式改进原有方法</figcaption>
</figure>
<h2 id="二-策略池与上下文对象">二、策略池与上下文对象</h2>
<p><strong>策略池</strong></p>
<p>根据上文的简单例子，我们将具体的策略通过策略接口与调用方法耦合了，但是我们不难发现，现在的<strong>实现仍然需要通过大量的 if-else 判断去选择执行策略</strong>。</p>
<p>实际上，我们可以这么考虑，代码被封装到实现类里以后，实际上一个<strong>策略跟对应的判断条件实际上就是一种 key 和 value 之间的映射关系</strong>了，我们可以根据这个思路，换一个更简洁一些的方式去替换 if-else 的代码：比如<strong>将条件字段与策略类放入 Map 集合实现的一个策略池中，直接通过 key 去获取对应的策略类</strong>。</p>
<p>还是基于上述导出接口的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略池</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;String,IExportFile&gt; exportStrategyPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;excel&quot;</span>, <span class="keyword">new</span> ExportExcel());</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;word&quot;</span>, <span class="keyword">new</span> ExportWord());</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;pdf&quot;</span>, <span class="keyword">new</span> ExportPdf());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!exportStrategyPool.containsKey(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    IExportFile exportFile = exportStrategyPool.get(type);</span><br><span class="line">    exportFile.export();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，通过策略池，我们直接简化了大量的 if-else 代码。</p>
<p>实际上，<strong>考虑到实现类是无状态的，那么策略类和策略池都应该是单例的</strong>，因此，这里使用了饿汉式去创建策略池，这里同样有许多优化的地方：比如可以手动创建改为通过反射自动装填策略类；可以创建枚举类或者将条件作为常量来规范策略的对应关系；如果在 spring 项目中，也可以考虑通过 spring 去创建......</p>
<p>这些的都可以根据需求进行优化的，但是核心仍然是在调用前<strong>建立条件与策略的映射关系</strong>。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201120140547234.png" alt="策略池的实现"><figcaption aria-hidden="true">策略池的实现</figcaption>
</figure>
<p><strong>上下文对象</strong></p>
<p>现在，出于优化 if-else 的原因，我们为导出方法加入了策略池，但是这个类的其他方法未必用得到，为此我们不妨将整个策略池和导出方法都封装到另一个单独的类里，只提供一个带条件参数的方法。现在策略池归上下文对象管理了，那么这个<strong>上下文对象也应该是单例的</strong>，就个人观点，单独放到一个独立的 Service 和对应一个实现类，由 spring 管理应该是比较合适的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileExporter 屏蔽了方法的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,IExportFile&gt; exportStrategyPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exportStrategyPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;excel&quot;</span>, FileExporter::exportExcel);</span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;word&quot;</span>, FileExporter::exportWord);</span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;pdf&quot;</span>, FileExporter::exportPdf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exportStrategyPool.containsKey(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        IExportFile exportFile = exportStrategyPool.get(type);</span><br><span class="line">        exportFile.export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">new</span> FileExporter().exportFile(<span class="string">&quot;word&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>通过 FileExporter 这个承上启下的上下文对象，我们屏蔽了具体代码的实现，同时通过“人”去调用“行为”这个逻辑也更符合面向对象的思想。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201120141054014.png" alt="上下文对象"><figcaption aria-hidden="true">上下文对象</figcaption>
</figure>
<h2 id="三-配合函数式接口使用">三、配合函数式接口使用</h2>
<p>策略模式+策略池的手段已经可以解决传统 if-else 的大多数问题了，但是他也随之带来了两个问题：</p>
<ul>
<li>一个方法要用到的策略会产生大量实现类；</li>
<li>业务逻辑被分散到了各个实现类，无法方便的总览。</li>
</ul>
<p>为此，JDK8 的函数式接口刚好能非常完美的解决这些痛点。</p>
<p>关于函数式接口，我已在<a href="https://blog.xiajibagao.top/2020/11/02/java/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JDK1.8新特性（三）：Lambda表达式</a>里介绍过了，这里就不再赘述，直接上手。</p>
<p>还是以上文的文件导出接口为例：</p>
<p>当我们完成这个功能以后，我们会在原来的基础上多处一个上下文对象，一个策略接口，<strong>以及 n 多个实现接口的策略类</strong>，一个策略对应一个策略实现类的问题是导致类数量膨胀的原因，因此我们可以将策略接口替换为函数式接口，这样就可以在需要的时<strong>直接通过 Lambda 表达式传入实现类，避免新建类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将原本的IExportFile改为函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IExportFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">export</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在策略池阶段直接放入匿名实现类</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;String,IExportFile&gt; exportStrategyPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;excel&quot;</span>, () -&gt; System.out.println(<span class="string">&quot;excel&quot;</span>));</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;word&quot;</span>, () -&gt; System.out.println(<span class="string">&quot;excel&quot;</span>));</span><br><span class="line">    exportStrategyPool.put(<span class="string">&quot;pdf&quot;</span>, () -&gt; System.out.println(<span class="string">&quot;excel&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，实际工作中的方法肯定比区区一句 <code>System.out.println()</code>要复杂的多，我们不可能集中在策略池里写实现。这个问题也很好解决，我们可以将具体的方法抽出来放到一个实现类里，比 service 的实现类，或者上下文对象中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,IExportFile&gt; exportStrategyPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exportStrategyPool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;excel&quot;</span>, <span class="keyword">this</span>::exportExcel);</span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;word&quot;</span>, <span class="keyword">this</span>::exportWord);</span><br><span class="line">        exportStrategyPool.put(<span class="string">&quot;pdf&quot;</span>, <span class="keyword">this</span>::exportPdf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exportStrategyPool.containsKey(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;错误的文件类型！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        IExportFile exportFile = exportStrategyPool.get(type);</span><br><span class="line">        exportFile.export();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 导出的策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出excel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出word&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportPdf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出pdf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，业务代码可以都放在一个类里面了，总览起来也非常方便。</p>
<h2 id="四-总结">四、总结</h2>
<p>通过策略模式，我们可以做到：</p>
<ol type="1">
<li>通过将行为抽象为一个策略接口，具体的行为作为接口的实现类，来分离方法和逻辑分支中的代码；</li>
<li>通过策略池来避免大量的 if-else 判断；</li>
<li>通过将策略池和方法封装到上下文对象来对外部屏蔽底层的实现；</li>
</ol>
<p>对于策略模式带来的策略类过多，业务逻辑分散的问题：</p>
<ol type="1">
<li>将策略接口改为函数式接口，省去创建实现类，直接通过 Lambda 表达式直接传入匿名实现类；</li>
<li>在上述基础上，将实现方法统一写在一个类里，策略池在创建时通过 Lambda 表达式把类中的方法传入策略池。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（一）：工厂模式</title>
    <url>/2020/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<blockquote>
<p>工厂模式（Factory Pattern）属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<p>工厂模式旨在与解决接口实现类选择这一类问题，让实例创建的代码使用实例的方法解耦。</p>
<p>当我们需要根据不同的明确条件下创建不同的实例的时候，就可以使用工厂模式。</p>
<p>工厂模式分为三类：</p>
<ul>
<li>工厂方法模式：一个工厂生产固定的一个类。</li>
<li>简单/静态工厂模式：一个工厂生产固定种类的多个类。</li>
<li>抽象工厂模式：一个抽象工厂生产一</li>
</ul>
<h2 id="一-工厂方法模式">一、工厂方法模式</h2>
<p>假设我们有一个导出报表的抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件导出接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Exporter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">export</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他现在有一个Excel导出实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Excel导出实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelExporter</span> <span class="title">extend</span> <span class="title">Exporter</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String modelPath;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出Excel:&quot;</span>+<span class="string">&quot;模板路径：&quot;</span>+ modelPath +<span class="string">&quot;文件名：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExcelExporter</span><span class="params">(String modelPath, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelPath = modelPath;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要在一个方法里去调用它，让客户可以导出报表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从配置中读取模板路径</span></span><br><span class="line">String modelPath = Config.getExcelModelPath();</span><br><span class="line"><span class="comment">//获取文件名</span></span><br><span class="line">String fileName = name + Config.getExcelLastName(); </span><br><span class="line">ExcelExporter ee = <span class="keyword">new</span> ExcelExporter(modelPath, fileName);</span><br><span class="line"><span class="comment">//一些其他业务逻辑</span></span><br><span class="line">... ...</span><br><span class="line">ee.export();</span><br></pre></td></tr></table></figure>
<p>我们在很多方法都需要调用这个类，但是每次使用都要写那么多行代码，实在太麻烦，而且万一忽然modelPath或者fileName这些参数要改，那工程量也很让人头痛。</p>
<p>所以我们可以把获取对象的操作提出来，把读取配置路径等方法都单独提出来，最后统一放到一个工厂类里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Excel文件导出实现类的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelExporterFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExcelLastName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Config.getExcelLastName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModePath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Config.getExcelModelPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExcelExporter <span class="title">getExporter</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExcelExporter(getModePath(),getExcelLastName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后使用的时候不需要在意实例化的过程，只需要调用方法获取新对象就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExcelExporterFactory factory = <span class="keyword">new</span> ExcelExporterFactory();</span><br><span class="line">factory.getExcelExporter().export();</span><br></pre></td></tr></table></figure>
<p>值得一提的是，由于工厂的特殊性，它大多数情况下都是单例的。</p>
<p>不难发现，工厂方法模式有以下优点：</p>
<ul>
<li>1:客户端不需要在负责对象的创建,<strong>明确了各个类的职责</strong>；</li>
<li>2:如果有<strong>新的对象增加</strong>,只需要<strong>增加一个具体的类和具体的工厂类</strong>即可；</li>
<li>3:<strong>不会影响已有的代码</strong>,后期维护容易,增强系统的扩展性。</li>
</ul>
<h2 id="二-简单静态工厂">二、简单/静态工厂</h2>
<p>工厂方法模式确实好，但是有时候我们需要用工厂生产的往往只有特定的几个类，其他的直接new就可以了。这种情况下在<strong>为每一个类单独创建一个工厂类太过麻烦，为此我们让一个工厂去生产固定的那几种类</strong>，这就是简单/静态工厂。</p>
<p>假设我们目前只需要导出Excel和word类型的报表，我们在上一个例子的基础上再加一WordExporter实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Excel导出实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordExporter</span> <span class="title">extend</span> <span class="title">Exporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String modelPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出Word！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordExporter</span><span class="params">(String modelPath, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelPath = modelPath;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们改造一下原本的ExcelExporterFactory，让他也能生产WordExporter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件导出实现类的简单工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExporterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExcelLastName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Config.getExcelLastName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModePath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Config.getExcelModelPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exporter <span class="title">getExporter</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据条件返回对应的实例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;word&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WordExporter(getModePath(),getExcelLastName());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;excel&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExcelExporter(getModePath(),getExcelLastName());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;导出类型不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们要调用的时候，直接通过工厂调用就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExporterFactory factory = <span class="keyword">new</span> ExporterFactory();</span><br><span class="line">factory.getExcelExporter(type).export();</span><br></pre></td></tr></table></figure>
<p>这个就是<strong>简单工厂</strong>。</p>
<p>在简单工厂的基础上，我们不难看出，现在的ExporterFactory总是只能生产固定的那几种类，那么其实调用<code>getExporter()</code>去获取实现类的时候根本没必要new一个新工厂。</p>
<p>于是我们将这个工程里的所有方法都变成静态方法，调用的时候就很方便了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExportService es = ExporterFactory.getExporter(type);</span><br></pre></td></tr></table></figure>
<p>这个就是<strong>静态工厂</strong>。</p>
<h2 id="三-抽象工厂模式">三、抽象工厂模式</h2>
<p>简单工厂对工厂方法做了减法，简化了代码结构，但是简单工厂违背了开闭原则，如果要添加新的产品，就需要修改工厂类代码。而传统的工厂方法模式，如果有很多产品的情况下又会创建过多的工厂类。</p>
<p>为此，我们对工厂方法模式做加法，就有了抽象工厂模式：由顶层的抽象工厂提供生产产品的接口，具体的生产过程由继承了抽象工厂的子工厂去实现。</p>
<p>举个例子：</p>
<p>根据上文，我们现在有了Exporter接口，和两个实现类ExcelExporter和WordExporter，现在我们有了新的需求：</p>
<p>导出的报表要分成两种类型：有数据的表格和没有数据的表格。（empty）</p>
<h3 id="1产品的抽象">1.产品的抽象</h3>
<p>我们先对产品进行抽象：</p>
<p>Exporter这个类不管是否有数据，都需要导出方法 <code>export()</code>，然后根据表格是否有数据，还需要一个方法 <code>empty()</code>。</p>
<p>我们将其分为由原本的ExcelExporter和WordExporter也变成抽象类，只实现各种的<code>export()</code>方法，然后再针对ExcelExporter和WordExporter再拆分，得到无数据表格类EmptyExcelExporter，EmptyWordExporter，有数据表格类FullExcelExporter，FullWordExporter。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200926191804858.png" alt="抽象工厂生产产品的抽象"><figcaption aria-hidden="true">抽象工厂生产产品的抽象</figcaption>
</figure>
<h3 id="2工厂的抽象">2.工厂的抽象</h3>
<p>由于产品的层级变成了三层，原本用于生产WordExporter和ExcelExporter的工厂ExporterFactory也要进行拆分。</p>
<p>将ExporterFactory变为接口，里面规定了<code>getExcelExporter()</code>和<code>getWordExporter()</code>两个接口方法，然后由EmptyExporterFactory还有FullExporterFactory工厂去</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200926192545919.png" alt="工厂类的抽象"><figcaption aria-hidden="true">工厂类的抽象</figcaption>
</figure>
<p>不难看出，抽象工厂通过多了一层抽象，减少了工厂类的数量，但是当要添加一类产品，比如加一个导出PDF类，同样要修改ExporterFactory及其实现类。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（三）：代理模式</title>
    <url>/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<blockquote>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
</blockquote>
<p>策略模式旨在不改变被代理对象的基础上进行方法增强。</p>
<p>当我们一个原有的类不能满足功能，又处于职责或其他原因不便修改的时候，我们可以使用代理模式。通过代理类去调用被代理类的方法，在原方法的基础上进行各种加强，又不会改变原代码。</p>
<p>spring 中的 AOP 就运用了代理模式。</p>
<h2 id="一-静态代理">一、静态代理</h2>
<p>为了简单的说明代理模式，我们举个例子：</p>
<p>首先有一个接口，叫做购房者，然后这个类地下有一个实现类，叫做小明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//购房者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 买房</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小明实现了购房者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> <span class="keyword">implements</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小明买了一套房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>买房子还要货比三家，小明没时间，于是就把买房子这件事情委托给中介</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intermediary</span> <span class="keyword">implements</span> <span class="title">Buyers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> XiaoMing xiaoMing ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小明把权限委托给了中介</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Intermediary</span><span class="params">(XiaoMing xiaoMing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.xiaoMing = xiaoMing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这基础上又添加了挑选方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;房中介先挑了最合适的房&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中介让XiaoMing这个类执行了购房的动作</span></span><br><span class="line">        xiaoMing.buy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这基础上又添加了抽成方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;买完房中介要那点抽成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="D:\代码及jar包\学习记录\设计模式\小明买房（静态代理）.png" alt="小明买房（静态代理）"><figcaption aria-hidden="true">小明买房（静态代理）</figcaption>
</figure>
<p>在这个例子里：</p>
<ul>
<li>被代理对象是小明这个类，是我们最终要访问的；</li>
<li>代理对象就是中介这个类，他是被代理对象的加强，我们通过代理对象去访问目标对象，在这基础上对其进行加强。</li>
</ul>
<p>为了做到代理的效果，代理对象和目标对象<strong>需要实现同一个接口或者继承同一个类</strong>，以达到通过代理对象的方法去调用被代理对象的方法。这种方法叫做<strong>静态代理</strong>。</p>
<h2 id="二-动态代理">二、动态代理</h2>
<p>通过静态代理，我们可以在不改变代理类代码的基础上进行方法增强，但是如果有很多这样的代理行为，那么就需要很多代理类或者代理类去实现很多接口的方法，这样做显然会来带麻烦，为此，我们可以选择只在需要的时候才生产代理对象，这就是动态代理。</p>
<p>针对动态代理，有两种实现方法：</p>
<ul>
<li>JDK 代理，通过 JDK 的 API 实现；</li>
<li>CGLib 代理，通过 CGLib 包实现。</li>
</ul>
<h3 id="1-jdk代理">1. JDK代理</h3>
<p>JDK 代理仍然需要被代理去实现某个接口，因为 JDK 代理的方式本质仍然还是生成一个与被代理类继承同一个接口的类，去代替被代理类的方法提供调用，但是和静态代理不同，这个代理对象由代码在调用的时候动态生成。</p>
<p>我们可以先看看实现代理效果的核心方法<code>Proxy.newProxyInstance()</code>的注释：</p>
<blockquote>
<p>返回指定接口的代理类的实例，该实例将方法调用分派到指定的调用处理程序。</p>
<p>参数：</p>
<p><code>ClassLoader loader</code>：指定加载被代理对象的类加载器</p>
<p><code>Class&lt;?&gt;[] interfaces</code>：被代理对象实现的接口的类型,使用泛型方式确认类型</p>
<p><code>InvocationHandler h</code>：事件处理,执行被代理对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</p>
</blockquote>
<p>我们需要提供三个参数，被代理类的类的加载器，被代理类实现的结构，一个代理方法要实现的函数式接口。</p>
<p>对于函数式接口 <code>InvocationHandler</code>，我们不妨再看看他的参数：</p>
<blockquote>
<p><code>proxy</code>：在方法上调用方法的代理实例method-与在代理实例上调用的接口方法相对应的Method实例。</p>
<p><code>Method</code>：对象的声明类将是在其中声明该方法的接口，它可能是代理类通过其继承该方法的代理接口的超接口。</p>
<p><code>args</code> ：包含在代理实例的方法调用中传递的参数值的对象数组；如果接口方法不带参数，则为null。基本类型的参数包装在适当的基本包装器类的实例中，例如java.lang.Integer或java.lang.Boolean。</p>
</blockquote>
<p>可以说非常直观了，下面我们来简单实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    XiaoMing xiaoMing = <span class="keyword">new</span> XiaoMing();</span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    Buyers proxyBuyers = (Buyers) Proxy.newProxyInstance(</span><br><span class="line">        <span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">        xiaoMing.getClass().getClassLoader(),</span><br><span class="line">        <span class="comment">//获取被代理对象实现的接口</span></span><br><span class="line">        xiaoMing.getClass().getInterfaces(),</span><br><span class="line">        <span class="comment">//让代理对象实现被代理对象实现的接口</span></span><br><span class="line">        (proxy, method, params) -&gt; &#123;</span><br><span class="line">            <span class="comment">//只有对buy方法进行加强，如果不是buy方法就直接执行被代理对象的方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.getName() != <span class="string">&quot;buy&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(xiaoMing, params);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;中介帮小明找到了最合适的房源&quot;</span>);</span><br><span class="line">            method.invoke(xiaoMing, params);</span><br><span class="line">            System.out.println(<span class="string">&quot;中介抽了一笔中介费&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//通过代理对象买房</span></span><br><span class="line">    proxyBuyers.buy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">中介帮小明找到了最合适的房源</span><br><span class="line">小明买了一套房</span><br><span class="line">中介抽了一笔中介费</span><br></pre></td></tr></table></figure>
<h3 id="2-cglib-代理">2. CGLib 代理</h3>
<p>对于动态代理，我们可以通过JDK的<code>Proxy.newProxyInstance()</code>方法动态的生成一个实现了被代理类指定接口的代理类，那么，如果<strong>被代理类没有实现任何接口</strong>，那我们该怎么办呢？答案就是使用 CGLib 代理。</p>
<p>CGLib 代理的原理就是在内存里创建一个被代理类的对象的子类，然后重写父类要加强的方法，而无需加强的方法就直接使用父类方法。</p>
<p>要使用 CGLib 代理，需要引入 jar 包 （ Spring 的动态代理就是基于 CGLib 实现的，所以 Spring 的依赖里默认就会引入）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们实现一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XiaoMing xiaoMing = <span class="keyword">new</span> XiaoMing();</span><br><span class="line"><span class="comment">//获取代理对象</span></span><br><span class="line">Buyers proxyBuyers = (Buyers) Enhancer.create(</span><br><span class="line">    <span class="comment">//获取被代理对象的类</span></span><br><span class="line">    xiaoMing.getClass(),</span><br><span class="line">    <span class="comment">//实现代理逻辑切入类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o 代理类对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> method 要拦截的被代理类的方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> objects 被代理类的方法参数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodProxy 要触发父类的方法对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName() != <span class="string">&quot;buy&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">//注意，这里参数是o，调用的是invokeSuper</span></span><br><span class="line">                <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;中介帮小明找到了最合适的房源&quot;</span>);</span><br><span class="line">            <span class="comment">//注意，这里参数是xiaoMing，调用的是invoke</span></span><br><span class="line">            methodProxy.invoke(xiaoMing, objects);</span><br><span class="line">            System.out.println(<span class="string">&quot;中介抽了一笔中介费&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">proxyBuyers.buy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般为了方便使用，我们会将代理过程整合到一个代理工厂类中。</p>
<p><strong>由于需要生成子类，所以要被代理的类最好不能用final修饰</strong></p>
<p><strong>如何选择代理模式</strong></p>
<ul>
<li>JDK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低。</li>
<li>如果是单例的代理，推荐使用CGLib</li>
</ul>
<p>也就是说，<strong>如果需要频繁的创建代理对象（多例），那么就该选择JDK代理，否则（单例）使用CGLib代理</strong></p>
<h2 id="四-总结">四、总结</h2>
<p>对于两种代理模式：</p>
<ul>
<li>静态代理：被代理类和代理类需要实现相同接口，通过组合的方式，在代理类实例化时将被代理类作为参数传入；</li>
<li>动态代理：通过 JDK 自带的 <code>Proxy.newProxyInstance</code>，在需要的时候动态生成代理类，解决了静态代理需要创建大量代理类的缺点；</li>
<li>CGLib 代理：通过 CGLib 动态生成被代理类的子类来实现代理，解决了动态代理还需要被代理类去实现接口的缺点。</li>
</ul>
<p>对于动态代理中 JDK 代理和 CGLib 代理的选择：</p>
<ul>
<li>需要频繁的创建代理对象选择 JDK 代理</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（四）：模板方法模式</title>
    <url>/2020/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<blockquote>
<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
</blockquote>
<p>模板方法模式旨在为一些方法的主体部分提供骨架，将具体细节上的一些实现延迟到他的实现类。</p>
<p>JDBC 运用了模板模式。JDK 在实现 List 接口的过程中， AbstractCollection 和 AbstractList 也使用了模板模式。</p>
<h2 id="一-简单实现">一、简单实现</h2>
<p>举个我在做项目的时候遇到的例子：</p>
<p>假设我们有一个简单的针对 Demo 类的文件导出类，他提供了 Excel 文档的基本导出功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoExcelExporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 导出excel</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Demo&gt; list = getData();</span><br><span class="line">        <span class="keyword">for</span>(Demo d : list) &#123;</span><br><span class="line">        	handle(d);</span><br><span class="line">        &#125;</span><br><span class="line">        excel(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.获取要到导出数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Demo&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 2.处理数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Demo demo)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 3.导出的数据集为excel文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excel</span><span class="params">(List&lt;Demo&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要为 Demo2 和 Demo3 这两个类也添加一个导出 Excel 文档的功能，最简单是方式就是复制黏贴，把 Demo 换成 Demo2 和 Demo3。但是这显然不是我们想要的，根据模板模式，我们可以设置一个 ExcelExporter 抽象类作为模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelExporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 导出excel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; list = getData();</span><br><span class="line">        <span class="keyword">for</span>(T t : list) &#123;</span><br><span class="line">            handle(t);</span><br><span class="line">        &#125;</span><br><span class="line">        excel(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取要到导出数据集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.处理数据集，改为抽象方法，由子类去实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(T demo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.导出的数据集为excel文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excel</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后由子类去继承这个模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Demo类的ExcelExporter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoExcelExporter</span> <span class="keyword">extends</span> <span class="title">ExcelExporter</span>&lt;<span class="title">Demo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Demo demo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demo的处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">new</span> DemoExcelExporter().export();</span><br></pre></td></tr></table></figure>
<p>其他两个类也分别创建自己的 ExcelExporter 类，通过继承模板，他们都直接获得了已经实现了大部分的逻辑的<code>export()</code>方法了，只需要自己再根据需求实现一下 <code>handle</code>方法即可。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201120171820576.png" alt="模板方法模式改进的ExcelExporter"><figcaption aria-hidden="true">模板方法模式改进的ExcelExporter</figcaption>
</figure>
<h2 id="二-模板的继承">二、模板的继承</h2>
<p>模板模式的强大之处在于，模板和模板之间可以通过继承来进一步增强现有的方法。</p>
<p>比如我们现在希望 Demo3 不仅要导出 Excel 模板，还要导出美化排版，我们可以在 ExcelExporter 的基础上继续新增模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BeautifyExportExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span>  <span class="title">ExcelExporter</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写了excel方法，在导出前可以先设置一些样式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excel</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        settingStyle();</span><br><span class="line">        <span class="keyword">super</span>.excel(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义要设置的样式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">settingStyle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 Demo3 不再继承 ExcelExporter ，而是去继承 BeautifyExporter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3ExcelExporter</span> <span class="keyword">extends</span> <span class="title">BeautifyExporter</span>&lt;<span class="title">Demo3</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Demo3 demo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Demo的处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">settingStyle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置样式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，BeautifyExporter 对 ExcelExporter 定义的逻辑进行了一定的调整，添加了可以设置样式的抽象方法，Demo3ExcelExporter 通过继承了 BeautifyExporter 获得了经过调整之后的 ExcelExporter 的逻辑和方法。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201120175032833.png" alt="调整之后的 ExcelExporter 的逻辑"><figcaption aria-hidden="true">调整之后的 ExcelExporter 的逻辑</figcaption>
</figure>
<h2 id="三-模板模式的特点">三、模板模式的特点</h2>
<h3 id="1可以修改实现仍然复用逻辑">1.可以修改实现仍然复用逻辑</h3>
<p>实际上，大多数时候我们会选择抽取工具类，比如上述的第一个例子，我们可以把 Demo 换成泛型，这样 Demo2 和 Demo3 也可以复用了。</p>
<p>但是有一个关键的问题：Demo2 和 Demo3 并不是同一个类，他们字段不同，导出中间有些的处理过程也不同，<strong>尽管他们的整体过程大体相同，但是有些地方的处理过程是不一样的</strong>。比如说 <code>getData()</code>和 <code>excel()</code> 这三个类都可用，但是 Demo 的 <code>handle()</code> 方法却不能复用在 Demo2 和 Demo3 。</p>
<p>我们可以妥协一下，只把 <code>getData()</code>和 <code>excel()</code> 提取成公共类，但是实际上整个导出过程的三个方法是连贯的，只提取两个方法，尽管<code>export()</code>中调用的顺序是定死的，最后实现的时候还是需要重复写无数个相同逻辑的<code>export()</code>，也就是说，<strong>我们只复用的方法，而没有复用逻辑</strong>。</p>
<p>所以根据上述的分析，我们可以看出，模板模式最大的优点在于<strong>使子类可以不改变一个算法的结构即可重定义该算法的某些步骤，这使得模板模式可以复用代码逻辑结构</strong>。因为模板父类已经定义好了整个方法执行流程，构建好了骨架和一些关键的步骤，所以子类只需要实现一些关键的步骤，并且根据需求去重写一些父类方法以调整逻辑。</p>
<h3 id="2扩展方便">2.扩展方便</h3>
<p>相对接口而言，如果接口是简答题，那么抽象类就是填空题。由于模板方法模式使用的是抽象类，业务的实现因此可以是“分步”的，整个功能是可以一层一层完善并且加强，或者做一些调整，这使得一套代码和逻辑可以在各个地方分层复用。</p>
<p>比如下图就是一个例子。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201120180913712.png" alt="image-20201120180913712"><figcaption aria-hidden="true">image-20201120180913712</figcaption>
</figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性（一）：Stream</title>
    <url>/2019/12/01/java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AStream/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
<p>元素流在管道中经过中间操作的处理，最后由最终操作得到前面处理的结果。</p>
<p><img src="http://img.xiajibagao.top/描述stream.PNG"></p>
<h2 id="二-举个例子">二. 举个例子？</h2>
<p>现在有一个字符串集合，我们需要过滤掉集合里头长度小于2的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strings)&#123;</span><br><span class="line">        <span class="comment">//如果长度大于2</span></span><br><span class="line">        <span class="keyword">if</span> (str.length() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//将字符串添加至新集合</span></span><br><span class="line">            stringList.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    strings = stringList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用stream实现一模一样的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    <span class="comment">//通过stream操作集合</span></span><br><span class="line">    strings = strings.stream()</span><br><span class="line">        <span class="comment">//去掉长度小于2的字符串</span></span><br><span class="line">        .filter(s -&gt; s.length() &gt;= <span class="number">2</span>)</span><br><span class="line">        <span class="comment">//转回集合</span></span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，使用streamAPI可以轻松写出更高效，更简洁，可读性更强的代码</p>
<h2 id="三-如何使用stream">三. 如何使用stream？</h2>
<p>简单的说，分两步：生成流，操作流</p>
<h3 id="1-生成流">1. 生成流</h3>
<p>Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， 不支持Map</p>
<p>1.1 Collection接口的stream()或parallelStream()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将Set或List集合直接转换为stream对象</span></span><br><span class="line">List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Stream&lt;Person&gt; personStream1 = personList.stream();<span class="comment">//生成串行流</span></span><br><span class="line">Stream&lt;Person&gt; personStream2 = set.parallelStream();<span class="comment">//生成并行流</span></span><br></pre></td></tr></table></figure>
<p>1.2 Stream.of()，Arrays.stream，Stream.empty()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArr = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream.empty()</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream.of() （方法内部调用的还是Arrays.stream）</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(strArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.stream</span></span><br><span class="line">Stream&lt;String&gt; stringStream2 = Arrays.stream(strArr);</span><br></pre></td></tr></table></figure>
<p>1.3 Stream.concat()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已有的对象</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.empty();</span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(strArr);</span><br><span class="line">Stream&lt;String&gt; stringStream2 = Arrays.stream(strArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个流</span></span><br><span class="line">Stream conStream1 = Stream.concat(stringStream,integerStream);</span><br><span class="line">Stream conStream2 = Stream.concat(stringStream,stringStream2);</span><br></pre></td></tr></table></figure>
<p>1.4 静态的Files.lines(path)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;D://test.txt&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; lines = Files.lines(file);</span><br></pre></td></tr></table></figure>
<h3 id="2-操作流">2. 操作流</h3>
<p>Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，可以在后头跟上其他中间操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接下来的示例代码基于此集合</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>2.1 filter(Predicate：将结果为false的元素过滤掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去掉长度小于2的字符串</span></span><br><span class="line">strings = strings.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt;= <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings</span></span><br><span class="line">[ab, bc, cd, abcd, jkl]</span><br></pre></td></tr></table></figure>
<p>2.2 map(fun)：转换元素的值，可以引用方法或者直接用lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//为每个字符串加上“？？？”</span></span><br><span class="line">    .map(s -&gt; s += <span class="string">&quot;？？？&quot;</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings</span></span><br><span class="line">[ab？？？, ？？？, bc？？？, cd？？？, abcd？？？, ？？？, jkl？？？]</span><br></pre></td></tr></table></figure>
<p>2.3 limit(n)：保留前n个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//保留前3个</span></span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings</span></span><br><span class="line">[ab, , bc]</span><br></pre></td></tr></table></figure>
<p>2.4 skip(n)：跳过前n个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//跳过前2个</span></span><br><span class="line">    .skip(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings</span></span><br><span class="line">[bc, cd, abcd, , jkl]</span><br></pre></td></tr></table></figure>
<p>2.5 distinct()：剔除重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//过滤重复元素</span></span><br><span class="line">    .distinct()</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings(过滤掉了一个空字符串)</span></span><br><span class="line">[ab, , bc, cd, abcd, jkl]</span><br></pre></td></tr></table></figure>
<p>2.6 sorted()：通过Comparable对元素排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//按字符串长度排序</span></span><br><span class="line">    .sorted(</span><br><span class="line">        <span class="comment">//比较字符串长度</span></span><br><span class="line">        Comparator.comparing(s -&gt; s.length())</span><br><span class="line">	)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings(过滤掉了一个空字符串)</span></span><br><span class="line">[, , ab, bc, cd, jkl, abcd]</span><br></pre></td></tr></table></figure>
<p>2.7 peek(fun)：流不变，但会把每个元素传入fun执行，可以用作调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//为字符串增加“？？？”</span></span><br><span class="line">    .peek(s -&gt; s += <span class="string">&quot;???&quot;</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(strings);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印strings，和map对比，实际并没有改变集合</span></span><br><span class="line">[ab, , bc, cd, abcd, , jkl]</span><br></pre></td></tr></table></figure>
<p>2.8 flatMap(fun)：若元素是流，将流摊平为正常元素，再进行元素转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将具有多重嵌套结构的集合扁平化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个两重集合</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;asd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bzxasdc&quot;</span>, <span class="string">&quot;cddsdsd&quot;</span>, <span class="string">&quot;adsdsg&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jvcbl&quot;</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lists.add(strings);</span><br><span class="line">lists.add(strings2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取将两重集合压成一层</span></span><br><span class="line">List&lt;String&gt; stringList = lists.stream()</span><br><span class="line">    <span class="comment">//将两重集合的子元素，即集合strings和strings2转成流再平摊</span></span><br><span class="line">    .flatMap(Collection::stream)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(stringList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印stringList</span></span><br><span class="line">[ab, , bc, cd, abcd, , jkl, asd, , bzxasdc, cddsdsd, adsdsg, , jvcbl]</span><br></pre></td></tr></table></figure>
<p>2.9 anyMatch(fun)，allMatch(fun)：判断流中的元素是否匹配 【最终操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//allMatch</span></span><br><span class="line">Boolean isAllMatch = strings.stream()</span><br><span class="line">    <span class="comment">//判断元素中是否有匹配“ab”的字符串，返回true或fals</span></span><br><span class="line">    <span class="comment">//判断元素中的字符串是否都与“ab”匹配，返回true或fals</span></span><br><span class="line">    .allMatch(str -&gt; str.equals(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(isMatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//anyMatch</span></span><br><span class="line">Boolean isAnyMatch = strings.stream()</span><br><span class="line">    <span class="comment">//判断元素中是否有匹配“ab”的字符串，返回true或fals</span></span><br><span class="line">    .anyMatch(str -&gt; str.equals(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;isAnyMatch：&quot;</span> + isAnyMatch);</span><br><span class="line">System.out.println(<span class="string">&quot;isAllMatch：&quot;</span> + isAllMatch);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">isAnyMatch：<span class="keyword">true</span></span><br><span class="line">isAllMatch：<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>2.10 forEach(fun)： 迭代流中的每个数据 【最终操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings.stream()</span><br><span class="line">    <span class="comment">//遍历每一个元素</span></span><br><span class="line">    .forEach(s -&gt; System.out.print(s + <span class="string">&quot;; &quot;</span>));</span><br></pre></td></tr></table></figure>
<p>2.11 collect()：返回结果集 【最终操作】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings = strings.stream()</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h2 id="四-使用intsummarystatistics类处理数据">四. 使用IntSummaryStatistics类处理数据</h2>
<h3 id="1-intsummarystatistics类">1. IntSummaryStatistics类</h3>
<p>IntSummaryStatistics类，在 java8中配合Stream使用，是用于收集统计信息（例如计数，最小值，最大值，总和和*平均值）的状态对象。</p>
<p>这个类长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSummaryStatistics</span> <span class="keyword">implements</span> <span class="title">IntConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntSummaryStatistics</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        sum += value;</span><br><span class="line">        min = Math.min(min, value);</span><br><span class="line">        max = Math.max(max, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(IntSummaryStatistics other)</span> </span>&#123;</span><br><span class="line">        count += other.count;</span><br><span class="line">        sum += other.sum;</span><br><span class="line">        min = Math.min(min, other.min);</span><br><span class="line">        max = Math.max(max, other.max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCount() &gt; <span class="number">0</span> ? (<span class="keyword">double</span>) getSum() / getCount() : <span class="number">0.0d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(</span><br><span class="line">            <span class="string">&quot;%s&#123;count=%d, sum=%d, min=%d, average=%f, max=%d&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">this</span>.getClass().getSimpleName(),</span><br><span class="line">            getCount(),</span><br><span class="line">            getSum(),</span><br><span class="line">            getMin(),</span><br><span class="line">            getAverage(),</span><br><span class="line">            getMax());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2使用">2.使用</h3>
<p>这个类的理解起来很简单，内部有这几个方法：</p>
<p>2.1 获取总条数：getCount()，</p>
<p>2.2 获取和：getSum()，</p>
<p>2.3 获取最小值：getMin()，</p>
<p>2.4 获取最大值：getMax()，</p>
<p>2.5 获取平均值：getAverage()</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">75</span>, <span class="number">32</span>, <span class="number">54</span>);</span><br><span class="line"></span><br><span class="line">    IntSummaryStatistics sta = integerList</span><br><span class="line">        .stream()</span><br><span class="line">        <span class="comment">//将元素映射为对应的数据类型（int,double,long）</span></span><br><span class="line">        .mapToInt(i -&gt; i)</span><br><span class="line">        <span class="comment">//转换为summaryStatistics类</span></span><br><span class="line">        .summaryStatistics();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;总共有 : &quot;</span>+ sta.getCount());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + sta.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + sta.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + sta.getSum());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span> + sta.getAverage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">总共有 : <span class="number">7</span></span><br><span class="line">列表中最大的数 : <span class="number">75</span></span><br><span class="line">列表中最小的数 : <span class="number">3</span></span><br><span class="line">所有数之和 : <span class="number">221</span></span><br><span class="line">平均数 : <span class="number">31.571428571428573</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性（三）：Lambda表达式</title>
    <url>/2020/10/30/java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>JDK8 为我们带来了 Lambda 表达式和函数式接口，这一点在前文介绍 Stream 和 Collectors 的时候已有提及。通过使用这些特性，我们可以更简洁的创建匿名内部类，也可以将方法作为参数直接传入方法中调用。本文将就这两点简要的总结一下 Lambda 的使用。</p>
<h2 id="一-函数式接口">一、函数式接口</h2>
<p>我们知道，java 中允许将接口作为方法的参数类型，但是我们只能传入其实现类。实际开发中，有些接口的仅有少数的方法，并且往往其实现类只在特定的地方使用，为此专门去创建一个新的实现类其实是有点繁琐的，为此 JDK8 引入了函数式接口。</p>
<p>函数式接口有且仅有一个抽象方法，抽象方法允许有一个默认实现（实际上接口的默认实现也是 JDK8 的新特性）。当我们调用方法时，<strong>可以直接通过 Lambda 表达式直接以匿名内部类的形式去实现他的方法</strong>。表现为直接在参数小括号中： <code>void test(param1, () -&gt; System.out.print("hello world"))</code></p>
<p>当使用作为方法参数类型是，通过在接口上添加<code>@FunctionalInterface</code>注解来声明。</p>
<p>我们举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将接口作为方法参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(TestInterface testInterface)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 有且仅有一个抽象方法</span></span><br><span class="line">    testInterface.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">test(()-&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>我们可以看到，实现的代码非常的简洁，对于一些不复杂的功能用起来非常方便，而如果使用原本的实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestInterface testInterface = <span class="keyword">new</span> TestInterface() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">test(testInterface);</span><br></pre></td></tr></table></figure>
<p>Lambda 写法的方便简洁可见一斑。</p>
<h2 id="二-lambda-表达式">二、Lambda 表达式</h2>
<h3 id="1语法">1.语法</h3>
<p>Lambda 表达式，也可称为闭包。一个典型的表达式由一对圆括号和括号中的参数，一个横杠加箭头，和一对大括号组成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123; System.out.println(<span class="string">&quot;hello world&quot;</span>)) &#125;</span><br></pre></td></tr></table></figure>
<p>实际上，表达式并不是所有时候都需要写的那么标准：</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<h3 id="2配合函数式接口使用">2.配合函数式接口使用</h3>
<p>Lambda 表达式需要配合函数式接口使用。</p>
<p>对于函数式接口，我们可以像上文举的例子一样，自己创建一个函数式接口，也可以使用 <code>java.util.function</code>包下已经提供好的函数式接口。</p>
<p><code>java.util.function</code>包提供了很多现成的接口，<a href="https://www.runoob.com/java/java8-functional-interfaces.html">菜鸟教程</a>上介绍的很详细，这里就不复制黏贴了。</p>
<p>现在，我们用用看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用自己的函数式接口</span></span><br><span class="line">TestInterface testInterface = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    System.out.println(i++);</span><br><span class="line">&#125;;</span><br><span class="line">testInterface.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 java.util.function 包的函数式接口</span></span><br><span class="line">IntFunction intFunction = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">System.out.println(intFunction.apply(<span class="number">15</span>));</span><br></pre></td></tr></table></figure>
<p>我们可以发现，对于我们自己的定义的接口，唯一的抽象方法是<code>test()</code>，所以放入实现以后实际上就是<code>test()</code>方法的实现，而 IntFunction 通过表达式实现的就是<code>apply()</code>方法。</p>
<p>其中，函数式接口总是有且仅有一个抽象方法，当作为参数使用的时候，通过 Lambda 表达式传入匿名方法默认就是实现这个唯一的抽象方法。另外，和正常的接口一样，函数式接口也允许拥有多个 default 修饰的默认实现方法。</p>
<h3 id="3变量作用域">3.变量作用域</h3>
<p>Lambda 实际上可以理解为一个匿名的内部类，<strong>他可以访问外部的变量，但是不可以对变量做出改变</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">IntFunction intFunction = x -&gt; &#123;</span><br><span class="line">    <span class="comment">// lambda表达式中使用的变量应该是final</span></span><br><span class="line">    i++; </span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure>
<p>上述这段代码会报编译错误，他会提示 lambda 表达式中使用的变量应该是 final。当然，我们删去 <code>i++</code>这行代码，让方法返回 <code>i + 1</code>就没影响了。可以见我们并不需要加 final 也可以。以前 java 的匿名内部类在访问外部变量的时候，外部变量必须用 final 修饰。在JDK8 对这个限制做了优化，可以不用显示使用final修饰，编译器自己隐式当成 final 来处理。</p>
<h3 id="4表达式的-this">4.表达式的 this</h3>
<p>我们可以通过一个简单的例子来了解一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">&quot;BeanA&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">private</span> String name = <span class="string">&quot;Runnable&quot;</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里的this指向匿名类:&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lambda表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这里的this指向当前的ThisDemo类:&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 这里的this指向匿名类:Runnable</span></span><br><span class="line"><span class="comment">// 这里的this指向当前的ThisDemo类:张三</span></span><br></pre></td></tr></table></figure>
<p>匿名内部类的 this 指向的是内部类自己，而 Lambda 表达式里的 <strong>this 实际上指向的是离他最近的那一层的外部类</strong>。</p>
<p>之所以这样，是因为当要编译 Lambda 表达式的时候，JVM会把 Lambda 表达式编译为一个<strong>在本类中的以lambda$+数字的方法</strong>。</p>
<p>值得一提的是，我们知道静态方法通过类调用，所以静态方法是获取不到 this 实例的，而Lambda 表达式会被编译为一个方法，<strong>如果表达式中使用了 this，那么就会编译为一个非静态方法，而未使用 this，就会编译为一个带 static 关键字的静态方法</strong>。</p>
<h2 id="三-方法引用">三、方法引用</h2>
<h3 id="1语法">1.语法</h3>
<p>方法引用通过方法的名字来指向一个方法，他使 Lambada 更加简洁易懂。</p>
<p>方法引用的写法类似这样 <code>类/实例::方法名</code>：</p>
<ul>
<li>引用静态方法/成员方法：Class::StaticMethod 或 Class::Method</li>
<li>引用成员方法：Instance::Method</li>
</ul>
<p>下面举个例子来说明一下这些引用方式的差异：</p>
<p>假如我们有这么一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(BeanA a)</span> </span>&#123;</span><br><span class="line">        System.out.println(a.getName() + <span class="string">&quot;被staticMethod输出了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;被instanceMethod方法输出了！this指向&quot;</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过方法引用来使用这些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.引用静态方法</span></span><br><span class="line">Consumer&lt;BeanA&gt; c = BeanA::staticMethod;</span><br><span class="line">c.accept(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过类引用成员方法</span></span><br><span class="line">Consumer&lt;BeanA&gt; c2 = BeanA::instanceMethod;</span><br><span class="line">c2.accept(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过实例引用成员方法</span></span><br><span class="line">Supplier&lt;String&gt; c3 = a::instanceMethod;</span><br><span class="line">c3.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">张三被staticMethod输出了！</span><br><span class="line">张三被instanceMethod方法输出了！<span class="keyword">this</span>指向<span class="number">45721950</span></span><br><span class="line">张三被instanceMethod方法输出了！<span class="keyword">this</span>指向<span class="number">45721950</span></span><br></pre></td></tr></table></figure>
<h3 id="2方法引用中的this">2.方法引用中的this</h3>
<p>我们可以在上述的例子中注意到一个很有趣的地方，<strong>成员方法使用了this，但是仍然可以通过跟静态一样的形式去调用，但是却需要传递一个方法参数，而通过实例去调用就不需要传入参数</strong>。</p>
<p><code>instanceMethod()</code>本身是个无参的方法，但是在第二中引用方式中却传递了 a 这个对象进去，我们是不是可以认为这就是被传入使用的 this？</p>
<p>我们再写一个方法作为对照：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入李四</span></span><br><span class="line">Consumer&lt;BeanA&gt; c2 = BeanA::instanceMethod;</span><br><span class="line">c2.accept(<span class="keyword">new</span> BeanA(<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="comment">// 传入张三</span></span><br><span class="line">Consumer&lt;BeanA&gt; c25 = BeanA::instanceMethod;</span><br><span class="line">c25.accept(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">李四被instanceMethod方法输出了！<span class="keyword">this</span>指向<span class="number">49685098</span></span><br><span class="line">张三被instanceMethod方法输出了！<span class="keyword">this</span>指向<span class="number">45721950</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，同样一个方法，传入了不同的实例，this 就指向了不同的实例。我们可以进一步推测，是不是跟 python 中的类的成员方法中的 self 一样，java 的成员方法也有一个 this 作为参数，只是平时编译器帮我们省略了呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动添加一个 this</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">(BeanA <span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数this指向&quot;</span> + <span class="keyword">this</span>.hashCode() + <span class="string">&quot;,关键字的this指向&quot;</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时可以发现，并不需要传入 this 这个参数</span></span><br><span class="line">a.testMethod();</span><br></pre></td></tr></table></figure>
<p>至此问题就明朗了，this 其实也是一个方法参数。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性（二）：Collectors收集器类</title>
    <url>/2019/12/01/java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ACollectors%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>上文我们介绍了JDK8新添加的Stream流接口，借助Stream配合拉姆达表达式，我们可以很方便的处理流对象。</p>
<p>针对流的聚合操作，Stream有一个对应的收集器类Collectors，通过Stream中的collect和collectingAndThen方法，我们可以借助收集器类聚合流中的数据，例如将元素累积到集合中，并根据各种标准对元素进行汇总，分类等操作。</p>
<h2 id="二-举个例子">二. 举个例子？</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取String集合</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">//通过stream操作集合</span></span><br><span class="line">List&lt;String&gt; stringList = strings.stream()</span><br><span class="line">    <span class="comment">//为集合中的每一个元素拼接“？？？”</span></span><br><span class="line">    .map(s -&gt; s += <span class="string">&quot;???&quot;</span>)</span><br><span class="line">    <span class="comment">//返回集合</span></span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>如代码所示，我们可以很方便的通过Collectors类对被处理的流数据进行聚合操作，包括并不仅限与将处理过的流转换成集合</p>
<h2 id="三-如何使用collectors">三. 如何使用Collectors？</h2>
<h3 id="1-collectors类中提供的方法">1. Collectors类中提供的方法</h3>
<p>总结一下，就是以下几类方法：</p>
<p>1.1 转换成集合：toList()，toSet()，toMap()，toCollection()</p>
<p>1.2 将集合拆分拼接成字符串：joining()</p>
<p>1.3 求最大值、最小值、求和、平均值 ：maxBy()，minBy()，summingInt()，averagingDouble()</p>
<p>1.4 对集合分组：groupingBy()，partitioningBy()</p>
<p>1.5 对数据进行映射：mapping()</p>
<h3 id="2-collectors类方法源码">2. Collectors类方法源码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Collectors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">                                                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接字符串，有多个重载方法                                  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter);   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                             CharSequence prefix,</span><br><span class="line">                                                             CharSequence suffix);      </span><br><span class="line">    <span class="comment">// 最大值、最小值、求和、平均值                                                         </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper);      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper);                   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组：可以分成true和false两组，也可以根据字段分成多组                                 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier);</span><br><span class="line">    <span class="comment">// 只能分成true和false两组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                                                          Collector&lt;? <span class="keyword">super</span> U, A, R&gt; downstream);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                                                     Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                                                     BinaryOperator&lt;U&gt; op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-实例">四. 实例</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接下来的示例代码基于此集合</span></span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;sd&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-将流数据转换成集合">1. 将流数据转换成集合</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换成list集合</span></span><br><span class="line">List&lt;String&gt; stringList = strings.stream().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成Set集合</span></span><br><span class="line">Set&lt;String&gt; stringSet = strings.stream().collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成Map集合</span></span><br><span class="line">Map&lt;String,Object&gt; stringObjectMap = strings.stream()</span><br><span class="line">    .collect(Collectors.toMap(k -&gt; k, v -&gt; v ));</span><br><span class="line"></span><br><span class="line">System.out.println(stringList);</span><br><span class="line">System.out.println(stringSet);</span><br><span class="line">System.out.println(stringObjectMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">[ab, s, bc, cd, abcd, sd, jkl]</span><br><span class="line">[ab, bc, cd, sd, s, jkl, abcd]</span><br><span class="line">&#123;sd=sd, cd=cd, bc=bc, ab=ab, s=s, jkl=jkl, abcd=abcd&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-将集合拆分拼接成字符串">2. 将集合拆分拼接成字符串</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//joining</span></span><br><span class="line">String str1 = strings.stream()</span><br><span class="line">    .collect(Collectors.joining(<span class="string">&quot;--&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//collectingAndThen</span></span><br><span class="line">String str2 = strings.stream()</span><br><span class="line">    .collect(Collectors.collectingAndThen(</span><br><span class="line">        <span class="comment">//在第一个joining操作的结果基础上再进行一次操作</span></span><br><span class="line">        Collectors.joining(<span class="string">&quot;--&quot;</span>), s1 -&gt; s1 += <span class="string">&quot;,then&quot;</span></span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">ab--s--bc--cd--abcd--sd--jkl</span><br><span class="line">ab--s--bc--cd--abcd--sd--jkl,then</span><br></pre></td></tr></table></figure>
<h3 id="3-求最大值-最小值-求和-平均值">3. 求最大值、最小值、求和、平均值</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值</span></span><br><span class="line">Integer maxValue = list.stream().collect(Collectors.collectingAndThen(</span><br><span class="line">    <span class="comment">//maxBy需要Comparator.comparingInt来确定排序规则</span></span><br><span class="line">    Collectors.maxBy(Comparator.comparingInt(a -&gt; a)), Optional::get</span><br><span class="line">));</span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">Integer minValue = list.stream().collect(Collectors.collectingAndThen(</span><br><span class="line">    <span class="comment">//minBy需要Comparator.comparingInt来确定排序规则</span></span><br><span class="line">    Collectors.minBy(Comparator.comparingInt(a -&gt; a)), Optional::get</span><br><span class="line">));</span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">Integer sumValue = list.stream().collect(Collectors.summingInt(i -&gt; i));</span><br><span class="line"><span class="comment">//平均值</span></span><br><span class="line">Double avgValue = list.stream().collect(Collectors.averagingDouble(i -&gt; i));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + maxValue);</span><br><span class="line">System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + minValue);</span><br><span class="line">System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + sumValue);</span><br><span class="line">System.out.println(<span class="string">&quot;平均数 : &quot;</span> + avgValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">列表中最大的数 : <span class="number">5</span></span><br><span class="line">列表中最小的数 : <span class="number">1</span></span><br><span class="line">所有数之和 : <span class="number">15</span></span><br><span class="line">平均数 : <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>虽然这样也可以，但是明显IntSummaryStatistics要更灵活点</p>
<h3 id="4-对集合分组">4. 对集合分组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; map = strings.stream()</span><br><span class="line">    <span class="comment">//根据字符串长度分组（同理，对对象可以通过某个属性分组）</span></span><br><span class="line">    .collect(Collectors.groupingBy(String::length));</span><br><span class="line"></span><br><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; map2 = strings.stream()</span><br><span class="line">    <span class="comment">//根据字符串是否大于2分组</span></span><br><span class="line">    .collect(Collectors.groupingBy(s -&gt; s.length() &gt; <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line">System.out.println(map2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">&#123;<span class="number">1</span>=[s], <span class="number">2</span>=[ab, bc, cd, sd], <span class="number">3</span>=[jkl], <span class="number">4</span>=[abcd]&#125;</span><br><span class="line">&#123;<span class="keyword">false</span>=[ab, s, bc, cd, sd], <span class="keyword">true</span>=[abcd, jkl]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5对数据进行映射">5.对数据进行映射</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = strings.stream().collect(Collectors.mapping(</span><br><span class="line">    <span class="comment">//先对集合中的每一个元素进行映射操作</span></span><br><span class="line">    s -&gt; s += <span class="string">&quot;,mapping&quot;</span>,</span><br><span class="line">    <span class="comment">//再对映射的结果使用Collectors操作</span></span><br><span class="line">    Collectors.collectingAndThen(Collectors.joining(<span class="string">&quot;;&quot;</span>), s -&gt; s += <span class="string">&quot;=====then&quot;</span> )</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=================打印结果=================</span></span><br><span class="line">ab,mapping;s,mapping;bc,mapping;cd,mapping;abcd,mapping;sd,mapping;jkl,mapping=====then</span><br></pre></td></tr></table></figure>
<p>。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.8新特性（四）：Optional类</title>
    <url>/2020/11/03/java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/JDK1.8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AOptional%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>针对我们熟悉又深恶痛绝的空指针异常 <code>NullPointException</code>，JDK8 新增了一个用于处理可能出现的空对象的类 Optionalt ，也就意味着。他可以理解为对对象的包装类，对原本的类进行了增强，结合 Lambda 表达式和函数式接口，我们可以安心的操作一些可能是 null 的对象，避免繁琐的空值检验。</p>
<p>举个例子：</p>
<p>我们常见过一些处理对象的方法，有些时候经常能见到这样的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;TestBean&gt; <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;TestBean&gt; bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些时候可能是try-catch块的限制，或者一些其他什么原因，我们的方法可能会返回一个 null，这样对于调用方来说，如果没有做空值检验就很有可能报 NPE，使用 Optional，我们可以<strong>显示的声明返回值可能是 null，并且返回一个 Option 类，调用方可以直接使用内置的方法进行处理</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;TestBean&gt; <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;TestBean&gt; bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line">TestClass.getBean().isPresent();</span><br></pre></td></tr></table></figure>
<h2 id="一-创建-optional-对象">一、创建 Optional 对象</h2>
<p>在开始了解如何创建 Optional 对象之前，我们要明确，和 Integer 一样，Option 分为类本身与成员变量 value，其中 value 是可能为 null。</p>
<p>创建 Optional 对象有三种方法：</p>
<ul>
<li><p><strong><code>Optional.empty()</code>方法</strong>：创建一个 value 为 null 的空值 Optional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>Optional.of()</code>方法</strong>：创建一个有默认值的 Optional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; defaultOptional = Optional.of(<span class="string">&quot;这是一个默认值&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>Optional.ofNullable()</code>方法</strong>：创建一个可能是空值的 Optional。当有值的时候等同于<code>Optional.of()</code>，无值的时候等同于<code>Optional.empty()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; nullableOption = Optional.ofNullable(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Optional 的构造器是私有的，即无法也不应该通过构造方法去创建一个 Optional 实例。</p>
<p>下文的示例将基于空值对象 emptyOptional，非空值对象 defaultOptional 进行演示，</p>
<h2 id="二-optional-基本使用">二、Optional 基本使用</h2>
<h3 id="1判空">1.判空</h3>
<ul>
<li><p><strong><code>isPresent()</code> 方法</strong>：判空用于判断 Optional 类所包装的 value <strong>是否非空</strong>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(emptyOptional.isPresent()); <span class="comment">// false</span></span><br><span class="line">System.out.println(defaultOptional.isPresent()); <span class="comment">// true</span></span><br><span class="line">System.out.println(nullableOption.isPresent()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>ifPresent()</code>方法</strong>：用于指定若值为不为空的情况下的处理方法，可以看做 <code>ifPresent()</code>用法的延伸</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">emptyOptional.ifPresent(s -&gt; System.out.println(<span class="string">&quot;这玩意不是null&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2获取值">2.获取值</h3>
<p>获取值的方法：</p>
<ul>
<li><p><strong><code>orElse()</code>方法</strong>：参数是一个变量，允许传入空值而不会报 NPE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(emptyOptional.orElse(<span class="keyword">null</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(emptyOptional.orElse(<span class="string">&quot;这是空的&quot;</span>)); <span class="comment">// 这是空的</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>orElseGet()</code>方法</strong>：参数是一个无参有返回值的函数式接口 Supplier，不允许传入空值，当传入空值的时候会报 NPE 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(emptyOptional.orElseGet(<span class="keyword">null</span>)); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">System.out.println(emptyOptional.orElseGet(() -&gt; <span class="string">&quot;aaa&quot;</span>)); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>
<p>由于Supplier是无参的，所以更推荐使用 <code>Class::method</code>这样形式的静态方法引用来传入方法。</p></li>
<li><p><strong><code>orElseThrow()</code>方法</strong>：与 <code>orElseGet()</code>方法有点像，不过在<strong>传入的一个抛出异常的方法</strong>，简而言之，就是如果空值就抛异常，传入 null 就抛出 NPE，否则就按传入的自定义异常的构造函数来跑异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(nullableOption.orElseThrow(<span class="keyword">null</span>)); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">System.out.println(nullableOption.orElseThrow(MyException::<span class="keyword">new</span>)); <span class="comment">// MyException</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>get()</code>方法</strong>：Option 的 <code>get()</code>是一个奇葩，当 value 是 null 的时候，他不会抛出 NPE，但是会抛出 <code>NoSuchElementException</code>，实乃脱裤子放屁之举。所以一般不通过 <code>get()</code>去取值，只在内部用于其他方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(emptyOptional.get()); <span class="comment">// java.util.NoSuchElementException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>orElse()</code>方法和 <code>orElseGet()</code>方法用法看起来有点相近，但是参数决定了两个方法使用场景的不同。</p>
<p>就我个人理解，<code>orElse()</code>适用于检验参数的非空，比如一些<strong>非必要参数可以通过该方法保证默认值</strong>；而<code>orElseGet()</code>因为传入的是一个函数式接口的实现，适用于在<strong>使用前需要对可能为空的值进行预选处理的场合</strong>，比如日志系统记录空查询这样的情况。</p>
<p>另外，值得一提的是，<code>toString</code>未尝不能看做是一种特别的取值行为。Optional 重写了 <code>toStirng()</code>方法，当 value 为 null 的时候返回的是字符串 "Optional.empty"，否则返回 "Optional[默认值]"形式的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空值打印 Optional.empty，否则打印 Optional[这是一个默认值]</span></span><br><span class="line">System.out.println(nullableOption.toString());</span><br></pre></td></tr></table></figure>
<h2 id="三-optional-过滤和转换">三、Optional 过滤和转换</h2>
<h3 id="1过滤">1.过滤</h3>
<p>Optional 提供了 <code>filter()</code>方法用于过滤数据。它和 Stream 的 <code>filter()</code>方法一样，都是使用了有一个参数返回boolean值的函数式接口 Predicate作为参数，通过 Lambda 表达式直接传入实现类，从而实现快速过滤的目的。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// emptyOptional里面字符串长度并没有大于5</span></span><br><span class="line">Optional&lt;String&gt; s = emptyOptional.filter(t -&gt; t.length() &gt; <span class="number">5</span>);</span><br><span class="line">System.out.println(s); <span class="comment">// Optional.empty</span></span><br><span class="line">System.out.println(s.isPresent()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>由于默认会进行一次判空，所以<code>filter</code>我们可以看成下面代码的简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (conditionStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (conditionStr.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        System.out.println(emptyStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2转换">2.转换</h3>
<p><code>map()</code>用于值的转换，这个方法同样与 Stream 的 <code>map()</code>异曲同工。通过传入拥有一个参数和一个返回值的函数式接口 Function 的实现类，从而实现 value 的转换。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defaultOptional的value为“这是一个默认值”</span></span><br><span class="line">Optional&lt;String[]&gt; s = defaultOptional.map(t -&gt; t.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">System.out.println(Arrays.toString(s.get())); <span class="comment">// [这, 是, 一, 个, 默, 认, 值]</span></span><br></pre></td></tr></table></figure>
<h2 id="四-总结">四、总结</h2>
<p>网上对 Optional 类的评价有褒有贬，公司里因为有专门用于处理各种类型的参数的空值工具类，所以也不太常见到过它。但是我在知乎上曾经看到过一个对 Optional 类的很贴切的总结：</p>
<blockquote>
<p>Optional的核心思想就是<strong>我明确告诉你可能会返回null</strong>，你一定要处理。所以，现在模块间提供给其他人的接口，如果有可能返回为null都要声明为Optional。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList与LinkedList遍历操作问题</title>
    <url>/2020/12/04/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ArrayList%E4%B8%8ELinkedList%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>一个 java 程序猿比较广为人知的小知识 ，是 ArrayList 和 LinkedList 最好使用迭代器删除，而不是遍历删除。</p>
<p>当我们尝试使用 for 循环或者 forEach 进行删除的时候，往往会出现一些意外的情况，导致集合全部删除失败。关于这点，我一直保持知其然不知其所以然的状态，刚好最近刚看完 ArrayList 和 LinkedList 的源码，今天这篇文章，就结合源码，总结一下 ArrayList 和 LinkedList 的几种错误删除。</p>
<h2 id="一-list-集合的-fast-fail-机制">一、List 集合的 fast-fail 机制</h2>
<p>在开始前，我们需要了解一下集合的 fast-fail 机制。</p>
<p>List 接口有一个 AbstractList 抽象类，List 下的所有实现类都直接或间接的继承了它。</p>
<p>在它的成员变量中，有一个变量叫 <code>modCount</code>，当实现类进行结构性操作的时候——一般指会影响底层数据结构的操作，比如删除——就会+1。</p>
<p>在每一个迭代器创建的时候，会从外部获取当前的 <code>modCount</code>赋给迭代器的成员变量 <code>expectedModCount</code>，然后每次调用迭代器的 <code>next()</code>方法，或者其他增删方法都会比较<code>modCount</code>和<code>expectedModCount</code>是否相等，否则就会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<p>这个并发修改检查可以在出现问题是时候快速抛出异常，避免可能错误的数据进入后续的操作。这也是集合操作中大部分 ConcurrentModificationException 异常的来源。</p>
<h2 id="二-arraylist-的-for-循环删除">二、ArrayList 的 for 循环删除</h2>
<p>ArrayList 的 <code>remove()</code>有根据下标删除与根据元素删除两种，后者每次删除必然需要先遍历集合，效率非常低，所以这里只讨论前者，也就是根据下标删除的方法。</p>
<h3 id="1实例">1.实例</h3>
<p>我们知道， ArrayList 底层实现是数组，他又实现了 RandomAccess 的接口，因此官方是推荐使用 for 循环去操作遍历集合的。但是<strong>当我们使用 for + 下标删除 ArrayList 中的元素时，会发生“漏删”的问题</strong>。</p>
<p>我们来模拟一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list); <span class="comment">// [b, d]</span></span><br></pre></td></tr></table></figure>
<p>可见，b 和 d 被跳过了。</p>
<h3 id="2原因">2.原因</h3>
<p>我们可以看看 ArrayList 中 <code>remove()</code>方法的源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到他调用了<code>fastRemove()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// modCount++</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否需要移动数组</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 拷贝并且移动数组</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>fastRemove()</code>方法里，<strong>调用了数组拷贝的方法 <code>System.arraycopy()</code>，他将删除位置后的数组整体前移一位</strong>。</p>
<p>我们来复原一下这个删除的流程：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201205093614320.png" alt="ArrayList for循环删除的流程"><figcaption aria-hidden="true">ArrayList for循环删除的流程</figcaption>
</figure>
<p><strong>简单的来说，我把 index = a 的元素删掉了，那么原本 index = a + 1 的元素就会跑到 index = a 的位置，当开始下一次循环的时候，我们以为删的是 indedx = a + 1 的元素，其实是 index = a + 2 的元素，索引发生了“偏移”，这就是“漏删”的原因。</strong></p>
<h3 id="3解决办法">3.解决办法</h3>
<p>要避免这种情况，有两种办法：</p>
<ul>
<li>每次索引偏移以后都手动把 index--；</li>
<li>想办法不让索引“偏移”，也就是不调用 <code>arraycopy()</code>方法。</li>
</ul>
<p><strong>第一种办法是在偶次操作前让 index--</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; i++, j++) &#123;</span><br><span class="line">    list.remove(j);</span><br><span class="line">    <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>实际上，这个思路也是 ArrayList 中迭代器的 <code>remove()</code> 思路，但是用 for 循环写出来的代码非常繁琐，而且不便于理解。</p>
<p><strong>第二种办法是倒序删除</strong></p>
<p>我们回去看看 <code>fastRemove()</code>，会看到这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 是否需要移动数组</span></span><br><span class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>numMoved = szie - 1 - index</code>决定了是否需要移动数组，也就是说，我们传入的 <code>index</code> 只要大于等于 <code>size</code>，就不会引起下标，那样我们可以倒序删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h2 id="三-arraylist-的-foreach-删除">三、ArrayList 的 forEach 删除</h2>
<h3 id="1实例">1.实例</h3>
<p>先说问题，ArrayList 在使用 <code>forEach()</code>循环删除的时候会抛异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    list.forEach(list::remove);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">    System.out.println(list); <span class="comment">// [b, c, d]</span></span><br><span class="line">    e.printStackTrace(); <span class="comment">// ConcurrentModificationException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在删除第二个元素的时候，这段代码抛异常了。</p>
<h3 id="2原因">2.原因</h3>
<p>ArrayList 的 forEach 方法来自 Collection 的父接口 Iterable，Iterable 的默认显示方式是增强 for 循环，而 ArrayList 重写了这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="comment">// 获取当前 modCount</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="comment">// 每次循环开始前检查 modCount</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forEach()</code>开始就使用 <code>expectedModCount</code> 记录了方法开始时的 <code>modCount</code>，然后每次循环的时候和循环结束的时候都会判断 <code>modCount == expectedModCount</code>， 我们回头看看 ArrayList 的 <code>remove()</code>方法，会看到在 <code>fastRemove()</code>中开始就让 <code>modCount++</code>了，因此我们不难推断出这整个流程：</p>
<ul>
<li><code>forEach()</code>，方法调用，此时<code>expectedModCount = modCount = 0</code>；</li>
<li>进入 for 循环，判断 <code>expectedModCount = modCount</code>通过，进行第一次遍历</li>
<li><code>action.accept()</code>中我们使用 lambda 表达式传入了 <code>remove()</code>方法，此时删除了第一个元素，并且 <code>modCount++</code>。现在 <code>modCount=1</code></li>
<li>判断<code>expectedModCount = modCount</code>不通过，跳出循环</li>
<li>判断 <code>modCount != expectedModCount</code>通过，抛出异常</li>
</ul>
<p>也就说，<strong>不止是删除，所有会导致 <code>modCount</code>增加的方法，都不可以在 <code>forEach()</code>中使用</strong>。</p>
<p>我们可以使用 <code>add()</code>检验看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    list.forEach(list::add); <span class="comment">// [a, b, c, d, a]</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    e.printStackTrace(); <span class="comment">// ConcurrentModificationException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-arraylist-的迭代器删除">四、ArrayList 的迭代器删除</h2>
<p>使用<strong>迭代器的方法删除是没问题的，但是如果在迭代器迭代过程中，调用了非迭代器的方法，就会出问题</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        String s = (String) iterator.next();</span><br><span class="line">        <span class="comment">// 使用非iterator的方法删除</span></span><br><span class="line">        list.remove(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">    System.out.println(list); <span class="comment">// [b, c, d]</span></span><br><span class="line">    e.printStackTrace(); <span class="comment">// ConcurrentModificationException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到抛异常了，但是把 <code>list.remove()</code>换成 <code>iterator.remove()</code>就没问题。</p>
<p>我们可以看看 <code>iterator.remove()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用外部的remove方法</span></span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取最新的 modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明显的，相比直接调用外部 <code>remove()</code> ，迭代器内部的 <code>remove()</code>在调用外部的 <code>remove()</code>以后，又更新了 <code>expectedModCount</code>，这个 <code>expectedModCount</code>是个迭代器内部的成员变量，在构造方法执行的时候从外部获取 <code>modCount</code>并赋给他，每一次调用迭代器的 <code>next()</code>方法前都会比较 <code>expectedModCount</code> 和 <code>modCount</code>，如果不相等就会抛异常。</p>
<p>至此问题就明了了，<strong>当我们不使用迭代器内部的 <code>remove()</code>删除节点的时候，<code>modCount</code>更新了，但是<code>expectedModCount</code>，因而在迭代第二个元素的时候就会抛出 ConcurrentModificationException 异常</strong>。</p>
<p>换句话说，和 <code>forEach()</code>一样，并不是只有 <code>remove()</code>才会引起如此问题，<strong>在迭代器迭代过程中，调用任何外部会导致 <code>modCount</code>改变的方法都会使其抛异常。</strong></p>
<h2 id="五-linkedlist-的-for-循环删除">五、LinkedList 的 for 循环删除</h2>
<p>LinkedList 的 for 循环删除也会导致“漏删”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list); <span class="comment">// [b, d]</span></span><br></pre></td></tr></table></figure>
<p>和 ArrayList 的 for 循环删除出错的原因一样，也是因为索引发生了“偏移”。但是和 ArrayList 不一样的是，由于 LinkedList 底层实现是链表，所以他不是通过 <code>arraycopy()</code>方法，而是直接解除了前后节点的引用关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法和 ArrayList 一样，只要避免循环中索引“偏移”即可，ArrayList 中<strong>手动 index-- 和倒序删除两种办法对他同样适用</strong>。</p>
<h2 id="六-linkedlist-的-foreach-删除">六、LinkedList 的 forEach 删除</h2>
<p>ArrayList 中的 <code>forEach()</code>是重写了 Iterable 接口的 <code>forEach()</code>方法，但是 LinkedList 中没有重写，所以 LinkedList 的 <code>forEach()</code> 使用的仍然还是 Iterable 接口中提供的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用增强 for 循环遍历数组的时候，最终编译以后得到的是 for + 下标的普通 for 循环，而遍历集合则会编译为迭代器版的循环。因此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach</span></span><br><span class="line">list.forEach(list::remove);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强for</span></span><br><span class="line"><span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">    list.remove(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">Iterator&lt;T&gt; iterator = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    list.remove(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面三种写法是等价的。在 LinkedList 中， forEach 遍历和迭代器遍历是等价的，前者到最后还是用的迭代器。而实际上，当我们看到迭代器里面的 <code>list.remove()</code>就应该明白 LinkedList 的 <code>forEach()</code>为什么会抛异常了。</p>
<p>和 ArrayList 的迭代器删除一样，<strong>由于调用的是外部的 <code>remove()</code>导致<code>modCount</code>改变，而<code>expectedModCount</code>没有改变，因此在调用<code>next()</code>的时候会因为过不了 <code>expectedModCount = modCount</code>而抛出 ConcurrentModificationException 异常</strong>。</p>
<h2 id="七-总结">七、总结</h2>
<p><strong>为什么有时候会抛出 ConcurrentModificationException 异常？</strong></p>
<p>List 集合中存在并发修改检查机制，AbstractList 提供 <code>modCount</code>字段，当使用 <code>add()</code>或者 <code>remove()</code>这样结构性操作的方法时，会让 <code>modCount + 1</code>。List 实现类的迭代器在创建的时候，都会使用成员变量 <code>expectedModCount</code> 记录当前的 <code>modCount</code>，<strong>每次调用 <code>next()</code>的时候都会检查最新的 <code>modCount</code>与 <code>expectedModCount</code>是否相等，否则就抛出 Con0currentModificationException 异常</strong>。</p>
<p>因此，只有调用迭代器内部提供的方法，才会同步更新<code>expectedModCount</code>，否则只会更新<code>modCount</code>。<strong>所以 ArrayList 与 LinkedList 在迭代器迭代过程中增删会抛异常</strong>。</p>
<p>ArrayList 重写了 <code>forEach()</code>方法，从增强 for 改为了普通的 for 循环，但是<strong>在方法最开始也记录了<code>modCount</code>，每次循环都会对比，因此也会因为在循环中改变了 <code>modCount</code>而抛异常</strong>。</p>
<p>LinkedList 未重写 <code>forEach()</code>方法，<strong>底层仍然使用增强 for，编译后还是迭代器，因此抛异常的原因同迭代器中操作</strong>。</p>
<p><strong>为什么普通 for 循环删除会“漏删”？</strong></p>
<p>ArrayList 的删除底层是使用 <code>arraycopy</code>方法生成了一个新数组，新数组上被删除节点以后的全部元素都会前移一位，导致了索引的“偏移”，因此删除了 a，那 a+1 的元素就会调到 a 的位置，下一次删除 a + 1 实际上是删除 a + 2，因此 a + 1 就被跳过了。</p>
<p>LinkedList 是链表，但是删除一个节点也会导致后一个节点“补到”被删除节点的下标对应的位置，因此同样也会因为索引“偏移”而出现“漏删”的情况。</p>
<p>解决方法是有两种，一种是在删除元素以后让索引继续指向当前位置，另一种是倒序删除。</p>
<p>其实如果添加元素的话也会有问题，虽然能够添加成功，但是不会按照指定的顺序插入，这也是因为上面这个原因。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>杂七乱八</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（七）：LinkedHashMap</title>
    <url>/2020/12/21/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9ALinkedHashMap/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>LinkedHashMap 是 Map 接口下一个线程不安全的，允许 null 的，基于哈希表的实现。它是 HashMap 的子类， 由于引入了双向链表的数据结构，除了拥有 HashMap 的所有特征外，他还可以以双向链表的方式操作和访问，并且提供按插入顺序或访问顺序两种顺序访问方式。</p>
<p>由于结构的特殊性，通过 LinkedHashMap，我们可以非常便捷的实现一个基于 LRU 算法的缓存容器。</p>
<blockquote>
<p>这是关于 java 集合类源码的第七篇文章。往期文章：</p>
<ol type="1">
<li><a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a><br>
</li>
<li><a href="https://blog.xiajibagao.top/2020/11/27/java/集合类源码分析/java集合源码分析（二）：List与AbstractList/">java集合源码分析（二）：List与AbstractList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/02/java/集合类源码分析/java集合源码分析（三）：ArrayList/">java集合源码分析（三）：ArrayList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/03/java/集合类源码分析/java集合源码分析（四）：LinkedList/">java集合源码分析（四）：LinkedList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/07/java/集合类源码分析/java集合源码分析（五）：Map与AbstractMap/">java集合源码分析（五）：Map与AbstractMap</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/16/java/集合类源码分析/java集合源码分析（六）：HashMap/">java集合源码分析（六）：HashMap</a></li>
</ol>
</blockquote>
<h2 id="一-linkedhashmap-的数据结构">一、LinkedHashMap 的数据结构</h2>
<p>LinkedHashMap 是 HashMap 的子类，他的节点类 Entry 也继承了 HashMap 的节点类 Node 类。所以 LinkedHashMap 保留了 HashMap 的所有基本特征。</p>
<p>但是，不同的是，LinkedHashMap 在节点类 Entry 中增加了 after 和 before 两个指针用于指向前驱和后继节点，并且提供了头节点和尾节点的指针，也就是说，他实际上也可以认为是一条双向链表。</p>
<p>比如下图，依次按顺序插入三个节点：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201221133625968.png" alt="image-20201221133625968"><figcaption aria-hidden="true">image-20201221133625968</figcaption>
</figure>
<p>实际上，从链表的角度来看，也可以理解为这样：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201221133938535.png" alt="image-20201221133938535"><figcaption aria-hidden="true">image-20201221133938535</figcaption>
</figure>
<h2 id="二-成员变量">二、成员变量</h2>
<p>关于 HashMap 的成员变量，可以直接参考前文<a href="https://blog.xiajibagao.top/2020/12/16/java/集合类源码分析/java集合源码分析（六）：HashMap/">java集合源码分析（六）：HashMap</a>的第二节，故这里只了解 LinkedHashMap 的成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表头结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表尾节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否按访问顺序</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<h2 id="三-构造方法">三、构造方法</h2>
<p>LinkedHashMap 的构造方法有五个，基本和 HashMap 的相同，但是多了 accessOrder 参数：</p>
<p>当不指定开启的时候，默认都为 false，此时我们遍历得顺序即是插入顺序。</p>
<p>若指定为 true，即按访问顺序访问的。默认排序仍然按插入顺序，但是当我们使用 get 方法访问的任意一个节点，则该节点就会被默认移动到队尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指定容量和指定负载系数，默认按插入顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定容量和默认负载系数，默认按插入顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认容量和默认负载系数，默认按插入顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建包含指定元素的集合，默认按插入顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定容量和指定负载系数，按指定顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-内部类">三、内部类</h2>
<p>和 HashMap 相比，LinkedHashMap 只提供包括：</p>
<ul>
<li>三种额外的集合视图类：LinkedKeySet，LinkedValues，LinkedEntrySet</li>
<li>Entry 实现类：Entry（继承了 HashMap.Node）</li>
<li>迭代器抽象类：LinkedHashIterator</li>
<li>三种集合视图的迭代器类：LinkedKeyIterator，LinkedValueIterator，LinkedEntryIterator</li>
</ul>
<p>共计八个实现类。</p>
<p>比较值得注意的是，由于要基于哈希值访问可以直接使用父类 HashMap 的相关迭代器或者集合视图，因此 LinkedHashMap 提供的迭代器和集合视图只用于基于链表的访问。</p>
<h2 id="四-添加节点">四、添加节点</h2>
<h3 id="1父类中的putval">1.父类中的putVal</h3>
<p>LinkedHashMap 的插入直接使用了 HashMap 的方法，但是他基于 HashMap 留下的“后门”，巧妙的在 HashMap 的基础上实现了新功能。我们关注以下 HashMap 的 <code>putVal()</code>中的一些关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(添加新节点) &#123;</span><br><span class="line">        <span class="comment">// 添加新节点</span></span><br><span class="line">        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(节点已存在) &#123;</span><br><span class="line">        <span class="comment">// 访问节点后处理</span></span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加后处理</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 LinkedHashMap 与 HashMap 插入方法的区别就在于<code>newNode()</code>，<code>afterNodeAccess()</code>与 <code>afterNodeInsertion()</code>方法。</p>
<p><code>newNode()</code>方法是用于创建节点，HashMap 已有实现，但是 LinkedHashMap 重写了此方法，使得创建节点的时候同时构建链表。</p>
<p><code>afterNodeAccess()</code>与 <code>afterNodeInsertion()</code>两者在 HashMap 中都是空方法，在 LinkedHashMap 中提供了实现。</p>
<p>其中，<code>afterNodeAccess()</code>方法会让传入的节点移动到链表的尾端，而<code>afterNodeInsertion()</code>可能会根据情况删除最早添加节点。</p>
<h3 id="2newnode">2.newNode</h3>
<p>newNode 方法分为两步，第一步创建一个 Entry 实例，第二步调用 <code>linkNodeLast()</code>方法将节点添加到链表尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3afternodeaccess">3.afterNodeAccess</h3>
<p>afterNodeAccess 用于将节点移动到尾部，但是只有 <code>accessOrder=true</code> 并且尾节点不为 null 才会真正的移动节点。这个方法除了在 putVal 中被调用外，还在 get 或者 replace 等方法被调用。<strong>也就是说，我们访问一个节点以后，如果允许按访问顺序访问，那么被访问的节点就会被移动到链表尾部</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 允许按访问顺序访问，并尾节点不为null</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4afternodeinsertion">4.afterNodeInsertion</h3>
<p><code>afterNodeInsertion()</code>方法与其名字一样，只在添加和修改后会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的判断条件 <code>evict</code>是 HashMap 创建时会传入的一个参数，表示的是“集合是否处于创建模式”，只有使用 Map 集合作为构造器参数的时候会为 true，其他时候都为 false。</p>
<p>而 <code>removeEldestEntry()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法总是返回一个 false 值。</p>
<p>根据以上的判断条件，我们可以看出，这个方法一般情况下基本不可能会进入 if 分支，但是根据 <code>removeEldestEntry()</code>的注释提供的示例，如果我们创建一个集合类，并且继承了 LinkedHashMap ，那么我们可以补充并且重写如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，假如容器容量固定为100，则当添加101个元素的时候，就会移除最古老的元素，也就是头结点的元素，这恰好是 LRU 算法的思想。基于这一点，我们可以自定义容器，通过继承 LinkedHashMap 来实现基于 LRU 算法的缓存。</p>
<h2 id="五-获取元素">五、获取元素</h2>
<p>LinkedHashMap 的 get 是自己重新实现的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和父类的 put 方法一样，如果允许按访问顺序排序，则在访问元素过后，该元素会排至链表尾部。</p>
<h2 id="六-删除元素">六、删除元素</h2>
<p>LinkedHashMap 的 remove 和 put 一样，都是通过在父方法中调用空实现方法，然后子类重写空实现方法，从而在父类的方法基础上扩展。</p>
<p>LinkedHashMap 的 remove 仍然直接使用 HashMap 的 <code>remove()</code> 方法，但是在 remove 的底层方法 <code>removeNode()</code>中，会在删除节点以后调用 <code>afterNodeRemoval()</code>，在 HashMap 中这是一个空方法，而 LinkedHashMap 实现了他。</p>
<p>因为 HashMap 的删除只是从数据结构上删除节点，所以 LinkedHashMap 需要自己去通过<code>afterNodeRemoval()</code>方法删除节点之间的引用关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七-迭代与顺序性">七、迭代与顺序性</h2>
<h3 id="1迭代方法">1.迭代方法</h3>
<p>LinkedHashMap 与 HashMap 一样，都可用通过集合视图迭代，同时也可以通过自己重写的 <code>forEach()</code>方法进行迭代。</p>
<p>由于 HashMap 实现了 fast-fail 机制，所以 LinkedList 同样也会针对迭代过程中的并发修改抛出 <code>ConcurrentModificationException</code>异常。</p>
<h3 id="2为什么迭代是顺序性的">2.为什么迭代是顺序性的</h3>
<p><strong>结构基础</strong></p>
<p>首先，根据上文，我们知道 LinkedList 在 HashMap 的哈希表的基础上又实现了双向链表的数据结构，并且在 get 和 put 中，通过实现父类的空方法的方式，扩展了 HashMap 的添加和修改。当我们要进行以上操作的时候：</p>
<ul>
<li>调用重写过的 <code>newNode()</code>方法创建节点，在创建节点的同时将新节点添加到链表尾部；</li>
<li>获取节点后，调用 <code>afterNodeAccess</code>，如果允许按访问顺序访问，就会把要修改/获取的节点移动到链表尾部；</li>
<li>调用 <code>afterNodeInsertion()</code>，在插入结束后移除最老节点。只有在 LinkedHashMap 的基础上重写 <code>removeEldestEntry()</code>才能真的实现该功能。</li>
</ul>
<p>第一点保证了链表最开始总是按照插入顺序排序，第二点则提供了按访问顺序排序的排序方式。</p>
<p><strong>迭代方式</strong></p>
<p>根据前文，我们知道三个集合视图本质都在使用集合不对外暴露的迭代器，而在 LinkedHashList 中这个迭代器就是 LinkedHashIterator。这个迭代器是的迭代方式就是把链表从头迭代到尾，这是就是顺序的。</p>
<p>而三个集合视图是分别在迭代得到的元素的基础上，分别拿 Entry，value 或者 key。LinkedHashList 又重写了 <code>entry()</code>，<code>values()</code>，<code>key()</code>方法，因此通过这些方法获得的集合视图也是有序的。</p>
<h2 id="八-基于-linkedhashmap-实现的缓存容器">八、基于 LinkedHashMap 实现的缓存容器</h2>
<p>LRU（Least Recently Used）即最近最少使用，这个算法被广泛的用于缓存等领域。简单的用链表描述一下，就是规定一个容量一定的链表，当节点被访问时就移到队尾，当节点数量大于阈值的时候，就移除头结点以腾出空间。</p>
<p>换句话说，只需要一个集合能满足三点即可：</p>
<ul>
<li>容量一定</li>
<li>被访问的节点移到尾部</li>
<li>超过容量就删除头部节点</li>
</ul>
<p>若我们基于 LinkedHashMap ，则只需要重写 <code>removeEldestEntry()</code>方法，并且在构造方法中指定按访问顺序排序即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruLink</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LruLink</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 允许按访问顺序排序</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) ((maxSize / <span class="number">0.75f</span>) + <span class="number">1</span>), <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写removeEldestEntry，当长度大于容量的时候移除最老节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123;</span><br><span class="line">            s += <span class="string">&quot;[&quot;</span> + entry.getKey() + <span class="string">&quot;,&quot;</span> + entry.getValue() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; link = <span class="keyword">new</span> LruLink&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">link.put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">link.put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">link.put(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">link.get(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">link.put(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">System.out.println(link.toString()); <span class="comment">// [C,C][A,A][D,D]</span></span><br></pre></td></tr></table></figure>
<h2 id="九-总结">九、总结</h2>
<p><strong>数据结构</strong></p>
<p>LinkedHashMap 是 HashMap 的子类，它在 HashMap 提供的哈希表的基础上又实现了双向链表，链表默认按插入顺序排序，这是他有序性的结构基础。</p>
<p><strong>有序性</strong></p>
<p>LinkedHashMap 默认按插入顺序排序，可以通过在构造方法中指定 <code>accessOrder=true</code>，可以开启按访问顺序排序，此时，当访问节点后，被访问的节点会被移动到链表的尾部。</p>
<p><strong>迭代</strong></p>
<p>LinkedHashMap 也重写了 <code>forEach()</code>，因此它与 HashMap一样，可以通过 <code>forEach()</code>或者视图集合进行迭代。此外，它同样实现了 fast-fail 机制。</p>
<p>LinkedHashMap 重写了 <code>entrySet()</code>，<code>values()</code>和 <code>keySet()</code> 方法，并且视图集合的迭代器都依赖于 LinkedHashIterator，而该迭代器总是从链表头迭代到链表位，因此通过视图进行迭代也是有序的。</p>
<p><strong>LRU 容器的实现</strong></p>
<p>自定义一个类继承 LinkedHashMap，重写 <code>removeEldestEntry()</code>，并在父类构造方法中指定 <code>accessOrder=true</code>开启按访问顺序排序即可。另外，需要在父类构造器中指定容量需要大于<code>指定容量 / 负载系数</code>，避免扩容。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（一）：Collection 与 AbstractCollection</title>
    <url>/2020/11/25/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ACollection%E4%B8%8EAbstractCollection/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>我们知道，java 中容器分为 Map 集合和 Collection 集合，其中 Collection 中的又分为 Queue，List，Set 三大子接口。</p>
<p>其下实现类与相关的实现类子类数量繁多。我们仅以最常使用的 List 接口的关系为例，简单的画图了解一下 Collection 接口 List 部分的关系图。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201126100539307.png" alt="List集合的实现类关系图"><figcaption aria-hidden="true">List集合的实现类关系图</figcaption>
</figure>
<p>根据上图的类关系图，我们研究一下源码中，类与类之间的关系，方法是如何从抽象到具体的。</p>
<h2 id="一-iterable-接口">一、Iterable 接口</h2>
<p>Iterable 是最顶层的接口，继承这个接口的类可以被迭代。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201125151935252.png" alt="Iterable 接口的方法"><figcaption aria-hidden="true">Iterable 接口的方法</figcaption>
</figure>
<ul>
<li><p><code>iterator()</code>：用于获取一个迭代器。</p></li>
<li><p><code>forEach()</code> ：JDK8 新增。一个基于函数式接口实现的新迭代方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>spliterator()</code>：JDK8 新增。用于获取一个可分割迭代器。默认实现返回一个<code>IteratorSpliterator</code>类。</p></li>
</ul>
<p>这个跟迭代器类似，但是是用于并行迭代的，关于具体的情况可以参考一下掘金的一个讨论：<a href="https://segmentfault.com/q/1010000007087438">Java8里面的java.util.Spliterator接口有什么用？</a></p>
<h2 id="二-collection-接口">二、Collection 接口</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201125154357523.png" alt="Collection 接口的方法"><figcaption aria-hidden="true">Collection 接口的方法</figcaption>
</figure>
<p>Collection 是集合容器的顶级接口，他继承了 Iterable 接口，即凡是 Collection 的实现类都可以迭代，List 也是 Collection 的子接口，因此也拥有此特性。</p>
<p>可以看到， Collection 接口提供了十九个抽象方法，这些方法的命名都很直观的反应的这些方法的功能。通过这些方法规定了 Collection的实现类的一些基本特性：<strong>可迭代，可转化为数组，可对节点进行添加删除，集合间可以合并或者互相过滤，可以使用 Stream 进行流式处理。</strong></p>
<h3 id="1抽象方法">1.抽象方法</h3>
<p>我们可以根据功能简单的分类介绍一下 Collection 接口提供的方法。</p>
<p><strong>判断类：</strong></p>
<ul>
<li><code>isEmpty()</code>：判断集合是否不含有任何元素；</li>
<li><code>contains()</code>：判断集合中是否含有至少一个对应元素；</li>
<li><code>containsAll()</code>：判断集合中是否含另一个集合的所有元素；</li>
</ul>
<p><strong>操作类：</strong></p>
<ul>
<li><code>add()</code>：让集合包含此元素。如果因为除了已经包含了此元素以外的任何情况而不能添加，则必须抛出异常；</li>
<li><code>addAll()</code>：将指定集合中的所有元素添加到本集合；</li>
<li><code>remove()</code>：从集合移除指定元素；</li>
<li><code>removeAll()</code>：删除也包含在指定集合中的所有此集合的元素；</li>
<li><code>retainAll</code>：从此集合中删除所有未包含在指定集合中的元素；</li>
<li><code>clear()</code>：从集合中删除所有元素；</li>
</ul>
<p><strong>辅助类：</strong></p>
<ul>
<li><p><code>size()</code>：获取集合的长度。如果长度超过 Integer.MAX_VALU 就返回 Integer.MAX_VALU；</p></li>
<li><p><code>iterator()</code>：获取集合的迭代器；</p></li>
<li><p><code>toArray()</code>：返回一个包含此集合中所有元素的<strong>新数组实例</strong>。因为是新实例，所以对原数组的操作不会影响新数组，反之亦然；</p>
<p>它有一多态方法参数为<code>T[]</code>，此时调用 <code>toArray()</code>会将内部数组中的元素全部放入指定数组，如果结束后指定数组还有剩余空间，那剩余空间都放入null。</p></li>
</ul>
<h3 id="2jdk8-新增抽象方法">2.JDK8 新增抽象方法</h3>
<p>此外，在 JDK8 中新增了四个抽象方法，他们都提供了默认实现：</p>
<ul>
<li><code>removeIf</code>：相当于一个<code>filter()</code>，根据传入的函数接口的匿名实现类方法来判断是否要删除集合中的某些元素；</li>
<li><code>stream()</code>：JDK8 新特性中流式编程的灵魂方法，可以将集合转为 Stream 流式进行遍历，配合 Lambda 实现函数式编程；</li>
<li><code>parallelStream()</code>：同 <code>stream()</code> ，但是是生成并行流；</li>
<li><code>spliterator()</code>：重写了 Iterable 接口的 <code>iterator()</code>方法。</li>
</ul>
<h3 id="3equals-和-hashcode">3.equals 和 hashCode</h3>
<p>值得一提的是 Collection <strong>还重写了 Object 的 <code>equals()</code> 和 <code>hashCode()</code> 方法</strong>（或者说变成了抽象方法？），这样<strong>实现 Collection 的类就必须重新实现 <code>equals()</code> 和 <code>hashCode()</code> 方法</strong>。</p>
<h2 id="三-abstractcollection-抽象类">三、AbstractCollection 抽象类</h2>
<p>AbstractCollection 是一个抽象类，他实现了 Collection 接口的一些基本方法。我们可以根据 JavaDoc 简单的了解一下它：</p>
<blockquote>
<p><strong>要实现不可修改的集合</strong>，程序员只需扩展此类并为iterator和size方法提供实现。（由iterator方法返回的迭代器必须实现hasNext和next 。）</p>
<p><strong>要实现可修改的集合</strong>，程序员必须另外重写此类的add方法（否则将抛出UnsupportedOperationException ），并且iterator方法返回的迭代器必须另外实现其remove方法。</p>
<p>根据Collection接口规范中的建议，程序员通常应提供一个void（无参数）和Collection构造函数</p>
</blockquote>
<p>通过类的关系图，AbstractCollection 下面还有一个子抽象类 AbstractList ，进一步提供了对 List 接口的实现。 我们不难发现，这正是模板方法模式在 JDK 中的一种运用。</p>
<h3 id="0不支持的实现">0.不支持的实现</h3>
<p>在这之前，需要注意的是，AbstractCollection 中有一些比较特别的写法，即实现了方法，但是默认一调用立刻就抛出 <code>UnsupportedOperationException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要使用这个方法，就必须自己去重写他。这个写法让我纠结了很久，网上找了找也没找到一个具体的说法。</p>
<p>参考 JDK8 新增的接口方法默认实现这个特性，我大胆猜测，这应该是针对一些实现 Collection 接口，但是又不想要实现 <code>add(E e)</code>方法的类准备的。<strong>在 JDK8 之前，接口没有默认实现，如果抽象类还不提供一个实现，那么无论实现类是否需要这个方法，那么他都一定要实现这个方法</strong>，这明显不太符合我们设计的初衷。</p>
<h3 id="1isempty">1.isEmpty</h3>
<p>非常简短的方法，通过判断容器 size 是否为0判断集合是否为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2containscontainsall">2.contains/containsAll</h3>
<p>判断元素是否存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="comment">// 如果要查找的元素是null</span></span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>containsAll()</code>就是在<code>contains()</code>基础上进行了遍历判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c)</span><br><span class="line">        <span class="keyword">if</span> (!contains(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3addall">3.addAll</h3>
<p><code>addAll()</code>方法就是在 for 循环里头调用 <code>add()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (add(e))</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4removeremoveall">4.remove/removeAll</h3>
<p><code>remove()</code>这个方法与 <code>contains()</code>逻辑基本一样，<strong>因为做了null判断，所以List是默认支持传入null的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next())) &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5removeallretainall">5.removeAll/retainAll</h3>
<p><code>removeAll()</code>和 <code>retainAll()</code>的逻辑基本一致，都是通过 <code>contains()</code>方法判断元素在集合中是否存在，然后选择保存或者删除。由于 <code>contains()</code>方法只看是否存在，而不在意有几个，所以如果目标元素有多个，会都删除或者保留。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;?&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5toarray扩容">5.toArray（扩容）</h3>
<p>用于将集合转数组。有两个实现。一般常用的是无参的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// 创建一个和List相同长度的数字</span></span><br><span class="line">    Object[] r = <span class="keyword">new</span> Object[size()];</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果数组长度大于集合长度</span></span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="comment">// 用Arrays.copyOf把剩下的位置用null填充</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(r, i);</span><br><span class="line">        r[i] = it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果数组长度反而小于集合长度，就扩容数组并且重复上述过程</span></span><br><span class="line">    <span class="keyword">return</span> it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，在 finishToArray(r, it) 这个方法里涉及到了一个扩容的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成员变量，允许数组理论允许的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位运算，扩大当前容量的一半+1</span></span><br><span class="line"><span class="keyword">int</span> newCap = cap + (cap &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果扩容后的大小比MAX_ARRAY_SIZE还大</span></span><br><span class="line"><span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 使用原容量+1，去判断要直接扩容到MAX_ARRAY_SIZE，Integer.MAX_VALUE还是直接抛OutOfMemoryError异常</span></span><br><span class="line">    newCap = hugeCapacity(cap + <span class="number">1</span>);</span><br><span class="line">r = Arrays.copyOf(r, newCap);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>MAX_ARRAY_SIZE</code> 是一个常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>这里又通过<code>hugeCapacity()</code>方法进行了大小的限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经大到溢出就抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError</span><br><span class="line">        (<span class="string">&quot;Required array size too large&quot;</span>);</span><br><span class="line">    <span class="comment">// 容量+1是否还是大于允许的数组最大大小</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        <span class="comment">// 如果是，就把容量直接扩大到Integer.MAX_VALUE</span></span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    <span class="comment">// 否则就直接扩容到运行的数组最大大小</span></span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能有人会疑问，<code>MAX_ARRAY_SIZE</code>应该就是允许扩容的最大大小了，为什么还可以扩容到<code>Integer.MAX_VALUE</code>？</p>
<p>实际上，根据 JavaDoc 的解释：</p>
<blockquote>
<p>Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError</p>
</blockquote>
<p>一些 JVM 可能会用数组头存放一些关于数组的数据，一般情况下，最好不要直接可以扩容到<code>Integer.MAX_VALUE</code>，因此扩容到<code>Integer.MAX_VALUE-8</code>就是理论上允许的最大值了，但是如果真的大到了这个地步，就只能特殊情况特殊对待，试试看可不可以扩容到<code>Integer.MAX_VALUE</code>，如果再大就要溢出了。</p>
<h3 id="6clear">6.clear</h3>
<p>迭代并且删除全部元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; it = iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    it.next();</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7tostring">7.toString</h3>
<p>AbstractCollection 重写了 toString 方法，这也是为什么调用集合的<code>toStirng()</code> 不是像数组那样打印一个内存地址的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">        sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-总结">四、总结</h2>
<p><strong>Collection</strong></p>
<p>Collection 接口类是 List ，Queue，Set 三大子接口的父接口，他继承了 Iterable 接口，因而所有 Collection 的实现类都可以迭代。</p>
<p>Collection 中提供了规定了实现类应该实现的大部分增删方法，但是并没有规定关于如何使用下标进行操作的方法。</p>
<p><strong>实现类的equlas与hashCode方法</strong></p>
<p>值得注意的是，他重规定了 <code>equlas()</code> 和 <code>hashCode()</code>的方法，因此 Collection 的实现类的这两个方法不再跟 Object 类一样了。</p>
<p><strong>AbstractCollection</strong></p>
<p>AbstractCollection 是实现 Collection 接口的一个抽象类，JDK 在这里使用了模板方法模式，Collection 的实现类可以通过继承 AbstractCollection 获得绝大部分实现好的方法。</p>
<p>在 AbstractCollection 中，为<code>add()</code>抽象方法提供了不支持的实现：即实现了方法，但是调用却会抛出 <code>UnsupportedOperationException</code>。根据推测，这跟 JDK8 接口默认实现的特性一样，是为了让子类可以有选择性的去实现接口的抽象方法，不必即使不需要该方法，也必须提供一个无意义的空实现。</p>
<p>AbstractCollection 提供了对添加复数节点，替换、删除的单数和复数节点的方法实现，在这些实现里，因为做了null判断，因此是默认是支持传入的元素为null，或者集合中含有为null的元素，但是不允许传入的集合为null。</p>
<p><strong>扩容</strong></p>
<p>AbstractCollection 在集合转数组的 <code>toArrays()</code> 中提供了关于扩容的初步实现：一般情况下<code>新容量=旧容量 + (旧容量/2 + 1)</code>，如果新容量大于 MAX_ARRAY_SIZE，就会使用 <code>旧容量+1</code>去做判断，如果已经溢出则抛OOM溢出，大于 MAX_ARRAY_SIZE 就使用 Integer.MAX_VALUE 作为新容量，否则就使用 MAX_ARRY_SIZE。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（九）：HashSet与TreeSet.md</title>
    <url>/2020/12/22/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9AHashSet/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>HashSet 是 Set 接口下一个不允许重复但允许 null、无序并且线程不安全的集合。它基于 HashMap 实现。</p>
<p>从数据结构来说，他与 HashMap 相同，但是由于 HashSet 借助 HashMap 的 key 来存储数据，因而 HashMap 的 value 在 HashSet 中无意义。</p>
<p><img src="http://img.xiajibagao.top/image-20201208205304527.png" alt="HashMap的数据结构" style="zoom:67%;"></p>
<p>这是关于 java 集合类源码的第九篇文章。往期文章：</p>
<blockquote>
<ol type="1">
<li><a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a><br>
</li>
<li><a href="https://blog.xiajibagao.top/2020/11/27/java/集合类源码分析/java集合源码分析（二）：List与AbstractList/">java集合源码分析（二）：List与AbstractList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/02/java/集合类源码分析/java集合源码分析（三）：ArrayList/">java集合源码分析（三）：ArrayList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/03/java/集合类源码分析/java集合源码分析（四）：LinkedList/">java集合源码分析（四）：LinkedList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/07/java/集合类源码分析/java集合源码分析（五）：Map与AbstractMap/">java集合源码分析（五）：Map与AbstractMap</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/16/java/集合类源码分析/java集合源码分析（六）：HashMap/">java集合源码分析（六）：HashMap</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/21/java/集合类源码分析/java集合源码分析（七）：LinkedHashMap/">java集合源码分析（七）：LinkedHashMap</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/22/java/集合类源码分析/java集合源码分析（八）：Set与AbstracSet/">java集合源码分析（八）：Set与AbstractSet</a></li>
</ol>
</blockquote>
<h2 id="一-数据结构">一、数据结构</h2>
<p>HashSet 基于 HashMap 实现，也就是说，HashSet 用于存储数据的容器实际上就是一个 HashMap 实例。（关于 HashMap 的数据结构，可以参考前文<a href="https://blog.xiajibagao.top/2020/12/16/java/集合类源码分析/java集合源码分析（六）：HashMap/">java集合源码分析（六）：HashMap</a>中的第一部分。）</p>
<p>HashSet 使用 HashMap 的 key 作为存储数据的位置，而 value 的位置使用一个默认的全局空对象填充。大部分方法通过直接包装调用 HashMap 的来实现，也就是说，我们可以把 HashSet 看成 HashMap 的一个大号包装器——或者说适配器类。</p>
<h2 id="二-成员变量">二、成员变量</h2>
<p>由于直接基于 HashMap 实现，因而 HashSet 中只提供两个成员变量，一个 map 用于存放 HashMap 实例，一个 PRESENT 用于作为填充 value 的空对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<h2 id="三-构造方法">三、构造方法</h2>
<p>HashSet 提供了五个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没什么好说的，比较值得注意的是直接传入 Collection 集合的构造方法，这个方法取 HashMap 的默认容量16与传入容量除以默认负载系数的最大值，避免插入过程发生一次额外的扩容。</p>
<h2 id="四-成员方法">四、成员方法</h2>
<p>Set 接口继承了 Collection 接口，但是 Set 接口并未提供一些新的抽象方法。因而 HashSet 内部的方法基本都重写自 AbstractCollection 抽象类，并且实现都是基于 HashMap 方法的再包装。</p>
<p>也正由于此，HashSet 集合元素允许 null 但是不允许重复，因为 HashMap 的 key 允许有一个 null，并且不允许重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-总结">五、总结</h2>
<p>HashSet 基于 HashMap 实现，并且使用 HashMap 的 key 作为存储容器，将对应的 value 以一个 Object 对象常量进行充填。</p>
<p>HashSet 中的元素无序、不允许重复、允许一个 null 的特性皆来源于 HashMap 的 key 的特性。</p>
<p>实际上，HashSet 中的方法都来自于 Collection 接口，而真正的实现都来自于 HashMap，从这个角度来看，HashSet 其实就是 HashMap 与 Collection 接口之间的一种适配器。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（八）：Set与AbstractSet</title>
    <url>/2020/12/22/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9ASet%E4%B8%8EAbstracSet/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>Set 接口是 Collection 接口下三大子接口之一。其下实现类都为元素不可重复的，不保证线程安全的集合。他有两个主要实现，即无序的 HashSet 与有序的 TreeSet。</p>
<p>Set 相对 List 集合与 Queue 集合不同之处在于，他的实现类需要依赖与 Map 集合的实现类密切相关。这体现在以下两点：</p>
<ul>
<li>HashSet 实际依赖于 HashMap，他使用 HashMap 的 key 作为存储容器。TreeSet 同理，依赖于 TreeMap实现。</li>
<li>Map 集合中的 keySet 与 EntrySet 视图集合往往以实现了 Set 接口的内部类出现在 Map 的实现类中。</li>
</ul>
<figure>
<img src="http://img.xiajibagao.top/image-20201222152520801.png" alt="image-20201222152520801"><figcaption aria-hidden="true">image-20201222152520801</figcaption>
</figure>
<p>这是关于 java 集合类源码的第八篇文章。往期文章：</p>
<blockquote>
<ol type="1">
<li><a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a><br>
</li>
<li><a href="https://blog.xiajibagao.top/2020/11/27/java/集合类源码分析/java集合源码分析（二）：List与AbstractList/">java集合源码分析（二）：List与AbstractList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/02/java/集合类源码分析/java集合源码分析（三）：ArrayList/">java集合源码分析（三）：ArrayList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/03/java/集合类源码分析/java集合源码分析（四）：LinkedList/">java集合源码分析（四）：LinkedList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/07/java/集合类源码分析/java集合源码分析（五）：Map与AbstractMap/">java集合源码分析（五）：Map与AbstractMap</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/16/java/集合类源码分析/java集合源码分析（六）：HashMap/">java集合源码分析（六）：HashMap</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/21/java/集合类源码分析/java集合源码分析（七）：LinkedHashMap/">java集合源码分析（七）：LinkedHashMap</a></li>
</ol>
</blockquote>
<h2 id="一-set-接口的类关系">一、Set 接口的类关系</h2>
<h3 id="1父接口">1.父接口</h3>
<p>Set 接口继承了 Collection 接口，而 Collection 接口又继承了 Iterable 接口，这表明 Set 集合具有 Collection 的通性，是一维的元素集合，并且可以使用迭代器或者 <code>forEach()</code> 迭代。</p>
<p>Set 接口存在一个抽象实现类 AbstractSet，该类继承了 AbstractCollection 抽象类，为 Set 接口提供了大部分抽象方法的实现。</p>
<h3 id="2子接口">2.子接口</h3>
<p>Set 接口还存在子接口，即 SortedSet 与 NavigableSet 接口。这两者都表明实现类是可以根据自然顺序或者比较器排序从而维持有序的集合，并且提供了相关的边界操作方法。</p>
<p><strong>SortedSet</strong></p>
<p>先说 SortedSet，SortedSet是一个可排序的 Set 集合类接口，<strong>里面提供了一系列的边界操作——比如查找所有小于或者大于某个值的元素——的抽象方法</strong>。实现该接口的实现类中存放的元素必须可以通过比较器或者 <code>equlas()</code>方法对元素进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.返回一个比较器。若要使用自然排序则实现需要返回null</span></span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> E&gt; comparator();</span><br><span class="line"><span class="comment">// 2.返回一个视图集合。同List实现类的SubList</span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br><span class="line"><span class="comment">// 3.获取大于或小于某个值的所有元素</span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line"><span class="comment">// 4.获取最大或最小元素</span></span><br><span class="line"><span class="function">E <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">last</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>NavigableSet</strong></p>
<p>而 NavigableMap 接口是 SortedMap 的子接口，<strong>他在 SortedMap 的基础上进一步提供了更细化的边界操作的抽象方法</strong>，比如 SortedMap 提供了 <code>headMap()</code>用于获取所有大于指定值的元素，NavigableMap 就另外再提供 <code>higherXXX()</code>方法用于获取所有大于指定值的元素中的最小元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.返回小于指定值的最大元素</span></span><br><span class="line"><span class="function">E <span class="title">lower</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 2.返回小于等于指定的最大元素</span></span><br><span class="line"><span class="function">E <span class="title">floor</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 3.返回大于指定的最小元素</span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 4.返回大于等于指定值的最小元素</span></span><br><span class="line"><span class="function">E <span class="title">ceiling</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 5.获取并删除最大或最小元素</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 6.获取升序迭代器</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 7.获取降序迭代器或降序视图</span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 8.获取指定范围内的视图</span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line"><span class="comment">// 9.获取指定范围内的视图，并且可以选择开闭区间</span></span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                           E toElement,   <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                           E toElement,   <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br><span class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，TreeSet 实现了 SortedSet 与 NavigableSet 接口，同时，它依赖的 TreeMap 也实现了相应的 SortedMap 和 NavigableMap 接口。</p>
<h2 id="二-set-接口的方法">二、Set 接口的方法</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201222155937401.png" alt="image-20201222155937401"><figcaption aria-hidden="true">image-20201222155937401</figcaption>
</figure>
<p>set 接口不包含任何默认实现，也没有重写 Collection 中的任何方法，因而它提供的抽象方法与 Collection 相同。具体可以参考前文<a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a>中的第二部分。</p>
<h2 id="三-abstractset">三、AbstractSet</h2>
<p>AbstractSet 是实现了 Set 接口，并且继承了 AbstractCollection 的抽象类。他为 Set 接口提供了其父类接口 Collection 中的实现类，并且提供了 <code>equlas()</code>，<code>removeAll()</code>，<code>hashCode()</code>三个方法的重写/实现。</p>
<h2 id="1equlashashcode">1.equlas/hashCode</h2>
<p><strong>equals</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否同一对象</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为Set集合</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span><br><span class="line">    <span class="comment">// 长度是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (c.size() != size())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用containsAll(c)比较集合</span></span><br><span class="line">        <span class="keyword">return</span> containsAll(c);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>hashCode</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    Iterator&lt;E&gt; i = iterator();</span><br><span class="line">    <span class="comment">// 集合hashcode为元素hashcode之和</span></span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        E obj = i.next();</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>)</span><br><span class="line">            h += obj.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2removeall">2.removeAll</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 迭代较小的结合</span></span><br><span class="line">    <span class="keyword">if</span> (size() &gt; c.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); )</span><br><span class="line">            modified |= remove(i.next());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-总结">四、总结</h2>
<p><strong>Set 接口</strong></p>
<p>Set 接口是 Collection 下一个不可重复，线程不安全的集合，主要有 HashSet 与 TreeSet 两大实现类，分别依赖于 Map 接口下 HashMap 与 TreeMap 实现。</p>
<p>Set 继承了 Collection 接口，因而 Set 集合可以通过 <code>forEach()</code>或者迭代器迭代。</p>
<p>Set 接口存在子接口 SortedSet 与孙子接口 NavigableSet，规定了实现该接口的类可以根据自然顺序或者比较器排序保证顺序。</p>
<p><strong>AbstractSet 抽象类</strong></p>
<p>AbstractSet 抽象类继承了 Collection 抽象类，实现了 Set 接口。由于 Set 接口没有除 Collction 接口提供的方法以外的新抽象方法，故 Set 接口的大部分实现有其父类 AbstractCollection 提供，AbstractSet 只实现了 <code>removeAll()</code>，<code>equlas()</code>与 <code>hashCode()</code>方法。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基本操作</title>
    <url>/2019/09/02/docker/Docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="一-docker常用命令">一、Docker常用命令</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#镜像名			版本标签			镜像id			 创建时间			镜像大小</span></span><br><span class="line"><span class="string">REPOSITORY</span>          <span class="string">TAG</span>                 <span class="string">IMAGE</span> <span class="string">ID</span>            <span class="string">CREATED</span>             <span class="string">SIZE</span></span><br><span class="line"><span class="string">hello-world</span>         <span class="string">latest</span>              <span class="string">fce289e99eb9</span>        <span class="number">6</span> <span class="string">months</span> <span class="string">ago</span>        <span class="number">1.</span><span class="string">84kB</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">version/info</span> <span class="comment">#查看版本/信息</span></span><br><span class="line"><span class="string">docker</span> <span class="string">--help</span> <span class="comment">#查看说明文档</span></span><br><span class="line"><span class="string">docker</span> <span class="string">logs</span> <span class="string">-f</span> <span class="string">-t</span> <span class="string">--tail</span> <span class="string">日志条数</span> <span class="string">容器ID</span> <span class="comment">#查看容器日志</span></span><br><span class="line"><span class="string">docker</span> <span class="string">inspect</span> <span class="comment">#获取容器/镜像的元数据</span></span><br></pre></td></tr></table></figure>
<h2 id="二-镜像基本操作">二、镜像基本操作</h2>
<h3 id="1-拉取">1. 拉取</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">search</span> [<span class="string">xxx</span>] <span class="comment">#查找名为xxx的镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">pull</span> [<span class="string">xxx</span>]<span class="string">：版本号</span> <span class="comment"># 拉取xxx镜像，不加版本号则默认拉取最新版本</span></span><br></pre></td></tr></table></figure>
<h3 id="2-查看">2. 查看</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">images</span> <span class="string">-a/-qa</span> <span class="comment">#列出本地全部镜像/全部镜像的ID</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.xiajibagao.top/docker查看镜像.PNG"></p>
<h3 id="3-删除">3. 删除</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">rmi</span> <span class="string">-f</span> [<span class="string">xxx</span>] <span class="comment">#删除名为xxx的镜像，加-f为强制删除（不论现在正在运行）</span></span><br><span class="line"><span class="string">docker</span> <span class="string">rmi</span> <span class="string">$(docker</span> <span class="string">images</span> <span class="string">-q)</span> <span class="comment">#删除所有镜像</span></span><br></pre></td></tr></table></figure>
<p>注意：要拉取的镜像名确认不要写错，否则会报错（repository does not exist or may require 'docker login'）</p>
<h3 id="4-导出镜像">4. 导出镜像</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存镜像到指定目录</span></span><br><span class="line"><span class="comment">#这里的原image名和版本号需要与要保存的镜像一致</span></span><br><span class="line"><span class="string">docker</span> <span class="string">save</span>  <span class="string">镜像ID</span> <span class="string">-o</span> <span class="string">d:\dockerimages\新image名.tar</span> <span class="string">原image名:版本号</span></span><br></pre></td></tr></table></figure>
<h3 id="5-导入镜像">5. 导入镜像</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从指定目录加载镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">load</span> <span class="string">-i</span> <span class="string">\dockerimages\新image名.tar</span></span><br></pre></td></tr></table></figure>
<h2 id="三-容器基本操作">三、容器基本操作</h2>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-i为以交互模式启动容器</span></span><br><span class="line"><span class="comment">#-t为容器重新分配一个伪输入终端（两者合写为-it）</span></span><br><span class="line"><span class="comment">#--name为容器命名，不加则默认自动分配</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">--name</span> <span class="string">mycentos</span> <span class="string">centos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建守护式容器</span></span><br><span class="line"><span class="comment">#直接在后台创建一个容器，但是如果容器里没有活动则会在创建后立刻自动停止</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-d</span> <span class="string">centos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8080为docker服务对外暴露的端口，8080指docker内的tomcat端口</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-p</span> <span class="number">8080</span><span class="string">:8080</span> <span class="string">tomcat</span></span><br></pre></td></tr></table></figure>
<h3 id="1-查看">1. 查看</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="comment">#查看当前运行的容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="string">-l</span> <span class="comment">#列出最近创建的容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="string">-a</span> <span class="comment">#列出当前和曾经运行的容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">ps</span> <span class="string">-n</span> <span class="string">x</span> <span class="comment">#显示最近运行过的n个容器</span></span><br><span class="line"><span class="comment">#在以上基础上变为 -xq 可以只显示容器编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果找不到命令，则可能为该镜像没有包含procps工具</span></span><br><span class="line"><span class="string">apt-get</span> <span class="string">update</span> <span class="string">&amp;&amp;</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">procps</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.xiajibagao.top/docker查看容器.PNG"></p>
<h3 id="2-进入">2. 进入</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在已运行的容器中，执行命令，操作对象是容器，如果你要进入已运行的容器，并且执行命令，用exec；</span></span><br><span class="line"><span class="string">docker</span> <span class="string">exec</span> <span class="string">-it</span> <span class="string">容器名/容器ID</span> <span class="string">/bin/bash</span></span><br><span class="line"><span class="comment">#同样操作的是已运行的容器，可以将本机标准输入（键盘输入）输到容器中，也可以将容器的输出显示在本机的屏幕上，如果你想查看容器运行过程中产生的标准输入输出，用attach；</span></span><br><span class="line"><span class="string">docker</span> <span class="string">attach</span> <span class="string">容器名/容器ID</span></span><br></pre></td></tr></table></figure>
<h3 id="3-停止">3. 停止</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">stop</span> <span class="string">容器名/容器ID</span> <span class="comment">#停止单个</span></span><br><span class="line"><span class="string">docker</span> <span class="string">stop</span> <span class="string">$(docker</span> <span class="string">ps</span> <span class="string">-a</span> <span class="string">-q)</span> <span class="comment">#停止全部</span></span><br><span class="line"><span class="string">docker</span> <span class="string">kill</span> <span class="string">容器名/容器ID</span> <span class="comment">#强制停止</span></span><br></pre></td></tr></table></figure>
<h3 id="4-退出">4. 退出</h3>
<p>需要注意的是，容器停止后里面的数据就直接销毁了，所有如果没有提交镜像还没有备份，最好不要直接使用exit退出容器</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">exit</span> <span class="comment">#容器停止并退出</span></span><br><span class="line"><span class="string">ctrl+P+Q</span> <span class="comment">#容器不停止退出（非常重要！！！！！！！）</span></span><br></pre></td></tr></table></figure>
<h3 id="5-删除">5. 删除</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">rm</span> <span class="string">容器名/容器ID</span> <span class="comment">#删除单个</span></span><br><span class="line"><span class="string">docker</span> <span class="string">rm</span> <span class="string">$(docker</span> <span class="string">ps</span> <span class="string">-a</span> <span class="string">-q)</span> <span class="comment">#删除全部</span></span><br></pre></td></tr></table></figure>
<p>注意：rm为删除容器，rmi为删除镜像</p>
<h3 id="6-提交容器">6. 提交容器</h3>
<p>如果想要重复使用当前容器，可以将容器提交成镜像，那样下次使用时就可以直接拉取镜像并启动容器即可</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker commit <span class="attribute">-m</span>=<span class="string">&quot;描述信息&quot;</span> <span class="attribute">-a</span>=<span class="string">&quot;作者&quot;</span> 容器ID 要创建的新镜像名:版本号</span><br></pre></td></tr></table></figure>
<h3 id="7-从容器中拷贝文件到主机中">7. 从容器中拷贝文件到主机中</h3>
<p>顾名思义，将容器中的文件拷贝到主机，如日志或者sql文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">cp</span> <span class="string">容器名/容器ID:文件位置</span> <span class="string">/root</span></span><br></pre></td></tr></table></figure>
<h3 id="8-docker安装mysql">8. docker安装mysql</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-p</span> <span class="number">3306</span><span class="string">:3306</span> <span class="string">--name</span> <span class="string">mymysql</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/mysqlfile/conf:/etc/mysql/conf.d</span> <span class="comment">#挂载容器数据卷（可不带）</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/mysqlfile/logs:/logs</span> <span class="comment">#挂载容器数据卷（可不带）</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/mysqlfile/data:/var/lib/mysql</span> <span class="comment">#挂载容器数据卷（可不带）</span></span><br><span class="line"><span class="string">-e</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span> <span class="comment">#设置默认用户名</span></span><br><span class="line"><span class="string">-d</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">exec</span> <span class="string">-it</span> <span class="string">mymysql</span> <span class="string">/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以root身份登录</span></span><br><span class="line"><span class="string">mysql</span> <span class="string">-uroot</span> <span class="string">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选择mysql</span></span><br><span class="line"><span class="string">use</span> <span class="string">mysql;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果navicat远程连接报1521错误</span></span><br><span class="line"><span class="string">GRANT</span> <span class="string">ALL</span> <span class="string">ON</span> <span class="string">*.*</span> <span class="string">TO</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;;</span> <span class="comment">#远程连接授权</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">BY</span> <span class="string">&#x27;password&#x27;</span> <span class="string">PASSWORD</span> <span class="string">EXPIRE</span> <span class="string">NEVER;</span> <span class="comment">#更改加密规则</span></span><br><span class="line"><span class="string">ALTER</span> <span class="string">USER</span> <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27;</span> <span class="string">IDENTIFIED</span> <span class="string">WITH</span> <span class="string">mysql_native_password</span> <span class="string">BY</span> <span class="string">&#x27;123456&#x27;</span><span class="string">;</span> <span class="comment">#更改密码</span></span><br><span class="line"><span class="string">FLUSH</span> <span class="string">PRIVILEGES;</span> <span class="comment">#刷新权限</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四-容器数据卷">四、容器数据卷</h2>
<p>用于数据保存和持久化,简单的理解，就是容器和主机共享的一个公共硬盘，举个例子，原本tomcat部署应用，或者查看日志还需要进入容器，现在将日志文件夹和部署文件夹拿出来挂载到主机，就可以在不进入容器的情况下查看日志或者部署项目</p>
<h3 id="1-直接构建容器数据卷">1. 直接构建容器数据卷</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接把容器内文件夹挂在到主机文件夹上</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/宿主机绝对路径:/容器内目录</span> <span class="string">镜像名</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在主机根目录下创建MyDockerCentos文件夹，在centos容器中创建MyDockerCentos01文件夹</span></span><br><span class="line"><span class="comment">#挂载成功后，MyDockerCentos01文件夹内容即可共享在MyDockerCentos文件夹内的内容</span></span><br><span class="line"><span class="comment">#添加ro则该文件夹为只读</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/MyDockerCentos:/MyDockerCentos01</span> <span class="string">or</span> <span class="string">centos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过容器元数据查看挂载情况</span></span><br><span class="line"><span class="string">docker</span> <span class="string">inspect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在json中可以看到此段文字</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">&quot;Mounts&quot;:</span> [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;Type&quot;:</span> <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Source&quot;:</span> <span class="string">&quot;/MyDockerCentos&quot;</span>, <span class="comment">#此为主机挂载文件夹路径</span></span><br><span class="line">                <span class="attr">&quot;Destination&quot;:</span> <span class="string">&quot;/MyDockerCentos01&quot;</span>, <span class="comment">#此为容器挂载文件夹路径</span></span><br><span class="line">                <span class="attr">&quot;Mode&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;RW&quot;:</span> <span class="literal">true</span>, <span class="comment">#若为只读，则&quot;RW&quot;为false</span></span><br><span class="line">                <span class="attr">&quot;Propagation&quot;:</span> <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]<span class="string">,</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<h3 id="2通过dockerfile构建容器数据卷">2.通过DockerFile构建容器数据卷</h3>
<p>关于DockerFile，具体介绍见下文</p>
<h4 id="21-编写一个构建docker镜像的脚本">2.1 编写一个构建docker镜像的脚本</h4>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在当前跟根目录新建mydockerfile</span></span><br><span class="line"><span class="string">vim</span> <span class="string">mydockerfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写入以下命令</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">centos</span></span><br><span class="line"><span class="string">VOLUME</span> [<span class="string">&quot;/dataVolumeContainer1&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>]</span><br><span class="line"><span class="string">CMD</span> <span class="string">echo</span> <span class="string">&quot;create success!&quot;</span></span><br><span class="line"><span class="string">CMD</span> <span class="string">/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：可以理解为</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-v</span> <span class="string">/host1:/dataVolumeContainer1</span> <span class="string">-v</span> <span class="string">/host2:/dataVolumeContainer1</span> <span class="string">centeros</span> <span class="string">/bin/bash</span></span><br></pre></td></tr></table></figure>
<h5 id="22-执行dockerfile">2.2 执行dockerfile</h5>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意：命令最后有一个“ . ”，请务必带不要忘记</span></span><br><span class="line"><span class="string">docker</span> <span class="string">build</span> <span class="string">-f</span> <span class="string">/mydocker/mydockerfile</span> <span class="string">-t</span> [<span class="string">新镜像名字</span>] <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行完后打印信息</span></span><br><span class="line">[<span class="string">root@iZwz9ev02los7q1d71e7muZ</span> <span class="string">mydocker</span>]<span class="comment"># docker build -f /mydocker/mydockerfile -t centos .</span></span><br><span class="line"><span class="string">Sending</span> <span class="string">build</span> <span class="string">context</span> <span class="string">to</span> <span class="string">Docker</span> <span class="string">daemon</span>  <span class="number">2.</span><span class="string">048kB</span></span><br><span class="line"><span class="attr">Step 1/4 :</span> <span class="string">FROM</span> <span class="string">centos</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">9f38484d220f</span> <span class="comment">#此为文件中指定的镜像模板ID</span></span><br><span class="line"><span class="attr">Step 2/4 :</span> <span class="string">VOLUME</span> [<span class="string">&quot;/dataVolumeContainer1&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>]</span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">Running</span> <span class="string">in</span> <span class="string">2b7657366a63</span></span><br><span class="line"><span class="string">Removing</span> <span class="string">intermediate</span> <span class="string">container</span> <span class="string">2b7657366a63</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">abec456be739</span></span><br><span class="line"><span class="attr">Step 3/4 :</span> <span class="string">CMD</span> <span class="string">echo</span> <span class="string">&quot;create success!&quot;</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">Running</span> <span class="string">in</span> <span class="string">9e043eaa69dd</span></span><br><span class="line"><span class="string">Removing</span> <span class="string">intermediate</span> <span class="string">container</span> <span class="string">9e043eaa69dd</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">ff5086933e91</span></span><br><span class="line"><span class="attr">Step 4/4 :</span> <span class="string">CMD</span> <span class="string">/bin/bash</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">Running</span> <span class="string">in</span> <span class="string">046617fa2f7a</span></span><br><span class="line"><span class="string">Removing</span> <span class="string">intermediate</span> <span class="string">container</span> <span class="string">046617fa2f7a</span></span><br><span class="line"> <span class="string">---&gt;</span> <span class="string">0245ba1fc082</span> <span class="comment">#根据此id新运行一个容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新运行一个容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">0245ba1fc082</span> <span class="string">/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看根目录所有文件后可见</span></span><br><span class="line">[<span class="string">root@2ca987ed7f70</span> <span class="string">/</span>]<span class="comment"># ll</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">drwxr-xr-x</span>  <span class="number">2</span> <span class="string">root</span> <span class="string">root</span>  <span class="number">4096 </span><span class="string">Jul</span> <span class="number">31</span> <span class="number">15</span><span class="string">:06</span> <span class="string">dataVolumeContainer1</span> <span class="comment">#dataVolumeContainer1</span></span><br><span class="line"><span class="string">drwxr-xr-x</span>  <span class="number">2</span> <span class="string">root</span> <span class="string">root</span>  <span class="number">4096 </span><span class="string">Jul</span> <span class="number">31</span> <span class="number">15</span><span class="string">:06</span> <span class="string">dataVolumeContainer2</span> <span class="comment">#dataVolumeContainer2</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="23-查看数据卷情况">2.3 查看数据卷情况</h5>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看该容器元信息</span></span><br><span class="line"><span class="string">docker</span> <span class="string">inspect</span> <span class="string">2ca987ed7f70</span></span><br><span class="line"><span class="comment">#可知当未指定文件夹在主机的路径时，则默认创建在/var/lib/docker/volumes目录下</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">&quot;Mounts&quot;:</span> [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;Type&quot;:</span> <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Name&quot;:</span> <span class="string">&quot;008c479311eb38775908647c6f89cebbed368107a418a385ee58b5461341db0b&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Source&quot;:</span> <span class="string">&quot;/var/lib/docker/volumes/008c479311eb38775908647c6f89cebbed368107a418a385ee58b5461341db0b/_data&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Destination&quot;:</span> <span class="string">&quot;/dataVolumeContainer2&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Driver&quot;:</span> <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Mode&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;RW&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">&quot;Propagation&quot;:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;Type&quot;:</span> <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Name&quot;:</span> <span class="string">&quot;fdbf4a0b6921b7950a214f8bf028cf00edad091870e523bd694a984cc87fac30&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Source&quot;:</span> <span class="string">&quot;/var/lib/docker/volumes/fdbf4a0b6921b7950a214f8bf028cf00edad091870e523bd694a984cc87fac30/_data&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Destination&quot;:</span> <span class="string">&quot;/dataVolumeContainer1&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Driver&quot;:</span> <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;Mode&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;RW&quot;:</span> <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">&quot;Propagation&quot;:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]<span class="string">,</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<h2 id="五-dockerfile脚本">五、DockerFile脚本</h2>
<h3 id="1-dockerfile简介">1. DockerFile简介</h3>
<p>生成docker镜像的脚本,类似于.bat批处理文件，构建容器的时候会按脚本执行构建，如果在里面写好预先写好环境配置的相关命令，那么执行完脚本以后，就能直接得到一个已经配置好环境的容器</p>
<h3 id="2-dockerfile指令">2. DockerFile指令</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="comment">#基础镜像，指定</span></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="comment">#镜像维护者信息</span></span><br><span class="line"><span class="string">RUN</span> <span class="comment">#容器构建时需要运行的命令</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="comment">#当前容器对外暴露的端口</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="comment">#主机进入容器后的所在的默认路径位置</span></span><br><span class="line"><span class="string">ENV</span> <span class="comment">#用于在构建镜像的过程中设置环境变量</span></span><br><span class="line"><span class="string">COPY/ADD</span> <span class="comment">#将主机文件拷贝至镜像，若ADD则还会自动解压压缩包和出来URL</span></span><br><span class="line"><span class="string">VOLUME</span> <span class="comment">#容器数据卷，用于数据保存和持久化</span></span><br><span class="line"><span class="string">CMD</span> <span class="comment">#指定容器启动时要运行的命令（脚本中可以有多个，但是只有最后一个生效）</span></span><br><span class="line"><span class="string">ENTRYPOINT</span> <span class="comment">#同CMD，但是不会被docker run之后的参数覆盖</span></span><br><span class="line"><span class="string">ONBUILD</span> <span class="comment">#父镜像被子镜像继承后触发</span></span><br></pre></td></tr></table></figure>
<h3 id="3-dockerignore">3. dockerignore</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代表根目录（上下文环境目录中）中以abc开头的任意直接子目录或者直接子文件将被忽略</span></span><br><span class="line"><span class="comment">#如/abc  abc.txt</span></span><br><span class="line"><span class="string">/abc*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代表根目录（上下文环境目录中）中任意直接子目录中以abc开头的任意直接子目录或者直接子文件将被忽略</span></span><br><span class="line"><span class="comment">#如 /file/abc  /file/abc.txt</span></span><br><span class="line"><span class="string">*/abc*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#代表根目录（上下文环境目录中）中任意两级目录下以abc开头的任意直接子目录或者直接子文件将被忽略</span></span><br><span class="line"><span class="comment">#如 /file1/file2/abc  /file1/file2/abc.txt</span></span><br><span class="line"><span class="string">*/*/abc*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#排除根目录中的文件和目录，其名称是单字符扩展名temp。例如，/tempa与/tempb被排除在外。</span></span><br><span class="line"><span class="string">temp?</span>	</span><br><span class="line"></span><br><span class="line"><span class="comment">#Docker还支持一个**匹配任意数量目录（包括零）的特殊通配符字符串</span></span><br><span class="line"><span class="string">**/abc*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以!（感叹号）开头的行可用于对排除项进行例外处理,比如原本包含了README.md这个文件的过滤，但是加了如下一行后</span></span><br><span class="line"><span class="comment">#就不会再过滤README.md，依然会将其提交到守护进程。</span></span><br><span class="line"><span class="type">!README.md</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#异常规则的放置位置会影响行为</span></span><br><span class="line"><span class="string">*.md</span></span><br><span class="line"><span class="type">!README*.md</span></span><br><span class="line"><span class="string">README-secret.md</span></span><br><span class="line"><span class="comment">#README-secret.md 仍然会被忽略</span></span><br><span class="line">	</span><br><span class="line"><span class="string">*.md</span></span><br><span class="line"><span class="string">README-secret.md</span></span><br><span class="line"><span class="type">!README*.md</span></span><br><span class="line"><span class="comment">#README-secret.md 不会被忽略</span></span><br><span class="line"></span><br><span class="line"><span class="string">您甚至可以使用该.dockerignore文件来排除Dockerfile和.dockerignore文件。这些文件仍然发送到守护程序，因为它需要它们来完成它的工作。但是ADD和COPY命令不会将它们复制到图像中。</span></span><br></pre></td></tr></table></figure>
<h2 id="六-dockerfile实战">六、DockerFile实战</h2>
<h3 id="1使用dockerfile自定义一个centos镜像">1.使用DockerFile自定义一个centos镜像</h3>
<p><strong>第一步，编写脚本</strong>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FORM</span> <span class="string">centos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ENV mypath /temp #设置一个环境变量</span></span><br><span class="line"><span class="comment">#WORKDIR $mypath #设置默认进入容器的路径，指向环境变量所规定的路径</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">vim</span> <span class="string">-y</span> <span class="comment">#安装vim</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">tree</span> <span class="string">-y</span> <span class="comment">#安装tree</span></span><br><span class="line"></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">80</span> <span class="comment">#暴露出80端口</span></span><br><span class="line"></span><br><span class="line"><span class="string">CMD</span> <span class="string">echo</span> <span class="string">&quot;success!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">CMD</span> <span class="string">/bin/bash</span></span><br></pre></td></tr></table></figure>
<p><strong>第二步，运行脚本</strong>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">build</span> <span class="string">-f</span> <span class="string">/mydocker/dockerfile/mydockerfile2</span> <span class="string">-t</span> <span class="string">mycentos</span> <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用命令查看容器历史可见</span></span><br><span class="line"><span class="string">docker</span> <span class="string">history</span> <span class="string">22d8bbae3a6f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#顺序加载，倒序执行</span></span><br><span class="line"><span class="string">IMAGE</span>               <span class="string">CREATED</span>             <span class="string">CREATED</span> <span class="string">BY</span>                              		<span class="string">SIZE</span>   </span><br><span class="line"><span class="string">22d8bbae3a6f</span>        <span class="number">3</span> <span class="string">hours</span> <span class="string">ago</span>         <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">tree</span> <span class="string">-y</span> <span class="comment">#安装tree          23MB         </span></span><br><span class="line"><span class="string">b77e4249fba5</span>        <span class="number">3</span> <span class="string">hours</span> <span class="string">ago</span>         <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">vim</span> <span class="string">-y</span> <span class="comment">#安装vim            167MB       </span></span><br><span class="line"><span class="string">9f38484d220f</span>        <span class="number">4</span> <span class="string">months</span> <span class="string">ago</span>        <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]              0B         </span></span><br><span class="line"><span class="string">&lt;missing&gt;</span>           <span class="number">4</span> <span class="string">months</span> <span class="string">ago</span>        <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="comment">#(nop)  LABEL org.label-schema.sc…     0B         </span></span><br><span class="line"><span class="string">&lt;missing&gt;</span>           <span class="number">4</span> <span class="string">months</span> <span class="string">ago</span>        <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="comment">#(nop) ADD file:074f2c974463ab38c…     202MB </span></span><br></pre></td></tr></table></figure>
<p>注意：如果无法解决权限问题报错，可以进入dockerfile文件夹后运行程序</p>
<h3 id="2自定义一个带jdk和tomcat的centos">2.自定义一个带jdk和tomcat的centos</h3>
<p><strong>第一步，编写脚本</strong>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">centos</span></span><br><span class="line"><span class="string">MAINTAINER</span> <span class="string">huang&lt;841396397@qq.com&gt;</span></span><br><span class="line"><span class="comment">#把主机下的目录tomcat和jdk添加至容器，这里脚本与安装包在同一路径下</span></span><br><span class="line"><span class="string">ADD</span> <span class="string">apache-tomcat-8.5.43.tar.gz</span> <span class="string">/usr/local</span></span><br><span class="line"><span class="string">ADD</span> <span class="string">jdk-8u221-linux-i586.tar.gz</span> <span class="string">/usr/local</span></span><br><span class="line"><span class="comment">#安装插件</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">vim</span> <span class="string">-y</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">wget</span> <span class="string">-y</span> </span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">tree</span> <span class="string">-y</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">bash-completion</span> <span class="string">-y</span></span><br><span class="line"><span class="comment">#设置访问时的容器路径</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">MYPATH</span> <span class="string">/usr/local</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">$MYPATH</span></span><br><span class="line"><span class="comment">#配置JDK和tomcat环境 </span></span><br><span class="line"><span class="string">ENV</span> <span class="string">JAVA_HOME</span> <span class="string">/usr/local/jdk1.8.0_221</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">CLASSPATH</span> <span class="string">$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">CATALINA_HOME</span> <span class="string">/usr/local/apache-tomcat-8.5.43</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">CATALINA_BASE</span> <span class="string">/usr/local/apache-tomcat-8.5.43</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">PATH</span> <span class="string">$PATH:$JAVA_HOME/lib:$CATALINA_HOME/lib:$$CATALINA_HOME/bin</span></span><br><span class="line"><span class="comment">#容器运行时监听的端口</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line"><span class="string">CMD</span> <span class="string">/usr/local/apache-tomcat-8.5.43/bin/startup.sh</span> <span class="string">&amp;&amp;</span> <span class="string">tail</span> <span class="string">-F</span> <span class="string">/usr/local/apache-tomcat-8.5.43/bin/logs/catalina.out</span></span><br></pre></td></tr></table></figure>
<p><strong>第二步，运行脚本</strong>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">build</span> <span class="string">-f</span> <span class="string">/mydocker/dockerfile/tomcat</span> <span class="string">-t</span> <span class="string">mytomcat</span> <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行成功</span></span><br><span class="line"><span class="string">REPOSITORY</span>          <span class="string">TAG</span>                 <span class="string">IMAGE</span> <span class="string">ID</span>            <span class="string">CREATED</span>             <span class="string">SIZE</span></span><br><span class="line"><span class="string">mytomcat</span>            <span class="string">latest</span>              <span class="string">71e04bed14cd</span>        <span class="number">9</span> <span class="string">seconds</span> <span class="string">ago</span>       <span class="string">859MB</span></span><br></pre></td></tr></table></figure>
<p><strong>第三步，启动容器</strong>：</p>
<p>注意：配置tomcat和jdk参考 ” linux常用操作 “</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#容器暴露端口，名称</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="string">-it</span> <span class="string">-p</span> <span class="number">8001</span><span class="string">:8080</span> <span class="string">--name</span> <span class="string">mycat</span></span><br><span class="line"><span class="comment">#创建两个容器数据卷</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/tomcatfile/webapp:/usr/local/apache-tomcat-8.5.43/webapp</span></span><br><span class="line"><span class="string">-v</span> <span class="string">/mydocker/dockersoft/tomcatfile/logs:/usr/local/apache-tomcat-8.5.43/logs</span></span><br><span class="line"><span class="string">--privileged=true</span></span><br><span class="line"><span class="comment">#镜像模板</span></span><br><span class="line"><span class="string">mytomcat</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#容器启动</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS           </span><br><span class="line">edd612a7f92f        mytomcat            &quot;/bin/sh -c &#x27;/usr/lo…&quot;   <span class="number">24</span> seconds ago      Up <span class="number">23</span> seconds  </span><br><span class="line"></span><br><span class="line">PORTS                    NAMES</span><br><span class="line"><span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">8001</span>-&gt;<span class="number">8080</span>/tcp   mycat</span><br></pre></td></tr></table></figure>
<h2 id="七-使用阿里云镜像仓库管理镜像">七、使用阿里云镜像仓库管理镜像</h2>
<p>选中镜像仓库管理首页的镜像仓库选项，根据提示创建命名空间和镜像仓库，并绑定github或其他代码托管平台账号</p>
<h3 id="1-打包镜像">1. 打包镜像</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把成功运行的容器打包成镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">commit</span> <span class="string">-m=&quot;jdk+tomcat+centos&quot;</span> <span class="string">-a=&quot;huang&quot;</span> <span class="string">c0733d9e5807</span> <span class="string">mycentos:1.0</span></span><br><span class="line"><span class="comment">#查看镜像</span></span><br><span class="line"><span class="string">Docker</span> <span class="string">Registry</span></span><br><span class="line"><span class="comment">#可见新镜像</span></span><br><span class="line"><span class="string">REPOSITORY</span>          <span class="string">TAG</span>                 <span class="string">IMAGE</span> <span class="string">ID</span>            <span class="string">CREATED</span>             <span class="string">SIZE</span></span><br><span class="line"><span class="string">mycentos</span>            <span class="number">1.0</span>                 <span class="string">fe6434ec860e</span>        <span class="number">6</span> <span class="string">seconds</span> <span class="string">ago</span>       <span class="string">923MB</span></span><br></pre></td></tr></table></figure>
<h3 id="2-登录阿里云docker-registry">2. 登录阿里云Docker Registry</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">login</span> <span class="string">--username=xxxxxxxx</span> <span class="string">registry.cn-shenzhen.aliyuncs.com</span></span><br><span class="line"><span class="string">xxxpasswordxxx</span></span><br></pre></td></tr></table></figure>
<h3 id="3-从registry拉取推送镜像">3. 从Registry拉取/推送镜像</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">pull</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/xxxx/depository01:[镜像版本号]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#推送镜像</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">tag</span> [<span class="string">ImageId</span>] <span class="string">registry.cn-shenzhen.aliyuncs.com/xxxxxx/depository01:[镜像版本号]</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/xxxxxx/depository01:[镜像版本号]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-在阿里云查看镜像">4. 在阿里云查看镜像</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看公有镜像</span></span><br><span class="line"><span class="string">进入阿里云镜像容器管理主界面，选择镜像中心的镜像搜索选项，搜索仓库</span></span><br><span class="line"><span class="string">eg：xxxxxx/depository01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看私有镜像</span></span><br><span class="line"><span class="string">进入阿里云镜像容器管理主界面，选中自己的仓库，点击镜像版本管理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>String类小结</title>
    <url>/2020/08/11/java/String%E7%B1%BB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>java 的 String 类可以说是日常中使用的最多的类，但是大多数时候都只是简单的拼接或者调用 API，只知其然不知其所以然。为了改变这个情况，我决定结合网上的资料，参考源码，深入一点去了解 String 这个熟悉的陌生人。</p>
<p>要第一时间了解一个类，没有什么比官方的javaDoc文档更直观的了：</p>
<blockquote>
<p>String类表示字符串。Java程序中的所有字符串文本（如“abc”）都作为此类的实例实现。</p>
<p><strong>字符串是常量；它们的值在创建后不能更改</strong>。字符串缓冲区支持可变字符串。<strong>因为字符串对象是不可变的，所以可以共享它们</strong>。</p>
<p>类字符串包括用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串以及创建字符串副本的方法，其中所有字符都转换为大写或小写。大小写映射基于Character类指定的Unicode标准版本。</p>
<p><strong>Java语言提供了对字符串连接运算符（+）以及将其他对象转换为字符串的特殊支持。字符串连接是通过<code>StringBuilder</code>（或<code>StringBuffer</code>）类及其<code>append</code>方法实现的。字符串转换是通过<code>toString</code>方法实现的</strong>，由Object定义并由Java中的所有类继承。有关字符串连接和转换的更多信息，请参阅Gosling、Joy和Steele，Java语言规范。</p>
<p>除非另有说明，否则向此类中的构造函数或方法传递null参数将导致引发<code>NullPointerException</code>。 字符串表示UTF-16格式的字符串，其中补充字符由代理项对表示（有关详细信息，请参阅<code>Character</code>类中的Unicode字符表示部分）。索引值引用字符代码单位，因此补充字符在字符串中使用两个位置。</p>
<p>除了处理Unicode代码单元（即字符值）的方法外，String类还提供了处理Unicode代码点（即字符）的方法。</p>
</blockquote>
<p>根据文档，对于String类，我们关注三个问题：</p>
<ul>
<li>String对象的不可变性（为什么是不可变的，这么设计的必要性）</li>
<li>String对象的创建方式（两种创建方式，字符串常量池）</li>
<li>String对象的拼接（StringBuffer，StringBuilder，加号拼接的本质）</li>
</ul>
<h2 id="一-string对象的不可变性">一、String对象的不可变性</h2>
<h3 id="1string为什么是不可变的">1.String为什么是不可变的</h3>
<p>文档中提到：</p>
<blockquote>
<p>字符串是常量；它们的值在创建后不能更改。</p>
</blockquote>
<p>对于这段话我们结合源码来看;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，String类字符其实就是char数组对象的二次封装，存储变量<code>value[]</code>是被final修饰的，所以一个String对象创建以后是无法被改变值的，这点跟包装类是一样的。</p>
<p>我们常见的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;BBB&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>实际上创建了两个String对象，我们使用 = 只是把s指从AAA的内存地址指向了BBB的内存地址。</p>
<p>我们再看看熟悉的<code>substring()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">        : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，在最后也是返回了一个新的String对象，同理，<code>toLowerCase()</code>,<code>trim()</code>等返回字符串的方法也都是在最后返回了一个新对象。</p>
<h3 id="2string不可变的必要性">2.String不可变的必要性</h3>
<p>String之所以被设计为不可变的，目的是为了<strong>效率和安全性</strong>：</p>
<ul>
<li>效率：
<ol type="1">
<li>String不可变是字符串常量池实现的必要条件，通过常量池可以避免了过多的创建String对象，节省堆空间。</li>
<li>String的包含了自身的HashCode，不可变保证了对象HashCode的唯一性，避免了反复计算。</li>
</ol></li>
<li>安全性：
<ol type="1">
<li>String被许多Java类用来当参数，如果字符串可变，那么会引起各种严重错误和安全漏洞。</li>
<li>再者String作为核心类，很多的内部方法的实现都是本地调用的，即调用操作系统本地API，其和操作系统交流频繁，假如这个类被继承重写的话，难免会是操作系统造成巨大的隐患。</li>
<li>最后字符串的不可变性使得同一字符串实例被多个线程共享，所以保障了多线程的安全性。而且类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。</li>
</ol></li>
</ul>
<h2 id="二-字符串常量池">二、字符串常量池</h2>
<h3 id="1作用">1.作用</h3>
<p>文档中有提到：</p>
<blockquote>
<p>因为字符串对象是不可变的，所以可以共享它们</p>
</blockquote>
<p>字符串常量池是一块用于记录字符串常量的特殊区域（具体可以参考我在关于<a href="https://www.cnblogs.com/Createsequence/p/13447923.html">jvm内存结构的文章</a>），JDK8之前字符串常量池在方法区的运行时常量池中，JDK8之后分离到了堆中。“共享”操作就依赖于字符串常量池。</p>
<p>我们知道String是一个对象，而<code>value[]</code>是一个不可变值，所以当我们日常中使用String的时候就会频繁的创建新的String对象。JVM为了提高性能减少内存开销，在通过类似<code>String S = “aaa”</code>这样的操作的时候，<strong>JVM会先检查常量池是否是存在相同的字符串，如果已存在就直接返回字符串实例地址，否则就会先实例一个String对象放到池中，再返回地址</strong>。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;aaa&quot;</span>;  </span><br><span class="line">String s2 = <span class="string">&quot;aaa&quot;</span>; </span><br><span class="line">System.out.print(s1 == s2);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>我们知道“==”比较对象的时候比较的是内存地址是否相等，当s1创建的时候，一个“aaa”String对象被创建并放入池中，s1指向的是该对象地址；当第二个s2赋值的时候，JVM从常量池中找到了值为“aaa”的字符串对象，于是跳过了创建过程，直接将s1指向的对象地址也赋给了s2.</p>
<h3 id="2入池方法intern">2.入池方法<code>intern()</code></h3>
<p>这里要提一下String对象的手动入池方法 <code>intern()</code>。</p>
<p>这个方法的注释是这样的：</p>
<blockquote>
<p>最初为空的字符串池由String类私有维护。</p>
<p>调用intern方法时，如果池已经包含等于<code>equal()</code>方法确定的此String对象的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。</p>
</blockquote>
<p>举个例子说明作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;aabb&quot;</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aabb&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>最开始s1创建了“aabb”对象A，并且加入了字符串常量池，接着s2创建了新的"aabb"对象B，这个对象在堆中并且独立于常量池，此时s1指向常量池中的A，s2指向常量池外的B，所以==返回是false。</p>
<p>我们使用<code>intern()</code>方法手动入池，字符串常量池中已经有了值等于“aabb”的对象A，于是直接返回了对象A的地址，此时s1和s2指向的都是内存中的对象A，所以==返回了true。</p>
<h2 id="三-string对象的创建方式">三、String对象的创建方式</h2>
<p>从上文我们知道String对象的创建和字符串常量池是密切相关的，而创建一个新String对象有两种方式：</p>
<ul>
<li>使用字面值形式创建。类似 <code>String s = "aaa"</code></li>
<li>使用new关键字创建。类似 <code>String s = new String("aaa")</code></li>
</ul>
<h3 id="1使用字面值形式创建">1.使用字面值形式创建</h3>
<figure>
<img src="http://img.xiajibagao.top/字面量形式创建String.png" alt="字面值形式创建String"><figcaption aria-hidden="true">字面值形式创建String</figcaption>
</figure>
<p><strong>当使用字面值创建String对象的时候，会根据该字符串是否已存在于字符串常量池里来决定是否创建新的String对象。</strong></p>
<p>当我们使用类似<code>String s = "a"</code>这样的代码创建字符串常量的时候，JVM会先检查“a”这个字符串是否在常量池中：</p>
<ul>
<li><p><strong>如果存在，就直接将此String对象地址赋给引用s（引用s是个成员变量，它在虚拟机栈中）</strong>；</p></li>
<li><p><strong>如果不存在，就会先在堆中创建一个String对象，然后将对象移入字符串常量池，最后将地址赋给s</strong>。</p></li>
</ul>
<h3 id="2使用new关键字创建">2.使用new关键字创建</h3>
<figure>
<img src="http://img.xiajibagao.top/new关键字创建String.png" alt="new关键字创建String"><figcaption aria-hidden="true">new关键字创建String</figcaption>
</figure>
<p><strong>当使用String关键字创建String对象的时候，无论字符串常量池中是否有同值对象，都会创建一个新实例。</strong></p>
<p>看看new调用的的构造函数的注释：</p>
<blockquote>
<p>初始化新创建的字符串对象，使其表示与参数相同的字符序列；换句话说，<strong>新创建的字符串是参数字符串的副本</strong>。除非需要original的显式副本，否则没有必要使用此构造函数，因为字符串是不可变的。</p>
</blockquote>
<p>当我们使用new关键字创建String对象时，和字面值形式创建一样，JVM会检查字符串常量池是否存在同值对象：</p>
<ul>
<li><strong>如果存在，则就在堆中创建一个对象，然后返回该堆中对象的地址</strong>；</li>
<li><strong>否则就先在字符串常量池中创建一个String对象，然后再在堆中创建一个一模一样的对象，然后返回堆中对象的地址</strong>。</li>
</ul>
<p>也就是说，使用字面值创建后产生的对象只会有一个，但是用new创建对象后产生的对象可能会有两个（只有堆中一个，或者堆中一个和常量池中一个）。</p>
<p>我们举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;aabb&quot;</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aabb&quot;</span>);</span><br><span class="line">String s3 = <span class="string">&quot;aa&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;aa&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s4); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，四个String对象是都是相互独立的。</p>
<p>实际上，执行完以后对象在内存中的情况是这样的：</p>
<figure>
<img src="http://img.xiajibagao.top/代码执行后堆和常量池中的String对象.png" alt="代码执行后堆和常量池中的String对象"><figcaption aria-hidden="true">代码执行后堆和常量池中的String对象</figcaption>
</figure>
<h3 id="3小结">3.小结</h3>
<ul>
<li>使用new或者字面值形式创建String时都会根据常量池是否存在同值对象而决定是否在常量池中创建对象</li>
<li>使用字面值创建的String，引用直接指向常量池中的对象</li>
<li>使用new创建的String，还会在堆中常量池外再创建一个对象，引用指向常量池外的对象</li>
</ul>
<h2 id="四-string的拼接">四、String的拼接</h2>
<p>我们知道，String经常会用拼接操作，而这依赖于StringBuilder类。实际上，<strong>字符串类不止有String，还有StringBuilder和StringBuffer</strong>。</p>
<p>简单的来说，StringBuilder和StringBuffer与String的主要区别在于后两者是<strong>可变的字符序列</strong>，每次改变都是针对对象本身，而不是像String那样直接创建新的对象，然后再改变引用。</p>
<h3 id="1stringbuilder">1.StringBuilder</h3>
<p>我们先看看它的javaDoc是怎么介绍的：</p>
<blockquote>
<p><strong>可变的字符序列</strong>。</p>
<p><strong>此类提供与StringBuffer兼容的API，但不保证同步</strong>。</p>
<p>此类设计为在单线程正在使用StringBuilder的地方来代替StringBuffer。在可能的情况下，建议优先使用此类而不是StringBuffer，因为在大多数实现中它会更快。</p>
<p>StringBuilder上的主要操作是<code>append()</code>和<code>insert()</code>方法，它们会被重载以接受任何类型的数据。每个有效地将给定的基准转换为字符串，然后将该字符串的字符追加或插入到字符串生成器中。 a<strong>ppend方法始终将这些字符添加到生成器的末尾。 insert方法在指定点添加字符</strong>。</p>
<p>例如:</p>
<p>如果z指向当前内容为“ start”的字符串生成器对象，则方法调用z.append（“ le”）会使字符串生成器包含“ startle”，而z.insert（4，“ le”）将更改字符串生成器以包含“ starlet”。</p>
<p>通常，如果sb引用StringBuilder的实例，则sb.append（x）与sb.insert（sb.length（），x）具有相同的效果。每个字符串生成器都有能力。只要字符串构建器中包含的字符序列的长度不超过容量，就不必分配新的内部缓冲区。如果内部缓冲区溢出，则会自动变大。</p>
<p>StringBuilder实例不能安全地用于多个线程。如果需要这样的同步，则建议使用StringBuffer。除非另有说明，否则将null参数传递给此类中的构造函数或方法将导致引发NullPointerException。</p>
</blockquote>
<p>我们知道这个类的主要作用在于能够动态的扩展（<code>append()</code>）和改变字符串对象（<code>insert()</code>）的值。</p>
<p>我们对比一下String和StringBuilder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，两者的区别在于String实现了Comparable接口而StringBulier继承了抽象类AbstractStringBuilder。后者的扩展性就来自于AbstractStringBuilder。</p>
<p>AbstractStringBuilder中和String一样采用一个<strong>char数组</strong>来保存字符串值，但是这个char数组是未经final修饰，是可变的。</p>
<p>char数组有一个初始大小，跟集合容器类似，当append的字符串长度超过当前char数组容量时，则对char数组进行动态扩展，即重新申请一段更大的内存空间，然后将当前char数组拷贝到新的位置；反之就会适当缩容。</p>
<p>一般是新数组长度默认为：<code>(旧数组长度+新增字符长度) * 2 + 2</code>。(不太准确，想要了解更多的同学可以参考AbstractStringBuilder类源码中的<code>newCapacity()</code>方法)</p>
<h3 id="2加号拼接与append方法拼接">2.加号拼接与append方法拼接</h3>
<p>我们平时一般都直接对String使用加号拼接，实际上这仍然还是依赖于StringBuilder的<code>append()</code>方法。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这写法实际上编译以后会变成类似这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s = (<span class="keyword">new</span> StringBuilder(String.valueOf(s))).append(<span class="string">&quot;a&quot;</span>).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看见<strong>每一次循环都会生成一个新的StringBuilder对象，这样无疑是很低效的</strong>，也是为什么网上很多文章会说循环中拼接字符串不要使用String而是StringBuilder的原因。因为如果我们自己写就可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明显比编译器转换后的写法要高效。</p>
<p>理解了加号拼接的原理，我们也就知道了为什么字符串对象使用加号凭借==返回的是false：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">String s4 = s1 + s2;</span><br><span class="line">String s5 = <span class="string">&quot;ab&quot;</span> + s3;</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s5); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>分析一下上面的过程，<strong>无论 <code>s1 + s2</code>还是 <code>"ab" + s3</code>实际上都调用了StringBuilder在字符串常量池外创建了一个新的对象</strong>，所以==判断返回了false。</p>
<p>值得一提的是，如果我们遇到了“常量+字面值”的组合，是可以看成单纯的字面值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String s3 = <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">String s5 = <span class="string">&quot;ab&quot;</span> + s3;</span><br><span class="line">System.out.println(s1 == s5); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>总结一下就是：</p>
<ul>
<li><strong>对于“常量+字面值”的组合，可以等价于纯字面值创建对象</strong></li>
<li><strong>对于包含字符串对象引用的写法，由于会调用StringBuilder类的toString方法生成新对象，所以等价于new的方式创建对象</strong></li>
</ul>
<h3 id="3stringbuffer">3.StringBuffer</h3>
<p>同样看看它的javaDoc，与StringBuilder基本相同的内容我们跳过：</p>
<blockquote>
<p><strong>线程安全的可变字符序列</strong>。StringBuffer类似于字符串，但是可以修改。</p>
<p>对于**。字符串缓冲区可安全用于多个线程。这些方法在必要时进行同步，以使任何特定实例上的所有操作都表现为好像以某种串行顺序发生，该顺序与所涉及的每个单独线程进行的方法调用的顺序一致。</p>
<p>... ...</p>
<p>请注意，虽然StringBuffer被设计为可以安全地从多个线程中并发使用，但是如果将构造函数或append或insert操作传递给在线程之间共享的源序列，则调用代码必须确保该操作具有一致且不变的视图操作期间源序列的长度。这可以通过调用方在操作调用期间保持锁定，使用不可变的源序列或不跨线程共享源序列来满足。</p>
<p>... ...</p>
<p><strong>从JDK 5版本开始，该类已经添加了一个等效类StringBuilder，该类旨在供单线程使用。</strong>通常应优先使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步，因此它比所有此类都优先使用。</p>
</blockquote>
<p>可以知道，StringBuilder是与JDK5之后添加的StringBuffer是“等效类”，两个类功能基本一致，唯一的区别在于<strong>StringBuffer是线程安全的</strong>。</p>
<p>我们查看源码，可以看到<strong>StringBuffer实现线程安全的方式是为成员方法添加<code>synchronized</code>关键字进行修饰</strong>，比如<code>append()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，StringBuffer几乎所有的方法都加了<code>synchronized</code>。这也就不难理解为什么一般情况下StringBuffer效率不如StringBuilder了，因为StringBuffer的所有方法都加了锁。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis在SpringBoot的基本使用</title>
    <url>/2020/11/24/spring/Redis%E5%9C%A8SpringBoot%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一-配置">一、配置</h2>
<h3 id="1添加依赖">1.添加依赖</h3>
<p>在 springboot 启动器中直接添加依赖，或者创建后添加 Maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-boot-starter-data-redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，默认在springboot 1X 中默认使用的是 Jedis 客户端，而在 springboot 2X 默认使用的就是 Lettuce，我这里使用的是 2X 的版本，所以要添加 Jedis 的客户端依赖。</p>
<h3 id="2配置连接池">2.配置连接池</h3>
<p>在 springboot 配置文件中配置连接信息：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment"># redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># 数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="comment">#- 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10000</span></span><br><span class="line">    <span class="comment"># jedis 线程池设置</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">        <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="3配置redistemplate">3.配置RedisTemplate</h3>
<p>其实这个时候已经可以使用 RedisTemplate 操作 redis了，因为 Spring 已经默认提供 <code>RedisTemplate&lt;Object, Object&gt;</code> 和 <code>RedisTemplate&lt;String, String&gt;</code> 这两个 <code>RedisTemplate&lt;K,V&gt;</code> 的两个子类供我们使用。但是前者要求作为 key 和 value 的类型必须实现 Serializable 接口，而后者需要我们在存入数据之前自己将 key 和 value 变成 string ，所以这默认的 RedisTemplate 并不是那么好用，最好自己再重新配置一个 <code>RedisTemplate&lt;String, Object&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池配置信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JedisPoolConfig <span class="title">jedisPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    <span class="comment">// 最大连接数</span></span><br><span class="line">    jedisPoolConfig.setMaxTotal(maxActive);</span><br><span class="line">    <span class="comment">// 当池内没有可用连接时，最大等待时间</span></span><br><span class="line">    jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">    <span class="comment">// 最大空闲连接数</span></span><br><span class="line">    jedisPoolConfig.setMinIdle(maxIdle);</span><br><span class="line">    <span class="comment">// 最小空闲连接数</span></span><br><span class="line">    jedisPoolConfig.setMinIdle(minIdle);</span><br><span class="line">    <span class="keyword">return</span> jedisPoolConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jedis连接工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jedisPoolConfig 上文配置的jedis连接池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> org.springframework.data.redis.connection.jedis.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/23 13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">(JedisPoolConfig jedisPoolConfig)</span> </span>&#123;</span><br><span class="line">    JedisClientConfiguration jedisClientConfiguration = JedisClientConfiguration.builder().usePooling()</span><br><span class="line">        .poolConfig(jedisPoolConfig).and().readTimeout(Duration.ofMillis(timeout)).build();</span><br><span class="line">    RedisStandaloneConfiguration redisStandaloneConfiguration = <span class="keyword">new</span> RedisStandaloneConfiguration();</span><br><span class="line">    redisStandaloneConfiguration.setHostName(host);</span><br><span class="line">    redisStandaloneConfiguration.setPort(port);</span><br><span class="line">    redisStandaloneConfiguration.setPassword(RedisPassword.of(password));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory(redisStandaloneConfiguration, jedisClientConfiguration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Jackson2JsonRedisSerializer代替默认的序列化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer&lt;java.lang.Object&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/24 16:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jackson2JsonRedisSerializer&lt;Object&gt; <span class="title">jackson2JsonRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer =</span><br><span class="line">        <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    objectMapper.configure(MapperFeature.USE_ANNOTATIONS, <span class="keyword">false</span>);</span><br><span class="line">    objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则会报java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX</span></span><br><span class="line">    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonRedisSerializer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置redisTemplate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jedisConnectionFactory 上文配置的jedis连接工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jackson2JsonRedisSerializer  上文配置的序列化类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> org.springframework.data.redis.core.RedisTemplate&lt;java.lang.String,java.lang.Object&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/24 16:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(JedisConnectionFactory jedisConnectionFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接工厂</span></span><br><span class="line">    RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(jedisConnectionFactory);</span><br><span class="line">    redisTemplate.setEnableTransactionSupport(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义key的序列化方式</span></span><br><span class="line">    StringRedisSerializer stringSerial = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 序列化方式使用stringSerial</span></span><br><span class="line">    redisTemplate.setKeySerializer(stringSerial);</span><br><span class="line">    <span class="comment">// value 序列化方式使用jackson</span></span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    <span class="comment">// hash key 序列化方式使用stringSerial</span></span><br><span class="line">    redisTemplate.setHashKeySerializer(stringSerial);</span><br><span class="line">    <span class="comment">// hash value 序列化方式使用jackson</span></span><br><span class="line">    redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：以上配置跟网上找到的大同小异，但是尤其要注意在 jackson2JsonRedisSerializer 中对 ObjectMapper 的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br></pre></td></tr></table></figure>
<p>如果不设置此项，ObjectMapper 会将 redis 返回的字符串反序列化为 <code>java.util.LinkedHashMap</code>，结果就是 Spring 做类型转换的时候报错：<code>java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to XXX</code>。</p>
<h2 id="二-使用">二、使用</h2>
<h3 id="1封装为工具类">1.封装为工具类</h3>
<p>RedisTemplate 内部已经提供了一系列 API 供我们调用，但是使用起来也并不是很方便，因此基本都会再封装一层作为工具类使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2使用">2.使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;template&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">getByTemplate</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Object object = redisTemplate;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        redisUtils.set(key, <span class="string">&quot;这是一条来自缓存的数据！&quot;</span>);</span><br><span class="line">        object = <span class="string">&quot;已经存入缓存！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.success(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&quot;data&quot;: &quot;已经存入缓存！&quot;&#125;</span></span><br><span class="line"><span class="comment">//&#123;&quot;data&quot;: &quot;这是一条来自缓存的数据&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="三-接入-springcache">三、接入 SpringCache</h2>
<p>SpringCache 是在 Spring3 版本开始加入的缓存接口，在配置 RedisCacheManager 之后，我们可以很方便通过注解实现方法级别的缓存。</p>
<p>具体的内容可以参考前文：<a href="https://www.cnblogs.com/Createsequence/p/11237426.html">使用SpringCache做简单缓存</a>。具体实例仍然同前文中一样，提因此只在上述配置的基础上再提供一个 RedisCacheManager 配置类。即可实现从 ConcurrentMapCacheManager 到 RedisCacheManager 的切换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RedisCacheConfig配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/24 13:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 配置CacheManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> template 在RedisConfig中定义的RedisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.cache.CacheManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Createsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2020/11/24 16:21</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate&lt;String, Object&gt; template)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置RedisCacheConfiguration</span></span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            <span class="comment">// 设置key为String</span></span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(template.getStringSerializer()))</span><br><span class="line">            <span class="comment">// 设置value 为自动转Json的Object</span></span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(template.getValueSerializer()))</span><br><span class="line">            <span class="comment">// 不缓存null</span></span><br><span class="line">            .disableCachingNullValues()</span><br><span class="line">            <span class="comment">// 缓存数据保存1小时</span></span><br><span class="line">            .entryTtl(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用RedisCacheConfiguration创建RedisCacheManager</span></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.RedisCacheManagerBuilder</span><br><span class="line">            <span class="comment">// Redis 连接工厂</span></span><br><span class="line">            .fromConnectionFactory(Objects.requireNonNull(template.getConnectionFactory()))</span><br><span class="line">            <span class="comment">// 缓存配置</span></span><br><span class="line">            .cacheDefaults(redisCacheConfiguration)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里有一个坑，就是<strong>在 SpringBoot 1X 中，RedisCacheManager 构造器传入的参数的 RedisTemplate，而在 SpingBoot 2X 中需要传入 RedisCacheConfiguration 作为配置对象</strong>，点开源码也能看得见，构造器里没有 RedisTemplate 类型的参数。否则获取的数据可能会出现乱码。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(七)：全局锁，表锁，行锁，间隙锁</title>
    <url>/2020/11/03/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%85%A8%E5%B1%80%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81%EF%BC%8C%E8%A1%8C%E9%94%81%EF%BC%8C%E9%97%B4%E9%9A%99%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 6、7、20 节锁相关部分的总结</p>
</blockquote>
<h2 id="一-全局锁">一、全局锁</h2>
<h3 id="1概述">1.概述</h3>
<p>全局锁就是对整个数据库实例加锁。通过使用 <code>Flush tables with read lock</code>（FTWRL）语句加锁，此后整个库都会处于只读状态，这时，其他线程的数据定义语句（DDL），数据操作语句（DML）以及更新类事务的提交语句都会被阻塞。</p>
<p>也就是说，<strong>加了全局锁以后，其他线程不能对数据增删改，也不能对表增删改</strong>。</p>
<p>另外值得一提的是，在此之前，数据库会<strong>等待 FTWRL 操作前的所有读写操作完成，事务提交完毕；并且把脏页的数据从缓存刷入磁盘，保证数据的一致性</strong>。</p>
<p>全局锁的典型使用场景是对数据库进行整库备份。</p>
<h3 id="2全局锁的缺陷和解决方案">2.全局锁的缺陷和解决方案</h3>
<p>全局锁有以下问题：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li>
</ul>
<p>但是，<strong>如果不加锁，备份时如果有表的数据发生了变更，那么备份后的数据库就不能保证整个库的表都是在同一个逻辑时间点</strong>，可能会导致使用备份恢复数据库的时候，发生类似“我扣款了但是我下的单没了”，或者“我下单了但是没扣款”这样的问题。</p>
<p>根据前文提到的数据库事务相关知识，我们知道，要保证一个事务进行中，其他事务的提交不影响会到这个事务，也就是要求事务执行前后的数据要一致，就需要<strong>开启可重复读的隔离级别</strong>。根据这个原理，官方自带的逻辑备份工具 mysqldump 当使用参数 <code>–single-transaction</code> 的时候，<strong>导出数据之前就会启动一个事务，来确保拿到一致性视图</strong>。而且由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>
<p>single-transaction 虽好，但是对于像 MyISAM 这样不支持事务的引擎而言就享受不到这样的便利，所以还是需要 FTWRL 语句。这也是为什么推荐使用 innodb 引擎的原因之一。</p>
<h3 id="3-为何不能使用readonly替代">3. 为何不能使用readonly替代</h3>
<p>全局锁的效果表现为全库变为只读，但是同样的效果，<code>set global readonly=true</code> 却不是一个合适的替代方案：</p>
<ol type="1">
<li><strong>global 不宜改动</strong>：在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大。</li>
<li><strong>在异常处理机制上有差异</strong>：<strong>如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁</strong>，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会<strong>一直保持 readonly 状态</strong>，这样会导致整个库长时间处于不可写状态，风险较高。</li>
<li><strong>无法限制超管操作</strong>：只会禁止普通用户权限的 mysql 写操作，不能限制 super 权限用户的写操作。</li>
</ol>
<h2 id="二-表级锁">二、表级锁</h2>
<p>表级锁是针对数据库表的锁，分为两种：表锁和元数据锁（MDL）。</p>
<h3 id="1表锁">1.表锁</h3>
<p>表锁的语法是<code>lock tables … read/write</code>他与全局锁类似，也可以通过<code>unlock tables</code>提前释放锁，也可以在客户端断开连接的时候自动释放锁。</p>
<p>如语法所说，表锁区分读锁和写锁，与全局锁不同的是，<strong>表锁除了限制别的线程的操作外，也会限制本线程的操作</strong>：</p>
<blockquote>
<p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
</blockquote>
<h3 id="2元数据锁">2.元数据锁</h3>
<p>元数据锁跟表锁相比，最显著的差别在于<strong>元数据锁不需要显式的调用，在访问表的时候会自动加上</strong>。</p>
<p>元数据锁的作用在于保证读写的正确性。假设在没有加表锁的情况下，一个线程对另一个线程正在查询的表结构做了修改，那么就会导致查询出了结构不正确的数据。为此 mysql 在5.5版本中引入了 MDL：当读的时候加 MDL 读锁，写的时候加 MDL 写锁。</p>
<p>申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到 MDL 锁后，直到事务执行完才会将锁释放。<strong>如果事务中包含 DDL 操作，mysql 会在 DDL 操作语句执行前，隐式提交commit，以保证该DDL语句操作作为一个单独的事务存在，同时也保证元数据排他锁的释放</strong>。</p>
<p>换句话说，<strong>元数据锁最主要的目的不是保证 select 与 update 之间的正确进行，而是保证 DDL 语句 和 DML/DQL 语句之间的正确进行</strong>。</p>
<p>其中：</p>
<ol type="1">
<li>读锁与读锁之间不互斥，因此可以同时有多个线程对同一张表进行查询；</li>
<li>读锁之写锁之间是互斥的，并且写锁获取优先级高，这可以避免一次事务的两次查询查到不一样的表结构；</li>
<li>写锁与写锁之间是互斥的，这可以用来保证要更改表结构的操作的安全性；</li>
</ol>
<p>第二点很好理解，但是第一点可能有点难理解，我们举个例子：</p>
<p>假如A和B线程同时修改T表的两行数据，A 线程先分别获取 MDL 读锁和 MDL 写锁，然后 B 线程获取 MDL 读锁，但是 B 线程无法获取MDL写锁，所以 B 线程进入等待，等到 A 线程完成后B线程才获取写锁，继续操作。</p>
<h3 id="3元数据锁存在的问题">3.元数据锁存在的问题</h3>
<p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。所以可能会出现这样的问题：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201022131135062.png" alt="image-20201022131135062"><figcaption aria-hidden="true">image-20201022131135062</figcaption>
</figure>
<ol type="1">
<li>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行；</li>
<li>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞；</li>
<li>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了；</li>
<li>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</li>
</ol>
<p>针对以上的情况，我们有以下的改善方式：</p>
<ol type="1">
<li>假如不是热点表：如果要修改的表有长事务要进行，<strong>要么 kill 掉长事务，要么先暂停表结构的修改</strong>；</li>
<li>假如是热点表：<strong>为 alert 语句加上等待时间</strong>，避免长时间的阻塞后面的语句。</li>
</ol>
<h2 id="三-行锁">三、行锁</h2>
<h3 id="1概述">1.概述</h3>
<p>顾名思义，行锁的作用是保证对同一行数据的并发修改可以正确进行。</p>
<p>假设我们有这样一条sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> a = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> a = <span class="number">3</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>这个过程是这样的：</p>
<ol type="1">
<li>开启了一个事务；</li>
<li>第一条 sql 获得了 id = 1 这一行的行锁，执行完后不释放；</li>
<li>第二条 sql 获得了 id = 2 这一行的行锁，但是执行完也不释放；</li>
<li>提交事务，并且释放所有的行锁。</li>
</ol>
<p>我们可以看到，<strong>行锁是需要的时候就加上，但是更新完后并不会立刻释放，而是等到事务提交后再统一释放。这就是行锁的两阶段锁。</strong></p>
<p>基于两阶段锁的原理，对于一些 sql ，我们可以做一些优化，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> a = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> a = <span class="number">3</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>上面这条 sql 涉及到两个 update 的 sql，一条 select 的 sql。如果可能的话，我们可以把 select 的操作放到最前面，这样就能减少两条 update 的 sql 获取行锁的时间。</p>
<h3 id="2死锁与死锁处理策略">2.死锁与死锁处理策略</h3>
<p>在学多线程的时候不难理解死锁的概念，两个线程互相持有对方所需要的锁就会导致死锁。我们拿数据库中的死锁举例：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201022134524700.png" alt="image-20201022134524700"><figcaption aria-hidden="true">image-20201022134524700</figcaption>
</figure>
<p>这时候，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。</p>
<p>当出现死锁以后，有两种策略：</p>
<ol type="1">
<li><p><strong>直接进入等待，直到超时</strong>。</p>
<p>这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。</p></li>
<li><p>发<strong>起死锁检测，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行</strong>。</p>
<p>将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p></li>
</ol>
<p>设置超时时间看上去是个好选择，但是实际上这个时间很难把握。innodb 的默认超时时间是50s，这个时间几乎是不可能接受的。但是如果将时间设置果断，可能又会导致正常的等待锁释放的过程受到影响。</p>
<p>因此，还是需要采用第二种策略，死锁检测。<strong>这个也是 innodb 默认开启的。死锁检测的问题在于检测过程也是一个非常消耗性能的过程</strong>。当多个事务同时更新一条数据的时候，每个线程都要把所有争夺这把锁的线程检测一遍。这也是有时候 cpu 利用率极高，但是每秒仍然执行不了几个事务。</p>
<h3 id="3死锁检测的优化">3.死锁检测的优化</h3>
<p>说明的是，并非所有的访问都需要加锁，对于读和一般不太可能出现死锁的情况是不会进行检测的，比如：</p>
<blockquote>
<p>B在等A，D在等C，现在来了一个E，发现E需要等D，那么E才判断跟D、C是否会形成死锁，这个检测不用管B和A</p>
</blockquote>
<p>死锁检测的处理过程是很难优化的，我们只能想办法避免这个过程。为此，我们有以下几种方式来优化死锁检测：</p>
<ul>
<li><strong>关掉不必要是死锁检测</strong>。如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的；</li>
<li><strong>在客户端做控制并发度</strong>。即控制客户端的并发线程。但是这个方法并不可靠，因为客户端的数量并不可控，即使每个客户端只允许存在三个并发线程，一旦客户端达到1000个，最后还是会可能达到3000个的并发线程；</li>
<li><strong>在服务端做并发控制</strong>。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。但是这个方案有很高的技术要求。</li>
<li><strong>分散锁冲突</strong>。即在逻辑上把一行数据改成多行数据，比如对一个总金额字段改为多个金额字段的和。这样在操作的时候锁冲突就会由一个锁分散到多个锁。但是这个方案需要修改业务逻辑，也涉及到一些其他代码的改动。</li>
</ul>
<h3 id="4行锁的锁定范围">4.行锁的锁定范围</h3>
<p>虽然叫行锁，但是<strong>锁并不是只锁一条数据，有些时候行锁会锁住多条数据，在一些没指明主键的情况，行锁会直接转为表锁</strong>。</p>
<p>我们举个例子:</p>
<p>假设有个表单 products ，里面有 id 跟 name 二个字段。</p>
<ol type="1">
<li><p>明确指定主键，并且有能查到，加行锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">&#x27;3&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">&#x27;3&#x27;</span> <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>明确指定主键，不能查到，不加锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">&#x27;-1&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>不指明主键，加表锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;Mouse&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>主键不明确，加表锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="string">&#x27;3&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">&#x27;3&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>实际上，不难看出，如果没有使用索引，行锁很容易就会上升到表锁。</p>
<h2 id="四-间隙锁">四、间隙锁</h2>
<h3 id="1行锁的局限性">1.行锁的局限性</h3>
<p>假设有表 t，t 有 id 和 d 两个字段。现有数据（0，5）和（2，1）。</p>
<p>我们开启一个事务，加上写锁，进行了三次查询，这样每次都是“当前读”;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">where</span> d = <span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d = <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d = <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q2</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> d = <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q3</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>其中，在 Q1 和 Q2 的间隙有一个事务进行了更新：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d = <span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>; <span class="comment"># Q4</span></span><br></pre></td></tr></table></figure>
<p>在 Q2 和 Q3 的间隙进行了一次插入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">5</span>); <span class="comment"># Q5</span></span><br></pre></td></tr></table></figure>
<p>现在 sql 的执行顺序是：Q1 -&gt; Q4 -&gt; Q2 -&gt; Q5 -&gt; Q3</p>
<p>在这种情况下，三条查询的 sql 分别查询出了一条、两条、三条数据：</p>
<ul>
<li>Q1：查到了（10，5）</li>
<li>Q2：查到了（0，5），（2，5）</li>
<li>Q3：查到了（0，5），（2，5），（3，5）</li>
</ul>
<p>其中，<strong>Q3 查到了一条原本不存在的数据，也就是幻读</strong>。</p>
<p>我们可以看到，虽然在事务一开始的时候就已经拿到了（0，5）的行锁，但是由于没有锁住其他的行，导致最后在 binlog 里出现了严重的数<strong>据不一致问题</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d = <span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">where</span> d = <span class="number">5</span> <span class="comment"># 最后事务提交的时候行锁才释放</span></span><br></pre></td></tr></table></figure>
<p>也就是说，当从库同步的时候，或者通过 binlog 备份的时候，<strong>原本在数据中的数据，应该只有（0，5）这行的 id 被改成了5，但是最后备份的时候（2，5）和（3，5）的 id 也要被改成了5</strong>，先不说是否能成功，这种情况显然是不允许出现的。</p>
<p>由于没锁住其他的行，导致了 binlog 上因为顺序导致的数据不一致问题，那么如果把所有扫描到的行都加上锁，那么 Q1 和 Q2 之间的更新就会被放到 Q3 执行事务提交完后，反应到 binlog：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">where</span> d = <span class="number">5</span> <span class="comment"># 最后事务提交的时候行锁才释放</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d = <span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>; <span class="comment"># 拿到写锁后才能更新</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，及时这样，insert 语句还是会引起 binlog 上的数据不一致，最根本的原因在于，<strong>加锁的时候（3，5）这行还不存在，所以锁加不到这行数据上</strong>。这就是幻读引起的问题。</p>
<p>因此，需要一种新的锁，来锁住行与行的间隙，来防止意外的插入，这就是间隙锁。</p>
<h3 id="2间隙锁">2.间隙锁</h3>
<p>行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”，所以可能会出现幻读的情况。因此，为了解决这个问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p>
<p>顾名思义，<strong>间隙锁（next-key lock），锁的就是两个值之间的空隙</strong>。</p>
<p>在最开始，表 t 一共有两条（0，5），（2，5）数据，那么就有三个<strong>前开后闭的区间/间隙</strong>（-∞，0 ]，（0，2 ]，（2，+ supremum )。其中，supremum 是 innodb 允许的索引最大值，这是一个概念上的数，可以认为是正无穷。</p>
<p>当我们执行第 <code>select * from t whrere d = 5 for update</code>的时候，除了为扫描到的两条数据加上行锁外，还会为这三个区间加上间隙锁。</p>
<h3 id="3间隙锁引起死锁问题">3.间隙锁引起死锁问题</h3>
<p>间隙锁跟间隙锁之间是不冲突的，有冲突的是往间隙插入值的行为。也就是说，同样的一个间隙，两条 sql 分别加上了间隙锁，这样就很可能引起死锁。</p>
<p>举个例子：</p>
<p>在一开始的时候，表有（0，5）和（2，1）这两条数据，sessionA 执行了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q1</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># Q2</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>sessionB 在 sessionA 开始事务后也开启了事务：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment"># Q3</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># Q4</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>现在，语句的执行顺序的：Q1 -&gt; Q3 -&gt; Q4 -&gt; Q2。</p>
<p>在这种情况下，不等到 Q4 执行，就已经形成死锁了：</p>
<ol type="1">
<li>session A 执行 Q1 语句，由于 id=1 这一行并不存在，因此会加上间隙锁 (0,2);</li>
<li>session B 执行 Q3 语句，同样会加上间隙锁 (5,12)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li>
<li>session B 试图插入 Q4，被 session A 的间隙锁挡住了，只好进入等待；</li>
<li>session A 试图插入一行 Q2，被 session B 的间隙锁挡住了。</li>
</ol>
<p>至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。</p>
<p>间隙锁在解决了一些问题的情况下，又引入了一些新的问题，所以我们也有其他的选择，并非一定需要引入间隙锁：</p>
<blockquote>
<p>隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。这也是现在不少公司使用的配置组合。</p>
</blockquote>
<p>读提交每次每次 sql 执行的时候都是当前读，所以影响数据的一致性；而 binlog 设置为 row 以后记录的就是每一条数据的变化，因而备份的时候不会导致数据不一致。</p>
<h2 id="五-总结">五、总结</h2>
<p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类，其中针对行锁难以解决的幻读问题，又添加了间隙锁。</p>
<p><strong>全局锁</strong>：</p>
<ol type="1">
<li>通过 <code>Flush tables with read lock</code>（FTWRL）语句加锁，可以主动释放或者在客户端断开连接时释放；</li>
<li>会限制其他线程的 DDL 和 DML 操作，但不会限制自己的；</li>
<li>一般用于 MyISAM 之类不支持事务的引擎进行整库备份。若 innodb 的话，可以开启事务为可重复读，接着 MVCC 实现无全局锁备份。</li>
</ol>
<p><strong>表级锁</strong>：</p>
<ol type="1">
<li>分为表锁和元数据锁，两者都区分读锁和写锁；</li>
<li>表锁：
<ul>
<li>表锁和全局锁一样，可以主动释放或者在客户端断开连接时释放；</li>
<li>表锁是显式使用的，不但限制其他线程对表的操作，也会限制本线程对表的操作；</li>
</ul></li>
<li>元数据锁：
<ul>
<li>是一种典型的读写锁，每一条 DDL 都会自动加上元数据锁；</li>
<li>作用是确保 DDL 和 DML/DQL 语句的正确执行；</li>
<li>元数据锁可能会因为无法获取锁而引起阻塞，最好的办法是避免长事务和 DDL 的同时存在，对于热点数据由于可能存在频繁的事务开启，所以最好为 DDL 语句添加超时时间，再无法修改表结构的情况下避免阻塞。</li>
</ul></li>
</ol>
<p><strong>行级锁</strong>：</p>
<ol type="1">
<li><p>存在两阶段锁的机制：即需要就先获取锁，而使用后不释放锁，直到事务结束再统一释放锁。</p>
<p>因此，优化思路是在执行 sql 的时候把需要获取行锁的语句放在后面，避免过长时间的占用锁；</p></li>
<li><p>可能会存在死锁问题，处理策略有两种：</p>
<ul>
<li>调整超时时间。innodb_lock_wait_timeout 默认为50s。但是调长容易引起阻塞，调短可能影响正常的锁等待；</li>
<li>死锁检测。每次获取锁都检测是否有死锁，有就回滚其中一个事务。innodb_deadlock_detect 是默认开启的，但是容易死锁检测在并发线程多的情况下非常消耗性能。</li>
</ul></li>
<li><p>死锁检测的优化思路有四种：</p>
<ul>
<li>关掉不必要是死锁检测。可能引起大量超时，导致操作丢失；</li>
<li>在客户端做控制并发度。限制客户端线程并发数，但是无法限制客户端数量，所以不是很有效；</li>
<li>在服务端做并发控制。使用中间件或者修改 mysql 源码，让争夺锁的线程进入等待队列；</li>
<li>分散锁冲突。将一个字段在逻辑上分为多个字段，避免多个线程争夺同一把锁。</li>
</ul></li>
<li><p>锁同时存在的情况下，并不是只要满足粒度最小的锁不互斥就可以了，而是必须满足全部全部不互斥才行。</p></li>
</ol>
<p><strong>间隙锁</strong>：</p>
<ol type="1">
<li>锁索引之间的间隙，是前开后闭的区间；</li>
<li>间隙锁之间不冲突，但是插入间隙的行为是冲突的，所以当两个事务同时为一个间隙加锁容易引起死锁；</li>
<li>能解决幻读，但不是必须的。读已提交 + 把 binlog 格式设置为 row 也可以防止幻读。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL45讲》读书笔记(四)：索引</title>
    <url>/2020/10/29/mysql/%E3%80%8AMySQL45%E8%AE%B2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<blockquote>
<p>此文为极客时间：MySQL实战45讲的 4、5、9、10、11、15、18节索引相关部分的总结</p>
</blockquote>
<h2 id="一-innodb索引模型">一、Innodb索引模型</h2>
<h3 id="1主键非主键索引的区别">1.主键/非主键索引的区别</h3>
<p>每个索引在Innodb中都是一颗B+树，其中根据索引叶子节点的不同，分为主键索引和非主键索引。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200930164149290.png" alt="image-20200930164149290"><figcaption aria-hidden="true">image-20200930164149290</figcaption>
</figure>
<p>我们可以看到：</p>
<ul>
<li>主键索引将索引和整行的数据都放在了一起，所以又叫<strong>聚簇索引</strong></li>
<li>非主键索引的叶子节点内容是主键的值。所以又叫<strong>二级索引</strong></li>
</ul>
<p>其中，如果非主键索引查询字段没有做到覆盖索引，就需要先从非主键索引树中找到对应的主键，然后再回到主键索引树找到对应的行数据，这个过程叫做<strong>回表</strong>。</p>
<p>而相应的，直接把全部的主键索引过一遍，然后每拿到一个主键索引，就把相应的数据拿出来，这个过程叫做<strong>全表扫描</strong>。</p>
<h3 id="2索引维护">2.索引维护</h3>
<p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p>
<p>以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<strong>页分裂</strong>。在这种情况下，性能自然会受影响。（同理，相邻的两个页如果删除了数据，也会执行一个合并的过程）</p>
<h3 id="3根据主键和非主键索引排序">3.根据主键和非主键索引排序</h3>
<p>假设t有字段a，b，c，d，设定（a，b）为主键索引，c，（c，b）为非主键索引，当查询的时候情况如下：</p>
<ul>
<li>使用（a，b），则默认排序为先按a排序，再按b排序</li>
<li>使用c，则实际为（c，a，b），先按c排序，再按a排序，接着按b排序</li>
<li>使用（c，b），这实际为（c，b，a），先按c排序，再按b排序，接着按a排序</li>
</ul>
<p>我们可以认为，<strong>排序的时候innodb会默认去重并且在排序条件上加上主键</strong></p>
<h2 id="二-为什么要使用自增主键">二 .为什么要使用自增主键</h2>
<h3 id="1索引有序">1.索引有序</h3>
<p>当我们使用自增主键的时候，插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。这样的主键是默认有序的，不涉及到挪动其他记录，也不会触发叶子节点的分裂</p>
<h3 id="2节约空间">2.节约空间</h3>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p>
<p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。一页加载出来的数据就越多</strong></p>
<h3 id="3非自增主键的情况">3.非自增主键的情况</h3>
<p>一些项目会使用雪花算法获取 id，主键是递增的，就并不会影响索引的有序性。</p>
<h2 id="三-覆盖索引与最左前缀">三、覆盖索引与最左前缀</h2>
<h3 id="1索引覆盖">1.索引覆盖</h3>
<p>假如我们建立了一个覆盖字段id和B的联合索引，如果执行的语句是 select id，B from T where id between 3 and 5，由于要查询的字段id和B都已经在B索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引已经“覆盖了”我们的查询需求，我们称为<strong>覆盖索引</strong>。</p>
<h3 id="2最左前缀">2.最左前缀</h3>
<p>由于Innodb的索引结构是B+树，所以索引可以通过最左前缀原则让联合索引的“一部分”也能起作用。</p>
<p>我们以（name，age）联合索引举例：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20200930171920117.png" alt="image-20200930171920117"><figcaption aria-hidden="true">image-20200930171920117</figcaption>
</figure>
<p>当搜索条件是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span></span><br></pre></td></tr></table></figure>
<p>都能通过索引快速定位到第一个符合条件的记录，然后向后遍历获取数据。</p>
<p>可见，这个<strong>最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong>。</p>
<p>如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
<p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。</p>
<h3 id="3索引下推">3.索引下推</h3>
<p>根据上一个例子，我们有sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">where</span> age = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比age字段值。</p>
<p>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， 可以在索引遍历过程中，先<strong>对索引中包含的字段先做判断，直接过滤掉不满足条件的记录</strong>，减少回表次数。</p>
<p>InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
<p><strong>简单的说，如果你的判断字段被联合索引覆盖了，但是又不符合最左前缀，那样数据库引擎会自动在非主键索引树阶段就做完判断，避免不必要的回表。</strong></p>
<h2 id="四-前缀索引">四、前缀索引</h2>
<h3 id="1前缀索引的优劣">1.前缀索引的优劣</h3>
<p>很多情况下，我们需要根据一个长字符串类型的字段去查找记录，比如身份证，邮箱，为了避免全表扫描，就需要为字符串字段添加索引。</p>
<p>由于Mysql支持前缀索引，所以我们可以选择<strong>将整个字段添加索引，或者只将前一部分的字符串加上索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#整个字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">index</span> index1(email);</span><br><span class="line"><span class="comment">#一部分字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">index</span> index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>
<p>假设我们执行一条查询sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>对于完整索引：</p>
<ol type="1">
<li>从 index1 索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得 ID2 的值；</li>
<li>到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</li>
<li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email='zhangssxyz@xxx.com’的条件了，循环结束。</li>
</ol>
<p>而对于前缀索引：</p>
<ol type="1">
<li>从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；</li>
<li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是’zhangssxyz@xxx.com’，这行记录丢弃；</li>
<li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在 index2 上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>根据这个流程，我们不难发现前缀索引有以下问题：</p>
<ul>
<li><strong>索引覆盖失效</strong>：由于前缀索引在命中以后，必须再回主键索引树确定一次，所以索引覆盖对前缀索引来说是无效的。</li>
<li><strong>回表次数多</strong>：使用前缀索引后，可能会导致查询语句读数据的次数变多。</li>
</ul>
<h3 id="2如何选择合适的长度">2.如何选择合适的长度</h3>
<p>前缀索引需要有足够的区分度才能提高查找效率。比如有ABCC，ABDD，ABEE三条数据，选前两个个字符作为索引等于没加索引，选前三个字符作为索引就很合适。当然，实际情况肯定会更复杂，我们就需要更具体的分析。</p>
<ul>
<li><p>首先，算出这个列上有多少个不同的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> T;</span><br></pre></td></tr></table></figure></li>
<li><p>依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)）<span class="keyword">as</span> L4,</span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)）<span class="keyword">as</span> L5,</span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)）<span class="keyword">as</span> L6,</span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)）<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> T;</span><br></pre></td></tr></table></figure></li>
<li><p>使用前缀索引必然会损失一部分区分度，所以我们需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，然后选择最短的长度。</p></li>
</ul>
<h3 id="3其他优化方式">3.其他优化方式</h3>
<p>对于邮箱，前缀索引效果还比较明显，因为@之前的字符串一般不会有太多的相似度，但是对于比如像身份证这样，同一个县市里的市民只有后几位才会有较大区别的长字符串，可能就需要设置一个非常长的前缀索引了，这显然不是我们乐意见到的。</p>
<ul>
<li><p><strong>倒序存储</strong></p>
<p>我们可以借助<code>reverse()</code>函数实现倒序存储。比如身份证存入的时候我们可以倒序存储，查找的时候也先反转在查找。这样加索引以后只需要选择前几位辨识度高的即可。</p></li>
<li><p><strong>Hash字段</strong></p>
<p>我们借助<code>crc32/64()</code>函数去获取长字符串的校验码，在表上另外开一个字段用于存储对应的校验码，以长度较短的校验码作为索引。不过由于<code>crc32</code>仍然会出现值重复的情况，所以查询的时候还需要判断拿到的记录是否与条件字段完全一致。</p></li>
</ul>
<p>他们的异同如下：</p>
<ul>
<li><strong>都不支持范围查找</strong></li>
<li><strong>占用空间</strong>：倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>
<li><strong>额外消耗</strong>：序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 <code>crc32()</code> 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>
<li><strong>查询效率</strong>：使用 hash 字段方式的查询性能相对更稳定一些。因为 <code>crc32()</code> 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ul>
<p>当然，还有一种折中的方法，就是<strong>拆分字段</strong>：</p>
<p>对于像邮箱这样的字段，有时候@后面的字段往往都是固定的几种，可以单独拆分出来作为一个字段，<span class="citation" data-cites="前的作为单独的字段直接加全字段索引">@前的作为单独的字段直接加全字段索引</span>，这样减少的字段长度，并且保证也了范围查找的性能。</p>
<h3 id="4小结">4.小结</h3>
<p>要给字符串类型字段的加索引，我们有以下几种方式：</p>
<ol type="1">
<li>直接创建完整索引，这样可能比较占用空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ol>
<h2 id="五-唯一索引和-change-buffer">五、唯一索引和 change buffer</h2>
<h3 id="1对查找的影响">1.对查找的影响</h3>
<p>对于普通索引，当执行定值查找的时候，会先按索引找到对应的叶子节点，即数据页，然后通过二分法查找到第一条符合条件的数据，然后继续查找直到遇到第一个不符合条件的数据。</p>
<p>而对于唯一索引，当找到第一条符合条件的数据即返回，因为已经能确定是唯一的了。</p>
<p>由于mysql加载数据是根据页来加载的，当已有的页里找不到对应的数据的时候，不会从磁盘单独读取一条数据，而是接着加载下一页然后再在内存里查找，因此，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。由于一个数据页可以放很多的数据，大多数情况下相邻的数据都在同一页，相对于现在强大的cpu性能，节省的那些查找时间可以忽略不计。</p>
<p>也就是说，<strong>对于查找，唯一索引和普通索引差别的不大</strong>。</p>
<h3 id="2对更新的影响">2.对更新的影响</h3>
<p>首先我们需要了解一个新东西：<strong>change buffer，也就是写缓冲。</strong></p>
<p>change buffer 和 log buffer 一样，也是 buffer pool 的一部分，他会占用 buffer pool 的容量。</p>
<p>我们知道，mysql按页去将磁盘中的数据读取到内存中（一页的大小通常是16k），当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。一般在三种情况下会进行merge：</p>
<ul>
<li>这个数据页被访问</li>
<li>在数据库正常关闭的过程中</li>
<li>后台线程会定时执行</li>
</ul>
<p>而唯一索引在插入或者更新时必须先获取对应记录以保证唯一性，也就是说<strong>当更新的时候必然要访问数据页，所以唯一索引无法使用 change buffer</strong> 。所以，如果要更新一条数据，而该数据所在页又不在内存中，就要先把数据页读入内存，这一过程随机的磁盘IO，是消耗非常大的操作。</p>
<p>所以，<strong>一般情况下，不推荐使用唯一索引。除非业务需要保证字段的唯一性。</strong></p>
<h3 id="3写缓冲的使用场景">3.写缓冲的使用场景</h3>
<p>值得一提的是，并不是所有情况下使用 change buffer 都会带来收益，因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多，收益就越大。</p>
<p>因此，<strong>对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好</strong>。这种业务模型常见的就是账单类、日志类的系统。</p>
<p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，<strong>对于这种立刻写立刻读的业务模式来说，change buffer 反而起到了副作用</strong>。这种情况就需要关闭写缓冲。</p>
<h2 id="六-索引失效的情况">六、索引失效的情况</h2>
<p>一般来说，如果查询很慢，应该优先考虑一下是不是没加索引，或是因为 sql 的写法而导致查询未能走索引。针对以下例子，我们讨论日常可能出现的“索引失效”的情况。</p>
<p>这里我们需要针对“索引失效”的情况做一下区分：</p>
<ul>
<li>全表扫描：即真正意义上的索引失效，指的是不走索引回表而是直接进行全表扫描，把数据一行一行的拿出来对比字段；</li>
<li>索引扫描：指的是通过索树快速定位了<strong>一部分数据</strong>，然后再根据索引树上的主键id会主键索引树把对应的数据拿出来；</li>
<li>全索引扫描：指的是介于两者中间的状态：使用了索引，但是<strong>把全部的索引都走了一遍</strong></li>
</ul>
<p>这里的情况大多数是指全索引扫描。</p>
<h3 id="1对条件字段的函数操作">1.对条件字段的函数操作</h3>
<p>假如我们执行了这么一条SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计7月的总记录条数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>其中原本 t_modified 是有索引的，但是使用了 month() 函数之后走了全索引扫描，影响了查询速度。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201030140942153.png" alt="image-20201030140942153"><figcaption aria-hidden="true">image-20201030140942153</figcaption>
</figure>
<p>上图是索引的树结构，我们不难看出，由于索引同层节点间是有序的，如果使用日期去查询的话，可以很快的定位到存在目标数据的下一层对应的父节点，也就是绿色箭头的路线。但是使用了 month() 函数后，由于索引的节点并不直接包含 month() 计算得到的树值，所以是无序的，如上图的二级节点所示，所以只能选择直接从叶子结点把所有的节点都过一遍，也就是说，如果有十万条数据，他就得把十万个索引节点都走一遍。</p>
<p>当然，虽然不能快速定位，但是查询依然通过遍历索引树的方式走了查询，没有直接回表全表查询，也就是说，其实还是走了索引，但是没有用到 B+ 树快速定位的性质，查询是速度还是有所下降的。</p>
<p>总结一下，就是：<strong>由于加了函数操作，MySQL 无法再使用索引快速定位功能，而只能使用全索引扫描。</strong></p>
<p>值得一提的是，虽然不是所有的函数操作都会破坏索引树的有序性，但是优化器仍然会选择不使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全索引扫描</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">10000</span></span><br><span class="line"><span class="comment"># 快速定位</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">10000</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="2隐式类型转换">2.隐式类型转换</h3>
<p>假如要执行以下的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全索引扫描</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid = <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>
<p>其中，由于 tradeid 是 varchar 类型，但是查询的条件却是 int 类型，这导致了隐式的类型转换，也就是使用了函数操作。</p>
<p>而在 mysql 中，字符串和数字比较，是转换字符串为数字，也就说，上面的 sql 实际上等同于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="built_in">int</span>)  = <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>
<p>这里的原理和上文提到了对条件字段的函数操作是一样的，因为对条件字段的操作破坏了索引树的有序性，导致只能全索引扫描。换而言之，如果不破坏有序性，函数操作就不会影响索引树的快速定位：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速定位</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">&#x27;110717&#x27;</span>;</span><br><span class="line"><span class="comment"># 上面的sql等同于下面</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="keyword">id</span> = <span class="keyword">CAST</span>(<span class="string">&#x27;110717&#x27;</span> <span class="keyword">AS</span> signed <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure>
<p>如上，id 是 int 类型的字段，那么不会导致索引的快速定位失效。</p>
<p>也就是说：<strong>要将函数操作的对象从条件字段变成条件字段的参数</strong></p>
<h3 id="3隐式字符编码转换">3.隐式字符编码转换</h3>
<p>假如要执行以下的 sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> trade_detail d <span class="keyword">on</span> d.tradeid = l.tradeid</span><br><span class="line"><span class="keyword">where</span> l.id=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>其中，trade_detail 的 tradeid 字段是有索引的，但是 explain 后却显示查询 trade_detail 仍然全表扫描。</p>
<p>也就是说，我们希望 tradelog 拿到了 tradeid 以后，能够直接在 trade_detail 的 tradeid 索引树上找到对应的记录，然后直接回表取出对应的数据，但是他却没通过索引，而是直接把 trade_detail 扫了一遍，把 tradeid 符合的数据拿出来了。</p>
<p>原因在于，tradelog 的字符集是 utf8，trade_detail 的字符集是 utf8mb4。而</p>
<blockquote>
<p>utf8mb4 是 utf8 的超集。类似地，在程序设计语言里面，做自动类型转换的时候，为了避免数据在转换过程中由于截断导致数据错误，也都是“按数据长度增加的方向”进行转换的。</p>
</blockquote>
<p>所以对于 trade_detail，他的 sql 实际上是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将trade_detail的tradeid转成utf8mb4</span></span><br><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> trade_detail d <span class="keyword">where</span> <span class="keyword">CONVERT</span>(d.tradeid <span class="keyword">USING</span> utf8mb4) = l.tradeid</span><br></pre></td></tr></table></figure>
<p>可见，这又是一个对条件字段使用了函数操作的情况。</p>
<p>根据上面两种情况的，我们有两种方法来优化这个 sql：</p>
<ul>
<li><p>将 trade_detail 表转为 utf8mb4 的编码格式</p></li>
<li><p>将函数操作的对象从条件字段变成条件字段的参数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> trade_detail d <span class="keyword">where</span> d.tradeid = <span class="keyword">CONVERT</span>(l.tradeid <span class="keyword">USING</span> utf8mb4) </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="七-总结">七、总结</h2>
<ol type="1">
<li>尽量做到索引覆盖，减少回表次数；</li>
<li>排序总是会在按排序条件排完后，再根据主键排序，所以联合索引的最后不必包含主键字段；</li>
<li>索引需要尽可能的保证有序，并且尽可能的小；</li>
<li>条件字段需要尽可能的使用索引覆盖，以便索引下推，减少回表；</li>
<li>条件字段需要尽可能的按照联合索引的字段顺序排序，以便最左前缀原则生效；</li>
<li>长字符串索引使用索引：
<ul>
<li>完整索引。这样可能比较占用空间；</li>
<li>前缀索引。节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储。再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建 hash 字段索引。查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ul></li>
<li>类型转换和字符集转换的实质都是实用的函数，而函数操作会引起的索引失效和全索引扫描问题，解决方式是将要将函数操作的对象从条件字段变成条件字段的参数</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（八）：排序</title>
    <url>/2020/06/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="什么是排序">什么是排序？</h2>
<blockquote>
<p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。</p>
</blockquote>
<h3 id="1排序的分类">1.排序的分类</h3>
<p>排序分为两类：</p>
<ul>
<li>内部排序：若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。</li>
<li>外部排序：若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。</li>
</ul>
<p>一般来说，外部排序只有数据量极大时会使用，一般情况下排序指的都是内部排序。</p>
<figure>
<img src="http://img.xiajibagao.top/20200630224748.png" alt="image-20200627110216492"><figcaption aria-hidden="true">image-20200627110216492</figcaption>
</figure>
<h3 id="2空间复杂度">2.空间复杂度</h3>
<blockquote>
<p>1.类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</p>
<p>2.空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。</p>
<p>3.在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。</p>
</blockquote>
<h3 id="3排序的稳定">3.排序的稳定</h3>
<blockquote>
<p>待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中arr[i]领先于arr[j]（即i&lt;j）。若在排序后的序列中arr[i]仍然领先于arr[j]，则称所用的方法是稳定的。</p>
<p>比如int数组[1,1,1,6,4]中arr[0]，arr[1]，arr[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的。</p>
</blockquote>
<ul>
<li>稳定的排序：冒泡排序，插入排序，归并排序，基数排序，计数排序</li>
<li>不稳定的排序：快速排序，希尔排序，选择排序，堆排序</li>
</ul>
<p>稳定性设计到排序的现实意义，举个例子：</p>
<blockquote>
<p>例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。</p>
</blockquote>
<p>更多关于稳定性的理解可以<a href="https://blog.csdn.net/csdn_kou/article/details/82965310">参考这个</a></p>
<h3 id="4各排序时间复杂度概览">4.各排序时间复杂度概览</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">排序法</th>
<th>平均时间</th>
<th style="text-align: left;">最差情形</th>
<th>是否稳定</th>
<th>优先选择条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">冒泡排序</td>
<td>O(n^2)</td>
<td style="text-align: left;">O(n^2)</td>
<td>稳定</td>
<td>n小时较好</td>
</tr>
<tr class="even">
<td style="text-align: left;">交换排序</td>
<td>O(n^2)</td>
<td style="text-align: left;">O(n^2)</td>
<td>不稳定</td>
<td>n小时较好</td>
</tr>
<tr class="odd">
<td style="text-align: left;">选择排序</td>
<td>O(n^2)</td>
<td style="text-align: left;">O(n^2)</td>
<td>不稳定</td>
<td>n小时较好</td>
</tr>
<tr class="even">
<td style="text-align: left;">插入排序</td>
<td>O(n^2)</td>
<td style="text-align: left;">O(n^2)</td>
<td>稳定</td>
<td>大部分已排序时较好</td>
</tr>
<tr class="odd">
<td style="text-align: left;">基数排序</td>
<td>O(logRB)</td>
<td style="text-align: left;">O(logRB)</td>
<td>稳定</td>
<td>B是真数（0-9）,R是基数(个十百)</td>
</tr>
<tr class="even">
<td style="text-align: left;">希尔排序</td>
<td>O(nlogn)</td>
<td style="text-align: left;">O(ns)1&lt;s&lt;2</td>
<td>不稳定</td>
<td>s是所选分组</td>
</tr>
<tr class="odd">
<td style="text-align: left;">快速排序</td>
<td>O(nlogn)</td>
<td style="text-align: left;">O(n2)</td>
<td>不稳定</td>
<td>n大时较好</td>
</tr>
<tr class="even">
<td style="text-align: left;">归并排序</td>
<td>O(nlogn)</td>
<td style="text-align: left;">O(nlogn)</td>
<td>稳定</td>
<td>n大时较好</td>
</tr>
<tr class="odd">
<td style="text-align: left;">堆排序</td>
<td>O(nlogn)</td>
<td style="text-align: left;">O(nlogn)</td>
<td>不稳定</td>
<td>n大时较好</td>
</tr>
</tbody>
</table>
<h2 id="一-冒泡排序">一、冒泡排序</h2>
<p>冒泡排序是一种简单的排序算法，它也是一种稳定排序算法。其实现原理是重复扫描待排序序列，并比较每一对相邻的元素，当该对元素顺序不正确时进行交换。一直重复这个过程，直到没有任何两个相邻元素可以交换，就表明完成了排序。</p>
<p><img src="http://img.xiajibagao.top/20200630224744.gif"></p>
<h3 id="1举个例子">1.举个例子</h3>
<p>要对10,-1,8,3这四个数进行排序：</p>
<blockquote>
<p>第一次排序：</p>
<ul>
<li><p>-1,10,8,3 //比较10和-1，逆序则交换</p></li>
<li><p>-1,8,10,3 //比较10和8</p></li>
<li><p>-1,8,3,<strong>10</strong> //比较10和3</p>
<p>第一次排序结束，确定了四个数里最大的数的位置</p></li>
</ul>
<p>第二次排序：</p>
<ul>
<li><p>-1,8,3,<strong>10</strong> //比较-1和8，不逆序所以不需要移动</p></li>
<li><p>-1,3,<strong>8</strong>,<strong>10</strong> //比较8和3</p>
<p>由于已经确定了10为最大数，所以只需要比较到倒数第二位。</p>
<p>第二次排序结束，确定了第二大的数的位置</p></li>
</ul>
<p>第三次排序：</p>
<ul>
<li><p>-1,<strong>3</strong>,<strong>8</strong>,<strong>10</strong> //比较-1和3</p>
<p>由于已经确定了第三和第四大的数，所以只需要比较到倒数第三位。</p>
<p>第三次排序结束，确定了第三大的数，故第一大的数也随之确定</p></li>
</ul>
</blockquote>
<h3 id="2思路">2.思路</h3>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
<li></li>
</ul>
<h3 id="3实现代码">3.实现代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//如果某次排序不发生交换，说明上一次排序前已经为有序</span></span><br><span class="line">    <span class="keyword">boolean</span> isChange = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据数组长度决定一共需要排序几次</span></span><br><span class="line">    <span class="keyword">int</span> round = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; round; i++) &#123;</span><br><span class="line">        <span class="comment">//每次排序需要对比到第几位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; round - i; j++) &#123;</span><br><span class="line">            <span class="comment">//对比大小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//发生交换</span></span><br><span class="line">                isChange = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断本次排序是否发生交换</span></span><br><span class="line">        <span class="keyword">if</span> (!isChange) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次排序无交换，第&quot;</span> + i + <span class="string">&quot;次排序已为有序！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            isChange = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次排序：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;-1, 52, 9, 13, -5, 7&#125;排序运行结果</span></span><br><span class="line">第<span class="number">1</span>次排序：[-<span class="number">1</span>, <span class="number">9</span>, <span class="number">13</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">52</span>]</span><br><span class="line">第<span class="number">2</span>次排序：[-<span class="number">1</span>, <span class="number">9</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br><span class="line">第<span class="number">3</span>次排序：[-<span class="number">1</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br><span class="line">第<span class="number">4</span>次排序：[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br><span class="line">第<span class="number">5</span>次排序无交换，第<span class="number">4</span>次排序已为有序！</span><br></pre></td></tr></table></figure>
<h2 id="二-选择排序">二、选择排序</h2>
<p>选择排序，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<p><img src="http://img.xiajibagao.top/20200630224739.gif"></p>
<h3 id="1举个例子">1.举个例子</h3>
<blockquote>
<p>选择排序（select sorting）也是一种简单的排序方法。 它的基本思想是： 第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换; 第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换; 第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换; … 第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换; … 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换, 总共通过n-1次，得到一个按排序码从小到大排列的有序序列。</p>
</blockquote>
<h3 id="2思路">2.思路</h3>
<ul>
<li>需要进行n-1轮排序</li>
<li>若要为第i个数排序，就先默认第i个元素为最小数，记录其大小和下标</li>
<li>接着从第i+1到第n个数开始依次比较，如果有数小于最小数，则用该数替换原最小数和其下标</li>
<li>第i轮比较结束后，让找出的最小数与第i个数交换位置</li>
</ul>
<h3 id="3代码实现">3.代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length -<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//用于存放每次选择中最小数的下标，最小值默认为第一个数为i</span></span><br><span class="line">        <span class="keyword">int</span> minNumIndex = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从（i+1,arr.length）的范围中筛选最小的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//如果范围内有数比现有minNum小，则替换下标</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minNumIndex]) &#123;</span><br><span class="line">                minNumIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一次选择结束，将（i+1,arr.length）的范围中的最小数与arr[i]交换位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[minNumIndex];</span><br><span class="line">        arr[minNumIndex] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;-1, 52, 9, 13, -5, 7&#125;排序运行结果</span></span><br><span class="line">第<span class="number">1</span>轮后:[-<span class="number">5</span>, <span class="number">52</span>, <span class="number">9</span>, <span class="number">13</span>, -<span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">2</span>轮后:[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">3</span>轮后:[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">4</span>轮后:[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">52</span>, <span class="number">13</span>]</span><br><span class="line">第<span class="number">5</span>轮后:[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br></pre></td></tr></table></figure>
<h3 id="4与冒泡排序比较">4.与冒泡排序比较</h3>
<p>同样对长度80000的数字进行排序，选择排序比冒泡排序快不少，原因在于选择排序每次排序只移动指针，找到位置后才进行一次元素交换，而冒泡需要多次交换。</p>
<p>换句话说，要排序的数组越长，冒泡每次排序元素要移动的次数就越多，与选择排序的差距就越明显。</p>
<p>这个同样能解释希尔排序的两种实现方式的速度差距。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序交换值，交换n次值</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">arr[j] = arr[j + gap]</span><br><span class="line">    </span><br><span class="line"><span class="comment">//插入排序交换值，交换n次指针</span></span><br><span class="line">arr[j] = arr[j - gap]</span><br><span class="line"><span class="comment">//然后交换1次值</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">arr[j] = arr[j + gap]</span><br></pre></td></tr></table></figure>
<h2 id="三-插入排序">三、插入排序</h2>
<p>插入排序，是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表</p>
<p><img src="http://img.xiajibagao.top/20200630224735.gif"></p>
<h3 id="1举个例子">1.举个例子</h3>
<blockquote>
<p>有数组{5,2,4,6,1,3}要进行排序，</p>
<ul>
<li>从第二位往前看，5比2大，且5为第一个数，于是5后移，把2插入5前。现在是{2,5,4,6,1,3}</li>
<li>从第三位往前看，5比4大，于是5后移，继续往前看，2比4小，所以把4插入原先5的位置。现在是{2,4,5,6,1,3}</li>
<li>从第四位往前看，4比6小，于是6就不动了。现在是{2,4,5,6,1,3}</li>
<li>从第五位往前看，6比1小，于是6后移，继续往前看，5比1小，5后移，继续往前看.....2比1小，2后移，又2为第一个数，于是把1插入原本2的位置。现在是{1,2,4,5,6,3}</li>
<li>从第六位往前看，6比3小，于是6后移，继续往前看，.....3比2大，于是把3插入原先4的位置。排序完成。</li>
</ul>
</blockquote>
<p><img src="http://img.xiajibagao.top/20200630224731.png"></p>
<h3 id="2思路分析">2.思路分析</h3>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<h3 id="3代码实现">3.代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//需要从第二位开始，避免i-1出现控制针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//指向当前插入位置前一个元素的指针</span></span><br><span class="line">        <span class="keyword">int</span> pre = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前处理元素的值</span></span><br><span class="line">        <span class="keyword">int</span> val = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让比当前元素大的元素不断的后移，直到到头了或者找到了比当前元素小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (pre &gt;= <span class="number">0</span> &amp;&amp; arr[pre] &gt; val) &#123;</span><br><span class="line">            <span class="comment">//前一个元素往后移</span></span><br><span class="line">            arr[pre + <span class="number">1</span>] = arr[pre];</span><br><span class="line">            <span class="comment">//继续往前移动</span></span><br><span class="line">            pre--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳出循环时即找到了当前元素的正确插入位置</span></span><br><span class="line">        <span class="comment">//将该位置的值赋成处理元素的值</span></span><br><span class="line">        arr[pre + <span class="number">1</span>] = val;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;-1, 52, 9, 13, -5, 7&#125;排序运行结果</span></span><br><span class="line">第<span class="number">2</span>轮：[-<span class="number">1</span>, <span class="number">52</span>, <span class="number">9</span>, <span class="number">13</span>, -<span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">3</span>轮：[-<span class="number">1</span>, <span class="number">9</span>, <span class="number">52</span>, <span class="number">13</span>, -<span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">4</span>轮：[-<span class="number">1</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>, -<span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">5</span>轮：[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">7</span>]</span><br><span class="line">第<span class="number">6</span>轮：[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br></pre></td></tr></table></figure>
<h2 id="四-希尔排序">四、希尔排序</h2>
<p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为缩小增量排序。</p>
<blockquote>
<p>希尔排序是把记录按下标的一定增量分组， 对每组使用直接插入排序算法排序； 随着增量逐渐减少，每组包含的关键词越来越多， 当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
</blockquote>
<p><img src="http://img.xiajibagao.top/20200630224726.gif"></p>
<h3 id="1举个例子">1.举个例子</h3>
<p><img src="http://img.xiajibagao.top/20200630224723.png"></p>
<h3 id="2思路">2.思路</h3>
<ul>
<li>将数组除于2进行分组，得到gap组数字</li>
<li>对gap组数字进行插入排序，由于数据共分为gap组，所以同一组相邻的数字在数组中的位置总是相隔gap</li>
<li>遍历gap组数字，表现在数组上就是从gap遍历到arr.length</li>
</ul>
<h3 id="3代码实现">3.代码实现</h3>
<p>有两种实现思路，一种是<strong>交换法</strong>，一种是<strong>移位法</strong>，</p>
<p>先说结论：<strong>移位法比交换法快</strong>，原因在于：</p>
<p>交换法思路有点类似于冒泡排序，需要不断的比较并交换数值，</p>
<p>而移位法即选择排序，仅仅遍历赋值后移动指针，找到插入位置后，再把元素插入到有序表，而不是多次交换加入有序表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换法交换n次值</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">arr[j] = arr[j + gap]</span><br><span class="line">    </span><br><span class="line"><span class="comment">//位移法移动n次指针后只交换一次值</span></span><br><span class="line">arr[j] = arr[j - gap]</span><br></pre></td></tr></table></figure>
<h4 id="31交换法实现">3.1交换法实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行希尔排序</span></span><br><span class="line"><span class="comment"> * 注意，此方法为移位法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将数组每次对半分分成多组，组数逐渐缩小</span></span><br><span class="line">    <span class="comment">// gap为每次分组后的同组元素的间隔，比如分成5组，那同组元素间隔即为5，即位置是i和i+5的元素是一组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从第gap个元素开始，逐步遍历其所在的组，即从第一组开始向后遍历</span></span><br><span class="line">        <span class="comment">// 第gap个元素即为第一组的最后一个元素，也就是i即表示某组的最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 接着遍历同组元素，即一组有几个元素就遍历几次</span></span><br><span class="line">            <span class="comment">// j=i-gap即获得第某组的倒数第二个元素位置</span></span><br><span class="line">            <span class="comment">// 向前遍历，每隔gap个元素就对比一次大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j = j - gap) &#123;</span><br><span class="line">                <span class="comment">//如果当前元素大于后一个元素,就交换位置</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + gap];</span><br><span class="line">                    arr[j + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (++count) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;-1, 52, 9, 13, -5, 7&#125;排序运行结果</span></span><br><span class="line">第<span class="number">1</span>轮：[-<span class="number">1</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">52</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">2</span>轮：[-<span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">52</span>]</span><br></pre></td></tr></table></figure>
<h4 id="32-移位法实现">3.2 移位法实现</h4>
<p><strong>下面是通过移位法实现的排序，比交换法更快更稳定：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，对其进行希尔排序</span></span><br><span class="line"><span class="comment"> * 注意，此方法为移位法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortByMove(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将数组每次对半分分成多组，组数逐渐缩小</span></span><br><span class="line">    <span class="comment">// gap为每次分组后的同组元素的间隔，比如分成5组，那同组元素间隔即为5，即位置是i和i+5的元素是一组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从第gap个元素开始，逐个对其所在组进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            <span class="comment">//如果某组最后一个元素比前一个元素小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                <span class="comment">//将同组元素不断后移，直到该元素找到位置或者到头为止</span></span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                    j = j - gap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当找到位置时插入元素</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (++count) + <span class="string">&quot;轮：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-快速排序">五、快速排序</h2>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><img src="http://img.xiajibagao.top/20200630224718.gif"></p>
<h3 id="1举个例子">1.举个例子</h3>
<p><img src="http://img.xiajibagao.top/20200630224715.png"></p>
<blockquote>
<ul>
<li>先选择一个中间位置数11，分别将数组中比11大和比11小的数放到左右两个数组中</li>
<li>对两个数组分别选一个中间位置数，也就是5和21，各自再根据比中间数小或者比中间数大再次分为两个数组。以此类推</li>
</ul>
</blockquote>
<h3 id="2思路">2.思路</h3>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
<li>对左支和右支可通过递归实现排序</li>
</ul>
<h3 id="3代码实现">3.代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一串无序数组，并根据给定的左右指针对指定的范围其进行排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l = left;</span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到中间数</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">    <span class="comment">//用于元素交换的临时变量</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将比中间数小的放左边，比中间数大的放右边</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 从左往右遍历，寻找比中间数大的数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左遍历，寻找比中间数小的数</span></span><br><span class="line">        <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果l &gt; r，即左指针右指针都越过了中间数，说明两边数都已经有序</span></span><br><span class="line">        <span class="comment">// 如果l = r，即可能存在多个与中间数同值的元素的情况下，左右指针一起指向了同一边的同一个元素，也说明两边数都已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换元素</span></span><br><span class="line">        temp = arr[l];</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        arr[r] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果交换完后，发现现在右侧有一个与中间数相同的数，右指针前移一位</span></span><br><span class="line">        <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果交换完后，发现现在左侧有一个与中间数相同的数，左指针后移一位</span></span><br><span class="line">        <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止死循环</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        l += <span class="number">1</span>;</span><br><span class="line">        r -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向右递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">        sort(arr, l, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">        sort(arr, left, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-归并排序">六、归并排序</h2>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><img src="http://img.xiajibagao.top/20200630224710.gif"></p>
<h3 id="1举个例子">1.举个例子</h3>
<p><img src="http://img.xiajibagao.top/20200630224706.png"></p>
<p>我们以上图最后一次合并为例：</p>
<p><img src="http://img.xiajibagao.top/20200630224703.png"></p>
<p><img src="http://img.xiajibagao.top/20200630224700.png"></p>
<p>以上多个有序数组间的合并需要进行多次，通过递归完成</p>
<h3 id="2思路">2.思路</h3>
<ul>
<li>把长度为n的数组分成两个长度为n/2的子数组；</li>
<li>如果子数组仍然长度大于1，就重复步骤1直到所有数组都被拆分完毕</li>
<li>将拆分后的元素两两合并为一个有序数组，然后相邻两个数组A，B进行合并：
<ol type="1">
<li>创建一个新数组，然后遍历B数组并与A数组第一位进行比较，如果该数字比A数组第一小则放入新数组第一位</li>
<li>否则将A数组第一位放入新数组</li>
</ol></li>
<li>重复上面步骤3直到A，B数组所有元素都有序放入新数组，即合并完成</li>
<li>重复步骤3，直到所有数组都最终都被合并为一个有序数组</li>
</ul>
<h3 id="3代码实现">3.代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">return</span> sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 临时存储的中转数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//获取中间索引</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//向左递归分解</span></span><br><span class="line">        sort(arr, left, mid, temp);</span><br><span class="line">        <span class="comment">//向右递归分解</span></span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 先左遍历到最左边，然后向右遍历，当l=r时触发排序</span></span><br><span class="line">        merge(arr, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 临时存储的中转数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左边有序序列的初始索引</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="comment">//中间索引</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//temp的索引</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先把左右两边有序的数据按照规则填充到temp数组，直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//如果左边的有序序列的当前元素小于等于右边有序序列的当前元素</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则将右边有序序列的当前元素填充到temp数组</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[t] = arr[i];</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[t] = arr[j];</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        j += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将temp数组里的有序元素拷贝回arr数组</span></span><br><span class="line">    <span class="comment">//从左边开始拷贝， 注意：不是每次都拷贝所有</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tempLeft = left;</span><br><span class="line">    <span class="comment">//第一次合并：templeft = 0，right = 1。 第二次合并：templeft = 2，right = 3。 最后一次：templeft = 0，right = 7</span></span><br><span class="line">    <span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">        arr[tempLeft] = temp[t];</span><br><span class="line">        t += <span class="number">1</span>;</span><br><span class="line">        tempLeft += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七-基数排序">七、基数排序</h2>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p><img src="http://img.xiajibagao.top/20200630224653.gif"></p>
<h3 id="1举个例子">1.举个例子</h3>
<p><img src="http://img.xiajibagao.top/20200630224650.png"></p>
<p><img src="http://img.xiajibagao.top/20200630224648.png"></p>
<p><img src="http://img.xiajibagao.top/20200630224641.png"></p>
<h3 id="2思路">2.思路</h3>
<ul>
<li>取得数组中的最大数，并取得位数</li>
<li>准备一个长度为10，内部一位数组长度为arr.length的二维数组，可以理解为10个高度为arr.length的桶</li>
<li>遍历数组，根据数组中个位数决定要放在哪个桶，即如果个位数为1就放入1号桶，为2就放入2号桶，直到数组所有元素分配完毕</li>
<li>遍历桶将桶中数字放回原数组，然后清空桶。即完成了个位数的排序</li>
<li>重复步骤3和步骤4，但是排序依据从个位数换成十位数，然后百位数.....以此类推，直到数组最大位数</li>
</ul>
<h3 id="3代码实现">3.代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中的最大数的位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(max).length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp 临时存储的中转数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//设置二维数组用于表示桶</span></span><br><span class="line">    <span class="comment">//第一层数组下标即表示存放某数位为x的数字的桶，比如下标为2的桶用于存放个位数为2的数字；下标为0的桶用于存放十位数为0的数字</span></span><br><span class="line">    <span class="comment">//第二层数组即表示桶高度</span></span><br><span class="line">    <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示某个桶内用几个元素，比如bucketElementCount[0]即表示bucket[0]桶有几个元素</span></span><br><span class="line">    <span class="comment">//由于数字下标从0开始，所以这同时也表示了桶下一个元素的插入下标，比如bucketElementCount[0]=1，就意味着bucket[0]下一个元素应该插到bucket[0][1]去</span></span><br><span class="line">    <span class="keyword">int</span>[] bucketElementCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大数有几位就循环排序几次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt;= getMaxDigit(arr); i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历元素并归类到桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//获取元素某数位的数字</span></span><br><span class="line">            <span class="comment">//根据遍历，获取数字的个位，十位数，百位数......</span></span><br><span class="line">            <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//将其归类到桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCount[digitOfElement]] = arr[j];</span><br><span class="line">            <span class="comment">//提高桶高度</span></span><br><span class="line">            bucketElementCount[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按顺序将每一个桶中元素取出并放入原集合</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCount.length; k++) &#123;</span><br><span class="line">            <span class="comment">//如果桶中有元素就取出</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCount[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历桶中元素并放入数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCount[k]; l++) &#123;</span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//清空桶</span></span><br><span class="line">            bucketElementCount[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4基数排序注意事项">4.基数排序注意事项：</h3>
<ul>
<li><p>基数排序是典型的空间换时间，当排序的数字过多的时候可能会发生<code>OutOfMemoryError</code>（实测八千万时报错）</p></li>
<li><p>基数排序要排负数的时候需要加以改进：</p>
<p>将数组中的负数单独摘出并取绝对值后进行排序，然后倒序插入排序完的整数数组，并且在插入过程加上负号</p></li>
</ul>
<h2 id="八-堆排序">八、堆排序</h2>
<p>参照<a href>二叉树部分</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十五）：二叉排序树</title>
    <url>/2020/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<h2 id="一-什么是二叉排序树">一、什么是二叉排序树</h2>
<blockquote>
<p><strong>二叉排序树</strong>（Binary Sort Tree）又称<strong>二叉查找树</strong>、<strong>二叉搜索树</strong>。 它或者是一棵空树；或者是具有下列性质的二叉树：</p>
<p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>（3）左、右子树也分别为二叉排序树；</p>
</blockquote>
<figure>
<img src="http://img.xiajibagao.top/二叉排序树.png" alt="image-20200720112917992"><figcaption aria-hidden="true">image-20200720112917992</figcaption>
</figure>
<p>当我们使用需要对数列进行操作的时候，我们原本有以下选择：</p>
<ul>
<li>数组：不排序的数组插入快而查找慢，排序数组通过算法可以快速查找，但是插入效率又会受到影响</li>
<li>链表：不管是否有序，插入都快，但是查找效率都不高</li>
<li>哈希表：查找修改都简单，但当哈希冲突严重的时候传统哈希表效率也会下降</li>
</ul>
<p>而二叉排序树的查找类似二分查找，而插入类似链表，相较以上三种结构可以较好的平衡查找和插入效率</p>
<h2 id="二-代码实现">二、代码实现</h2>
<p>我们先实现一个节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-20 11:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉排序树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BinarySortTreeNode left;</span><br><span class="line">    BinarySortTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;val=&quot;</span> + val +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再实现一个二叉排序树类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-20 12:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉排序树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BinarySortTreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTree</span><span class="params">(BinarySortTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;根节点不允许为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1添加">1.添加</h3>
<p>思路如下：</p>
<ul>
<li>获取要插入的节点与其父节点比较值，比父节点小向左树插，否则就向右插</li>
<li>插入是判断父节点的左/右子节点是否存在，存在就继续递归遍历左/右树直到找到插入位置，否则直接插入</li>
</ul>
<p>在节点类中添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要添加的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode parent,BinarySortTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断子节点是否小于父节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent.val &gt; node.val) &#123;</span><br><span class="line">        <span class="comment">//判断要添加的位置是否还有节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//有就继续遍历左树</span></span><br><span class="line">            add(parent.left, node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则直接添加</span></span><br><span class="line">            parent.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            add(parent.right, node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2查找">2.查找</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 要查找的节点值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">search</span><span class="params">(BinarySortTreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前节点是否为要找到的值</span></span><br><span class="line">    <span class="keyword">if</span> (node.val != val) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; val) &#123;</span><br><span class="line">        <span class="comment">//如果当前节点大于查找值，就向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(node.left, val);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则就向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(node.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3删除">3.删除</h3>
<p>删除节点时会出现三种情况：</p>
<ul>
<li>要删除的节点是叶子结点</li>
<li>要删除的节点是一棵树的根节点</li>
<li>要删除的节点是两棵树的根节点</li>
</ul>
<p>不管对于哪种情况而言，我们都需要先找到要要删除节点的父节点的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查找目标节点的父节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> val 要查找的值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">searchParentOfTarget</span><span class="params">(BinarySortTreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前节点的子节点是否为目标节点</span></span><br><span class="line">    <span class="keyword">boolean</span> isTargetParent = (node.left != <span class="keyword">null</span> &amp;&amp; node.left.val == val) || (node.right != <span class="keyword">null</span> &amp;&amp; node.right.val == val);</span><br><span class="line">    <span class="keyword">if</span> (isTargetParent) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果查找值小于当前节点，向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; node.val &amp;&amp; node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchParentOfTarget(node.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= node.val &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果查找值大于当前节点,向右递归</span></span><br><span class="line">            <span class="keyword">return</span> searchParentOfTarget(node.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则目标节点不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先区分三种情况，然后在此基础上分别实现三种情况下的删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定叶子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要删除节点的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 要删除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断要删除的是否为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;树中只有根节点，无法删除!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找目标节点</span></span><br><span class="line">    BinarySortTreeNode target = search(val);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找目标节点的父节点</span></span><br><span class="line">    BinarySortTreeNode parent = searchTargetParent(val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断要删除的节点的子节点情况</span></span><br><span class="line">    <span class="keyword">if</span> (target.left == <span class="keyword">null</span> &amp;&amp; target.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//删除叶子节点</span></span><br><span class="line">        deleteLeafNode(val, parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.left != <span class="keyword">null</span> &amp;&amp; target.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//删除有两颗子树的节点的节点</span></span><br><span class="line">        deleteTwoBranchNode(target);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//删除只有一颗子树的节点</span></span><br><span class="line">        deleteOneBranchNode(val, target, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在以上代码的基础上继续分析思路。</p>
<h4 id="31删除的节点是叶子结点">3.1删除的节点是叶子结点</h4>
<p>即方法<code>deleteLeafNode()</code></p>
<ul>
<li>找到要删除的节点，并判断其左右子节点是否都为空</li>
<li>若都为空，再找到其父节点，然后判断要删除的节点是父节点的左子节点还是右子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除叶子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 要删除节点的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 要删除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteLeafNode</span><span class="params">(<span class="keyword">int</span> val, BinarySortTreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断目标节点是父节点左节点还是右节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.val == val) &#123;</span><br><span class="line">        parent.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="32删除的节点有一课子树">3.2删除的节点有一课子树</h4>
<p>即方法<code>deleteOneBranchNode()</code></p>
<ul>
<li>找到目标节点，判断目标节点有的那颗子树是左子树还是右子树</li>
<li>判断目标节点是否为根节点，如果是就直接将根节点替换为目标节点的子节点</li>
<li>如果不是根节点，再判断目标节点是其父节点的左子节点还是右子节点</li>
<li>让父节点的子节点指向目标节点的子节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除只有一颗子树的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 要删除的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 要删除的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 要删除的节点的父节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteOneBranchNode</span><span class="params">(<span class="keyword">int</span> val, BinarySortTreeNode target, BinarySortTreeNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断目标节点有左子树还是右子树</span></span><br><span class="line">    <span class="keyword">if</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是根节点，就直接删除</span></span><br><span class="line">            root = target.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//目标节点只有左子树</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left.val == val) &#123;</span><br><span class="line">                parent.left = target.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = target.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = target.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//目标节点只有右子树</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left.val == val) &#123;</span><br><span class="line">                parent.left = target.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = target.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="33-删除的节点结点有两颗子树">3.3 删除的节点结点有两颗子树</h4>
<p>即方法<code>deleteLeafNode()</code></p>
<p>当有要删除的节点有两颗子树时情况比较特殊，我们不能通过直接改变指针指向的方式让子树直接“移接”到目标节点的父节点上，我们需要在目标节点的子树中找到一个能替换目标节点并且不会改变排序树顺序的节点。</p>
<p>我们举个例子，现有{5,3,2,7,6,4,1,0,8}，形成的树</p>
<figure>
<img src="http://img.xiajibagao.top/删除的节点结点有一颗子树.png" alt="image-20200720164054844"><figcaption aria-hidden="true">image-20200720164054844</figcaption>
</figure>
<p>我们要删除节点3，那3的位置就必须换成一个比3的右子树节点小而比左子树所有节点大的数，也就是说，这个数：</p>
<ul>
<li>左树选最大：可以是目标节点的左子节点的左树最大值，也就是2；</li>
<li>右树选最小：可以是目标节点的右子节点的右树最小值，也就是4；</li>
</ul>
<p>这里我们选择用右子树的最小值作为替换值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除有两颗子树的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 目标节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteTwoBranchNode</span><span class="params">(BinarySortTreeNode target)</span> </span>&#123;</span><br><span class="line">    BinarySortTreeNode minNodeOfTargetRitht = target.right;</span><br><span class="line">    <span class="comment">//遍历找到目标节点右子树上的最小值</span></span><br><span class="line">    <span class="comment">//右子树上的最小值，也就是目标节点的右子节点的左树最大值</span></span><br><span class="line">    <span class="keyword">while</span> (minNodeOfTargetRitht.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        minNodeOfTargetRitht = minNodeOfTargetRitht.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除最小值</span></span><br><span class="line">    deleteNode(minNodeOfTargetRitht.val);</span><br><span class="line">    <span class="comment">//目标节点的值替换为该最小值</span></span><br><span class="line">    target.val = minNodeOfTargetRitht.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按以上方法，等于删除4，然后让3的值变为4：</p>
<figure>
<img src="http://img.xiajibagao.top/删除的节点结点有一颗子树2.png" alt="image-20200720165202316"><figcaption aria-hidden="true">image-20200720165202316</figcaption>
</figure>
<h2 id="三-完整代码">三、完整代码</h2>
<p>具体代码和测试用例可以去<a href="https://github.com/Createsequence/data_structure">GitHub</a>上看，这里就放实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-20 12:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：二叉排序树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BinarySortTreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTree</span><span class="params">(BinarySortTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;根节点不允许为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(BinarySortTreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            show(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.toString());</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            show(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        show(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 要添加的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode parent,BinarySortTreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断子节点是否小于父节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.val &gt; node.val) &#123;</span><br><span class="line">            <span class="comment">//判断要添加的位置是否还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//有就继续遍历左树</span></span><br><span class="line">                add(parent.left, node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则直接添加</span></span><br><span class="line">                parent.left = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                add(parent.right, node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BinarySortTreeNode node)</span></span>&#123;</span><br><span class="line">        add(root, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要查找的节点值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">search</span><span class="params">(BinarySortTreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前节点是否为要找到的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; val) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点大于查找值，就向左递归</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> search(node.left, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就向右递归</span></span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> search(node.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找目标节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BinarySortTreeNode <span class="title">searchTargetParent</span><span class="params">(BinarySortTreeNode node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前节点的子节点是否为目标节点</span></span><br><span class="line">        <span class="keyword">boolean</span> isTargetParent = (node.left != <span class="keyword">null</span> &amp;&amp; node.left.val == val) || (node.right != <span class="keyword">null</span> &amp;&amp; node.right.val == val);</span><br><span class="line">        <span class="keyword">if</span> (isTargetParent) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找值小于当前节点，向左递归</span></span><br><span class="line">            <span class="keyword">if</span> (val &lt; node.val &amp;&amp; node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> searchTargetParent(node.left, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt;= node.val &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果查找值大于当前节点,向右递归</span></span><br><span class="line">                <span class="keyword">return</span> searchTargetParent(node.right, val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则目标节点不存在</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinarySortTreeNode <span class="title">searchTargetParent</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchTargetParent(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要删除节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断要删除的是否为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == val &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;树中只有根节点，无法删除!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找目标节点</span></span><br><span class="line">        BinarySortTreeNode target = search(val);</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查找目标节点的父节点</span></span><br><span class="line">        BinarySortTreeNode parent = searchTargetParent(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断要删除的节点的子节点情况</span></span><br><span class="line">        <span class="keyword">if</span> (target.left == <span class="keyword">null</span> &amp;&amp; target.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//删除叶子节点</span></span><br><span class="line">            deleteLeafNode(val, parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.left != <span class="keyword">null</span> &amp;&amp; target.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//删除有两颗子树的节点的节点</span></span><br><span class="line">            deleteTwoBranchNode(target);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除只有一颗子树的节点</span></span><br><span class="line">            deleteOneBranchNode(val, target, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除有两颗子树的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTwoBranchNode</span><span class="params">(BinarySortTreeNode target)</span> </span>&#123;</span><br><span class="line">        BinarySortTreeNode minNodeOfTargetRitht = target.right;</span><br><span class="line">        <span class="comment">//遍历找到目标节点右子树上的最小值</span></span><br><span class="line">        <span class="comment">//右子树上的最小值，也就是目标节点的右子节点的左树最大值</span></span><br><span class="line">        <span class="keyword">while</span> (minNodeOfTargetRitht.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minNodeOfTargetRitht = minNodeOfTargetRitht.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除最小值</span></span><br><span class="line">        deleteNode(minNodeOfTargetRitht.val);</span><br><span class="line">        <span class="comment">//目标节点的值替换为该最小值</span></span><br><span class="line">        target.val = minNodeOfTargetRitht.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除只有一颗子树的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 要删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteOneBranchNode</span><span class="params">(<span class="keyword">int</span> val, BinarySortTreeNode target, BinarySortTreeNode parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断要目标节点有左子树还是右子树</span></span><br><span class="line">        <span class="keyword">if</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是根节点，就直接删除</span></span><br><span class="line">                root = target.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标节点只有左子树</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left.val == val) &#123;</span><br><span class="line">                    parent.left = target.left;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.right = target.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = target.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标节点只有右子树</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left.val == val) &#123;</span><br><span class="line">                    parent.left = target.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent.right = target.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除叶子节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要删除的节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteLeafNode</span><span class="params">(<span class="keyword">int</span> val, BinarySortTreeNode parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断目标节点是父节点左节点还是右节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.val == val) &#123;</span><br><span class="line">            parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法（十四）：赫夫曼编码</title>
    <url>/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="一-什么是赫夫曼编码">一、什么是赫夫曼编码</h2>
<p>哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，</p>
<p>使用赫夫曼编码可以有效的压缩数据，通常可以节省20%~90%的空间。</p>
<p>在理解赫夫曼编码前，我们需要对通讯领域的两种编码方式有个粗略的了解。</p>
<p>假设我们需要传输 <code>I'm a jvav programmer and I love programming</code>这样一句话，我们有两种传输方式：</p>
<ol type="1">
<li><p>定长编码</p>
<p>直接转换为对应长度的二进制格式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">01101111</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100111</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100111</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span> <span class="number">00100000</span></span><br></pre></td></tr></table></figure>
<p>总长度为296个字符</p></li>
<li><p>变长编码</p>
<p>按照各个字符出现的次数进行编码，按出现次数编码，出现次数越多的，则编码越小：</p>
<p>比如空格出现最多次，然后是a，以此类推......</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>=  ，<span class="number">1</span>=a，<span class="number">10</span>=i，<span class="number">11</span>=o......</span><br></pre></td></tr></table></figure>
<p>当传输的信息越多的时候，变长编码实际传输的长度相对定长编码就越小</p></li>
</ol>
<p>另外，我们还需要了解一下什么是补码：</p>
<blockquote>
<p>计算机里面只有加法器，没有减法器，所以减法必须用加法来完成。 对于 100 以内的十进制数，“-1”就可以用"+99"代替。比如 25 － 1 ＝ 24，可以写成 25 ＋ 99 ＝ (1)24。 如果限定了两位数，那“-1”和“+99”就是等效的。同样，“-2”可以用“+98”代替。</p>
<p>它们之间，称为<strong>补数</strong>，而100就称为<strong>模</strong>。</p>
<p>对于<strong>8位二进制数</strong>：0000 0000~1111 1111(255)，<strong>模为256</strong>。 －1，可以用 +255(1111 1111)代替。 －2，可以用 +254(1111 1110)代替</p>
<p>这些二进制数，就称为负数的<strong>补码</strong></p>
</blockquote>
<h2 id="二-赫夫曼编码思路">二、赫夫曼编码思路</h2>
<p>同样举个例子，我们要传输 <code>i like like like java do you like a java</code>这段话</p>
<ol type="1">
<li><p>统计各字符的出现次数</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">d:<span class="number">1</span> y:<span class="number">1</span> u:<span class="number">1</span> j:<span class="number">2</span> v:<span class="number">2</span> o:<span class="number">2</span> l:<span class="number">4</span> k:<span class="number">4</span> e:<span class="number">4</span> i:<span class="number">5</span> a:<span class="number">5</span> :<span class="number">9</span></span><br></pre></td></tr></table></figure></li>
<li><p>将字符出现次数作为节点的权，构建一个赫夫曼树（这里步骤同<a href="https://www.cnblogs.com/Createsequence/p/13331722.html#_label1">上一篇文章</a>）</p>
<figure>
<img src="http://img.xiajibagao.top/编码转树.png" alt="image-20200717213740072"><figcaption aria-hidden="true">image-20200717213740072</figcaption>
</figure></li>
<li><p>我们使用0和1来描述某个节点在树中往左或往右的路径，比如j，从根节点出发抵达j的路径就是0000，抵达i的路径就是101</p>
<p>于是现在对所有字符的路径进行统计，就有：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">o: <span class="number">1000</span>     u: <span class="number">10010</span>     d: <span class="number">100110</span>     y: <span class="number">100111</span>    i: <span class="number">101</span>    a : <span class="number">110</span></span><br><span class="line">k: <span class="number">1110</span>     e: <span class="number">1111</span>      j: <span class="number">0000</span>       v: <span class="number">0001</span>      l: <span class="number">001</span>      : <span class="number">01</span></span><br></pre></td></tr></table></figure></li>
<li><p>按照上面的路径，我们将其转为二进制</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</span></span><br></pre></td></tr></table></figure>
<p>直接转为二进制长度为359，而经过赫夫曼编码长度则是133，与直接转为二进制相比，缩短了62.9%</p></li>
</ol>
<h2 id="三-代码实现">三、代码实现</h2>
<h3 id="1创建节点类">1.创建节点类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-18 13:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：赫夫曼编码用节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCodeNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HuffmanCodeNode</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符</span></span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    HuffmanCodeNode left;</span><br><span class="line">    HuffmanCodeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanCodeNode</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanCodeNode</span><span class="params">(HuffmanCodeNode left, HuffmanCodeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算子节点权值之和</span></span><br><span class="line">        <span class="keyword">this</span>.weight = left.weight + right.weight;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(HuffmanCodeNode o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">            <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2统计字符出现次数并组装节点列表">2.统计字符出现次数，并组装节点列表</h3>
<p>对应思路中的第一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计字符在字符串中的出现次数，并组装节点列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HuffmanCodeNode&gt; <span class="title">getNodes</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将字符串转为字符串数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] strBytes = str.getBytes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历字节数组，并且统计某一字符出现次数</span></span><br><span class="line">    Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">24</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">        Integer count = counts.get(b);</span><br><span class="line">        <span class="comment">//判断某一字符是否第一次出现</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">            counts.put(b, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不是就让出现次数+1</span></span><br><span class="line">            counts.put(b, count ++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将map转为节点集合</span></span><br><span class="line">    List&lt;HuffmanCodeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HuffmanCodeNode(entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3生成赫夫曼树">3.生成赫夫曼树</h3>
<p>对应思路中的第二步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建赫夫曼树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodes 节点集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最终生成的树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HuffmanCodeNode <span class="title">createTree</span><span class="params">(List&lt;HuffmanCodeNode&gt; nodes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建树</span></span><br><span class="line">    <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line">        <span class="comment">//取出最小的两个数构建树</span></span><br><span class="line">        HuffmanCodeNode left = nodes.get(<span class="number">0</span>);</span><br><span class="line">        HuffmanCodeNode right = nodes.get(<span class="number">1</span>);</span><br><span class="line">        HuffmanCodeNode parant = <span class="keyword">new</span> HuffmanCodeNode(left, right);</span><br><span class="line">        <span class="comment">//删除两个节点</span></span><br><span class="line">        nodes.remove(left);</span><br><span class="line">        nodes.remove(right);</span><br><span class="line">        <span class="comment">//将根节点添加至集合</span></span><br><span class="line">        nodes.add(parant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个时候可以通过前序遍历来检查是否构建成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 树的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(HuffmanCodeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    System.out.println(node.toString());</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4得到赫夫曼编码">4.得到赫夫曼编码</h3>
<p>对应思路中的第三步：</p>
<p>我们已经得到了赫夫曼树，现在我们需要获得从根节点到各个叶子结点的路径，也就是赫夫曼编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成赫夫曼树对应的赫夫曼编码集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 储存某个叶子节点的拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将传入的节点作为树的根节点，找到其所有的叶子结点的赫夫曼编码，并放入赫夫曼编码集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> way 叶子结点的路径，左为0，右为1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> builder 用于拼接路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(HuffmanCodeNode node, String way, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(builder);</span><br><span class="line">    <span class="comment">//建路径拼接至上一路径</span></span><br><span class="line">    stringBuilder.append(way);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断当前是否为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//向左右递归直到找到叶子结点</span></span><br><span class="line">            getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">            getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//已经是叶子结点，将路径存入集合</span></span><br><span class="line">            huffmanCodes.put(node.data, stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建赫夫曼树</span></span><br><span class="line">    HuffmanCodeNode root = createTree();</span><br><span class="line">    <span class="comment">//处理左右子树</span></span><br><span class="line">    getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">    getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">    <span class="comment">//返回赫夫曼编码</span></span><br><span class="line">    <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5将得到的赫夫曼编码转回字节数组">5.将得到的赫夫曼编码转回字节数组</h3>
<p>对应思路中的第四步，也就是最后一步：</p>
<p>我们得到了赫夫曼编码表，也就是这玩意： <code>Map&lt;Byte, String&gt; huffmanCodes</code>，每串赫夫曼编码字符串都<strong>对应一个字符</strong>，我们需要<strong>处理赫夫曼编码的每一个字符</strong>，将其<strong>转为二进制后再转为byte</strong>，最后处理完得到一队字节数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串对应的byte数组，转换为经过赫夫曼编码压缩后的byte数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">    <span class="comment">//获取赫夫曼编码</span></span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//遍历byte数组，一个byte表示一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (Byte b : bytes) &#123;</span><br><span class="line">        <span class="comment">//将字符转为赫夫曼编码格式，一个字符对应8位编码</span></span><br><span class="line">        stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个字符对应对应的8位的赫夫曼编码，如果赫夫曼编码无法被8整除，就直接补齐赫夫曼编码不足八位的那一个字符</span></span><br><span class="line">    <span class="keyword">int</span> len = stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span> ? stringBuilder.length() / <span class="number">8</span> : stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//System.out.println(&quot;有几个字符：&quot;+len);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将压缩后的赫夫曼编码按字符分开存储</span></span><br><span class="line">    <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">    <span class="comment">//计录已处理几个字符</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每8位编码对应一个byte，所以步长为8</span></span><br><span class="line">    <span class="comment">//每循环一次处理一个byte，也就是一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123;</span><br><span class="line">        String strBytes;</span><br><span class="line">        <span class="comment">//判断编码长度是否超过8位</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">8</span> &lt; stringBuilder.length()) &#123;</span><br><span class="line">            <span class="comment">//超过8位就从赫夫曼编码截取八位（也就是一个字符）</span></span><br><span class="line">            strBytes = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就有多少截多少</span></span><br><span class="line">            strBytes = stringBuilder.substring(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将赫夫曼编码转为二进制，存入byte数组</span></span><br><span class="line">        huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strBytes, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//位已处理字符数+1</span></span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环结束后，返回赫夫曼编码按字符转换得到的字节数组</span></span><br><span class="line">    <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] zip() &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">    Map&lt;Byte, String&gt; huffmanCodes = getCodes();</span><br><span class="line">    <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6解码">6.解码</h3>
<p>信息被赫夫曼编码处理后我们会得到一队字节数组，如果要解码，我们需要先把字节数组按字符一个字节一个字节的转为二进制，然后通过赫夫曼编码表把二进制和字符字节一一找出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将byte转成二进制字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isComple 是否需要补高位。最后一个字节无需补位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 要转换的字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">byteToString</span><span class="params">(<span class="keyword">boolean</span> isComplate, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = b;</span><br><span class="line">    <span class="comment">//判断是否需要补齐高位</span></span><br><span class="line">    <span class="keyword">if</span> (isComplate) &#123;</span><br><span class="line">        temp |= <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回temp对应的二进制补码</span></span><br><span class="line">    String str = Integer.toBinaryString(temp);</span><br><span class="line">    <span class="keyword">return</span> isComplate ? str.substring(str.length() - <span class="number">8</span>) : str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码处理过的字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 原来未被转为赫夫曼编码的的字符串字节素组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将赫夫曼编码处理过byte数组转为二进制字符串</span></span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isComplate = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果是最后一个字节就不用补高位了</span></span><br><span class="line">        <span class="keyword">if</span> (i == huffmanBytes.length - <span class="number">1</span>) &#123;</span><br><span class="line">            isComplate = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接字节转的二进制字符串</span></span><br><span class="line">        stringBuilder.append(byteToString(isComplate, huffmanBytes[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把字符串按照指定赫夫曼编码进行解码</span></span><br><span class="line">    <span class="comment">//原本赫夫曼编码表是&lt;字节，二进制字符串&gt;，现在要转为&lt;二进制字符串，字节&gt;以通过转换得到的二进制字符串取出对应的字节</span></span><br><span class="line">    Map&lt;String, Byte&gt; reHuffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">        reHuffmanCodes.put(entry.getValue(), entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Byte&gt; bytes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//由于无法确认拼接后的二进制字符串每八位一定就能和某个字节对应，所以需要进行字符串匹配</span></span><br><span class="line">    <span class="comment">//这里可以简单理解为双指针，一号指针从i开始，二号指针从i+1开始</span></span><br><span class="line">    <span class="comment">//一号指针先指向字符串第i字符，然后二号指针从i+1个字符开始不断后移，然后进行进行匹配</span></span><br><span class="line">    <span class="comment">//比如：i=0，j=1，第一次截取并匹配的字符就是[0,1),也就是0；第二次是[0,2)，也就是01；然后是[0,3).....以此类推</span></span><br><span class="line">    <span class="comment">//直到找到以后，比如[2,7)，就移动一号指针到7，二号指针移动到8</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; stringBuilder.length(); i = --j) &#123;</span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!reHuffmanCodes.containsKey(key)) &#123;</span><br><span class="line">            key = stringBuilder.substring(i, j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes.add(reHuffmanCodes.get(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由集合转为字节数组</span></span><br><span class="line">    <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[bytes.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">        b[i] = bytes.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-完整代码">四、完整代码</h2>
<p>具体代码和测试用例可以去<a href="https://github.com/Createsequence/data_structure">GitHub</a>上看，这里就放实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：CreateSequence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2020-07-18 13:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：赫夫曼编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code.length() == <span class="number">0</span> || code == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;字符串必须有至少一个字符！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.str = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计字符在字符串中的出现次数，并组装节点列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;HuffmanCodeNode&gt; <span class="title">getNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将字符串转为字符串数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历字节数组，并且统计某一字符出现次数</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">24</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            Integer count = counts.get(b);</span><br><span class="line">            <span class="comment">//判断某一字符是否第一次出现</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不是就让出现次数+1</span></span><br><span class="line">                counts.put(b, count ++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将map转为节点集合</span></span><br><span class="line">        List&lt;HuffmanCodeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> HuffmanCodeNode(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建赫夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HuffmanCodeNode <span class="title">createTree</span><span class="params">(List&lt;HuffmanCodeNode&gt; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建树</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//从小到大排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出最小的两个数构建树</span></span><br><span class="line">            HuffmanCodeNode left = nodes.get(<span class="number">0</span>);</span><br><span class="line">            HuffmanCodeNode right = nodes.get(<span class="number">1</span>);</span><br><span class="line">            HuffmanCodeNode parant = <span class="keyword">new</span> HuffmanCodeNode(left, right);</span><br><span class="line">            <span class="comment">//删除两个节点</span></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            <span class="comment">//将根节点添加至集合</span></span><br><span class="line">            nodes.add(parant);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HuffmanCodeNode <span class="title">createTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTree(getNodes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(HuffmanCodeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        System.out.println(node.toString());</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HuffmanCodeNode root = createTree(getNodes());</span><br><span class="line">        preOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成赫夫曼树对应的赫夫曼编码集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 储存某个叶子节点的拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将传入的节点作为树的根节点，找到其所有的叶子结点的赫夫曼编码，并放入赫夫曼编码集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> way 叶子结点的路径，左为0，右为1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(HuffmanCodeNode node, String way, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(builder);</span><br><span class="line">        <span class="comment">//建路径拼接至上一路径</span></span><br><span class="line">        stringBuilder.append(way);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前是否为叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//向左右递归直到找到叶子结点</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//已经是叶子结点，将路径存入集合</span></span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回赫夫曼编码</span></span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建赫夫曼树</span></span><br><span class="line">        HuffmanCodeNode root = createTree();</span><br><span class="line">        <span class="comment">//处理左右子树</span></span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="comment">//返回赫夫曼编码</span></span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串对应的byte数组，转换为经过赫夫曼编码压缩后的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="comment">//获取赫夫曼编码</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历byte数组，一个byte表示一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (Byte b : bytes) &#123;</span><br><span class="line">            <span class="comment">//将字符转为赫夫曼编码格式，一个字符对应8位编码</span></span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个字符对应对应的8位的赫夫曼编码，如果赫夫曼编码无法被8整除，就直接补齐赫夫曼编码不足八位的那一个字符</span></span><br><span class="line">        <span class="keyword">int</span> len = stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span> ? stringBuilder.length() / <span class="number">8</span> : stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;有几个字符：&quot;+len);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将压缩后的赫夫曼编码按字符分开存储</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="comment">//计录已处理几个字符</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每8位编码对应一个byte，所以步长为8</span></span><br><span class="line">        <span class="comment">//每循环一次处理一个byte，也就是一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123;</span><br><span class="line">            String strBytes;</span><br><span class="line">            <span class="comment">//判断编码长度是否超过8位</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &lt; stringBuilder.length()) &#123;</span><br><span class="line">                <span class="comment">//超过8位就从赫夫曼编码截取八位（也就是一个字符）</span></span><br><span class="line">                strBytes = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则就有多少截多少</span></span><br><span class="line">                strBytes = stringBuilder.substring(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将赫夫曼编码转为二进制，存入byte数组</span></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strBytes, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//位已处理字符数+1</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环结束后，返回赫夫曼编码按字符转换得到的字节数组</span></span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] zip() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes();</span><br><span class="line">        <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将byte转成二进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isComple 是否需要补高位。最后一个字节无需补位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 要转换的字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">byteToString</span><span class="params">(<span class="keyword">boolean</span> isComplate, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        <span class="comment">//判断是否需要补齐高位</span></span><br><span class="line">        <span class="keyword">if</span> (isComplate) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回temp对应的二进制补码</span></span><br><span class="line">        String str = Integer.toBinaryString(temp);</span><br><span class="line">        <span class="keyword">return</span> isComplate ? str.substring(str.length() - <span class="number">8</span>) : str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码处理过的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来未被转为赫夫曼编码的的字符串字节素组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将赫夫曼编码处理过byte数组转为二进制字符串</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isComplate = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果是最后一个字节就不用补高位了</span></span><br><span class="line">            <span class="keyword">if</span> (i == huffmanBytes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                isComplate = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拼接字节转的二进制字符串</span></span><br><span class="line">            stringBuilder.append(byteToString(isComplate, huffmanBytes[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把字符串按照指定赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//原本赫夫曼编码表是&lt;字节，二进制字符串&gt;，现在要转为&lt;二进制字符串，字节&gt;以通过转换得到的二进制字符串取出对应的字节</span></span><br><span class="line">        Map&lt;String, Byte&gt; reHuffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            reHuffmanCodes.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Byte&gt; bytes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//由于无法确认拼接后的二进制字符串每八位一定就能和某个字节对应，所以需要进行字符串匹配</span></span><br><span class="line">        <span class="comment">//这里可以简单理解为双指针，一号指针从i开始，二号指针从i+1开始</span></span><br><span class="line">        <span class="comment">//一号指针先指向字符串第i字符，然后二号指针从i+1个字符开始不断后移，然后进行进行匹配</span></span><br><span class="line">        <span class="comment">//比如：i=0，j=1，第一次截取并匹配的字符就是[0,1),也就是0；第二次是[0,2)，也就是01；然后是[0,3).....以此类推</span></span><br><span class="line">        <span class="comment">//直到找到以后，比如[2,7)，就移动一号指针到7，二号指针移动到8</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; stringBuilder.length(); i = --j) &#123;</span><br><span class="line">            String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (!reHuffmanCodes.containsKey(key)) &#123;</span><br><span class="line">                key = stringBuilder.substring(i, j);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            bytes.add(reHuffmanCodes.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由集合转为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[bytes.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = bytes.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decode(<span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> decode(huffmanCodes, huffmanBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（二）：List与AbstractList</title>
    <url>/2020/11/27/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AList%E4%B8%8EAbstractList/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>List 应该接口是 Collection 最常被使用的接口了。其下的实现类皆为有序列表，其中主要分为 Vector，ArrayList，LinkedList 三个实现类，其中 Vecotr 又拥有子类 Stack。</p>
<p>从线程安全来说，List 下拥有线程安全的集合类 Vector；从数据结构来说，List 下拥有基于数组实现的 Vector 与 ArrayList，和基于链表实现的 LinkedList。</p>
<p>本篇文章暂不讨论具体的实现类，而将基于 List 接口与其抽象类 AbstractList，了解 List 接口是如何承上启下，进一步从 Collection 抽象到具体的。</p>
<blockquote>
<p>这是关于 java 集合类源码的第二篇文章。往期文章：</p>
<p><a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a></p>
</blockquote>
<h2 id="一-list-接口">一、List 接口</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201125163518482.png" alt="List 接口的方法"><figcaption aria-hidden="true">List 接口的方法</figcaption>
</figure>
<p>List 接口继承了 Collection 接口，在 Collection 接口的基础上增加了一些方法。相对于 Collection 接口，我们可以很明显的看到，List <strong>中增加了非常多根据下标操作集合的方法</strong>，我们可以简单粗暴的分辨一个方法的抽象方法到底来自 Collection 还是 List：参数里有下标就是来自 List，没有就是来自 Collection。</p>
<p>可以说，List 接口在 Collection 的基础上，<strong>进一步明确了 List 集合运允许根据下标快速存取的特性</strong>。</p>
<h3 id="1新增的方法">1.新增的方法</h3>
<ul>
<li><code>get()</code>：根据下标获取指定元素；</li>
<li><code>replaceAll()</code>：参数一个函数式接口<code>UnaryOperator&lt;E&gt;</code>，这个方法允许我们通过传入的匿名实现类的方法去对集合中的每一个类做一些处理以后再放回去；</li>
<li><code>sort()</code>：对集合中的数据进行排序。参数是 <code>Comparator&lt;? super E&gt;</code>，这个参数让我们传入一个比较的匿名方法，用于数组排序；</li>
<li><code>set()</code>：用指定的元素替换集合中指定位置的元素；</li>
<li><code>indexOf()</code>：返回指定元素在此列表中首次出现的索引；如果此列表不包含该元素，则返回-1；</li>
<li><code>lastIndexOf()</code>：返回指定元素在此列表中最后一次出现的索引，否则返回-1；</li>
<li><code>listIterator()</code>：这个是个多态的方法。无参的 <code>listIterator()</code>用于获取迭代器，而有参的 <code>listIterator()</code>可以传入下标，从集合的指定位置开始获取迭代器。指定的索引指示首次调用next将返回的第一个元素。</li>
<li><code>subList()</code>：返回此列表中指定的两个指定下标之间的集合的视图。注意，这里说的<strong>是视图，因而对视图的操作会影响到集合，反之亦然。</strong></li>
</ul>
<h3 id="2同名的新方法">2.同名的新方法</h3>
<ul>
<li><code>add()</code>：添加元素。List 中的 <code>add()</code> 参数的（int，E），而 Collection 中的 <code>add()</code> 参数是 E，<strong>因此 List 集合中同时存在指定下标和不指定下标两种添加方式</strong>；</li>
<li><code>remove()</code>：删除指定下标的元素。注意，List 的 <code>remove()</code> 参数是 int ，而 Collection 中的 `<code>remove()</code> 参数是 Objce，也就是说，<strong>List 中同时存在根据元素是否相等和根据元素下标删除元素两种方式</strong>。</li>
</ul>
<h3 id="3重写的方法">3.重写的方法</h3>
<ul>
<li><code>spliterator()</code>：List 接口重写了 Collection 接口的默认实现，换成了根据顺序的分割。</li>
</ul>
<h2 id="二-abstractlist-抽象类">二、AbstractList 抽象类</h2>
<p>AbstractList 类是一个继承了 AbstractCollection 类并且实现了 List 接口的抽象类，它相当于在 AbstractCollection 后的第二层方法模板。是对 List 接口的初步实现，同时也是 Collection 的进一步实现。</p>
<p>我们可以根据 JavaDoc 简单的了解一下它：</p>
<blockquote>
<p>此类提供List接口的基本实现，以最大程度地减少实现由“随机访问”数据存储（例如数组）支持的此接口所需的工作。 对于顺序访问数据（例如链表），应优先使用AbstractSequentialList代替此类。</p>
<p><strong>要实现不可修改的列表</strong>，程序员只需要扩展此类并为get(int)和size()方法提供实现即可。</p>
<p><strong>要实现可修改的列表</strong>，程序员必须另外重写set(int, E)方法（否则将抛出UnsupportedOperationException ）。 如果列表是可变大小的，则程序员必须另外重写add(int, E)和remove(int)方法。</p>
<p>不像其他的抽象集合实现，程序员<strong>不必提供迭代器实现</strong>;</p>
<p><strong>迭代器和列表迭代器由此类在“随机访问”方法之上实现</strong>： get(int) ， set(int, E) ， add(int, E)和remove(int) 。</p>
</blockquote>
<h3 id="1不支持的实现与抽象方法">1.不支持的实现与抽象方法</h3>
<p>可以直接通过下标操作的<code>set()</code>，<code>add()</code>，<code>remove()</code>都是 List 引入的新接口，这些都 AbstractList 都不支持，要使用必须由子类重写。</p>
<p><code>get()</code>由于不能确定子类是链表还是数组，所以此时<code>get()</code>仍然强制要求子类去实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2内部类们">2.内部类们</h3>
<p>跟 AbstractCollection 类不同，AbstractList 拥有几个特别的内部类，他们分别的迭代器类：Itr 和 ListItr，对应获取他们的方法是：</p>
<ul>
<li><code>iterator()</code>：获取 Itr 迭代器类；</li>
<li><code>listIterator()</code>：获取 ListItr 迭代器类。这是个多态方法，可以选择是否从指定下标开始，默认从下标为0的元素开始迭代；</li>
</ul>
<p>视图类 SubList 和 RandomAccessSubList：</p>
<ul>
<li><code>subList()</code>：获取视图类，会自动根据实现类是否继承 RandomAccess 而返回 SubList 或 RandomAccessSubList。</li>
</ul>
<p>这些内部类同样被一些其他的方法所依赖，所以要全面的了解 AbstractList 方法的实现，就需要先了解这些内部类的作用和实现原理。</p>
<h2 id="三-sublist方法与内部类">三、subList方法与内部类</h2>
<p><code>subList()</code>算是一个比较常用的方法了，在 List 接口的规定中，这个方法应该返回一个当前集合的一部分的视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是实现了RandomAccess接口的类</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="comment">// 是就返回一个可以随机访问的内部类RandomAccessSubList</span></span><br><span class="line">            <span class="keyword">new</span> RandomAccessSubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex) :</span><br><span class="line">            <span class="comment">// 否则返回一个普通内部类SubList</span></span><br><span class="line">            <span class="keyword">new</span> SubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到 RandomAccessSubList 和 SubList 这个内部类，其中，RandomAccessSubList 类是 SubList 类的子类，但是实现了 RandomAccess 接口。</p>
<h3 id="1sublist-内部类">1.SubList 内部类</h3>
<p>我们可以简单的把 SubList 和 AbstractList 理解为装饰器模式的一种实现，就像 SynchronizedList 和 List 接口的实现类一样。SubList 内部类通过对 AbstractList 的方法进行了再一次的封装，把对 AbstractList 的操作转变为了对 “视图的操作”。</p>
<p>通过对原有的 AbstractList 进行包装，将原本对 AbstractList 操作的方法改为了对 SubList 的操作的方法，是适配器模式思想的一种体现。</p>
<p>我们先看看 SubList 这个类的成员变量和构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 把外部类AbstractList作为成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; l;</span><br><span class="line">    <span class="comment">// 表示视图的起始位置（偏移量）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">// SubList视图的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;fromIndex = &quot;</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; list.size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;toIndex = &quot;</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line">                                               <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取外部类的引用</span></span><br><span class="line">        <span class="comment">// 这也是为什么操作视图或者外部类都会影响对方的原因，因为都操作内存中的同一个实例</span></span><br><span class="line">        l = list;</span><br><span class="line">        <span class="comment">// 获取当前视图在外部类中的起始下标</span></span><br><span class="line">        offset = fromIndex;</span><br><span class="line">        <span class="comment">// 当前视图的长度就是外部类截取的视图长度</span></span><br><span class="line">        size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = l.modCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以参考图片理解一下：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201126114026855.png" alt="image-20201126114026855"><figcaption aria-hidden="true">image-20201126114026855</figcaption>
</figure>
<p>然后 subList 里面的方法就很好理解了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查下标是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 判断是存在并发修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="comment">// 把元素添加到偏移量+视图下标的位置</span></span><br><span class="line">    <span class="keyword">return</span> l.set(index+offset, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他方法都差不多，这里便不再多费笔墨了。</p>
<h3 id="2randomaccesssublist-内部类">2.RandomAccessSubList 内部类</h3>
<p>然后是 SubList 的子类 RandomAccessSubList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomAccessSubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SubList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    RandomAccessSubList(AbstractList&lt;E&gt; list, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">super</span>(list, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomAccessSubList&lt;&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看见，他实际上还是 SubList，但是实现了 RandomAccess 接口。关于这个接口，其实只是一个标记，实现了该接口的类可以实现快速随机访问（下标），通过 for 循环+下标取值会比用迭代器更快。</p>
<p>Vector 和 ArrayList 都实现了这个接口，而 LinkedList 没有。专门做此实现也是为了在实现类调用的 <code>subList()</code>方法时可以分辨这三者。</p>
<h2 id="四-iterator方法与内部类">四、iterator方法与内部类</h2>
<p>在 AbstractList 里面，为我们提供了 Itr 和 ListItr 两种迭代器。</p>
<p>迭代器是 AbstractList 中很重要的一块内容，他是对整个接口体系的顶层接口，也就是 Iterable 接口中的 <code>iterator()</code> 方法的实现，源码中的很多涉及遍历的方法，都离不开内部实现的迭代器类。</p>
<h3 id="1迭代器的-fast-fail-机制">1.迭代器的 fast-fail 机制</h3>
<p>我们知道，AbstractList 默认是不提供线程安全的保证的，但是为了尽可能的避免并发修改对迭代带来的影响，JDK 引入一种 fast-fail 的机制，即如果检测的发生并发修改，就立刻抛出异常，而不是让可能出错的参数被使用从而引发不可预知的错误。</p>
<p>对此，AbstractList 提供了一个成员变量 <code>modCount</code>，JavaDoc 是这么描述它的：</p>
<blockquote>
<p>已对该列表进行结构修改的次数。</p>
<p>结构修改是指更改列表大小或以其他方式干扰列表的方式，即正在进行的迭代可能会产生错误的结果。该字段由iterator和listIterator方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，则迭代器（或列表迭代器）将抛出ConcurrentModificationException，以响应下一个，移除，上一个，设置或添加操作。</p>
<p>面对迭代期间的并发修改，这提供了快速失败的行为，而不是不确定的行为。</p>
<p>子类对此字段的使用是可选的。如果子类希望提供快速失败的迭代器（和列表迭代器），则只需在其add（int，E）和remove（int）方法（以及任何其他覆盖该方法导致结构化的方法）中递增此字段即可）。</p>
<p>一次调用add（int，E）或remove（int）不得在此字段中添加不超过一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationExceptions。</p>
<p>如果实现不希望提供快速失败迭代器，则可以忽略此字段。</p>
</blockquote>
<p>这个时候我们再回去看看迭代器类 Itr 的一部分代码，可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代器认为后备列表应该具有的modCount值。如果违反了此期望，则迭代器已检测到并发修改。</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否发生并发操作</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合代码，我们就不难理解这个 fast-fail 机制是怎么实现的了：</p>
<p>AbstractList 提供了一个成员变量用于记录对集合结构性修改的次数，如果子类希望实现并发修改错误的检查，就需要结构性操作的方法里让<code>modCount</code>+1。这样。在获取迭代器以后，迭代器内部会获取当前的<code>modCount</code>赋值给<code>expectedModCount</code>。</p>
<p>当使用迭代器迭代的时候，每一次迭代都会检测<code>modCount</code>和<code>expectedModCount</code>是否相等。如果不相等，说明迭代器创建以后，集合结构被修改了，这个时候再去进行迭代可能会出现错误（比如少遍历一个，多遍历一个），因此检测到后会直接抛出 <code>ConcurrentModificationException</code>异常。</p>
<p>ListItr 继承了 Itr ，因此他们都有一样的 fast-fail机制。</p>
<p>值得一提的是，<strong>对于启用了 fast-fail 机制的实现类，只有使用迭代器才能边遍历边删除</strong>，原因也是因为并发修改检测：</p>
<h3 id="2itr-迭代器">2.Itr 迭代器</h3>
<p>现在，回到 Itr 的代码上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 后续调用next返回的元素索引</span></span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最近一次调用返回的元素的索引。如果通过调用remove删除了此元素，则重置为-1。</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器认为后备列表应该具有的modCount值。如果违反了此期望，则迭代器已检测到并发修改。</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            E next = get(i);</span><br><span class="line">            lastRet = i;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">                cursor--;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>迭代方法</strong></p>
<p>除了并发修改检测外，迭代器迭代的方式也出乎意料。我们可以看看 <code>hasNext()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检验是否发生并发修改</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        E next = get(i);</span><br><span class="line">        lastRet = i;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个逻辑其实跟链表的遍历是一样的，只不过指针变成了数组的下标。以链表的方式去理解：</p>
<p>我们把循环里调用<code>next()</code>之后的节点叫做下一个节点，反正称为当前节点。假如现在有 a，b，c 三个元素：</p>
<ul>
<li>当初始化的时候，指向最后一次操作的的节点的指针 <code>lastRet=-1</code>，即当前节点不存在，当前游标 <code>cursor=0</code>，即指向下一个节点 a；</li>
<li>当开始迭代的时候，把游标的值赋给临时指针 i，然后通过游标获取并返回下一个节点 a，再把游标指向 a 的下一个节点 b，此时 <code>cursor=1</code>，<code>lastRet=-1</code>，<code>i=1</code>；</li>
<li>接着让<code>lastRet=i</code>，也就是当前指针指向新的当前节点 a，现在 lastRet=0<code>，</code>cursor=1`，完成了对第一个节点 a 的迭代；</li>
<li>重复上述过程，把节点中的每一个元素都处理完。</li>
</ul>
<p>现在我们知道了迭代的方式，<code>cursor</code>和 <code>lastRet</code> 的作用，也就不难理解 <code>remove()</code>方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用删除方法</span></span><br><span class="line">        AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">		   <span class="comment">// 因为删除了当前第i个节点，所以i+1个节点就会变成第i个节点，</span></span><br><span class="line">            <span class="comment">// 调用next()以后cursor会+1，因此如果不让cursor-1,就会,next()以后跳过原本的第i+1个节点</span></span><br><span class="line">            <span class="comment">// 拿上面的例子来说，你要删除abc，但是在删除a以后会跳过b直接删除c</span></span><br><span class="line">            cursor--;</span><br><span class="line">        <span class="comment">// 最近一个操作的节点被删除了，故重置为-1</span></span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 因为调用了外部类的remove方法，所以会改变modCount值，迭代器里也要获取最新的modCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于<code>hasNext()</code>方法没啥好说的，如果 <code>cursor</code>已经跟集合的长度一样长了，说明就已经迭代到底了。</p>
<h3 id="2listitr-迭代器">2.ListItr 迭代器</h3>
<p>ListItr 继承了 Itr 类，并且实现了 ListIterator 接口。其中，ListIterator 接口又继承了 Iterator 接口。他们的类关系图是这样的：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201126204925206.png" alt="ListIterator 的类关系图"><figcaption aria-hidden="true">ListIterator 的类关系图</figcaption>
</figure>
<p>ListIterator 接口在 Iterator 接口的基础上，主要提供了六个新的抽象方法：</p>
<ul>
<li><code>hasPrevious()</code>：是否有前驱节点；</li>
<li><code>previous()</code>：向前迭代；</li>
<li><code>nextIndex()</code>：获取下一个元素的索引；</li>
<li><code>previousIndex()</code>：返回上一个元素的索引；</li>
<li><code>set()</code>：替换元素；</li>
<li><code>add()</code>：添加元素；</li>
</ul>
<p>可以看出来，实现了 ListIterator 的 ListItr 类要比 Itr 更加强大，不但可以向后迭代，还能向前迭代，还可以在迭代过程中更新或者添加节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 可以自己设置迭代的开始位置</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 下一节点是否就是第一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查并发修改</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 让游标指向当前节点</span></span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 使用AbstractList的get方法获取当前节点</span></span><br><span class="line">            E previous = get(i);</span><br><span class="line">            lastRet = cursor = i;</span><br><span class="line">            <span class="keyword">return</span> previous;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取下一节点的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点（下一个节点的上一个节点）的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AbstractList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="comment">// 往下一个节点的位置添加新节点</span></span><br><span class="line">            AbstractList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里比较不好理解的是下一节点还有当前节点这个概念，其实可以这么理解：<code>cursor</code>游标指定的必定是下一次 <code>next()</code>操作要得到的节点，因此<code>cursor</code>在操作前或者操作后指向的必定就是下一节点，因此相对下一节点，<code>cursor</code>其实就是当前节点，相对下一节点来说就是上一节点。</p>
<p>也就是说，假如现在有 a，b，c 三个元素，现在的 <code>cursor</code> 为2，也就是指向 b。调用 <code>next()</code>以后游标就会指向 c，而调用<code>previous()</code>以后游标又会指回 b。</p>
<p>至于<code>lastRet</code>这个成员变量只是用于记录最近一次操作的节点是哪个，跟方向性是无关。</p>
<h2 id="五-abstractlist-实现的方法">五、AbstractList 实现的方法</h2>
<h3 id="1add">1.add</h3>
<p>注意，现在现在 AbstractList 的 <code>add(int index, E e)</code>仍然还不被支持，<code>add(E e)</code>只是定义了通过 <code>add(int index, E e)</code>把元素添加到队尾的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不指定下标的add，默认逻辑为添加到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 AbstractList 和 AbstractCollection 中 <code>add()</code>方法之间的关系是这样的：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201126110250536.png" alt="add方法的实现逻辑"><figcaption aria-hidden="true">add方法的实现逻辑</figcaption>
</figure>
<p>AbstractList 这里的 <code>add(E e)</code>就非常有模板方模式提到的“抽象类规定算法骨架”这个感觉了。AbstractCollection 接口提供了 <code>add(E e)</code>的初步实现（尽管只是抛异常），然后到了 AbstractList 中就完善了 <code>add(E e)</code>方法的逻辑——通过调用 <code>add(int index,E e)</code>方法把元素插到队尾，但是具体的 <code>add(int index,E e)</code>怎么实现再交给子类决定。</p>
<h3 id="2indexoflastindexof">2.indexOf/LastIndexOf</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(size());</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (it.previous()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.previous()))</span><br><span class="line">                <span class="keyword">return</span> it.nextIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3addall">3.addAll</h3>
<p>这里的<code>addAll</code>来自于List 集合的 <code>addAll</code>。参数是需要合并的集合跟起始下标：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>rangeCheckForAdd()</code>方法是一个检查下标是否越界的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不得小于0或者大于集合长度</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4removerange">4.removeRange</h3>
<p>这个方法是 AbstractList 私有的方法，一般被子类用于删除一段多个元素，实现上借助了 ListIter 迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="comment">// 从fromIndex的下一个开始，删到toIndex</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-abstractlist-重写的方法">六、AbstractList 重写的方法</h2>
<h3 id="1equals">1.equals</h3>
<p><code>equals()</code>方法比较特殊，他是来自于 Collection 和 List 接口中的抽象方法，在 AbstractList 得中实现，但是实际上也是对 Object 中方法的重写。考虑到 <code>equals()</code>情况特殊，所以我们也认为它是一个重写的方法。</p>
<p>我们可以先看看 JavaDoc 是怎么说的：</p>
<blockquote>
<p>比较指定对象与此列表是否相等。当且仅当指定对象也是一个列表，并且两个列表具有相同的大小，并且两个列表中所有对应的元素对相等时，才返回true</p>
</blockquote>
<p>然后再看看源码是什么样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否同一个集合</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 是否实现了List接口</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取集合的迭代器并同时遍历</span></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="comment">// 两个集合中的元素是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否两个集合长度相同</span></span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码也可以看出，AbstractList 的 <code>equals()</code> 是要求两个集合绝对相等的：顺序相等，并且相同位置的元素也要相等。</p>
<h3 id="2hashcode">2.hashCode</h3>
<p><code>hashCode()</code> 和 <code>equals()</code>情况相同。AbstractList 重新定义了 <code>hashCode()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : <span class="keyword">this</span>)</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (e==<span class="keyword">null</span> ? <span class="number">0</span> : e.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的计算方式会获取集合中每一个元素的 hashCode 去计算集合的 hashCode，这可能是考虑到原本情况下，同一个集合哪怕装入的元素不同也会获得相同的 hashCode，可能会引起不必要的麻烦，因此重写了次方法。</p>
<p>我们可以写个测试看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">System.out.println(list1.hashCode()); <span class="comment">// 128</span></span><br><span class="line">list1.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(list1.hashCode()); <span class="comment">// 4067</span></span><br></pre></td></tr></table></figure>
<h2 id="七-总结">七、总结</h2>
<p><strong>List</strong></p>
<p>List 接口继承了 Collection 接口，新增方法的特点主要体现在可以通过下标去操作节点，可以说大部分下标可以作为参数的方法都是 List 中添加的方法。</p>
<p><strong>AbstractList</strong></p>
<p>AbstractList 是实现了 List 的抽象类，他实现了 List 接口中的大部分方法，同时他继承了 AbstractCollection ，沿用了一些 AbstractCollection 中的实现。这两个抽象类可以看成是模板方法模式的一种体现。</p>
<p>他提供了下标版的 <code>add()</code>，<code>remove()</code>，<code>set()</code>的空实现。</p>
<p><strong>迭代器</strong></p>
<p>AbstractList 内部提供两个迭代器，Itr 和 ListItr，Itr 实现了 <code>Iterator</code>接口，实现了基本的迭代删除，而 ListItr 实现了<code>ListIterator</code>，在前者的基础上增加了迭代中添加修改，以及反向迭代的相关方法，并且可以从指定的位置开始创建迭代器。</p>
<p><strong>视图集合SubList</strong></p>
<p>AbstractList 的 SubList 可以看成 AbstractList 的包装类，他在实例化的时候会把外部类实例的引用赋值给成员变量，同名的操作方法还仍然是调用 AbstractList 的，但是基于下标的调用会在默认参数的基础上加上步长，以实现对“视图”的操作，这是适配器模式思想的一种体现。</p>
<p><strong>并发修改检查机制fast-fail</strong></p>
<p>AbstractList 引入了并发修改下 fast-fail 的机制，在内部维护一个成员变量 <code>modelCount</code>，默认为零，每次结构性修改都会让其+1。在迭代过程中会默认检查 <code>modelCount</code>是否符合预期值，否则抛出异常。值得注意的是，这个需要实现类的配合，在实现 <code>add()</code>等方法的时候要让 <code>modelCount</code>+1。对于一些实现类，在迭代中删除可能会抛出 <code>ConcurrentModificationExceptions</code>，就是这方面的问题。</p>
<p>AbstractList 重写了 <code>hashCode()</code>方法，不再直接获取实例的 HashCode 值，而遍历集合，根据每一个元素的 HashCode 计算集合的 HashCode，这样保证了内容不同的相同集合不会得到相同的 HashCode。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（五）：Map与AbstractMap</title>
    <url>/2020/12/07/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AMap%E4%B8%8EAbstractMap/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>Map 接口是 java 中两大集合接口之一，相对于 Collection，Map 接口结构规定了所有键值对形式的集合容器。同时，它与 Collection 的子接口 Set 又密切相关，Map 一部分实现依赖于 Set 集合，而 Set 集合的一些实现也依赖于 Map。</p>
<p>Map 接口下有四个主要实现类 TreeMap，HashMap，LinkedMap，Hashtable。基于以上四大实现类，这是他们的类关系图：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201208151954095.png" alt="Map 接口的类关系图"><figcaption aria-hidden="true">Map 接口的类关系图</figcaption>
</figure>
<p>与其相关的还有 Dictionary 类，这是一个已过时的早期键值对集合接口，后期的新集合都基于 Map 接口实现，唯一依赖与他的 Hashtable 因为性能原因也很少被使用，因此这个类是一个过时类。</p>
<blockquote>
<p>这是关于 java 集合类源码的第五篇文章。往期文章：</p>
<ol type="1">
<li><a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a><br>
</li>
<li><a href="https://blog.xiajibagao.top/2020/11/27/java/集合类源码分析/java集合源码分析（二）：List与AbstractList/">java集合源码分析（二）：List与AbstractList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/02/java/集合类源码分析/java集合源码分析（三）：ArrayList/">java集合源码分析（三）：ArrayList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/03/java/集合类源码分析/java集合源码分析（四）：LinkedList/">java集合源码分析（四）：LinkedList</a></li>
</ol>
</blockquote>
<h2 id="一-map-接口">一、Map 接口</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201207201537859.png" alt="image-20201207201537859"><figcaption aria-hidden="true">image-20201207201537859</figcaption>
</figure>
<p>Map 接口就是所有键值对类型集合接口的最上层接口，他规定了一个所有 Map 类型集合应该实现的抽象方法，同时提供了一个用于视图操作的默认接口类 Entry。</p>
<h3 id="1抽象方法">1.抽象方法</h3>
<p><strong>查询操作</strong></p>
<ul>
<li><code>size()</code>：获取键值对数量；</li>
<li><code>isEmpty()</code>：是否为空；</li>
<li><code>containsKey(Object key)</code>：是否存在对应的 key；</li>
<li><code>containsValue(Object value)</code>：是否存在对应的 value；</li>
<li><code>get(Object key)</code>：根据 key 获取 value；</li>
</ul>
<p><strong>更改操作</strong></p>
<ul>
<li><code>put(K key, V value)</code>：添加一对键值对；</li>
<li><code>remove(Object key)</code>：根据 key 删除相应键值对；</li>
<li><code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code>：合并 Map 集合；</li>
<li><code>clear()</code>：清空集合；</li>
</ul>
<p><strong>视图操作</strong></p>
<p>Map 是一种很特殊的集合，他表示的是一系列键值对的映射关系，因而无法像 Collection 集合一样直接看做一种元素的集合。为此，Map 定义了实现类必须可以通过以下三种方法返回特定的三个视图以方便操作：</p>
<ul>
<li><code>Set&lt;K&gt; keySet()</code>：返回一个由 key 组成的 Set 集合视图；</li>
<li><code>Collection&lt;V&gt; values()</code>：返回一个由 value 组成的 Collection 集合视图；</li>
<li><code>entrySet()</code>：返回一个由 key-value 对组成的 Set 视图；</li>
</ul>
<p>其中，<code>entrySet</code>返回的元素其实就是 Map 的内部接口 Entry 的实现类，一个 Entry 对象表示一对 key 和 value。</p>
<h3 id="2默认方法">2.默认方法</h3>
<p>接口的默认方法是 JDK8 新特性之一，因此此类方法全为 JDK8 新增方法。</p>
<p>这类方法的特点是<strong>参数多为函数式结构，并且大部分不会被实现类重写</strong>。我们可以通过 lambda 表达式去调用。</p>
<ul>
<li><code>getOrDefault(Object key, V defaultValue)</code>：获取 key 对应的 value，若不存在则返回 defaultValue；</li>
<li><code>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code>：遍历处理集合中的键值对；</li>
<li><code>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</code>：替换集合中的键值对；</li>
<li><code>putIfAbsent(K key, V value)</code>：仅当对应键值对不存在或 value 为 null 时新增；</li>
<li><code>remove(Object key, Object value)</code>：仅当对应键值存在并且 value 不为 null 时删除；</li>
<li><code>replace(K key, V oldValue, V newValue)</code>：仅当对应键值对存在，value 不为 null 且 value 等于指定 value 时（除非传入 null）替换旧 value；</li>
<li><code>computeIfAbsent(K key,Function&lt;? super K, ? extends V&gt; mappingFunction)</code>：如果当前键值对不存在，则将通过传入方法处理 key 得到的 value 与 key 一起添加到集合；</li>
<li><code>computeIfPresent(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>：如果当前键值对存在，则将原先的 value 更新为通过传入方法处理后的 value。如果处理后得到 null，则删除对应的键值对。</li>
<li><code>compute(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>：如果当前键值对存在，并且根据传入方法处理后得到的新 value 不为null，则更新键值对，否则则删除键值对。</li>
<li><code>merge(K key, V value,BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code>：如果当前键值对不存在，则新 value 等于当前值，否则由根据传入方法处理得到。若新 value 不为 null，则更新键值对，否则就删除键值对。</li>
</ul>
<h3 id="3equals和hashcode">3.equals和hashcode</h3>
<p>在 Map 中，由于多数比较基于 <code>equals()</code> 和 <code>hashCode()</code> 方法，因此 Map 集合要求实现类重写实现这两个方法，其中：</p>
<p><code>equals()</code> 要求以 <code>m1.entrySet().equals(m2.entrySet())</code> 的形式实现两个 Map 集和的比较；</p>
<p>而 <code>hashCode()</code>则与 Collection 的 <code>equals()</code>类似，要求 Map 集合的 hashcode 应当为集合内所有 <code>entrySet()</code>的 hashcode 之和。</p>
<h2 id="二-entry-接口">二、Entry 接口</h2>
<p>Entry 是 Map 的一个内部接口类。跟一般的接口不太一样，Entry 的实现类实际上是作为 Map 中键值对对象使用的，即一对 key 和 value 就作为一个 Entry 对象。Entry 实际上是对 Map 实现类中使用的键值对对象的一种约束。根据 JavaDoc 的说明：</p>
<blockquote>
<p>Map.entrySet方法返回 Map 的集合视图，该 Map 的元素属于此类。</p>
<p>这些 Map.Entry 对象仅在迭代期间有效。</p>
</blockquote>
<p>他提供了九个基本的方法：</p>
<ul>
<li><code>getKey()</code>：获取 key；</li>
<li><code>getValue</code>：获取 value；</li>
<li><code>comparingByKey()</code>：根据 key 排序；</li>
<li><code>comparingByValue()</code>：根据 value 排序；</li>
<li><code>comparingByKey(Comparator&lt;? super K&gt; cmp)</code>：根据 key 排序；</li>
<li><code>comparingByValue(Comparator&lt;? super V&gt; cmp)</code>：根据 value 排序。</li>
</ul>
<p>我们也可以把 Entry 看成 Map 集合中的一种视图，只不过它只局限于一对键值对。</p>
<h2 id="三-abstractmap-抽象类">三、AbstractMap 抽象类</h2>
<p>AbstractMap 与 AbstractList 一样，都是为于接口提供基本实现的抽象类。根据 JavaDoc，我们可以简单的了解一下它：</p>
<blockquote>
<p>此类提供Map接口的基本实现，以最大程度地减少实现此接口所需的工作。</p>
<p><strong>要实现不可修改的Map</strong>，程序员仅需要扩展此类并为 entrySet 方法提供实现，该方法将返回 Map 映射的 set-view。</p>
<p>通常，返回的集合将依次在 AbstractSet 之上实现。 此集合不支持add或remove方法，并且其迭代器不支持remove方法。</p>
<p><strong>要实现可修改的Map</strong>，程序员必须另外重写此类的put方法（否则将引发UnsupportedOperationException ），并且entrySet（）。iterator（）返回的迭代器必须另外实现其 remove 方法。</p>
</blockquote>
<h3 id="1成员变量">1.成员变量</h3>
<p>AbstractMap 内部拥有两个成员变量 <code>keySet</code>和 <code>values</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key的集合视图</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values的集合视图</span></span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，针对获取 keySet 的同名抽象方法 <code>keySet()</code>的注释上，指明了：</p>
<blockquote>
<p>这些字段中的每个字段都被初始化为在第一次请求此视图时包含相应视图的实例。 视图是无状态的，因此没有理由创建多个视图。</p>
<p>同样，实现也必须只读取一次该字段，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;  <span class="comment">// single racy read</span></span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可见，keySet 获取实例是一个很典型的单例模式。</p>
<h3 id="2内部类">2.内部类</h3>
<p>之前我们说，Map 接口提供的内部类接口 Entry，是为实现类的键值对对象提供约束。在 AbstractMap 中，就提供了两个实现了 Entry 接口的内部类 SimpleEntry 和 SimpleImmutableEntry。</p>
<p><strong>SimpleEntry</strong></p>
<p>SimpleEntry 是一个基于 Map 接口的内部接口类 Entry 的实现。他可以看成是<strong>集合中一对键值对对象的映射——或者说，视图</strong>。</p>
<p>当初始化时，需要传入 key 和 value 赋值给同名的成员变量，并且 key 会被 final 修饰，<strong>因而 key 不可更改，而 value 可以更改</strong>。</p>
<p>基于以上的原理，<strong>当 value 是引用类型，并且去修改它的时候，修改会真实的反应到外部类的 values 对应的那个 value 中，但是如果要做替换，则只能替换当前 SimpleEntry 对象中的 value</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8499721149061103585L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key不可变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleEntry</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key   = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleEntry</span><span class="params">(Entry&lt;? extends K, ? extends V&gt; entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key   = entry.getKey();</span><br><span class="line">        <span class="keyword">this</span>.value = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 更新值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写equals方法，要求key与value都需要相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="keyword">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key   == <span class="keyword">null</span> ? <span class="number">0</span> :   key.hashCode()) ^</span><br><span class="line">            (value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SimpleImmutableEntry</strong></p>
<p>SimpleImmutableEntry 与 SimpleEntry 没什么不同，只不过多了和他名字一样的特性：“<strong>不可变</strong>”。</p>
<p>相对于 SimpleEntry，SimpleImmutableEntry 的 <strong>value 也被 final 修饰，并且调用它的 <code>setValue()</code>方法会抛出 <code>UnsupportedOperationException</code>异常</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImmutableEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-abstractmap-的视图">五、AbstractMap 的视图</h2>
<h3 id="1四个视图">1.四个视图</h3>
<figure>
<img src="http://img.xiajibagao.top/image-20201209100407295.png" alt="Map的三个视图"><figcaption aria-hidden="true">Map的三个视图</figcaption>
</figure>
<p>我们知道，由于 Map 是一个键值对集合，因此它实际存放的是 key 与 value，还有他们的映射关系。单个操作的时候很好操作，要么根据 key 找 value，要么直接 找 key 或者 value。但是当迭代的时候，我们就需要区分，是要迭代全部的 key，还是迭代全部的 value，还是要同时迭代全部的 key + value。因此，就有了 Map 的三个视图：</p>
<ul>
<li>key 视图 keySet：用于存放 key 的 Set 集合；</li>
<li>value 视图 values：用于存放 value 的 Collection 集合；</li>
<li>key-value 视图 entrySet：用于存放 key-value 的视图 Entry 的 Set 集合。</li>
</ul>
<p>entrySet 比较不好理解，它里面放的是 Entry，一个 Entry 就代表一对键值对，因此，Entry 其实也可以理解为一个视图，这个视图只局限于一对键值对。</p>
<p>而 entrySet 装了集合里面全部的 Entry 视图，所以它也可以理解为一个表示整个 Map 容器中所有 key-value 的视图。或者简单粗暴的理解为<code>entrySet = keySet + values</code>。</p>
<p>由于 Entry 代表了键值对集合，因此也可以把 Map 集合以“Entry 对象的 Set 集合”——也就是 entrySet——表示。因此，在 Map 的实现类中，Entry 是一个很特别的类，他在很多的方法里都被作为参数使用。</p>
<h3 id="2视图类的实现">2.视图类的实现</h3>
<p>虽然定义好了视图类，但是 Map 接口并没有提供关于 keySet，values，Entry 与 entrySet 的实现。 但是定义了用于获取三个视图的方法 <code>keySet()</code>，<code>values()</code>和 <code>enrtySet()</code>。</p>
<p>AbstractMap 在上述基础上，提供了 keySet 和 values 作为成员变量，entrySet 变量需要由实现类自己去提供。</p>
<p>因此，<strong>如果一个实现类要实现 Map 接口，AbstractMap，理论上需要提供7个关于视图的实现类</strong>：</p>
<ul>
<li>KeySet 视图实现类，以及它的迭代器类;</li>
<li>Values 视图实现类，以及它的迭代器；</li>
<li>Entry 视图实现类；</li>
<li>EntrySet 类，以及它的迭代器；</li>
</ul>
<p>而在 AbstractMap 中，不提供 Entry 和 EntrySet 的实现，并且让 <code>entrySet()</code> 方法仍然保持抽象状态。</p>
<p>但是以匿名内部类的形式实现了 KeySet 和 Values 视图，并且让两者的迭代器都使用 <code>entrySet()</code>方法返回的 EntrySet 实现类提供的迭代器。</p>
<p>也就是说，<strong>如果一个类要实现 Map 接口，那么通过继承 AbstractMap，它只需要再提供3个实现类就可以了</strong>：</p>
<ul>
<li>EntrySet 实现类，以及它的迭代器；</li>
<li>Entry 视图实现类。</li>
</ul>
<h3 id="3keyset">3.keySet()</h3>
<p><code>keySet()</code>方法用于获取集合内部存放 key 的 Set 集合 keySet。他直接返回了一个继承并且实现了 AbstractSet 抽象方法 <code>iterator()</code> 的匿名内部类，并且直接使用 EntrySet 的迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 keySet</span></span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="comment">// 如果keySet为null，就创建一个自定义的 AbstractSet</span></span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> AbstractSet&lt;K&gt;() &#123;</span><br><span class="line">            <span class="comment">// 实现了AbstractSet中的iterator()方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 返回一个自定义的迭代器类</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 获取entrySet返回的Set集合的迭代器，以下方法全部基于改迭代器实现</span></span><br><span class="line">                    <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">                    </span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.next().getKey();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        i.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 以下方法全部都调用AbstractMap的实现</span></span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AbstractMap.<span class="keyword">this</span>.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.containsKey(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，AbstractMap 中使用的 keySet 相当于一个单例的 AbstractSet 内部实现类，这类的迭代器就是 <code>entrySet()</code>方法返回的 Set 集合的迭代器；而其他的方法直接使用外部类 AbstractMap 的：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201208150219575.png" alt="keySet 方法的实现"><figcaption aria-hidden="true">keySet 方法的实现</figcaption>
</figure>
<h3 id="4values">4.values()</h3>
<p>AbstractMap 的 <code>values()</code>方法和 <code>keySet()</code>类似。它返回一个继承了 AbstractCollection 抽象类的匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vals = values;</span><br><span class="line">    <span class="keyword">if</span> (vals == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vals = <span class="keyword">new</span> AbstractCollection&lt;V&gt;() &#123;</span><br><span class="line">            <span class="comment">// 使用entrySet().iterator()获取的迭代器</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;V&gt;() &#123;</span><br><span class="line">                    <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i.next().getValue();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        i.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接使用AbstractMap提供的方法</span></span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AbstractMap.<span class="keyword">this</span>.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.containsValue(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        values = vals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-abstractmap-的方法">五、AbstractMap 的方法</h2>
<h3 id="1不支持的实现">1.不支持的实现</h3>
<p>如类注释所说，AbstractMap 不支持 <code>put()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此经过已经实现了部分逻辑，但是 <code>putAll()</code>在实现 <code>put()</code>方法之前也无法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2实现的方法">2.实现的方法</h3>
<p><strong>查询操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entrySet().size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更改操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="comment">// 指定要获取的key是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="comment">// 返回对应的value</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取entrySet的迭代器</span></span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    Entry&lt;K,V&gt; correctEntry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 指定要删除的key是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (key==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (correctEntry==<span class="keyword">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="comment">// 找出key为null的那对键值对</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="keyword">null</span>)</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (correctEntry==<span class="keyword">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="comment">// 找出指定键值对</span></span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V oldValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (correctEntry !=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据key获取value</span></span><br><span class="line">        oldValue = correctEntry.getValue();</span><br><span class="line">        <span class="comment">// 删除该键值对</span></span><br><span class="line">        i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    entrySet().clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3equals-hashcode">3.equals / hashCode</h3>
<p>集合容器基本都会重写 <code>equals()</code> 和 <code>hashCode()</code>方法，AbstractMap 亦然。</p>
<p><strong>equals</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否实现Map接口</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">    <span class="comment">// 是否长度相同</span></span><br><span class="line">    <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历自己的键值对</span></span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            <span class="comment">// value是否为null</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 是否在比较的集合中key存在，并且对应的value是null</span></span><br><span class="line">                <span class="keyword">if</span> (!(m.get(key)==<span class="keyword">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若value不为null，比较是否value一致</span></span><br><span class="line">                <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>hashCode</strong></p>
<p>AbstractMap 的 hashcode 是集合内所有 entrySet 对象的 hashcode 之和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">        h += i.next().hashCode();</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4tosring">4.toSring</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">        K key = e.getKey();</span><br><span class="line">        V value = e.getValue();</span><br><span class="line">        sb.append(key   == <span class="keyword">this</span> ? <span class="string">&quot;(this Map)&quot;</span> : key);</span><br><span class="line">        sb.append(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        sb.append(value == <span class="keyword">this</span> ? <span class="string">&quot;(this Map)&quot;</span> : value);</span><br><span class="line">        <span class="keyword">if</span> (! i.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">&#x27;&#125;&#x27;</span>).toString();</span><br><span class="line">        sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5clone">5.clone</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    AbstractMap&lt;?,?&gt; result = (AbstractMap&lt;?,?&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    result.keySet = <span class="keyword">null</span>;</span><br><span class="line">    result.values = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-总结">六、总结</h2>
<p><strong>Map接口</strong></p>
<p>Map 接口规定了所有键值对类型的集合容器。他底下有 Hashtable，HashMap，TreeMap，以及 HashMap 的子类 LinkedMap 四个主要的实现类。</p>
<p>与他类似的还有 Dictionary 接口，Hashtable 实现了该接口。这是一个已经过时的键值对容器接口。</p>
<p>AbstractMap 抽象类为 Map 接口提供了大部分的实现。处理 Hashtable 外，其他三个主要实现类都继承了他。</p>
<p>在 Map 接口中，提供了键值对视图的接口 Entry，并且规定实现类需要实现 entrySet()，keySet()，values() 三个抽象方法，以返回 Entry 的 Set 集合视图，key 的 Set 集合视图以及 value 的 Collection 集合视图。</p>
<p><strong>AbstractMap</strong></p>
<p>在 AbstractMap 中，实现了 <code>keySet()</code>，<code>values()</code> 方法，并且提供了相应的成员变量 keySet 和 values 。但是没有提供 EntrySet 的实现类，也没有实现 <code>entrySet()</code> 方法。</p>
<p>用于获取 key 的<code>keySet()</code> 方法会返回一个 AbstractSet 的匿名实现类，迭代器通过 <code>entrySet()</code>获取实现类实现的 EntrySet 类的迭代器， 而其他方法直接使用 AbstractMap 的。用于获取 value 的<code>values()</code>方法也是如此，只不过返回的是一个 AbstractCollection 的匿名实现类。</p>
<p>针对 Entry 接口，AbstractMap 提供了 SimpleEntry 与 SimpleImmutableEntry 两个类，相对前者，后者的 value 被 final 修饰，并且调用 <code>setValue()</code> 方法会抛出 UnsupportedOperationException 异常，因而是不可变的。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（四）：LinkedList</title>
    <url>/2020/12/03/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ALinkedList/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>LinkedList 是一个不保证线程安全的、基于双向的双端链表的实现的 List 集合。LinkedList 继承了 AbstractSequentialList 抽象类，在实现 List 接口的同时还实现了 Deque 接口，也正因如此，它也具有队列的特性与方法。</p>
<blockquote>
<p>这是关于 java 集合类源码的第四篇文章。往期文章：</p>
<ol type="1">
<li><a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a><br>
</li>
<li><a href="https://blog.xiajibagao.top/2020/11/27/java/集合类源码分析/java集合源码分析（二）：List与AbstractList/">java集合源码分析（二）：List与AbstractList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/02/java/集合类源码分析/java集合源码分析（三）：ArrayList/">java集合源码分析（三）：ArrayList</a></li>
</ol>
</blockquote>
<h2 id="一-linkedlist-的类关系">一、LinkedList 的类关系</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201203153522364.png" alt="LinkedList 的类关系"><figcaption aria-hidden="true">LinkedList 的类关系</figcaption>
</figure>
<p>LinkedList 实现了 Cloneable ，Serializable 接口，表明它可以拷贝，可以被序列化。</p>
<p>但是和 ArrayList 或者 Vector 相比，因为它是链表，所以无法像数组那样通过下标快速随机访问，故而没有实现 RandomAccess 接口。</p>
<p>他实现了 List 接口，但是也实现了 Queue 的子接口 Deque，因此除了列表，他也具备双端队列的特性。</p>
<p>他的父类不再是 AbstractList，而是另一个继承了 AbstractList 的抽象类 AbstractSequentialList，这个类重写了 AbstractList 的一些方法，使之更适合 LinkedList 这样的链表。</p>
<h2 id="二-abstractsequentialist">二、AbstractSequentiaList</h2>
<p>要了解 LinkedList，绕不过去他的父类 AbstractSequentiaList 抽象类。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201203193013775.png" alt="AbstractSequentiaList 的方法"><figcaption aria-hidden="true">AbstractSequentiaList 的方法</figcaption>
</figure>
<p>从模板方法模式的角度理解，AbstractSequentiaList 是 AbstractList 之后的又一层模板，他进一步实现了 AbstractList 中的某些关键方法，同时也会调整原先的一些算法逻辑。</p>
<p>而事实也是如此，对于链表来说，迭代必然和数组是不同的。而 AbstractList 原本提供两个方法 <code>iterator()</code> 与 <code>listIterator()</code>，他们分别用来获取两个不同的迭代器 Itr 与 ListItr ，在 AbstractSequentiaList 里将 <code>iterator()</code> 与 <code>listIterator()</code>方法统一起来，并且将 <code>listIterator()</code> 变成了一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样一来，继承 AbstractSequentiaList 的类就必须重新实现 <code>listIterator()</code>方法，保证获取迭代器的行为是由子类自己决定的。</p>
<p>然后基于<code>listIterator()</code>方法，他进一步的实现了 AbstractList 中一些未实现的关键方法，比如 <code>get()</code>，<code>set()</code>，<code>add()</code>，<code>remove()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 直接获取从当前下标开始的迭代器，并且返回next</span></span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E oldVal = e.next();</span><br><span class="line">        e.set(element);</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listIterator(index).add(element);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addAll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">            ListIterator&lt;E&gt; e1 = listIterator(index);</span><br><span class="line">            Iterator&lt;? extends E&gt; e2 = c.iterator();</span><br><span class="line">            <span class="keyword">while</span> (e2.hasNext()) &#123;</span><br><span class="line">                e1.add(e2.next());</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> modified;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E outCast = e.next();</span><br><span class="line">        e.remove();</span><br><span class="line">        <span class="keyword">return</span> outCast;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以很直观的看出，这些增删改查操作都必须依赖迭代器，而这正对应链表增删改查的行为。可以说，当实现完 <code>listIterator()</code> 方法以后，LinkedList 就有了基本的雏形。</p>
<h2 id="三-成员变量与内部类">三、成员变量与内部类</h2>
<p>当一个类继承了 AbstractSequentiaList 抽象类之后，它就已经具有链表的操作模式了，但是要真正的使用，还需要提供关于链表的数据结构。</p>
<h3 id="1基本变量">1.基本变量</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">876323262645176354L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合中元素的格式</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2双向双端链表">2.双向/双端链表</h3>
<figure>
<img src="http://img.xiajibagao.top/image-20201204154129934.png" alt="LinkedList 的结构"><figcaption aria-hidden="true">LinkedList 的结构</figcaption>
</figure>
<p>LinkedList 底层实现是一个双向的双端链表，因此他具有一个节点内部类 Node ，类内持有前驱节点与后继节点的指针，LinkedList 类内持有整个链表的头尾指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 头指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">	</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-构造方法">四、构造方法</h2>
<p>LinkedList 提供了只提供了两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-类内的公共方法">五、类内的公共方法</h2>
<p>LinkedList 把一些增删节点的通用操作提取成了私有或者默认的公共方法：</p>
<h3 id="1添加节点">1.添加节点</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加头结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 如果当前链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果当前链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到某个节点之前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 如果是头结点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2删除节点">2.删除节点</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除某个节点</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是头结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>;</span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">// 如果是头结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>;</span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">// 如果是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3参数校验">3.参数校验</h3>
<p>LinkedList 内部提供两个参数校验的私有方法：</p>
<p><code>checkElementIndex()</code>：判断是否为现有元素的索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>checkPositionIndex</code>：判断是</p>
<h2 id="六-迭代器-listitr">六、迭代器 ListItr</h2>
<h3 id="1迭代器的构造方法">1.迭代器的构造方法</h3>
<p>LinkedList 重新设计了一个 ListItr 迭代器，并且实现了 <code>listIterator()</code>方法，这是一切可用方法实现的前提。</p>
<p>当一个 ListItr 根据传入的索引被创建的时候，实际上是获取到了索引对应的节点，我们的遍历都是基于这个节点展开，这样可以有效避免每一次迭代都需要重新遍历链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 最后一个操作的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 下一个节点的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line">    <span class="comment">// 记录 modCount</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// 如果不是在队尾，就找到下标对应的节点</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>node()</code>是一个通过 for 循环获取下标对应节点的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下标对应节点是否在链表前半部分</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 是则从头结点开始向后遍历</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在后半部分则从尾节点开始向前遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这是一个很巧妙的想法，<strong>借助双端链表的特点，根据下标确定要从头还是尾开始遍历，这样可以保证最多只遍历链表一半的节点，提高查找效率</strong>。</p>
<h3 id="2迭代器的成员方法">2.迭代器的成员方法</h3>
<p>迭代器内部提供了一系列用于确认节点位置与链表状态的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (!hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    lastReturned = next;</span><br><span class="line">    next = next.next;</span><br><span class="line">    nextIndex++;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取上一个节点（当前节点）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">    nextIndex--;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除当前节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    unlink(lastReturned);</span><br><span class="line">    <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">        next = lastNext;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextIndex--;</span><br><span class="line">    lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    expectedModCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line">    lastReturned.item = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并发修改检查</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    lastReturned = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        linkLast(e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(e, next);</span><br><span class="line">    nextIndex++;</span><br><span class="line">    expectedModCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历并且对节点中的值进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="comment">// 每次循环都进行并发修改检查，所以遍历中不允许进行结构性操作</span></span><br><span class="line">    <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</span><br><span class="line">        action.accept(next.item);</span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    checkForComodification();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3包装类-descendingiterator">3.包装类 DescendingIterator</h3>
<p>现在，通过 ListItr 可以正向也可反向迭代，但是为了方便，LinkedList 提供了一个 ListItrl 的反向迭代器适配器 DescendingIterator，他在 ListItr 的同名正向方法里，引用了反向迭代的方法，以实现调用他的 <code>next()</code>，实际上却调用 ListItr 的 <code>previous()</code>的效果。</p>
<p>他和 AbstractList 的 SubList 一样体现了适配器模式的思想，不过它只提供简单的几个功能，远远不如 SubList 相对 AbstractList 那样强大：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4迭代中操作的问题">4.迭代中操作的问题</h3>
<p>和 ArrayList 一样，LinkedList 不使用迭代器删除会出现各种问题。</p>
<p><strong>forEach</strong></p>
<p>由于 LinkedList 没有重写 <code>forEach()</code>方法，使用 <code>forEach()</code>仍然还是沿用 Iterable 接口提供的增强 for 循环实现，实际上编译以后还是用的迭代器，也就是说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach</span></span><br><span class="line">list.forEach(list::remove);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强for</span></span><br><span class="line"><span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">    list.remove(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">Iterator&lt;T&gt; iterator = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    list.remove(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这三种写法是没区别的，最后都会变成第三种，由于迭代器创建的时候就会获取 <code>modCount</code>赋给成员变量 <code>expectedModCount</code>，因此，<strong>在迭代器里调用非迭代器自带的结构性操作方法，都会在第二次的并发修改检测的时候抛出异常。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">Iterator&lt;String&gt; iterator = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String s = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (i++ == <span class="number">1</span>) &#123;</span><br><span class="line">        list.add(s); <span class="comment">// ConcurrentModificationException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for循环</strong></p>
<p>for 循环的删除与 Arraylist 一样，根据下标删除也会因为索引对应的元素偏移而出现“漏删”的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list); <span class="comment">// [b, d]</span></span><br></pre></td></tr></table></figure>
<p>解决的方式也跟 ArrayList 一样，选择一个不会引起索引偏移的删除方式，比如倒序删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">    list.remove(i); <span class="comment">// 等同于 list.remove(list.get(i));</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h2 id="七-来自-list-接口的方法">七、来自 List 接口的方法</h2>
<p>由于 LinkedList 很大部分的实现的抽象方法都来自于 Deque 接口，因而将来自 Deque 与 List 接口的方法分开讨论。</p>
<h3 id="1get-set-add">1.get / set / add</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查下标</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 获取下标对应的节点</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="comment">// 更新节点的值</span></span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加节点至队尾</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2addall">2.addAll</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从指定位置添加集合中的全部元素到链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 index &gt;= 0 &amp;&amp; index &lt;= size;</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 要添加的是否为空集合</span></span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">// 如果是添加在队尾</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        <span class="comment">// 遍历获取元素</span></span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 是否为头结点</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果添加的节点在队尾，那么添加的节点就是新的尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将集合中的全部元素添加到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3remove">3.remove</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据节点的索引删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 移除下标对应的节点</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据节点的值删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4toarray">4.toArray</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// 创建一个新数组</span></span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将节点对应的值填到数组中</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="comment">// 如果数组的长度小于集合元素数量</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">        a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="comment">// 将节点对应的值填入数组</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入数组的长度大于集合元素数量</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5contains-indexof">5.contains / indexOf</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查找节点是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6lastindexof">6.lastIndexOf</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="comment">// 返回把遇到的第一个符合条件的节点的下标</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7clear">7.clear</h3>
<p>LinkedList 的 <code>clear()</code>就是把所有节点的引用关系清除，用注释的话来说：</p>
<blockquote>
<p>Clearing all of the links between nodes is "unnecessary", but:helps a generational GC if the discarded nodes inhabit more than one generation ；is sure to free memory even if there is a reachable Iterator</p>
<p>清除节点之间的所有链接是“不必要的”，但是：</p>
<p>1.如果被丢弃的节点驻留在多个代中，那么这样有助于分代 GC；</p>
<p>2.如果存在可访问的迭代器，也不妨碍释放内存；</p>
</blockquote>
<p>对这段话，我是这么理解的：</p>
<p>有些节点可能被多次访问，有些则很少被访问，这样这些节点对象可能就会分布在不同的年代，断开引用可以保证不常使用的节点尽快回收。同时，每一个迭代器内部都会持有一个节点的引用，因此断开节点间的引用可以避免只要迭代器不销毁，引用链上的节点都无法回收的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="comment">// 清空节点的值，并断开每一个节点引用</span></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八-来自-deque接口的方法">八、来自 Deque接口的方法</h2>
<p>Deque 接口的实现类都是双端队列，因此他操作方法总是同时存在从队头或者队尾两个版本：</p>
<p>我们可以简单粗暴的理解：但凡方法名带 Last 或者 Firs 的方法，基本都是由 Deque 提供的。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201204133037473.png" alt="Deque 的方法"><figcaption aria-hidden="true">Deque 的方法</figcaption>
</figure>
<p>由于只要规定好从只从队头操作，那么这个结构同样也可以实现栈的效果，因此 Deque 的实现类也常用于代替 Stack 类，即List接口下老旧的 Vector 实现类的子类 Stack 类。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201204133141521.png" alt="stack 对应的方法"><figcaption aria-hidden="true">stack 对应的方法</figcaption>
</figure>
<p>换句话说，LinkedList 实现了 Deque 接口，所以他既有队列该有的方法，也有栈该有的方法。</p>
<h3 id="1add-offer-push">1.add / offer / push</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插到队首</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插到队尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2remove-poll-pop">2.remove / poll / pop</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除头结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3get-peek-element">3.get / peek / element</h3>
<p>peek 的意思是“瞟一眼”，在栈中 <code>pop()</code>会直接让栈顶元素出栈，所以当只想获取元素而不删除的时候，就需要 <code>peek()</code>，在 LinkedList 中 <code>pop()</code>其实就等于删除头结点，而 <code>peek()</code>自然就等于获取头结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九-其他">九、其他</h2>
<p>LinkedList 实现了 Cloneable 结构，所以他自然有 <code>clone()</code>方法可用。在 LinkedList，<code>clone()</code>分为了两步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝 LinkedList 对象本身</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将自己的节点放入拷贝得到的 LinkedList 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让克隆得到的集合回到初始状态</span></span><br><span class="line">    clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新添加节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        clone.add(x.item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十-总结">十、总结</h2>
<p><strong>数据结构</strong></p>
<p>LinkedList 底层实现基于双向的双端链表，他无法像 ArrayList 那样直接随机通过索引去访问元素，每一次获取迭代器或者节点，都需要通过 <code>node()</code>方法遍历整个链表。</p>
<p>LinkedList 实现了 Deque 接口，因此可以把它当成队列或者栈使用。实际上，他也提供了对应的同名方法。</p>
<p><strong>迭代优化</strong></p>
<p>尽管 LinkedList 针对这个问题做了优化，在遍历之前，通过位运算获取当前链表长度的一半，借此判断要获取的节点在链表前半截还是后半节，以选择从头还是尾开始遍历，保证了最坏情况下也只需要遍历一半的节点就能找到目标节点。</p>
<p>因此，如非必要，最好不要通过下标去删除 LinkedList 中的元素，或者尽量在一次循环中完成所有操作。</p>
<p><strong>迭代操作</strong></p>
<p>LinkedList 的迭代器创建的时候就会获取 <code>modCount</code>，所以在迭代器里调用非迭代器自带的结构性操作方法，都会导致在下一次调用迭代器的结构性操作方法的时候抛出 <code>ConcurrentModificationException</code>异常。</p>
<p>LinkedList 在 for 循环中删除元素，同 ArrayList 一样，会因为索引“偏移”导致漏删，解决方式也是倒序删除或者其他不会导致索引“偏移”的方法——当然，考虑到性能问题，最好不要在 for 循环去操作 LinkedList。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>资源推荐：数据库内核月报</title>
    <url>/2020/11/17/mysql/%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5/</url>
    <content><![CDATA[<p>今天在舍友的安利下发现了一个新的宝藏，阿里的<a href="http://mysql.taobao.org/monthly/">数据库内核日报</a>，内容之全面让小白我瞠目结舌，简单的爬了一下 mysql 相关的文章。</p>
<p>完整版可以直接<a href="http://xiajibagao.top/down/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5(%E6%88%AA%E6%AD%A22020%E5%B9%B411%E6%9C%8817%E6%97%A5).md">点击链接下载</a>。以下只是 Mysql 内容的整合：</p>
<ol type="1">
<li>MetadataLock子系统的优化 - <a href="http://mysql.taobao.org/monthly/2014/11/05/">2014/11/05/</a></li>
<li>Recovery改进 - <a href="http://mysql.taobao.org/monthly/2014/11/03/">2014/11/03/</a></li>
<li>高可用支持 - <a href="http://mysql.taobao.org/monthly/2014/11/04/">2014/11/04/</a></li>
<li>在线Truncateundolog表空间 - <a href="http://mysql.taobao.org/monthly/2014/11/06/">2014/11/06/</a></li>
<li>OptimizerCostModel - <a href="http://mysql.taobao.org/monthly/2014/10/01/">2014/10/01/</a></li>
<li>Renametable死锁分析 - <a href="http://mysql.taobao.org/monthly/2016/03/06/">2016/03/06/</a></li>
<li>CongratulationsonMySQL8.0GA - <a href="http://mysql.taobao.org/monthly/2018/05/01/">2018/05/01/</a></li>
<li>Redolog - <a href="http://mysql.taobao.org/monthly/2019/03/03/">2019/03/03/</a></li>
<li>tablespace源码分析 - <a href="http://mysql.taobao.org/monthly/2019/01/08/">2019/01/08/</a></li>
<li>TTL特性介绍 - <a href="http://mysql.taobao.org/monthly/2018/04/04/">2018/04/04/</a></li>
<li>MyRocks参数介绍 - <a href="http://mysql.taobao.org/monthly/2018/01/09/">2018/01/09/</a></li>
<li>OptimizerHints - <a href="http://mysql.taobao.org/monthly/2020/09/07/">2020/09/07/</a></li>
<li>ParallelIndexScans,OneisBetterThanTwo - <a href="http://mysql.taobao.org/monthly/2019/10/03/">2019/10/03/</a></li>
<li>数据的读取(二) - <a href="http://mysql.taobao.org/monthly/2018/12/08/">2018/12/08/</a></li>
<li>数据的读取(一) - <a href="http://mysql.taobao.org/monthly/2018/11/05/">2018/11/05/</a></li>
<li>LevelCompact分析 - <a href="http://mysql.taobao.org/monthly/2018/10/08/">2018/10/08/</a></li>
<li>TransactionDB介绍 - <a href="http://mysql.taobao.org/monthly/2018/10/09/">2018/10/09/</a></li>
<li>Memtableflush分析 - <a href="http://mysql.taobao.org/monthly/2018/09/04/">2018/09/04/</a></li>
<li>WritePreparedPolicy - <a href="http://mysql.taobao.org/monthly/2018/08/02/">2018/08/02/</a></li>
<li>MemTable的写入逻辑 - <a href="http://mysql.taobao.org/monthly/2018/08/08/">2018/08/08/</a></li>
<li>写入逻辑的实现 - <a href="http://mysql.taobao.org/monthly/2018/07/04/">2018/07/04/</a></li>
<li>ColumnFamily介绍 - <a href="http://mysql.taobao.org/monthly/2018/06/09/">2018/06/09/</a></li>
<li>MANIFEST文件介绍 - <a href="http://mysql.taobao.org/monthly/2018/05/08/">2018/05/08/</a></li>
<li>WAL(WriteAheadLog)介绍 - <a href="http://mysql.taobao.org/monthly/2018/04/09/">2018/04/09/</a></li>
<li>rbtreeblockallocator - <a href="http://mysql.taobao.org/monthly/2016/11/03/">2016/11/03/</a></li>
<li>checkpoint过程 - <a href="http://mysql.taobao.org/monthly/2016/06/06/">2016/06/06/</a></li>
<li>日志子系统和崩溃恢复过程 - <a href="http://mysql.taobao.org/monthly/2016/05/07/">2016/05/07/</a></li>
<li>TokuDB索引结构--FractalTree - <a href="http://mysql.taobao.org/monthly/2016/04/09/">2016/04/09/</a></li>
<li>Savepoint漫谈 - <a href="http://mysql.taobao.org/monthly/2016/04/10/">2016/04/10/</a></li>
<li>事务子系统和MVCC实现 - <a href="http://mysql.taobao.org/monthly/2016/03/01/">2016/03/01/</a></li>
<li>TokuDB之黑科技工具 - <a href="http://mysql.taobao.org/monthly/2016/02/06/">2016/02/06/</a></li>
<li>Cachetable的工作线程和线程池 - <a href="http://mysql.taobao.org/monthly/2016/01/06/">2016/01/06/</a></li>
<li>让HotBackup更完美 - <a href="http://mysql.taobao.org/monthly/2015/12/06/">2015/12/06/</a></li>
<li>TokuDB中的行锁 - <a href="http://mysql.taobao.org/monthly/2015/11/09/">2015/11/09/</a></li>
<li>文件目录谈 - <a href="http://mysql.taobao.org/monthly/2015/09/10/">2015/09/10/</a></li>
<li>疯狂的filenum++ - <a href="http://mysql.taobao.org/monthly/2015/08/08/">2015/08/08/</a></li>
<li>TokuDBCheckpoint机制 - <a href="http://mysql.taobao.org/monthly/2015/07/02/">2015/07/02/</a></li>
<li>TokuDB数据文件大小计算 - <a href="http://mysql.taobao.org/monthly/2015/06/10/">2015/06/10/</a></li>
<li>collation限制 - <a href="http://mysql.taobao.org/monthly/2018/09/09/">2018/09/09/</a></li>
<li>clusteredindex特性 - <a href="http://mysql.taobao.org/monthly/2018/07/07/">2018/07/07/</a></li>
<li>事务锁分析 - <a href="http://mysql.taobao.org/monthly/2018/03/07/">2018/03/07/</a></li>
<li>相关tools介绍 - <a href="http://mysql.taobao.org/monthly/2017/12/10/">2017/12/10/</a></li>
<li>myrocks之Bloomfilter - <a href="http://mysql.taobao.org/monthly/2017/09/04/">2017/09/04/</a></li>
<li>myrocks写入分析 - <a href="http://mysql.taobao.org/monthly/2017/07/05/">2017/07/05/</a></li>
<li>MyRocks之memtable切换与刷盘 - <a href="http://mysql.taobao.org/monthly/2017/06/08/">2017/06/08/</a></li>
<li>fastdataload - <a href="http://mysql.taobao.org/monthly/2017/05/09/">2017/05/09/</a></li>
<li>myrocks监控信息 - <a href="http://mysql.taobao.org/monthly/2017/03/10/">2017/03/10/</a></li>
<li>myrocks之备份恢复 - <a href="http://mysql.taobao.org/monthly/2017/02/02/">2017/02/02/</a></li>
<li>myrocksindexconditionpushdown - <a href="http://mysql.taobao.org/monthly/2017/01/02/">2017/01/02/</a></li>
<li>myrocks统计信息 - <a href="http://mysql.taobao.org/monthly/2016/12/02/">2016/12/02/</a></li>
<li>myrocks之事务处理 - <a href="http://mysql.taobao.org/monthly/2016/11/02/">2016/11/02/</a></li>
<li>datadictionary分析 - <a href="http://mysql.taobao.org/monthly/2016/10/05/">2016/10/05/</a></li>
<li>GTID启动优化 - <a href="http://mysql.taobao.org/monthly/2014/12/09/">2014/12/09/</a></li>
<li>InnoDB物理行中null值的存储的推断与验证 - <a href="http://mysql.taobao.org/monthly/2016/08/07/">2016/08/07/</a></li>
<li>MySQL5.7的JSON实现 - <a href="http://mysql.taobao.org/monthly/2016/01/03/">2016/01/03/</a></li>
<li>MySQL数据库SYSCPU高的可能性分析 - <a href="http://mysql.taobao.org/monthly/2015/05/02/">2015/05/02/</a></li>
<li>RDS三节点企业版的高可用体系 - <a href="http://mysql.taobao.org/monthly/2020/03/03/">2020/03/03/</a></li>
<li>MYSQL开源软件源码阅读小技巧 - <a href="http://mysql.taobao.org/monthly/2019/12/03/">2019/12/03/</a></li>
<li>复制性能改进过程 - <a href="http://mysql.taobao.org/monthly/2015/01/05/">2015/01/05/</a></li>
<li>MySQLindex_condition_pushdown - <a href="http://mysql.taobao.org/monthly/2015/03/05/">2015/03/05/</a></li>
<li>InnoDBBufferPool并发控制 - <a href="http://mysql.taobao.org/monthly/2020/05/06/">2020/05/06/</a></li>
<li>InnoDBmutex实现分析 - <a href="http://mysql.taobao.org/monthly/2020/03/05/">2020/03/05/</a></li>
<li>InnoDB的统计信息 - <a href="http://mysql.taobao.org/monthly/2020/03/08/">2020/03/08/</a></li>
<li>RedoLogging动态开关 - <a href="http://mysql.taobao.org/monthly/2020/08/03/">2020/08/03/</a></li>
<li>8.0新的火山模型执行器 - <a href="http://mysql.taobao.org/monthly/2020/07/01/">2020/07/01/</a></li>
<li>semi-join四个执行strategy - <a href="http://mysql.taobao.org/monthly/2020/07/04/">2020/07/04/</a></li>
<li>InnoDBbtreelatch优化历程 - <a href="http://mysql.taobao.org/monthly/2020/06/02/">2020/06/02/</a></li>
<li>Attachabletransaction - <a href="http://mysql.taobao.org/monthly/2020/06/03/">2020/06/03/</a></li>
<li>Linkbuf - <a href="http://mysql.taobao.org/monthly/2020/06/04/">2020/06/04/</a></li>
<li>一致性协议underthehood - <a href="http://mysql.taobao.org/monthly/2020/09/02/">2020/09/02/</a></li>
<li>binlog拉取速度的控制 - <a href="http://mysql.taobao.org/monthly/2015/07/09/">2015/07/09/</a></li>
<li>5.6并行复制实现分析 - <a href="http://mysql.taobao.org/monthly/2015/08/09/">2015/08/09/</a></li>
<li>MySQL表定义缓存 - <a href="http://mysql.taobao.org/monthly/2015/08/10/">2015/08/10/</a></li>
<li>InnoDBWarmup特性 - <a href="http://mysql.taobao.org/monthly/2014/10/06/">2014/10/06/</a></li>
<li>再议MySQL的故障恢复 - <a href="http://mysql.taobao.org/monthly/2018/12/04/">2018/12/04/</a></li>
<li>RDSMySQL参数调优最佳实践 - <a href="http://mysql.taobao.org/monthly/2015/12/04/">2015/12/04/</a></li>
<li>innodb_additional_mem_pool_size - <a href="http://mysql.taobao.org/monthly/2016/04/01/">2016/04/01/</a></li>
<li>thread_concurrency - <a href="http://mysql.taobao.org/monthly/2014/09/05/">2014/09/05/</a></li>
<li>timed_mutexes - <a href="http://mysql.taobao.org/monthly/2014/08/01/">2014/08/01/</a></li>
<li>innodb_flush_log_at_trx_commit - <a href="http://mysql.taobao.org/monthly/2014/08/02/">2014/08/02/</a></li>
<li>relayfetch备库优化 - <a href="http://mysql.taobao.org/monthly/2015/09/08/">2015/09/08/</a></li>
<li>MySQL的字段数据存储格式 - <a href="http://mysql.taobao.org/monthly/2020/02/05/">2020/02/05/</a></li>
<li>HybridDBforMySQL数据压缩 - <a href="http://mysql.taobao.org/monthly/2017/07/08/">2017/07/08/</a></li>
<li>对字符集和字符序支持的实现 - <a href="http://mysql.taobao.org/monthly/2017/03/06/">2017/03/06/</a></li>
<li>Sphinx源码剖析(三) - <a href="http://mysql.taobao.org/monthly/2017/10/06/">2017/10/06/</a></li>
<li>Sphinx源码剖析（二） - <a href="http://mysql.taobao.org/monthly/2017/04/03/">2017/04/03/</a></li>
<li>Sphinx源码剖析（一） - <a href="http://mysql.taobao.org/monthly/2016/11/05/">2016/11/05/</a></li>
<li>InnoDBhistorylist无法降到0的原因 - <a href="http://mysql.taobao.org/monthly/2019/04/04/">2019/04/04/</a></li>
<li>InnoDB行锁分析 - <a href="http://mysql.taobao.org/monthly/2018/05/04/">2018/05/04/</a></li>
<li>create_timeinstatus - <a href="http://mysql.taobao.org/monthly/2014/09/04/">2014/09/04/</a></li>
<li>InnoDB隐式锁功能解析 - <a href="http://mysql.taobao.org/monthly/2020/09/06/">2020/09/06/</a></li>
<li>truncatetable在大bufferpool下的优化 - <a href="http://mysql.taobao.org/monthly/2020/08/01/">2020/08/01/</a></li>
<li>INNODBUNDOLOG分配 - <a href="http://mysql.taobao.org/monthly/2020/08/02/">2020/08/02/</a></li>
<li>InnoDBBufferPage生命周期 - <a href="http://mysql.taobao.org/monthly/2020/08/04/">2020/08/04/</a></li>
<li>InnoDBUNDOLOG写入 - <a href="http://mysql.taobao.org/monthly/2020/08/05/">2020/08/05/</a></li>
<li>InnoDB数据文件简述 - <a href="http://mysql.taobao.org/monthly/2020/08/06/">2020/08/06/</a></li>
<li>InnoDBredologthreadcpuusage - <a href="http://mysql.taobao.org/monthly/2020/07/05/">2020/07/05/</a></li>
<li>基于GTID复制实现的工作原理 - <a href="http://mysql.taobao.org/monthly/2020/05/09/">2020/05/09/</a></li>
<li>8.0WindowFunctions剖析 - <a href="http://mysql.taobao.org/monthly/2020/04/04/">2020/04/04/</a></li>
<li>Performance_schema内存分配 - <a href="http://mysql.taobao.org/monthly/2020/04/05/">2020/04/05/</a></li>
<li>手动分析InnoDBB+Tree结构 - <a href="http://mysql.taobao.org/monthly/2020/04/06/">2020/04/06/</a></li>
<li>8.0LockManager - <a href="http://mysql.taobao.org/monthly/2020/04/09/">2020/04/09/</a></li>
<li>8.0InstantAddColumn功能解析 - <a href="http://mysql.taobao.org/monthly/2020/03/01/">2020/03/01/</a></li>
<li>Latch持有分析 - <a href="http://mysql.taobao.org/monthly/2020/03/07/">2020/03/07/</a></li>
<li>排序实现 - <a href="http://mysql.taobao.org/monthly/2020/03/09/">2020/03/09/</a></li>
<li>庖丁解InnoDB之REDOLOG - <a href="http://mysql.taobao.org/monthly/2020/02/01/">2020/02/01/</a></li>
<li>InnoDBBufferPool浅析 - <a href="http://mysql.taobao.org/monthly/2020/02/02/">2020/02/02/</a></li>
<li>8.0heaptable介绍 - <a href="http://mysql.taobao.org/monthly/2020/02/04/">2020/02/04/</a></li>
<li>MYSQLBinlogCache详解 - <a href="http://mysql.taobao.org/monthly/2020/02/06/">2020/02/06/</a></li>
<li>二级索引分析 - <a href="http://mysql.taobao.org/monthly/2020/01/01/">2020/01/01/</a></li>
<li>X-EngineOnlineDDL - <a href="http://mysql.taobao.org/monthly/2020/01/02/">2020/01/02/</a></li>
<li>InnoDBredolog之writeahead - <a href="http://mysql.taobao.org/monthly/2020/01/05/">2020/01/05/</a></li>
<li>InnodbWAL物理格式 - <a href="http://mysql.taobao.org/monthly/2020/01/06/">2020/01/06/</a></li>
<li>动态元信息持久化 - <a href="http://mysql.taobao.org/monthly/2019/12/01/">2019/12/01/</a></li>
<li>Binlogencryption浅析 - <a href="http://mysql.taobao.org/monthly/2019/12/02/">2019/12/02/</a></li>
<li>多线程调试工具DEBUG_SYNC的源码实现和使用 - <a href="http://mysql.taobao.org/monthly/2019/12/04/">2019/12/04/</a></li>
<li>InnoDBParallelreadofindex - <a href="http://mysql.taobao.org/monthly/2019/12/05/">2019/12/05/</a></li>
<li>RDS三节点企业版一致性协议 - <a href="http://mysql.taobao.org/monthly/2019/11/06/">2019/11/06/</a></li>
<li>RDS三节点企业版Learner只读实例 - <a href="http://mysql.taobao.org/monthly/2019/11/07/">2019/11/07/</a></li>
<li>Innodb表空间 - <a href="http://mysql.taobao.org/monthly/2019/10/01/">2019/10/01/</a></li>
<li>POLARDB并行查询加速全程详解 - <a href="http://mysql.taobao.org/monthly/2019/10/02/">2019/10/02/</a></li>
<li>SequenceEngine - <a href="http://mysql.taobao.org/monthly/2019/10/05/">2019/10/05/</a></li>
<li>临时表改进 - <a href="http://mysql.taobao.org/monthly/2019/09/01/">2019/09/01/</a></li>
<li>初探ClonePlugin - <a href="http://mysql.taobao.org/monthly/2019/09/02/">2019/09/02/</a></li>
<li>网络模块优化 - <a href="http://mysql.taobao.org/monthly/2019/09/03/">2019/09/03/</a></li>
<li>Multi-ValuedIndexes简述 - <a href="http://mysql.taobao.org/monthly/2019/09/04/">2019/09/04/</a></li>
<li>8.0Innodbredologrecord源码分析 - <a href="http://mysql.taobao.org/monthly/2019/08/03/">2019/08/03/</a></li>
<li>clone_plugin - <a href="http://mysql.taobao.org/monthly/2019/08/05/">2019/08/05/</a></li>
<li>ROLLUP功能用法和实现 - <a href="http://mysql.taobao.org/monthly/2019/08/08/">2019/08/08/</a></li>
<li>BufferPool漫谈 - <a href="http://mysql.taobao.org/monthly/2019/07/03/">2019/07/03/</a></li>
<li>CTE(CommonTableExpressions) - <a href="http://mysql.taobao.org/monthly/2019/07/06/">2019/07/06/</a></li>
<li>安全及权限改进相关 - <a href="http://mysql.taobao.org/monthly/2019/06/01/">2019/06/01/</a></li>
<li>说说InnoDBLogSystem的隐藏参数 - <a href="http://mysql.taobao.org/monthly/2019/06/07/">2019/06/07/</a></li>
<li>CHECKCONSTRAINT - <a href="http://mysql.taobao.org/monthly/2019/06/08/">2019/06/08/</a></li>
<li>通过SQL管理UNDOTABLESPACE - <a href="http://mysql.taobao.org/monthly/2019/05/04/">2019/05/04/</a></li>
<li>SkipScanRange - <a href="http://mysql.taobao.org/monthly/2019/05/06/">2019/05/06/</a></li>
<li>临时表那些事儿 - <a href="http://mysql.taobao.org/monthly/2019/04/01/">2019/04/01/</a></li>
<li>新的事务锁调度VATS简介 - <a href="http://mysql.taobao.org/monthly/2019/04/06/">2019/04/06/</a></li>
<li>增加系统文件追踪spaceID和物理文件的映射 - <a href="http://mysql.taobao.org/monthly/2019/04/07/">2019/04/07/</a></li>
<li>8.0DescendingIndex - <a href="http://mysql.taobao.org/monthly/2019/03/07/">2019/03/07/</a></li>
<li>MySQL状态信息Status实现 - <a href="http://mysql.taobao.org/monthly/2019/03/09/">2019/03/09/</a></li>
<li>InspectingtheContentofaMySQLHistogram - <a href="http://mysql.taobao.org/monthly/2019/02/02/">2019/02/02/</a></li>
<li>Thedesignofmysql8.0redolog - <a href="http://mysql.taobao.org/monthly/2019/02/05/">2019/02/05/</a></li>
<li>InnoDBMVCC相关实现 - <a href="http://mysql.taobao.org/monthly/2018/11/04/">2018/11/04/</a></li>
<li>CostModel,直方图及优化器开销优化 - <a href="http://mysql.taobao.org/monthly/2018/10/02/">2018/10/02/</a></li>
<li>B+树并发控制机制的前世今生 - <a href="http://mysql.taobao.org/monthly/2018/09/01/">2018/09/01/</a></li>
<li>IO_CACHE源码解析 - <a href="http://mysql.taobao.org/monthly/2018/09/03/">2018/09/03/</a></li>
<li>主库binlog概览 - <a href="http://mysql.taobao.org/monthly/2018/08/01/">2018/08/01/</a></li>
<li>WAL那些事儿 - <a href="http://mysql.taobao.org/monthly/2018/07/01/">2018/07/01/</a></li>
<li>InnoDB表空间加密 - <a href="http://mysql.taobao.org/monthly/2018/04/01/">2018/04/01/</a></li>
<li>InnoDB数据页解析 - <a href="http://mysql.taobao.org/monthly/2018/04/03/">2018/04/03/</a></li>
<li>INFORMATION_SCHEMA系统表的实现 - <a href="http://mysql.taobao.org/monthly/2018/02/08/">2018/02/08/</a></li>
<li>GroupReplication内核解析之二 - <a href="http://mysql.taobao.org/monthly/2018/01/01/">2018/01/01/</a></li>
<li>MySQL内核对读写分离的支持 - <a href="http://mysql.taobao.org/monthly/2018/01/02/">2018/01/02/</a></li>
<li>InnoDB事务系统 - <a href="http://mysql.taobao.org/monthly/2017/12/01/">2017/12/01/</a></li>
<li>Innodb锁子系统浅析 - <a href="http://mysql.taobao.org/monthly/2017/12/02/">2017/12/02/</a></li>
<li>DROPTABLE之binlog解析 - <a href="http://mysql.taobao.org/monthly/2017/11/02/">2017/11/02/</a></li>
<li>TokuDBhot-index机制 - <a href="http://mysql.taobao.org/monthly/2017/11/08/">2017/11/08/</a></li>
<li>InnoDBminitransation - <a href="http://mysql.taobao.org/monthly/2017/10/03/">2017/10/03/</a></li>
<li>GroupReplication内核解析 - <a href="http://mysql.taobao.org/monthly/2017/08/01/">2017/08/01/</a></li>
<li>InnoDB崩溃恢复 - <a href="http://mysql.taobao.org/monthly/2017/07/01/">2017/07/01/</a></li>
<li>从节点可更新机制 - <a href="http://mysql.taobao.org/monthly/2017/06/03/">2017/06/03/</a></li>
<li>InnoDBBufferPool - <a href="http://mysql.taobao.org/monthly/2017/05/01/">2017/05/01/</a></li>
<li>InnoDBIO子系统 - <a href="http://mysql.taobao.org/monthly/2017/03/01/">2017/03/01/</a></li>
<li>InnoDB同步机制 - <a href="http://mysql.taobao.org/monthly/2017/01/01/">2017/01/01/</a></li>
<li>Infobright列存数据库 - <a href="http://mysql.taobao.org/monthly/2016/12/01/">2016/12/01/</a></li>
<li>ColumnCompression浅析 - <a href="http://mysql.taobao.org/monthly/2016/11/04/">2016/11/04/</a></li>
<li>InnoDBCOUNT(*)优化(?) - <a href="http://mysql.taobao.org/monthly/2016/06/10/">2016/06/10/</a></li>
<li>基于InnoDB的物理复制实现 - <a href="http://mysql.taobao.org/monthly/2016/05/01/">2016/05/01/</a></li>
<li>InnoDB文件系统之文件物理结构 - <a href="http://mysql.taobao.org/monthly/2016/02/01/">2016/02/01/</a></li>
<li>InnoDB文件系统之IO系统和内存管理 - <a href="http://mysql.taobao.org/monthly/2016/02/02/">2016/02/02/</a></li>
<li>InnoDB事务锁系统简介 - <a href="http://mysql.taobao.org/monthly/2016/01/01/">2016/01/01/</a></li>
<li>InnoDB事务子系统介绍 - <a href="http://mysql.taobao.org/monthly/2015/12/01/">2015/12/01/</a></li>
<li>InnoDB全文索引简介 - <a href="http://mysql.taobao.org/monthly/2015/10/01/">2015/10/01/</a></li>
<li>InnoDBAdaptivehashindex介绍 - <a href="http://mysql.taobao.org/monthly/2015/09/01/">2015/09/01/</a></li>
<li>Innodbchangebuffer介绍 - <a href="http://mysql.taobao.org/monthly/2015/07/01/">2015/07/01/</a></li>
<li>InnoDBindexlock前世今生 - <a href="http://mysql.taobao.org/monthly/2015/07/05/">2015/07/05/</a></li>
<li>MySQLlogicalread-ahead - <a href="http://mysql.taobao.org/monthly/2015/07/08/">2015/07/08/</a></li>
<li>InnoDB崩溃恢复过程 - <a href="http://mysql.taobao.org/monthly/2015/06/01/">2015/06/01/</a></li>
<li>InnoDBredolog漫游 - <a href="http://mysql.taobao.org/monthly/2015/05/01/">2015/05/01/</a></li>
<li>InnoDBundolog漫游 - <a href="http://mysql.taobao.org/monthly/2015/04/01/">2015/04/01/</a></li>
<li>PageCache优化管理 - <a href="http://mysql.taobao.org/monthly/2020/09/01/">2020/09/01/</a></li>
<li>CloudDBASQL优化建议之统计信息获取 - <a href="http://mysql.taobao.org/monthly/2017/10/02/">2017/10/02/</a></li>
<li>MySQL常见SQL错误用法 - <a href="http://mysql.taobao.org/monthly/2017/03/03/">2017/03/03/</a></li>
<li>条件下推到物化表 - <a href="http://mysql.taobao.org/monthly/2016/07/08/">2016/07/08/</a></li>
<li>5.7.6InnoDBpageflush优化 - <a href="http://mysql.taobao.org/monthly/2015/03/02/">2015/03/02/</a></li>
<li>InnoDBbufferpoolflush策略漫谈 - <a href="http://mysql.taobao.org/monthly/2015/02/01/">2015/02/01/</a></li>
<li>GroupCommit优化 - <a href="http://mysql.taobao.org/monthly/2015/01/01/">2015/01/01/</a></li>
<li>启用GTID场景的性能问题及优化 - <a href="http://mysql.taobao.org/monthly/2015/01/03/">2015/01/03/</a></li>
<li>5.7Innodb事务系统 - <a href="http://mysql.taobao.org/monthly/2014/12/01/">2014/12/01/</a></li>
<li>threadpool原理分析 - <a href="http://mysql.taobao.org/monthly/2014/12/03/">2014/12/03/</a></li>
<li>并行复制外建约束问题 - <a href="http://mysql.taobao.org/monthly/2014/12/04/">2014/12/04/</a></li>
<li>BulkLoadforCREATEINDEX - <a href="http://mysql.taobao.org/monthly/2014/12/07/">2014/12/07/</a></li>
<li>hash_scan算法的实现解析 - <a href="http://mysql.taobao.org/monthly/2014/11/07/">2014/11/07/</a></li>
<li>LOCK_active_mi/LOCK_msp_map优化思路 - <a href="http://mysql.taobao.org/monthly/2017/02/03/">2017/02/03/</a></li>
<li>弱序内存模型导致的死锁问题 - <a href="http://mysql.taobao.org/monthly/2020/01/03/">2020/01/03/</a></li>
<li>UK包含NULL值备库延迟分析 - <a href="http://mysql.taobao.org/monthly/2018/01/04/">2018/01/04/</a></li>
<li>Errorinmunmap()"Cannotallocatememory" - <a href="http://mysql.taobao.org/monthly/2018/01/05/">2018/01/05/</a></li>
<li>字符集相关变量介绍及binlog中字符集相关缺陷分析 - <a href="http://mysql.taobao.org/monthly/2018/01/07/">2018/01/07/</a></li>
<li>信号处理机制分析 - <a href="http://mysql.taobao.org/monthly/2017/10/10/">2017/10/10/</a></li>
<li>showbinarylogs灵异事件 - <a href="http://mysql.taobao.org/monthly/2017/09/03/">2017/09/03/</a></li>
<li>InnoDBcrash - <a href="http://mysql.taobao.org/monthly/2017/06/05/">2017/06/05/</a></li>
<li>5.7mysql_upgrade元数据锁等待 - <a href="http://mysql.taobao.org/monthly/2017/04/10/">2017/04/10/</a></li>
<li>event_scheduler慢日志记错 - <a href="http://mysql.taobao.org/monthly/2017/01/05/">2017/01/05/</a></li>
<li>5.6中ORDERBY+LIMIT错选执行计划 - <a href="http://mysql.taobao.org/monthly/2016/12/08/">2016/12/08/</a></li>
<li>备库1206错误问题说明 - <a href="http://mysql.taobao.org/monthly/2016/07/10/">2016/07/10/</a></li>
<li>left-join多表导致crash - <a href="http://mysql.taobao.org/monthly/2016/05/10/">2016/05/10/</a></li>
<li>并行复制外键约束问题二 - <a href="http://mysql.taobao.org/monthly/2016/04/04/">2016/04/04/</a></li>
<li>MySQL外键异常分析 - <a href="http://mysql.taobao.org/monthly/2015/11/06/">2015/11/06/</a></li>
<li>ORDER/GROUPBY导致mysqldcrash - <a href="http://mysql.taobao.org/monthly/2015/11/08/">2015/11/08/</a></li>
<li>orderbylimit造成优化器选择索引错误 - <a href="http://mysql.taobao.org/monthly/2015/11/10/">2015/11/10/</a></li>
<li>startslavecrash诊断分析 - <a href="http://mysql.taobao.org/monthly/2015/10/05/">2015/10/05/</a></li>
<li>删除索引导致表无法打开 - <a href="http://mysql.taobao.org/monthly/2015/10/06/">2015/10/06/</a></li>
<li>BUG几例 - <a href="http://mysql.taobao.org/monthly/2015/09/03/">2015/09/03/</a></li>
<li>建表过程中crash造成重建表失败 - <a href="http://mysql.taobao.org/monthly/2015/09/05/">2015/09/05/</a></li>
<li>唯一键约束失效 - <a href="http://mysql.taobao.org/monthly/2015/06/02/">2015/06/02/</a></li>
<li>ALTERIGNORETABLE导致主备不一致 - <a href="http://mysql.taobao.org/monthly/2015/06/03/">2015/06/03/</a></li>
<li>任性的normalshutdown - <a href="http://mysql.taobao.org/monthly/2015/06/07/">2015/06/07/</a></li>
<li>5.6与5.5InnoDB不兼容导致crash - <a href="http://mysql.taobao.org/monthly/2015/05/03/">2015/05/03/</a></li>
<li>MySQLDDLBUG - <a href="http://mysql.taobao.org/monthly/2015/05/06/">2015/05/06/</a></li>
<li>临时表操作导致主备不一致 - <a href="http://mysql.taobao.org/monthly/2015/05/08/">2015/05/08/</a></li>
<li>连接断开导致XA事务丢失 - <a href="http://mysql.taobao.org/monthly/2015/04/05/">2015/04/05/</a></li>
<li>GTID下slave_net_timeout值太小问题 - <a href="http://mysql.taobao.org/monthly/2015/04/06/">2015/04/06/</a></li>
<li>Relaylog中GTIDgroup完整性检测 - <a href="http://mysql.taobao.org/monthly/2015/04/07/">2015/04/07/</a></li>
<li>删被引用索引导致crash - <a href="http://mysql.taobao.org/monthly/2015/04/09/">2015/04/09/</a></li>
<li>pidfile丢失问题分析 - <a href="http://mysql.taobao.org/monthly/2015/03/03/">2015/03/03/</a></li>
<li>DROPDATABASE外键约束的GTIDBUG - <a href="http://mysql.taobao.org/monthly/2015/03/06/">2015/03/06/</a></li>
<li>变量修改导致binlog错误 - <a href="http://mysql.taobao.org/monthly/2015/02/07/">2015/02/07/</a></li>
<li>InnoDB自增列重复值问题 - <a href="http://mysql.taobao.org/monthly/2015/01/04/">2015/01/04/</a></li>
<li>mysqlclientcrash一例 - <a href="http://mysql.taobao.org/monthly/2015/01/07/">2015/01/07/</a></li>
<li>设置gtid_purged破坏AUTO_POSITION复制协议 - <a href="http://mysql.taobao.org/monthly/2015/01/08/">2015/01/08/</a></li>
<li>replicatefilter和GTID一起使用的问题 - <a href="http://mysql.taobao.org/monthly/2015/01/09/">2015/01/09/</a></li>
<li>Openedtablesblockreadonly - <a href="http://mysql.taobao.org/monthly/2014/12/08/">2014/12/08/</a></li>
<li>OPTIMIZE不存在的表 - <a href="http://mysql.taobao.org/monthly/2014/11/01/">2014/11/01/</a></li>
<li>SIGHUP导致binlog写错 - <a href="http://mysql.taobao.org/monthly/2014/11/02/">2014/11/02/</a></li>
<li>binlog重放失败 - <a href="http://mysql.taobao.org/monthly/2014/10/03/">2014/10/03/</a></li>
<li>从库OOM - <a href="http://mysql.taobao.org/monthly/2014/10/04/">2014/10/04/</a></li>
<li>崩溃恢复失败 - <a href="http://mysql.taobao.org/monthly/2014/10/05/">2014/10/05/</a></li>
<li>GTID和DELAYED - <a href="http://mysql.taobao.org/monthly/2014/09/01/">2014/09/01/</a></li>
<li>GTID和binlog_checksum - <a href="http://mysql.taobao.org/monthly/2014/09/03/">2014/09/03/</a></li>
<li>auto_increment - <a href="http://mysql.taobao.org/monthly/2014/09/06/">2014/09/06/</a></li>
<li>Count(Distinct)ERROR - <a href="http://mysql.taobao.org/monthly/2014/08/03/">2014/08/03/</a></li>
<li>mysqldumpBUFFEROVERFLOW - <a href="http://mysql.taobao.org/monthly/2014/08/04/">2014/08/04/</a></li>
<li>longsemaphorewaits - <a href="http://mysql.taobao.org/monthly/2014/08/05/">2014/08/05/</a></li>
<li>bug分析两例 - <a href="http://mysql.taobao.org/monthly/2016/09/06/">2016/09/06/</a></li>
<li>ConnectionControl - <a href="http://mysql.taobao.org/monthly/2020/05/08/">2020/05/08/</a></li>
<li>undrop-for-innodb - <a href="http://mysql.taobao.org/monthly/2017/11/01/">2017/11/01/</a></li>
<li>告别frm文件 - <a href="http://mysql.taobao.org/monthly/2014/10/07/">2014/10/07/</a></li>
<li>DDLfastfail - <a href="http://mysql.taobao.org/monthly/2015/01/02/">2015/01/02/</a></li>
<li>MySQL哈希连接实现介绍 - <a href="http://mysql.taobao.org/monthly/2019/11/02/">2019/11/02/</a></li>
<li>5.7中Derivedtable变形记 - <a href="http://mysql.taobao.org/monthly/2017/03/05/">2017/03/05/</a></li>
<li>CTE执行过程与实现原理 - <a href="http://mysql.taobao.org/monthly/2017/02/06/">2017/02/06/</a></li>
<li>审计日志实用案例分析 - <a href="http://mysql.taobao.org/monthly/2016/07/07/">2016/07/07/</a></li>
<li>X-Engine并行扫描 - <a href="http://mysql.taobao.org/monthly/2020/04/03/">2020/04/03/</a></li>
<li>RDS三节点企业版热点组提交 - <a href="http://mysql.taobao.org/monthly/2020/02/03/">2020/02/03/</a></li>
<li>8.0redolog写入性能问题分析 - <a href="http://mysql.taobao.org/monthly/2020/01/04/">2020/01/04/</a></li>
<li>今天你并行了吗？---洞察PolarDB8.0之并行查询 - <a href="http://mysql.taobao.org/monthly/2019/11/01/">2019/11/01/</a></li>
<li>性能分析的大杀器—Optimizertrace - <a href="http://mysql.taobao.org/monthly/2019/11/03/">2019/11/03/</a></li>
<li>X-EngineMySQLRDS用户的新选择 - <a href="http://mysql.taobao.org/monthly/2019/10/04/">2019/10/04/</a></li>
<li>StatementOutline - <a href="http://mysql.taobao.org/monthly/2019/07/01/">2019/07/01/</a></li>
<li>RDSMySQL8.0语句级并发控制 - <a href="http://mysql.taobao.org/monthly/2019/06/02/">2019/06/02/</a></li>
<li>通过ResourceGroup来控制线程计算资源 - <a href="http://mysql.taobao.org/monthly/2019/05/05/">2019/05/05/</a></li>
<li>如何使用C++实现MySQL用户定义函数 - <a href="http://mysql.taobao.org/monthly/2019/02/08/">2019/02/08/</a></li>
<li>MySQL多队列线程池优化 - <a href="http://mysql.taobao.org/monthly/2019/02/09/">2019/02/09/</a></li>
<li>MySQL中的IO共享操作 - <a href="http://mysql.taobao.org/monthly/2019/01/09/">2019/01/09/</a></li>
<li>性能问题多维度诊断 - <a href="http://mysql.taobao.org/monthly/2018/11/08/">2018/11/08/</a></li>
<li>8.0CTE和窗口函数的用法 - <a href="http://mysql.taobao.org/monthly/2018/11/09/">2018/11/09/</a></li>
<li>一个TPC-C测试工具sqlbench使用 - <a href="http://mysql.taobao.org/monthly/2018/07/09/">2018/07/09/</a></li>
<li>难以置信，MySQL也可以无损自由切换 - <a href="http://mysql.taobao.org/monthly/2018/06/03/">2018/06/03/</a></li>
<li>在线收缩UNDOTablespace - <a href="http://mysql.taobao.org/monthly/2018/02/09/">2018/02/09/</a></li>
<li>一个“异常”的索引选择 - <a href="http://mysql.taobao.org/monthly/2017/12/06/">2017/12/06/</a></li>
<li>如何索引JSON字段 - <a href="http://mysql.taobao.org/monthly/2017/12/09/">2017/12/09/</a></li>
<li>什么时候该升级内存规格 - <a href="http://mysql.taobao.org/monthly/2017/11/04/">2017/11/04/</a></li>
<li>分区表基本类型 - <a href="http://mysql.taobao.org/monthly/2017/11/09/">2017/11/09/</a></li>
<li>空间优化 - <a href="http://mysql.taobao.org/monthly/2016/06/08/">2016/06/08/</a></li>
<li>RDS只读实例延迟分析 - <a href="http://mysql.taobao.org/monthly/2016/04/08/">2016/04/08/</a></li>
<li>RDSMySQL线上实例insert慢常见原因分析 - <a href="http://mysql.taobao.org/monthly/2018/09/07/">2018/09/07/</a></li>
<li>8.0 - <a href="http://mysql.taobao.org/monthly/2020/05/05/">2020/05/05/</a></li>
<li>内部XA和组提交 - <a href="http://mysql.taobao.org/monthly/2020/05/07/">2020/05/07/</a></li>
<li>InnoDB读写锁实现分析 - <a href="http://mysql.taobao.org/monthly/2020/04/02/">2020/04/02/</a></li>
<li><code>slowlog</code>与<code>CSV</code>引擎 - <a href="http://mysql.taobao.org/monthly/2019/07/08/">2019/07/08/</a></li>
<li>聚合函数（AggregateFunction）的实现过程 - <a href="http://mysql.taobao.org/monthly/2019/05/02/">2019/05/02/</a></li>
<li>LinkBuf设计与实现 - <a href="http://mysql.taobao.org/monthly/2019/05/08/">2019/05/08/</a></li>
<li>CHECKTABLE实现 - <a href="http://mysql.taobao.org/monthly/2019/03/05/">2019/03/05/</a></li>
<li>8.0Functionalindex的实现过程 - <a href="http://mysql.taobao.org/monthly/2019/02/06/">2019/02/06/</a></li>
<li>Innodb缓冲池刷脏的多线程实现 - <a href="http://mysql.taobao.org/monthly/2018/09/02/">2018/09/02/</a></li>
<li>连接与认证过程 - <a href="http://mysql.taobao.org/monthly/2018/08/07/">2018/08/07/</a></li>
<li>8.0原子DDL的实现过程续 - <a href="http://mysql.taobao.org/monthly/2018/07/02/">2018/07/02/</a></li>
<li>binlogcrashrecovery - <a href="http://mysql.taobao.org/monthly/2018/07/05/">2018/07/05/</a></li>
<li>changemasterto - <a href="http://mysql.taobao.org/monthly/2018/05/09/">2018/05/09/</a></li>
<li>协议模块浅析 - <a href="http://mysql.taobao.org/monthly/2018/04/05/">2018/04/05/</a></li>
<li>InnoDB的readview，回滚段和purge过程简介 - <a href="http://mysql.taobao.org/monthly/2018/03/01/">2018/03/01/</a></li>
<li>原子DDL的实现过程 - <a href="http://mysql.taobao.org/monthly/2018/03/02/">2018/03/02/</a></li>
<li>常用SQL语句的MDL加锁源码分析 - <a href="http://mysql.taobao.org/monthly/2018/02/01/">2018/02/01/</a></li>
<li>权限浅析 - <a href="http://mysql.taobao.org/monthly/2018/02/03/">2018/02/03/</a></li>
<li>新连接的建立 - <a href="http://mysql.taobao.org/monthly/2018/02/07/">2018/02/07/</a></li>
<li>InnoDBLRUList刷脏改进之路 - <a href="http://mysql.taobao.org/monthly/2017/11/05/">2017/11/05/</a></li>
<li>Innodb引擎Redo日志存储格式简介 - <a href="http://mysql.taobao.org/monthly/2017/09/07/">2017/09/07/</a></li>
<li>一条insert语句的执行过程 - <a href="http://mysql.taobao.org/monthly/2017/09/10/">2017/09/10/</a></li>
<li>MySQLreplicationpartialtransaction - <a href="http://mysql.taobao.org/monthly/2017/08/03/">2017/08/03/</a></li>
<li>mysql认证阶段漫游 - <a href="http://mysql.taobao.org/monthly/2017/08/05/">2017/08/05/</a></li>
<li>内存分配机制 - <a href="http://mysql.taobao.org/monthly/2017/08/06/">2017/08/06/</a></li>
<li>SHUTDOWN过程 - <a href="http://mysql.taobao.org/monthly/2017/08/09/">2017/08/09/</a></li>
<li>InnoDB异步IO工作流程 - <a href="http://mysql.taobao.org/monthly/2017/07/10/">2017/07/10/</a></li>
<li>Tokudb序列化和反序列化过程 - <a href="http://mysql.taobao.org/monthly/2017/06/01/">2017/06/01/</a></li>
<li>InnoDBRepeatableRead隔离级别之大不同 - <a href="http://mysql.taobao.org/monthly/2017/06/07/">2017/06/07/</a></li>
<li>MySQL半同步复制数据一致性分析 - <a href="http://mysql.taobao.org/monthly/2017/04/01/">2017/04/01/</a></li>
<li>MySQLBINLOG半同步复制数据安全性分析 - <a href="http://mysql.taobao.org/monthly/2017/03/07/">2017/03/07/</a></li>
<li>词法分析及其性能优化 - <a href="http://mysql.taobao.org/monthly/2017/02/04/">2017/02/04/</a></li>
<li>无法revoke单库或单表权限 - <a href="http://mysql.taobao.org/monthly/2016/10/06/">2016/10/06/</a></li>
<li>QueryCache并发处理 - <a href="http://mysql.taobao.org/monthly/2016/08/09/">2016/08/09/</a></li>
<li>网络通信模块浅析 - <a href="http://mysql.taobao.org/monthly/2016/07/04/">2016/07/04/</a></li>
<li>QueryCache内部剖析 - <a href="http://mysql.taobao.org/monthly/2016/07/09/">2016/07/09/</a></li>
<li>InnoDB伙伴内存分配系统实现分析 - <a href="http://mysql.taobao.org/monthly/2020/09/04/">2020/09/04/</a></li>
<li>PerconaXtraBackup备份原理 - <a href="http://mysql.taobao.org/monthly/2016/03/07/">2016/03/07/</a></li>
<li>一些流行引擎存储格式简介 - <a href="http://mysql.taobao.org/monthly/2017/10/04/">2017/10/04/</a></li>
<li>InnoDB对binlog_format的限制 - <a href="http://mysql.taobao.org/monthly/2018/08/04/">2018/08/04/</a></li>
<li>8.0对WAL的设计修改 - <a href="http://mysql.taobao.org/monthly/2018/06/01/">2018/06/01/</a></li>
<li>8.0WriteSet并行复制 - <a href="http://mysql.taobao.org/monthly/2018/06/04/">2018/06/04/</a></li>
<li>MySQL8.0资源组(ResourceGroups) - <a href="http://mysql.taobao.org/monthly/2018/05/03/">2018/05/03/</a></li>
<li>MySQL的预编译功能 - <a href="http://mysql.taobao.org/monthly/2018/04/07/">2018/04/07/</a></li>
<li>(deleted)临时空间 - <a href="http://mysql.taobao.org/monthly/2018/04/08/">2018/04/08/</a></li>
<li>innodb_buffer_pool_size在线修改 - <a href="http://mysql.taobao.org/monthly/2018/03/06/">2018/03/06/</a></li>
<li>LOGICAL_CLOCK并行复制原理及实现分析 - <a href="http://mysql.taobao.org/monthly/2017/12/03/">2017/12/03/</a></li>
<li>MySQL5.7外部XAReplication实现及缺陷分析 - <a href="http://mysql.taobao.org/monthly/2017/11/06/">2017/11/06/</a></li>
<li>数据一样checksum不一样 - <a href="http://mysql.taobao.org/monthly/2017/10/08/">2017/10/08/</a></li>
<li>浅谈MySQL5.7XA事务改进 - <a href="http://mysql.taobao.org/monthly/2017/09/05/">2017/09/05/</a></li>
<li>利用gdb跟踪MDL加锁过程 - <a href="http://mysql.taobao.org/monthly/2017/09/06/">2017/09/06/</a></li>
<li>到底是谁执行了FTWL - <a href="http://mysql.taobao.org/monthly/2017/08/04/">2017/08/04/</a></li>
<li>commontableexpression - <a href="http://mysql.taobao.org/monthly/2017/04/05/">2017/04/05/</a></li>
<li>5.7errorlog时区和系统时区不同 - <a href="http://mysql.taobao.org/monthly/2017/01/09/">2017/01/09/</a></li>
<li>直方图的实现与分析 - <a href="http://mysql.taobao.org/monthly/2016/10/09/">2016/10/09/</a></li>
<li>执行计划缓存设计与实现 - <a href="http://mysql.taobao.org/monthly/2016/09/04/">2016/09/04/</a></li>
<li>MySQL5.7新特性系列四 - <a href="http://mysql.taobao.org/monthly/2016/08/01/">2016/08/01/</a></li>
<li>MyRocks简介 - <a href="http://mysql.taobao.org/monthly/2016/08/03/">2016/08/03/</a></li>
<li>MySQL5.7新特性系列三 - <a href="http://mysql.taobao.org/monthly/2016/07/01/">2016/07/01/</a></li>
<li>5.7代价模型浅析 - <a href="http://mysql.taobao.org/monthly/2016/07/02/">2016/07/02/</a></li>
<li>innodb锁分裂继承与迁移 - <a href="http://mysql.taobao.org/monthly/2016/06/01/">2016/06/01/</a></li>
<li>MySQL5.7新特性系列二 - <a href="http://mysql.taobao.org/monthly/2016/06/02/">2016/06/02/</a></li>
<li>内部临时表 - <a href="http://mysql.taobao.org/monthly/2016/06/07/">2016/06/07/</a></li>
<li>MySQL5.7新特性系列一 - <a href="http://mysql.taobao.org/monthly/2016/05/02/">2016/05/02/</a></li>
<li>innodbbufferpool相关特性 - <a href="http://mysql.taobao.org/monthly/2016/05/04/">2016/05/04/</a></li>
<li>InnoDBtransactionhistory - <a href="http://mysql.taobao.org/monthly/2016/02/03/">2016/02/03/</a></li>
<li>线程池 - <a href="http://mysql.taobao.org/monthly/2016/02/09/">2016/02/09/</a></li>
<li>优化器MRR&amp;BKA - <a href="http://mysql.taobao.org/monthly/2016/01/04/">2016/01/04/</a></li>
<li>droptable的优化 - <a href="http://mysql.taobao.org/monthly/2016/01/07/">2016/01/07/</a></li>
<li>IndexConditionPushdown(ICP) - <a href="http://mysql.taobao.org/monthly/2015/12/08/">2015/12/08/</a></li>
<li>企业版特性一览 - <a href="http://mysql.taobao.org/monthly/2015/12/10/">2015/12/10/</a></li>
<li>StatementDigest - <a href="http://mysql.taobao.org/monthly/2015/11/02/">2015/11/02/</a></li>
<li>MDL实现分析 - <a href="http://mysql.taobao.org/monthly/2015/11/04/">2015/11/04/</a></li>
<li>跟踪Metadatalock - <a href="http://mysql.taobao.org/monthly/2015/10/02/">2015/10/02/</a></li>
<li>MySQL权限存储与管理 - <a href="http://mysql.taobao.org/monthly/2015/10/10/">2015/10/10/</a></li>
<li>5.6并行复制恢复实现 - <a href="http://mysql.taobao.org/monthly/2015/09/07/">2015/09/07/</a></li>
<li>5.6并行复制事件分发机制 - <a href="http://mysql.taobao.org/monthly/2015/09/09/">2015/09/09/</a></li>
<li>OnlineDDL工具gh-ost支持阿里云RDS - <a href="http://mysql.taobao.org/monthly/2018/05/02/">2018/05/02/</a></li>
<li>MariaDB10.2前瞻 - <a href="http://mysql.taobao.org/monthly/2016/09/03/">2016/09/03/</a></li>
<li>InnoDBPageCompression - <a href="http://mysql.taobao.org/monthly/2015/08/01/">2015/08/01/</a></li>
<li>MySQL5.6.26ReleaseNote解读 - <a href="http://mysql.taobao.org/monthly/2015/08/03/">2015/08/03/</a></li>
<li>MariaDBInnoDB表空间碎片整理 - <a href="http://mysql.taobao.org/monthly/2015/08/05/">2015/08/05/</a></li>
<li>MySQL内存分配支持NUMA - <a href="http://mysql.taobao.org/monthly/2015/07/06/">2015/07/06/</a></li>
<li>MariaDBRole体系 - <a href="http://mysql.taobao.org/monthly/2015/06/09/">2015/06/09/</a></li>
<li>5.6.23InnoDB相关Bugfix - <a href="http://mysql.taobao.org/monthly/2015/02/02/">2015/02/02/</a></li>
<li>MariaDB10.2GA - <a href="http://mysql.taobao.org/monthly/2017/06/10/">2017/06/10/</a></li>
<li>OracleOpenWorld2016见闻 - <a href="http://mysql.taobao.org/monthly/2016/10/02/">2016/10/02/</a></li>
<li>PerconaLive2016见闻 - <a href="http://mysql.taobao.org/monthly/2016/10/03/">2016/10/03/</a></li>
<li>MariaDBDeveloperMeeting2016 - <a href="http://mysql.taobao.org/monthly/2016/10/04/">2016/10/04/</a></li>
<li>OOW2015总结MySQL篇 - <a href="http://mysql.taobao.org/monthly/2015/11/01/">2015/11/01/</a></li>
<li>AliSQL那些事儿 - <a href="http://mysql.taobao.org/monthly/2016/09/01/">2016/09/01/</a></li>
<li>MySQL的那些网络超时错误 - <a href="http://mysql.taobao.org/monthly/2017/05/04/">2017/05/04/</a></li>
<li>备库Seconds_Behind_Master计算 - <a href="http://mysql.taobao.org/monthly/2016/03/09/">2016/03/09/</a></li>
<li>MySQL锁问题最佳实践 - <a href="http://mysql.taobao.org/monthly/2016/03/10/">2016/03/10/</a></li>
<li>mysqldumptips两则 - <a href="http://mysql.taobao.org/monthly/2016/02/10/">2016/02/10/</a></li>
<li>物理备份死锁分析 - <a href="http://mysql.taobao.org/monthly/2016/01/05/">2016/01/05/</a></li>
<li>GTID不一致分析 - <a href="http://mysql.taobao.org/monthly/2016/01/08/">2016/01/08/</a></li>
<li>MySQL优化器range的代价计算 - <a href="http://mysql.taobao.org/monthly/2015/11/07/">2015/11/07/</a></li>
<li>索引过滤性太差引起CPU飙高分析 - <a href="http://mysql.taobao.org/monthly/2015/10/03/">2015/10/03/</a></li>
<li>openfilelimits - <a href="http://mysql.taobao.org/monthly/2015/08/07/">2015/08/07/</a></li>
<li>外键删除bug分析 - <a href="http://mysql.taobao.org/monthly/2015/07/07/">2015/07/07/</a></li>
<li>浮点型的显示问题 - <a href="http://mysql.taobao.org/monthly/2015/07/10/">2015/07/10/</a></li>
<li>MySQLSort分页 - <a href="http://mysql.taobao.org/monthly/2015/06/04/">2015/06/04/</a></li>
<li>binlogevent中的errorcode - <a href="http://mysql.taobao.org/monthly/2015/06/05/">2015/06/05/</a></li>
<li>InnoDB预读VSOracle多块读 - <a href="http://mysql.taobao.org/monthly/2015/05/04/">2015/05/04/</a></li>
<li>setnames都做了什么 - <a href="http://mysql.taobao.org/monthly/2015/05/07/">2015/05/07/</a></li>
<li>binlog位点刷新策略 - <a href="http://mysql.taobao.org/monthly/2015/05/10/">2015/05/10/</a></li>
<li>UPDATE交换列单表和多表的区别 - <a href="http://mysql.taobao.org/monthly/2015/04/08/">2015/04/08/</a></li>
<li>GTID下auto_position=0时数据不一致 - <a href="http://mysql.taobao.org/monthly/2015/04/10/">2015/04/10/</a></li>
<li>并发Replaceinto导致的死锁分析 - <a href="http://mysql.taobao.org/monthly/2015/03/01/">2015/03/01/</a></li>
<li>usingfilesortVSusingtemporary - <a href="http://mysql.taobao.org/monthly/2015/03/04/">2015/03/04/</a></li>
<li>lower_case_table_names使用问题 - <a href="http://mysql.taobao.org/monthly/2015/03/07/">2015/03/07/</a></li>
<li>InnoDB丢失自增值 - <a href="http://mysql.taobao.org/monthly/2015/02/05/">2015/02/05/</a></li>
<li>5.5和5.6时间类型兼容问题 - <a href="http://mysql.taobao.org/monthly/2015/02/06/">2015/02/06/</a></li>
<li>binlogevent有序性 - <a href="http://mysql.taobao.org/monthly/2014/12/05/">2014/12/05/</a></li>
<li>server_id为0的Rotate - <a href="http://mysql.taobao.org/monthly/2014/12/06/">2014/12/06/</a></li>
<li>text字段数 - <a href="http://mysql.taobao.org/monthly/2014/10/02/">2014/10/02/</a></li>
<li>key分区算法演变分析 - <a href="http://mysql.taobao.org/monthly/2015/01/06/">2015/01/06/</a></li>
<li>5.6GTID和存储引擎那会事 - <a href="http://mysql.taobao.org/monthly/2014/12/02/">2014/12/02/</a></li>
<li>GTID和升级 - <a href="http://mysql.taobao.org/monthly/2017/05/08/">2014/09/02/</a></li>
<li>索引篇 - <a href="http://mysql.taobao.org/monthly/2017/02/05/">2017/02/05/</a></li>
</ol>
]]></content>
      <categories>
        <category>资源推荐</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>资源推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>资源推荐：数据库内核月报</title>
    <url>/2020/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5/</url>
    <content><![CDATA[<p>今天在舍友的安利下发现了一个新的宝藏，阿里的<a href="http://mysql.taobao.org/monthly/">数据库内核日报</a>，内容之全面让小白我瞠目结舌，简单的爬了一下 mysql 相关的文章。</p>
<p>完整版可以直接<a href="http://xiajibagao.top/down/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A5(%E6%88%AA%E6%AD%A22020%E5%B9%B411%E6%9C%8817%E6%97%A5).md">点击链接下载</a>。以下只是 Mysql 内容的整合：</p>
<ol type="1">
<li>MetadataLock子系统的优化 - <a href="http://mysql.taobao.org/monthly/2014/11/05/">2014/11/05/</a></li>
<li>Recovery改进 - <a href="http://mysql.taobao.org/monthly/2014/11/03/">2014/11/03/</a></li>
<li>高可用支持 - <a href="http://mysql.taobao.org/monthly/2014/11/04/">2014/11/04/</a></li>
<li>在线Truncateundolog表空间 - <a href="http://mysql.taobao.org/monthly/2014/11/06/">2014/11/06/</a></li>
<li>OptimizerCostModel - <a href="http://mysql.taobao.org/monthly/2014/10/01/">2014/10/01/</a></li>
<li>Renametable死锁分析 - <a href="http://mysql.taobao.org/monthly/2016/03/06/">2016/03/06/</a></li>
<li>CongratulationsonMySQL8.0GA - <a href="http://mysql.taobao.org/monthly/2018/05/01/">2018/05/01/</a></li>
<li>Redolog - <a href="http://mysql.taobao.org/monthly/2019/03/03/">2019/03/03/</a></li>
<li>tablespace源码分析 - <a href="http://mysql.taobao.org/monthly/2019/01/08/">2019/01/08/</a></li>
<li>TTL特性介绍 - <a href="http://mysql.taobao.org/monthly/2018/04/04/">2018/04/04/</a></li>
<li>MyRocks参数介绍 - <a href="http://mysql.taobao.org/monthly/2018/01/09/">2018/01/09/</a></li>
<li>OptimizerHints - <a href="http://mysql.taobao.org/monthly/2020/09/07/">2020/09/07/</a></li>
<li>ParallelIndexScans,OneisBetterThanTwo - <a href="http://mysql.taobao.org/monthly/2019/10/03/">2019/10/03/</a></li>
<li>数据的读取(二) - <a href="http://mysql.taobao.org/monthly/2018/12/08/">2018/12/08/</a></li>
<li>数据的读取(一) - <a href="http://mysql.taobao.org/monthly/2018/11/05/">2018/11/05/</a></li>
<li>LevelCompact分析 - <a href="http://mysql.taobao.org/monthly/2018/10/08/">2018/10/08/</a></li>
<li>TransactionDB介绍 - <a href="http://mysql.taobao.org/monthly/2018/10/09/">2018/10/09/</a></li>
<li>Memtableflush分析 - <a href="http://mysql.taobao.org/monthly/2018/09/04/">2018/09/04/</a></li>
<li>WritePreparedPolicy - <a href="http://mysql.taobao.org/monthly/2018/08/02/">2018/08/02/</a></li>
<li>MemTable的写入逻辑 - <a href="http://mysql.taobao.org/monthly/2018/08/08/">2018/08/08/</a></li>
<li>写入逻辑的实现 - <a href="http://mysql.taobao.org/monthly/2018/07/04/">2018/07/04/</a></li>
<li>ColumnFamily介绍 - <a href="http://mysql.taobao.org/monthly/2018/06/09/">2018/06/09/</a></li>
<li>MANIFEST文件介绍 - <a href="http://mysql.taobao.org/monthly/2018/05/08/">2018/05/08/</a></li>
<li>WAL(WriteAheadLog)介绍 - <a href="http://mysql.taobao.org/monthly/2018/04/09/">2018/04/09/</a></li>
<li>rbtreeblockallocator - <a href="http://mysql.taobao.org/monthly/2016/11/03/">2016/11/03/</a></li>
<li>checkpoint过程 - <a href="http://mysql.taobao.org/monthly/2016/06/06/">2016/06/06/</a></li>
<li>日志子系统和崩溃恢复过程 - <a href="http://mysql.taobao.org/monthly/2016/05/07/">2016/05/07/</a></li>
<li>TokuDB索引结构--FractalTree - <a href="http://mysql.taobao.org/monthly/2016/04/09/">2016/04/09/</a></li>
<li>Savepoint漫谈 - <a href="http://mysql.taobao.org/monthly/2016/04/10/">2016/04/10/</a></li>
<li>事务子系统和MVCC实现 - <a href="http://mysql.taobao.org/monthly/2016/03/01/">2016/03/01/</a></li>
<li>TokuDB之黑科技工具 - <a href="http://mysql.taobao.org/monthly/2016/02/06/">2016/02/06/</a></li>
<li>Cachetable的工作线程和线程池 - <a href="http://mysql.taobao.org/monthly/2016/01/06/">2016/01/06/</a></li>
<li>让HotBackup更完美 - <a href="http://mysql.taobao.org/monthly/2015/12/06/">2015/12/06/</a></li>
<li>TokuDB中的行锁 - <a href="http://mysql.taobao.org/monthly/2015/11/09/">2015/11/09/</a></li>
<li>文件目录谈 - <a href="http://mysql.taobao.org/monthly/2015/09/10/">2015/09/10/</a></li>
<li>疯狂的filenum++ - <a href="http://mysql.taobao.org/monthly/2015/08/08/">2015/08/08/</a></li>
<li>TokuDBCheckpoint机制 - <a href="http://mysql.taobao.org/monthly/2015/07/02/">2015/07/02/</a></li>
<li>TokuDB数据文件大小计算 - <a href="http://mysql.taobao.org/monthly/2015/06/10/">2015/06/10/</a></li>
<li>collation限制 - <a href="http://mysql.taobao.org/monthly/2018/09/09/">2018/09/09/</a></li>
<li>clusteredindex特性 - <a href="http://mysql.taobao.org/monthly/2018/07/07/">2018/07/07/</a></li>
<li>事务锁分析 - <a href="http://mysql.taobao.org/monthly/2018/03/07/">2018/03/07/</a></li>
<li>相关tools介绍 - <a href="http://mysql.taobao.org/monthly/2017/12/10/">2017/12/10/</a></li>
<li>myrocks之Bloomfilter - <a href="http://mysql.taobao.org/monthly/2017/09/04/">2017/09/04/</a></li>
<li>myrocks写入分析 - <a href="http://mysql.taobao.org/monthly/2017/07/05/">2017/07/05/</a></li>
<li>MyRocks之memtable切换与刷盘 - <a href="http://mysql.taobao.org/monthly/2017/06/08/">2017/06/08/</a></li>
<li>fastdataload - <a href="http://mysql.taobao.org/monthly/2017/05/09/">2017/05/09/</a></li>
<li>myrocks监控信息 - <a href="http://mysql.taobao.org/monthly/2017/03/10/">2017/03/10/</a></li>
<li>myrocks之备份恢复 - <a href="http://mysql.taobao.org/monthly/2017/02/02/">2017/02/02/</a></li>
<li>myrocksindexconditionpushdown - <a href="http://mysql.taobao.org/monthly/2017/01/02/">2017/01/02/</a></li>
<li>myrocks统计信息 - <a href="http://mysql.taobao.org/monthly/2016/12/02/">2016/12/02/</a></li>
<li>myrocks之事务处理 - <a href="http://mysql.taobao.org/monthly/2016/11/02/">2016/11/02/</a></li>
<li>datadictionary分析 - <a href="http://mysql.taobao.org/monthly/2016/10/05/">2016/10/05/</a></li>
<li>GTID启动优化 - <a href="http://mysql.taobao.org/monthly/2014/12/09/">2014/12/09/</a></li>
<li>InnoDB物理行中null值的存储的推断与验证 - <a href="http://mysql.taobao.org/monthly/2016/08/07/">2016/08/07/</a></li>
<li>MySQL5.7的JSON实现 - <a href="http://mysql.taobao.org/monthly/2016/01/03/">2016/01/03/</a></li>
<li>MySQL数据库SYSCPU高的可能性分析 - <a href="http://mysql.taobao.org/monthly/2015/05/02/">2015/05/02/</a></li>
<li>RDS三节点企业版的高可用体系 - <a href="http://mysql.taobao.org/monthly/2020/03/03/">2020/03/03/</a></li>
<li>MYSQL开源软件源码阅读小技巧 - <a href="http://mysql.taobao.org/monthly/2019/12/03/">2019/12/03/</a></li>
<li>复制性能改进过程 - <a href="http://mysql.taobao.org/monthly/2015/01/05/">2015/01/05/</a></li>
<li>MySQLindex_condition_pushdown - <a href="http://mysql.taobao.org/monthly/2015/03/05/">2015/03/05/</a></li>
<li>InnoDBBufferPool并发控制 - <a href="http://mysql.taobao.org/monthly/2020/05/06/">2020/05/06/</a></li>
<li>InnoDBmutex实现分析 - <a href="http://mysql.taobao.org/monthly/2020/03/05/">2020/03/05/</a></li>
<li>InnoDB的统计信息 - <a href="http://mysql.taobao.org/monthly/2020/03/08/">2020/03/08/</a></li>
<li>RedoLogging动态开关 - <a href="http://mysql.taobao.org/monthly/2020/08/03/">2020/08/03/</a></li>
<li>8.0新的火山模型执行器 - <a href="http://mysql.taobao.org/monthly/2020/07/01/">2020/07/01/</a></li>
<li>semi-join四个执行strategy - <a href="http://mysql.taobao.org/monthly/2020/07/04/">2020/07/04/</a></li>
<li>InnoDBbtreelatch优化历程 - <a href="http://mysql.taobao.org/monthly/2020/06/02/">2020/06/02/</a></li>
<li>Attachabletransaction - <a href="http://mysql.taobao.org/monthly/2020/06/03/">2020/06/03/</a></li>
<li>Linkbuf - <a href="http://mysql.taobao.org/monthly/2020/06/04/">2020/06/04/</a></li>
<li>一致性协议underthehood - <a href="http://mysql.taobao.org/monthly/2020/09/02/">2020/09/02/</a></li>
<li>binlog拉取速度的控制 - <a href="http://mysql.taobao.org/monthly/2015/07/09/">2015/07/09/</a></li>
<li>5.6并行复制实现分析 - <a href="http://mysql.taobao.org/monthly/2015/08/09/">2015/08/09/</a></li>
<li>MySQL表定义缓存 - <a href="http://mysql.taobao.org/monthly/2015/08/10/">2015/08/10/</a></li>
<li>InnoDBWarmup特性 - <a href="http://mysql.taobao.org/monthly/2014/10/06/">2014/10/06/</a></li>
<li>再议MySQL的故障恢复 - <a href="http://mysql.taobao.org/monthly/2018/12/04/">2018/12/04/</a></li>
<li>RDSMySQL参数调优最佳实践 - <a href="http://mysql.taobao.org/monthly/2015/12/04/">2015/12/04/</a></li>
<li>innodb_additional_mem_pool_size - <a href="http://mysql.taobao.org/monthly/2016/04/01/">2016/04/01/</a></li>
<li>thread_concurrency - <a href="http://mysql.taobao.org/monthly/2014/09/05/">2014/09/05/</a></li>
<li>timed_mutexes - <a href="http://mysql.taobao.org/monthly/2014/08/01/">2014/08/01/</a></li>
<li>innodb_flush_log_at_trx_commit - <a href="http://mysql.taobao.org/monthly/2014/08/02/">2014/08/02/</a></li>
<li>relayfetch备库优化 - <a href="http://mysql.taobao.org/monthly/2015/09/08/">2015/09/08/</a></li>
<li>MySQL的字段数据存储格式 - <a href="http://mysql.taobao.org/monthly/2020/02/05/">2020/02/05/</a></li>
<li>HybridDBforMySQL数据压缩 - <a href="http://mysql.taobao.org/monthly/2017/07/08/">2017/07/08/</a></li>
<li>对字符集和字符序支持的实现 - <a href="http://mysql.taobao.org/monthly/2017/03/06/">2017/03/06/</a></li>
<li>Sphinx源码剖析(三) - <a href="http://mysql.taobao.org/monthly/2017/10/06/">2017/10/06/</a></li>
<li>Sphinx源码剖析（二） - <a href="http://mysql.taobao.org/monthly/2017/04/03/">2017/04/03/</a></li>
<li>Sphinx源码剖析（一） - <a href="http://mysql.taobao.org/monthly/2016/11/05/">2016/11/05/</a></li>
<li>InnoDBhistorylist无法降到0的原因 - <a href="http://mysql.taobao.org/monthly/2019/04/04/">2019/04/04/</a></li>
<li>InnoDB行锁分析 - <a href="http://mysql.taobao.org/monthly/2018/05/04/">2018/05/04/</a></li>
<li>create_timeinstatus - <a href="http://mysql.taobao.org/monthly/2014/09/04/">2014/09/04/</a></li>
<li>InnoDB隐式锁功能解析 - <a href="http://mysql.taobao.org/monthly/2020/09/06/">2020/09/06/</a></li>
<li>truncatetable在大bufferpool下的优化 - <a href="http://mysql.taobao.org/monthly/2020/08/01/">2020/08/01/</a></li>
<li>INNODBUNDOLOG分配 - <a href="http://mysql.taobao.org/monthly/2020/08/02/">2020/08/02/</a></li>
<li>InnoDBBufferPage生命周期 - <a href="http://mysql.taobao.org/monthly/2020/08/04/">2020/08/04/</a></li>
<li>InnoDBUNDOLOG写入 - <a href="http://mysql.taobao.org/monthly/2020/08/05/">2020/08/05/</a></li>
<li>InnoDB数据文件简述 - <a href="http://mysql.taobao.org/monthly/2020/08/06/">2020/08/06/</a></li>
<li>InnoDBredologthreadcpuusage - <a href="http://mysql.taobao.org/monthly/2020/07/05/">2020/07/05/</a></li>
<li>基于GTID复制实现的工作原理 - <a href="http://mysql.taobao.org/monthly/2020/05/09/">2020/05/09/</a></li>
<li>8.0WindowFunctions剖析 - <a href="http://mysql.taobao.org/monthly/2020/04/04/">2020/04/04/</a></li>
<li>Performance_schema内存分配 - <a href="http://mysql.taobao.org/monthly/2020/04/05/">2020/04/05/</a></li>
<li>手动分析InnoDBB+Tree结构 - <a href="http://mysql.taobao.org/monthly/2020/04/06/">2020/04/06/</a></li>
<li>8.0LockManager - <a href="http://mysql.taobao.org/monthly/2020/04/09/">2020/04/09/</a></li>
<li>8.0InstantAddColumn功能解析 - <a href="http://mysql.taobao.org/monthly/2020/03/01/">2020/03/01/</a></li>
<li>Latch持有分析 - <a href="http://mysql.taobao.org/monthly/2020/03/07/">2020/03/07/</a></li>
<li>排序实现 - <a href="http://mysql.taobao.org/monthly/2020/03/09/">2020/03/09/</a></li>
<li>庖丁解InnoDB之REDOLOG - <a href="http://mysql.taobao.org/monthly/2020/02/01/">2020/02/01/</a></li>
<li>InnoDBBufferPool浅析 - <a href="http://mysql.taobao.org/monthly/2020/02/02/">2020/02/02/</a></li>
<li>8.0heaptable介绍 - <a href="http://mysql.taobao.org/monthly/2020/02/04/">2020/02/04/</a></li>
<li>MYSQLBinlogCache详解 - <a href="http://mysql.taobao.org/monthly/2020/02/06/">2020/02/06/</a></li>
<li>二级索引分析 - <a href="http://mysql.taobao.org/monthly/2020/01/01/">2020/01/01/</a></li>
<li>X-EngineOnlineDDL - <a href="http://mysql.taobao.org/monthly/2020/01/02/">2020/01/02/</a></li>
<li>InnoDBredolog之writeahead - <a href="http://mysql.taobao.org/monthly/2020/01/05/">2020/01/05/</a></li>
<li>InnodbWAL物理格式 - <a href="http://mysql.taobao.org/monthly/2020/01/06/">2020/01/06/</a></li>
<li>动态元信息持久化 - <a href="http://mysql.taobao.org/monthly/2019/12/01/">2019/12/01/</a></li>
<li>Binlogencryption浅析 - <a href="http://mysql.taobao.org/monthly/2019/12/02/">2019/12/02/</a></li>
<li>多线程调试工具DEBUG_SYNC的源码实现和使用 - <a href="http://mysql.taobao.org/monthly/2019/12/04/">2019/12/04/</a></li>
<li>InnoDBParallelreadofindex - <a href="http://mysql.taobao.org/monthly/2019/12/05/">2019/12/05/</a></li>
<li>RDS三节点企业版一致性协议 - <a href="http://mysql.taobao.org/monthly/2019/11/06/">2019/11/06/</a></li>
<li>RDS三节点企业版Learner只读实例 - <a href="http://mysql.taobao.org/monthly/2019/11/07/">2019/11/07/</a></li>
<li>Innodb表空间 - <a href="http://mysql.taobao.org/monthly/2019/10/01/">2019/10/01/</a></li>
<li>POLARDB并行查询加速全程详解 - <a href="http://mysql.taobao.org/monthly/2019/10/02/">2019/10/02/</a></li>
<li>SequenceEngine - <a href="http://mysql.taobao.org/monthly/2019/10/05/">2019/10/05/</a></li>
<li>临时表改进 - <a href="http://mysql.taobao.org/monthly/2019/09/01/">2019/09/01/</a></li>
<li>初探ClonePlugin - <a href="http://mysql.taobao.org/monthly/2019/09/02/">2019/09/02/</a></li>
<li>网络模块优化 - <a href="http://mysql.taobao.org/monthly/2019/09/03/">2019/09/03/</a></li>
<li>Multi-ValuedIndexes简述 - <a href="http://mysql.taobao.org/monthly/2019/09/04/">2019/09/04/</a></li>
<li>8.0Innodbredologrecord源码分析 - <a href="http://mysql.taobao.org/monthly/2019/08/03/">2019/08/03/</a></li>
<li>clone_plugin - <a href="http://mysql.taobao.org/monthly/2019/08/05/">2019/08/05/</a></li>
<li>ROLLUP功能用法和实现 - <a href="http://mysql.taobao.org/monthly/2019/08/08/">2019/08/08/</a></li>
<li>BufferPool漫谈 - <a href="http://mysql.taobao.org/monthly/2019/07/03/">2019/07/03/</a></li>
<li>CTE(CommonTableExpressions) - <a href="http://mysql.taobao.org/monthly/2019/07/06/">2019/07/06/</a></li>
<li>安全及权限改进相关 - <a href="http://mysql.taobao.org/monthly/2019/06/01/">2019/06/01/</a></li>
<li>说说InnoDBLogSystem的隐藏参数 - <a href="http://mysql.taobao.org/monthly/2019/06/07/">2019/06/07/</a></li>
<li>CHECKCONSTRAINT - <a href="http://mysql.taobao.org/monthly/2019/06/08/">2019/06/08/</a></li>
<li>通过SQL管理UNDOTABLESPACE - <a href="http://mysql.taobao.org/monthly/2019/05/04/">2019/05/04/</a></li>
<li>SkipScanRange - <a href="http://mysql.taobao.org/monthly/2019/05/06/">2019/05/06/</a></li>
<li>临时表那些事儿 - <a href="http://mysql.taobao.org/monthly/2019/04/01/">2019/04/01/</a></li>
<li>新的事务锁调度VATS简介 - <a href="http://mysql.taobao.org/monthly/2019/04/06/">2019/04/06/</a></li>
<li>增加系统文件追踪spaceID和物理文件的映射 - <a href="http://mysql.taobao.org/monthly/2019/04/07/">2019/04/07/</a></li>
<li>8.0DescendingIndex - <a href="http://mysql.taobao.org/monthly/2019/03/07/">2019/03/07/</a></li>
<li>MySQL状态信息Status实现 - <a href="http://mysql.taobao.org/monthly/2019/03/09/">2019/03/09/</a></li>
<li>InspectingtheContentofaMySQLHistogram - <a href="http://mysql.taobao.org/monthly/2019/02/02/">2019/02/02/</a></li>
<li>Thedesignofmysql8.0redolog - <a href="http://mysql.taobao.org/monthly/2019/02/05/">2019/02/05/</a></li>
<li>InnoDBMVCC相关实现 - <a href="http://mysql.taobao.org/monthly/2018/11/04/">2018/11/04/</a></li>
<li>CostModel,直方图及优化器开销优化 - <a href="http://mysql.taobao.org/monthly/2018/10/02/">2018/10/02/</a></li>
<li>B+树并发控制机制的前世今生 - <a href="http://mysql.taobao.org/monthly/2018/09/01/">2018/09/01/</a></li>
<li>IO_CACHE源码解析 - <a href="http://mysql.taobao.org/monthly/2018/09/03/">2018/09/03/</a></li>
<li>主库binlog概览 - <a href="http://mysql.taobao.org/monthly/2018/08/01/">2018/08/01/</a></li>
<li>WAL那些事儿 - <a href="http://mysql.taobao.org/monthly/2018/07/01/">2018/07/01/</a></li>
<li>InnoDB表空间加密 - <a href="http://mysql.taobao.org/monthly/2018/04/01/">2018/04/01/</a></li>
<li>InnoDB数据页解析 - <a href="http://mysql.taobao.org/monthly/2018/04/03/">2018/04/03/</a></li>
<li>INFORMATION_SCHEMA系统表的实现 - <a href="http://mysql.taobao.org/monthly/2018/02/08/">2018/02/08/</a></li>
<li>GroupReplication内核解析之二 - <a href="http://mysql.taobao.org/monthly/2018/01/01/">2018/01/01/</a></li>
<li>MySQL内核对读写分离的支持 - <a href="http://mysql.taobao.org/monthly/2018/01/02/">2018/01/02/</a></li>
<li>InnoDB事务系统 - <a href="http://mysql.taobao.org/monthly/2017/12/01/">2017/12/01/</a></li>
<li>Innodb锁子系统浅析 - <a href="http://mysql.taobao.org/monthly/2017/12/02/">2017/12/02/</a></li>
<li>DROPTABLE之binlog解析 - <a href="http://mysql.taobao.org/monthly/2017/11/02/">2017/11/02/</a></li>
<li>TokuDBhot-index机制 - <a href="http://mysql.taobao.org/monthly/2017/11/08/">2017/11/08/</a></li>
<li>InnoDBminitransation - <a href="http://mysql.taobao.org/monthly/2017/10/03/">2017/10/03/</a></li>
<li>GroupReplication内核解析 - <a href="http://mysql.taobao.org/monthly/2017/08/01/">2017/08/01/</a></li>
<li>InnoDB崩溃恢复 - <a href="http://mysql.taobao.org/monthly/2017/07/01/">2017/07/01/</a></li>
<li>从节点可更新机制 - <a href="http://mysql.taobao.org/monthly/2017/06/03/">2017/06/03/</a></li>
<li>InnoDBBufferPool - <a href="http://mysql.taobao.org/monthly/2017/05/01/">2017/05/01/</a></li>
<li>InnoDBIO子系统 - <a href="http://mysql.taobao.org/monthly/2017/03/01/">2017/03/01/</a></li>
<li>InnoDB同步机制 - <a href="http://mysql.taobao.org/monthly/2017/01/01/">2017/01/01/</a></li>
<li>Infobright列存数据库 - <a href="http://mysql.taobao.org/monthly/2016/12/01/">2016/12/01/</a></li>
<li>ColumnCompression浅析 - <a href="http://mysql.taobao.org/monthly/2016/11/04/">2016/11/04/</a></li>
<li>InnoDBCOUNT(*)优化(?) - <a href="http://mysql.taobao.org/monthly/2016/06/10/">2016/06/10/</a></li>
<li>基于InnoDB的物理复制实现 - <a href="http://mysql.taobao.org/monthly/2016/05/01/">2016/05/01/</a></li>
<li>InnoDB文件系统之文件物理结构 - <a href="http://mysql.taobao.org/monthly/2016/02/01/">2016/02/01/</a></li>
<li>InnoDB文件系统之IO系统和内存管理 - <a href="http://mysql.taobao.org/monthly/2016/02/02/">2016/02/02/</a></li>
<li>InnoDB事务锁系统简介 - <a href="http://mysql.taobao.org/monthly/2016/01/01/">2016/01/01/</a></li>
<li>InnoDB事务子系统介绍 - <a href="http://mysql.taobao.org/monthly/2015/12/01/">2015/12/01/</a></li>
<li>InnoDB全文索引简介 - <a href="http://mysql.taobao.org/monthly/2015/10/01/">2015/10/01/</a></li>
<li>InnoDBAdaptivehashindex介绍 - <a href="http://mysql.taobao.org/monthly/2015/09/01/">2015/09/01/</a></li>
<li>Innodbchangebuffer介绍 - <a href="http://mysql.taobao.org/monthly/2015/07/01/">2015/07/01/</a></li>
<li>InnoDBindexlock前世今生 - <a href="http://mysql.taobao.org/monthly/2015/07/05/">2015/07/05/</a></li>
<li>MySQLlogicalread-ahead - <a href="http://mysql.taobao.org/monthly/2015/07/08/">2015/07/08/</a></li>
<li>InnoDB崩溃恢复过程 - <a href="http://mysql.taobao.org/monthly/2015/06/01/">2015/06/01/</a></li>
<li>InnoDBredolog漫游 - <a href="http://mysql.taobao.org/monthly/2015/05/01/">2015/05/01/</a></li>
<li>InnoDBundolog漫游 - <a href="http://mysql.taobao.org/monthly/2015/04/01/">2015/04/01/</a></li>
<li>PageCache优化管理 - <a href="http://mysql.taobao.org/monthly/2020/09/01/">2020/09/01/</a></li>
<li>CloudDBASQL优化建议之统计信息获取 - <a href="http://mysql.taobao.org/monthly/2017/10/02/">2017/10/02/</a></li>
<li>MySQL常见SQL错误用法 - <a href="http://mysql.taobao.org/monthly/2017/03/03/">2017/03/03/</a></li>
<li>条件下推到物化表 - <a href="http://mysql.taobao.org/monthly/2016/07/08/">2016/07/08/</a></li>
<li>5.7.6InnoDBpageflush优化 - <a href="http://mysql.taobao.org/monthly/2015/03/02/">2015/03/02/</a></li>
<li>InnoDBbufferpoolflush策略漫谈 - <a href="http://mysql.taobao.org/monthly/2015/02/01/">2015/02/01/</a></li>
<li>GroupCommit优化 - <a href="http://mysql.taobao.org/monthly/2015/01/01/">2015/01/01/</a></li>
<li>启用GTID场景的性能问题及优化 - <a href="http://mysql.taobao.org/monthly/2015/01/03/">2015/01/03/</a></li>
<li>5.7Innodb事务系统 - <a href="http://mysql.taobao.org/monthly/2014/12/01/">2014/12/01/</a></li>
<li>threadpool原理分析 - <a href="http://mysql.taobao.org/monthly/2014/12/03/">2014/12/03/</a></li>
<li>并行复制外建约束问题 - <a href="http://mysql.taobao.org/monthly/2014/12/04/">2014/12/04/</a></li>
<li>BulkLoadforCREATEINDEX - <a href="http://mysql.taobao.org/monthly/2014/12/07/">2014/12/07/</a></li>
<li>hash_scan算法的实现解析 - <a href="http://mysql.taobao.org/monthly/2014/11/07/">2014/11/07/</a></li>
<li>LOCK_active_mi/LOCK_msp_map优化思路 - <a href="http://mysql.taobao.org/monthly/2017/02/03/">2017/02/03/</a></li>
<li>弱序内存模型导致的死锁问题 - <a href="http://mysql.taobao.org/monthly/2020/01/03/">2020/01/03/</a></li>
<li>UK包含NULL值备库延迟分析 - <a href="http://mysql.taobao.org/monthly/2018/01/04/">2018/01/04/</a></li>
<li>Errorinmunmap()"Cannotallocatememory" - <a href="http://mysql.taobao.org/monthly/2018/01/05/">2018/01/05/</a></li>
<li>字符集相关变量介绍及binlog中字符集相关缺陷分析 - <a href="http://mysql.taobao.org/monthly/2018/01/07/">2018/01/07/</a></li>
<li>信号处理机制分析 - <a href="http://mysql.taobao.org/monthly/2017/10/10/">2017/10/10/</a></li>
<li>showbinarylogs灵异事件 - <a href="http://mysql.taobao.org/monthly/2017/09/03/">2017/09/03/</a></li>
<li>InnoDBcrash - <a href="http://mysql.taobao.org/monthly/2017/06/05/">2017/06/05/</a></li>
<li>5.7mysql_upgrade元数据锁等待 - <a href="http://mysql.taobao.org/monthly/2017/04/10/">2017/04/10/</a></li>
<li>event_scheduler慢日志记错 - <a href="http://mysql.taobao.org/monthly/2017/01/05/">2017/01/05/</a></li>
<li>5.6中ORDERBY+LIMIT错选执行计划 - <a href="http://mysql.taobao.org/monthly/2016/12/08/">2016/12/08/</a></li>
<li>备库1206错误问题说明 - <a href="http://mysql.taobao.org/monthly/2016/07/10/">2016/07/10/</a></li>
<li>left-join多表导致crash - <a href="http://mysql.taobao.org/monthly/2016/05/10/">2016/05/10/</a></li>
<li>并行复制外键约束问题二 - <a href="http://mysql.taobao.org/monthly/2016/04/04/">2016/04/04/</a></li>
<li>MySQL外键异常分析 - <a href="http://mysql.taobao.org/monthly/2015/11/06/">2015/11/06/</a></li>
<li>ORDER/GROUPBY导致mysqldcrash - <a href="http://mysql.taobao.org/monthly/2015/11/08/">2015/11/08/</a></li>
<li>orderbylimit造成优化器选择索引错误 - <a href="http://mysql.taobao.org/monthly/2015/11/10/">2015/11/10/</a></li>
<li>startslavecrash诊断分析 - <a href="http://mysql.taobao.org/monthly/2015/10/05/">2015/10/05/</a></li>
<li>删除索引导致表无法打开 - <a href="http://mysql.taobao.org/monthly/2015/10/06/">2015/10/06/</a></li>
<li>BUG几例 - <a href="http://mysql.taobao.org/monthly/2015/09/03/">2015/09/03/</a></li>
<li>建表过程中crash造成重建表失败 - <a href="http://mysql.taobao.org/monthly/2015/09/05/">2015/09/05/</a></li>
<li>唯一键约束失效 - <a href="http://mysql.taobao.org/monthly/2015/06/02/">2015/06/02/</a></li>
<li>ALTERIGNORETABLE导致主备不一致 - <a href="http://mysql.taobao.org/monthly/2015/06/03/">2015/06/03/</a></li>
<li>任性的normalshutdown - <a href="http://mysql.taobao.org/monthly/2015/06/07/">2015/06/07/</a></li>
<li>5.6与5.5InnoDB不兼容导致crash - <a href="http://mysql.taobao.org/monthly/2015/05/03/">2015/05/03/</a></li>
<li>MySQLDDLBUG - <a href="http://mysql.taobao.org/monthly/2015/05/06/">2015/05/06/</a></li>
<li>临时表操作导致主备不一致 - <a href="http://mysql.taobao.org/monthly/2015/05/08/">2015/05/08/</a></li>
<li>连接断开导致XA事务丢失 - <a href="http://mysql.taobao.org/monthly/2015/04/05/">2015/04/05/</a></li>
<li>GTID下slave_net_timeout值太小问题 - <a href="http://mysql.taobao.org/monthly/2015/04/06/">2015/04/06/</a></li>
<li>Relaylog中GTIDgroup完整性检测 - <a href="http://mysql.taobao.org/monthly/2015/04/07/">2015/04/07/</a></li>
<li>删被引用索引导致crash - <a href="http://mysql.taobao.org/monthly/2015/04/09/">2015/04/09/</a></li>
<li>pidfile丢失问题分析 - <a href="http://mysql.taobao.org/monthly/2015/03/03/">2015/03/03/</a></li>
<li>DROPDATABASE外键约束的GTIDBUG - <a href="http://mysql.taobao.org/monthly/2015/03/06/">2015/03/06/</a></li>
<li>变量修改导致binlog错误 - <a href="http://mysql.taobao.org/monthly/2015/02/07/">2015/02/07/</a></li>
<li>InnoDB自增列重复值问题 - <a href="http://mysql.taobao.org/monthly/2015/01/04/">2015/01/04/</a></li>
<li>mysqlclientcrash一例 - <a href="http://mysql.taobao.org/monthly/2015/01/07/">2015/01/07/</a></li>
<li>设置gtid_purged破坏AUTO_POSITION复制协议 - <a href="http://mysql.taobao.org/monthly/2015/01/08/">2015/01/08/</a></li>
<li>replicatefilter和GTID一起使用的问题 - <a href="http://mysql.taobao.org/monthly/2015/01/09/">2015/01/09/</a></li>
<li>Openedtablesblockreadonly - <a href="http://mysql.taobao.org/monthly/2014/12/08/">2014/12/08/</a></li>
<li>OPTIMIZE不存在的表 - <a href="http://mysql.taobao.org/monthly/2014/11/01/">2014/11/01/</a></li>
<li>SIGHUP导致binlog写错 - <a href="http://mysql.taobao.org/monthly/2014/11/02/">2014/11/02/</a></li>
<li>binlog重放失败 - <a href="http://mysql.taobao.org/monthly/2014/10/03/">2014/10/03/</a></li>
<li>从库OOM - <a href="http://mysql.taobao.org/monthly/2014/10/04/">2014/10/04/</a></li>
<li>崩溃恢复失败 - <a href="http://mysql.taobao.org/monthly/2014/10/05/">2014/10/05/</a></li>
<li>GTID和DELAYED - <a href="http://mysql.taobao.org/monthly/2014/09/01/">2014/09/01/</a></li>
<li>GTID和binlog_checksum - <a href="http://mysql.taobao.org/monthly/2014/09/03/">2014/09/03/</a></li>
<li>auto_increment - <a href="http://mysql.taobao.org/monthly/2014/09/06/">2014/09/06/</a></li>
<li>Count(Distinct)ERROR - <a href="http://mysql.taobao.org/monthly/2014/08/03/">2014/08/03/</a></li>
<li>mysqldumpBUFFEROVERFLOW - <a href="http://mysql.taobao.org/monthly/2014/08/04/">2014/08/04/</a></li>
<li>longsemaphorewaits - <a href="http://mysql.taobao.org/monthly/2014/08/05/">2014/08/05/</a></li>
<li>bug分析两例 - <a href="http://mysql.taobao.org/monthly/2016/09/06/">2016/09/06/</a></li>
<li>ConnectionControl - <a href="http://mysql.taobao.org/monthly/2020/05/08/">2020/05/08/</a></li>
<li>undrop-for-innodb - <a href="http://mysql.taobao.org/monthly/2017/11/01/">2017/11/01/</a></li>
<li>告别frm文件 - <a href="http://mysql.taobao.org/monthly/2014/10/07/">2014/10/07/</a></li>
<li>DDLfastfail - <a href="http://mysql.taobao.org/monthly/2015/01/02/">2015/01/02/</a></li>
<li>MySQL哈希连接实现介绍 - <a href="http://mysql.taobao.org/monthly/2019/11/02/">2019/11/02/</a></li>
<li>5.7中Derivedtable变形记 - <a href="http://mysql.taobao.org/monthly/2017/03/05/">2017/03/05/</a></li>
<li>CTE执行过程与实现原理 - <a href="http://mysql.taobao.org/monthly/2017/02/06/">2017/02/06/</a></li>
<li>审计日志实用案例分析 - <a href="http://mysql.taobao.org/monthly/2016/07/07/">2016/07/07/</a></li>
<li>X-Engine并行扫描 - <a href="http://mysql.taobao.org/monthly/2020/04/03/">2020/04/03/</a></li>
<li>RDS三节点企业版热点组提交 - <a href="http://mysql.taobao.org/monthly/2020/02/03/">2020/02/03/</a></li>
<li>8.0redolog写入性能问题分析 - <a href="http://mysql.taobao.org/monthly/2020/01/04/">2020/01/04/</a></li>
<li>今天你并行了吗？---洞察PolarDB8.0之并行查询 - <a href="http://mysql.taobao.org/monthly/2019/11/01/">2019/11/01/</a></li>
<li>性能分析的大杀器—Optimizertrace - <a href="http://mysql.taobao.org/monthly/2019/11/03/">2019/11/03/</a></li>
<li>X-EngineMySQLRDS用户的新选择 - <a href="http://mysql.taobao.org/monthly/2019/10/04/">2019/10/04/</a></li>
<li>StatementOutline - <a href="http://mysql.taobao.org/monthly/2019/07/01/">2019/07/01/</a></li>
<li>RDSMySQL8.0语句级并发控制 - <a href="http://mysql.taobao.org/monthly/2019/06/02/">2019/06/02/</a></li>
<li>通过ResourceGroup来控制线程计算资源 - <a href="http://mysql.taobao.org/monthly/2019/05/05/">2019/05/05/</a></li>
<li>如何使用C++实现MySQL用户定义函数 - <a href="http://mysql.taobao.org/monthly/2019/02/08/">2019/02/08/</a></li>
<li>MySQL多队列线程池优化 - <a href="http://mysql.taobao.org/monthly/2019/02/09/">2019/02/09/</a></li>
<li>MySQL中的IO共享操作 - <a href="http://mysql.taobao.org/monthly/2019/01/09/">2019/01/09/</a></li>
<li>性能问题多维度诊断 - <a href="http://mysql.taobao.org/monthly/2018/11/08/">2018/11/08/</a></li>
<li>8.0CTE和窗口函数的用法 - <a href="http://mysql.taobao.org/monthly/2018/11/09/">2018/11/09/</a></li>
<li>一个TPC-C测试工具sqlbench使用 - <a href="http://mysql.taobao.org/monthly/2018/07/09/">2018/07/09/</a></li>
<li>难以置信，MySQL也可以无损自由切换 - <a href="http://mysql.taobao.org/monthly/2018/06/03/">2018/06/03/</a></li>
<li>在线收缩UNDOTablespace - <a href="http://mysql.taobao.org/monthly/2018/02/09/">2018/02/09/</a></li>
<li>一个“异常”的索引选择 - <a href="http://mysql.taobao.org/monthly/2017/12/06/">2017/12/06/</a></li>
<li>如何索引JSON字段 - <a href="http://mysql.taobao.org/monthly/2017/12/09/">2017/12/09/</a></li>
<li>什么时候该升级内存规格 - <a href="http://mysql.taobao.org/monthly/2017/11/04/">2017/11/04/</a></li>
<li>分区表基本类型 - <a href="http://mysql.taobao.org/monthly/2017/11/09/">2017/11/09/</a></li>
<li>空间优化 - <a href="http://mysql.taobao.org/monthly/2016/06/08/">2016/06/08/</a></li>
<li>RDS只读实例延迟分析 - <a href="http://mysql.taobao.org/monthly/2016/04/08/">2016/04/08/</a></li>
<li>RDSMySQL线上实例insert慢常见原因分析 - <a href="http://mysql.taobao.org/monthly/2018/09/07/">2018/09/07/</a></li>
<li>8.0 - <a href="http://mysql.taobao.org/monthly/2020/05/05/">2020/05/05/</a></li>
<li>内部XA和组提交 - <a href="http://mysql.taobao.org/monthly/2020/05/07/">2020/05/07/</a></li>
<li>InnoDB读写锁实现分析 - <a href="http://mysql.taobao.org/monthly/2020/04/02/">2020/04/02/</a></li>
<li><code>slowlog</code>与<code>CSV</code>引擎 - <a href="http://mysql.taobao.org/monthly/2019/07/08/">2019/07/08/</a></li>
<li>聚合函数（AggregateFunction）的实现过程 - <a href="http://mysql.taobao.org/monthly/2019/05/02/">2019/05/02/</a></li>
<li>LinkBuf设计与实现 - <a href="http://mysql.taobao.org/monthly/2019/05/08/">2019/05/08/</a></li>
<li>CHECKTABLE实现 - <a href="http://mysql.taobao.org/monthly/2019/03/05/">2019/03/05/</a></li>
<li>8.0Functionalindex的实现过程 - <a href="http://mysql.taobao.org/monthly/2019/02/06/">2019/02/06/</a></li>
<li>Innodb缓冲池刷脏的多线程实现 - <a href="http://mysql.taobao.org/monthly/2018/09/02/">2018/09/02/</a></li>
<li>连接与认证过程 - <a href="http://mysql.taobao.org/monthly/2018/08/07/">2018/08/07/</a></li>
<li>8.0原子DDL的实现过程续 - <a href="http://mysql.taobao.org/monthly/2018/07/02/">2018/07/02/</a></li>
<li>binlogcrashrecovery - <a href="http://mysql.taobao.org/monthly/2018/07/05/">2018/07/05/</a></li>
<li>changemasterto - <a href="http://mysql.taobao.org/monthly/2018/05/09/">2018/05/09/</a></li>
<li>协议模块浅析 - <a href="http://mysql.taobao.org/monthly/2018/04/05/">2018/04/05/</a></li>
<li>InnoDB的readview，回滚段和purge过程简介 - <a href="http://mysql.taobao.org/monthly/2018/03/01/">2018/03/01/</a></li>
<li>原子DDL的实现过程 - <a href="http://mysql.taobao.org/monthly/2018/03/02/">2018/03/02/</a></li>
<li>常用SQL语句的MDL加锁源码分析 - <a href="http://mysql.taobao.org/monthly/2018/02/01/">2018/02/01/</a></li>
<li>权限浅析 - <a href="http://mysql.taobao.org/monthly/2018/02/03/">2018/02/03/</a></li>
<li>新连接的建立 - <a href="http://mysql.taobao.org/monthly/2018/02/07/">2018/02/07/</a></li>
<li>InnoDBLRUList刷脏改进之路 - <a href="http://mysql.taobao.org/monthly/2017/11/05/">2017/11/05/</a></li>
<li>Innodb引擎Redo日志存储格式简介 - <a href="http://mysql.taobao.org/monthly/2017/09/07/">2017/09/07/</a></li>
<li>一条insert语句的执行过程 - <a href="http://mysql.taobao.org/monthly/2017/09/10/">2017/09/10/</a></li>
<li>MySQLreplicationpartialtransaction - <a href="http://mysql.taobao.org/monthly/2017/08/03/">2017/08/03/</a></li>
<li>mysql认证阶段漫游 - <a href="http://mysql.taobao.org/monthly/2017/08/05/">2017/08/05/</a></li>
<li>内存分配机制 - <a href="http://mysql.taobao.org/monthly/2017/08/06/">2017/08/06/</a></li>
<li>SHUTDOWN过程 - <a href="http://mysql.taobao.org/monthly/2017/08/09/">2017/08/09/</a></li>
<li>InnoDB异步IO工作流程 - <a href="http://mysql.taobao.org/monthly/2017/07/10/">2017/07/10/</a></li>
<li>Tokudb序列化和反序列化过程 - <a href="http://mysql.taobao.org/monthly/2017/06/01/">2017/06/01/</a></li>
<li>InnoDBRepeatableRead隔离级别之大不同 - <a href="http://mysql.taobao.org/monthly/2017/06/07/">2017/06/07/</a></li>
<li>MySQL半同步复制数据一致性分析 - <a href="http://mysql.taobao.org/monthly/2017/04/01/">2017/04/01/</a></li>
<li>MySQLBINLOG半同步复制数据安全性分析 - <a href="http://mysql.taobao.org/monthly/2017/03/07/">2017/03/07/</a></li>
<li>词法分析及其性能优化 - <a href="http://mysql.taobao.org/monthly/2017/02/04/">2017/02/04/</a></li>
<li>无法revoke单库或单表权限 - <a href="http://mysql.taobao.org/monthly/2016/10/06/">2016/10/06/</a></li>
<li>QueryCache并发处理 - <a href="http://mysql.taobao.org/monthly/2016/08/09/">2016/08/09/</a></li>
<li>网络通信模块浅析 - <a href="http://mysql.taobao.org/monthly/2016/07/04/">2016/07/04/</a></li>
<li>QueryCache内部剖析 - <a href="http://mysql.taobao.org/monthly/2016/07/09/">2016/07/09/</a></li>
<li>InnoDB伙伴内存分配系统实现分析 - <a href="http://mysql.taobao.org/monthly/2020/09/04/">2020/09/04/</a></li>
<li>PerconaXtraBackup备份原理 - <a href="http://mysql.taobao.org/monthly/2016/03/07/">2016/03/07/</a></li>
<li>一些流行引擎存储格式简介 - <a href="http://mysql.taobao.org/monthly/2017/10/04/">2017/10/04/</a></li>
<li>InnoDB对binlog_format的限制 - <a href="http://mysql.taobao.org/monthly/2018/08/04/">2018/08/04/</a></li>
<li>8.0对WAL的设计修改 - <a href="http://mysql.taobao.org/monthly/2018/06/01/">2018/06/01/</a></li>
<li>8.0WriteSet并行复制 - <a href="http://mysql.taobao.org/monthly/2018/06/04/">2018/06/04/</a></li>
<li>MySQL8.0资源组(ResourceGroups) - <a href="http://mysql.taobao.org/monthly/2018/05/03/">2018/05/03/</a></li>
<li>MySQL的预编译功能 - <a href="http://mysql.taobao.org/monthly/2018/04/07/">2018/04/07/</a></li>
<li>(deleted)临时空间 - <a href="http://mysql.taobao.org/monthly/2018/04/08/">2018/04/08/</a></li>
<li>innodb_buffer_pool_size在线修改 - <a href="http://mysql.taobao.org/monthly/2018/03/06/">2018/03/06/</a></li>
<li>LOGICAL_CLOCK并行复制原理及实现分析 - <a href="http://mysql.taobao.org/monthly/2017/12/03/">2017/12/03/</a></li>
<li>MySQL5.7外部XAReplication实现及缺陷分析 - <a href="http://mysql.taobao.org/monthly/2017/11/06/">2017/11/06/</a></li>
<li>数据一样checksum不一样 - <a href="http://mysql.taobao.org/monthly/2017/10/08/">2017/10/08/</a></li>
<li>浅谈MySQL5.7XA事务改进 - <a href="http://mysql.taobao.org/monthly/2017/09/05/">2017/09/05/</a></li>
<li>利用gdb跟踪MDL加锁过程 - <a href="http://mysql.taobao.org/monthly/2017/09/06/">2017/09/06/</a></li>
<li>到底是谁执行了FTWL - <a href="http://mysql.taobao.org/monthly/2017/08/04/">2017/08/04/</a></li>
<li>commontableexpression - <a href="http://mysql.taobao.org/monthly/2017/04/05/">2017/04/05/</a></li>
<li>5.7errorlog时区和系统时区不同 - <a href="http://mysql.taobao.org/monthly/2017/01/09/">2017/01/09/</a></li>
<li>直方图的实现与分析 - <a href="http://mysql.taobao.org/monthly/2016/10/09/">2016/10/09/</a></li>
<li>执行计划缓存设计与实现 - <a href="http://mysql.taobao.org/monthly/2016/09/04/">2016/09/04/</a></li>
<li>MySQL5.7新特性系列四 - <a href="http://mysql.taobao.org/monthly/2016/08/01/">2016/08/01/</a></li>
<li>MyRocks简介 - <a href="http://mysql.taobao.org/monthly/2016/08/03/">2016/08/03/</a></li>
<li>MySQL5.7新特性系列三 - <a href="http://mysql.taobao.org/monthly/2016/07/01/">2016/07/01/</a></li>
<li>5.7代价模型浅析 - <a href="http://mysql.taobao.org/monthly/2016/07/02/">2016/07/02/</a></li>
<li>innodb锁分裂继承与迁移 - <a href="http://mysql.taobao.org/monthly/2016/06/01/">2016/06/01/</a></li>
<li>MySQL5.7新特性系列二 - <a href="http://mysql.taobao.org/monthly/2016/06/02/">2016/06/02/</a></li>
<li>内部临时表 - <a href="http://mysql.taobao.org/monthly/2016/06/07/">2016/06/07/</a></li>
<li>MySQL5.7新特性系列一 - <a href="http://mysql.taobao.org/monthly/2016/05/02/">2016/05/02/</a></li>
<li>innodbbufferpool相关特性 - <a href="http://mysql.taobao.org/monthly/2016/05/04/">2016/05/04/</a></li>
<li>InnoDBtransactionhistory - <a href="http://mysql.taobao.org/monthly/2016/02/03/">2016/02/03/</a></li>
<li>线程池 - <a href="http://mysql.taobao.org/monthly/2016/02/09/">2016/02/09/</a></li>
<li>优化器MRR&amp;BKA - <a href="http://mysql.taobao.org/monthly/2016/01/04/">2016/01/04/</a></li>
<li>droptable的优化 - <a href="http://mysql.taobao.org/monthly/2016/01/07/">2016/01/07/</a></li>
<li>IndexConditionPushdown(ICP) - <a href="http://mysql.taobao.org/monthly/2015/12/08/">2015/12/08/</a></li>
<li>企业版特性一览 - <a href="http://mysql.taobao.org/monthly/2015/12/10/">2015/12/10/</a></li>
<li>StatementDigest - <a href="http://mysql.taobao.org/monthly/2015/11/02/">2015/11/02/</a></li>
<li>MDL实现分析 - <a href="http://mysql.taobao.org/monthly/2015/11/04/">2015/11/04/</a></li>
<li>跟踪Metadatalock - <a href="http://mysql.taobao.org/monthly/2015/10/02/">2015/10/02/</a></li>
<li>MySQL权限存储与管理 - <a href="http://mysql.taobao.org/monthly/2015/10/10/">2015/10/10/</a></li>
<li>5.6并行复制恢复实现 - <a href="http://mysql.taobao.org/monthly/2015/09/07/">2015/09/07/</a></li>
<li>5.6并行复制事件分发机制 - <a href="http://mysql.taobao.org/monthly/2015/09/09/">2015/09/09/</a></li>
<li>OnlineDDL工具gh-ost支持阿里云RDS - <a href="http://mysql.taobao.org/monthly/2018/05/02/">2018/05/02/</a></li>
<li>MariaDB10.2前瞻 - <a href="http://mysql.taobao.org/monthly/2016/09/03/">2016/09/03/</a></li>
<li>InnoDBPageCompression - <a href="http://mysql.taobao.org/monthly/2015/08/01/">2015/08/01/</a></li>
<li>MySQL5.6.26ReleaseNote解读 - <a href="http://mysql.taobao.org/monthly/2015/08/03/">2015/08/03/</a></li>
<li>MariaDBInnoDB表空间碎片整理 - <a href="http://mysql.taobao.org/monthly/2015/08/05/">2015/08/05/</a></li>
<li>MySQL内存分配支持NUMA - <a href="http://mysql.taobao.org/monthly/2015/07/06/">2015/07/06/</a></li>
<li>MariaDBRole体系 - <a href="http://mysql.taobao.org/monthly/2015/06/09/">2015/06/09/</a></li>
<li>5.6.23InnoDB相关Bugfix - <a href="http://mysql.taobao.org/monthly/2015/02/02/">2015/02/02/</a></li>
<li>MariaDB10.2GA - <a href="http://mysql.taobao.org/monthly/2017/06/10/">2017/06/10/</a></li>
<li>OracleOpenWorld2016见闻 - <a href="http://mysql.taobao.org/monthly/2016/10/02/">2016/10/02/</a></li>
<li>PerconaLive2016见闻 - <a href="http://mysql.taobao.org/monthly/2016/10/03/">2016/10/03/</a></li>
<li>MariaDBDeveloperMeeting2016 - <a href="http://mysql.taobao.org/monthly/2016/10/04/">2016/10/04/</a></li>
<li>OOW2015总结MySQL篇 - <a href="http://mysql.taobao.org/monthly/2015/11/01/">2015/11/01/</a></li>
<li>AliSQL那些事儿 - <a href="http://mysql.taobao.org/monthly/2016/09/01/">2016/09/01/</a></li>
<li>MySQL的那些网络超时错误 - <a href="http://mysql.taobao.org/monthly/2017/05/04/">2017/05/04/</a></li>
<li>备库Seconds_Behind_Master计算 - <a href="http://mysql.taobao.org/monthly/2016/03/09/">2016/03/09/</a></li>
<li>MySQL锁问题最佳实践 - <a href="http://mysql.taobao.org/monthly/2016/03/10/">2016/03/10/</a></li>
<li>mysqldumptips两则 - <a href="http://mysql.taobao.org/monthly/2016/02/10/">2016/02/10/</a></li>
<li>物理备份死锁分析 - <a href="http://mysql.taobao.org/monthly/2016/01/05/">2016/01/05/</a></li>
<li>GTID不一致分析 - <a href="http://mysql.taobao.org/monthly/2016/01/08/">2016/01/08/</a></li>
<li>MySQL优化器range的代价计算 - <a href="http://mysql.taobao.org/monthly/2015/11/07/">2015/11/07/</a></li>
<li>索引过滤性太差引起CPU飙高分析 - <a href="http://mysql.taobao.org/monthly/2015/10/03/">2015/10/03/</a></li>
<li>openfilelimits - <a href="http://mysql.taobao.org/monthly/2015/08/07/">2015/08/07/</a></li>
<li>外键删除bug分析 - <a href="http://mysql.taobao.org/monthly/2015/07/07/">2015/07/07/</a></li>
<li>浮点型的显示问题 - <a href="http://mysql.taobao.org/monthly/2015/07/10/">2015/07/10/</a></li>
<li>MySQLSort分页 - <a href="http://mysql.taobao.org/monthly/2015/06/04/">2015/06/04/</a></li>
<li>binlogevent中的errorcode - <a href="http://mysql.taobao.org/monthly/2015/06/05/">2015/06/05/</a></li>
<li>InnoDB预读VSOracle多块读 - <a href="http://mysql.taobao.org/monthly/2015/05/04/">2015/05/04/</a></li>
<li>setnames都做了什么 - <a href="http://mysql.taobao.org/monthly/2015/05/07/">2015/05/07/</a></li>
<li>binlog位点刷新策略 - <a href="http://mysql.taobao.org/monthly/2015/05/10/">2015/05/10/</a></li>
<li>UPDATE交换列单表和多表的区别 - <a href="http://mysql.taobao.org/monthly/2015/04/08/">2015/04/08/</a></li>
<li>GTID下auto_position=0时数据不一致 - <a href="http://mysql.taobao.org/monthly/2015/04/10/">2015/04/10/</a></li>
<li>并发Replaceinto导致的死锁分析 - <a href="http://mysql.taobao.org/monthly/2015/03/01/">2015/03/01/</a></li>
<li>usingfilesortVSusingtemporary - <a href="http://mysql.taobao.org/monthly/2015/03/04/">2015/03/04/</a></li>
<li>lower_case_table_names使用问题 - <a href="http://mysql.taobao.org/monthly/2015/03/07/">2015/03/07/</a></li>
<li>InnoDB丢失自增值 - <a href="http://mysql.taobao.org/monthly/2015/02/05/">2015/02/05/</a></li>
<li>5.5和5.6时间类型兼容问题 - <a href="http://mysql.taobao.org/monthly/2015/02/06/">2015/02/06/</a></li>
<li>binlogevent有序性 - <a href="http://mysql.taobao.org/monthly/2014/12/05/">2014/12/05/</a></li>
<li>server_id为0的Rotate - <a href="http://mysql.taobao.org/monthly/2014/12/06/">2014/12/06/</a></li>
<li>text字段数 - <a href="http://mysql.taobao.org/monthly/2014/10/02/">2014/10/02/</a></li>
<li>key分区算法演变分析 - <a href="http://mysql.taobao.org/monthly/2015/01/06/">2015/01/06/</a></li>
<li>5.6GTID和存储引擎那会事 - <a href="http://mysql.taobao.org/monthly/2014/12/02/">2014/12/02/</a></li>
<li>GTID和升级 - <a href="http://mysql.taobao.org/monthly/2017/05/08/">2014/09/02/</a></li>
<li>索引篇 - <a href="http://mysql.taobao.org/monthly/2017/02/05/">2017/02/05/</a></li>
</ol>
]]></content>
      <categories>
        <category>资源推荐</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>资源推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（三）：ArrayList</title>
    <url>/2020/12/02/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AArrayList/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>ArrayList 是 List 接口下一个基于可扩展数组的实现类，它和它的兄弟类 Vector 有着一样的继承关系，也都能随机访问，但是不同的是不能保证线程安全。</p>
<blockquote>
<p>这是关于 java 集合类源码的第三篇文章。往期文章：</p>
<ol type="1">
<li><a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a><br>
</li>
<li><a href="https://blog.xiajibagao.top/2020/11/27/java/集合类源码分析/java集合源码分析（二）：List与AbstractList/">java集合源码分析（二）：List与AbstractList</a></li>
</ol>
</blockquote>
<h2 id="一-arraylist-的类关系">一、ArrayList 的类关系</h2>
<figure>
<img src="http://img.xiajibagao.top/image-20201201161347920.png" alt="image-20201201161347920"><figcaption aria-hidden="true">image-20201201161347920</figcaption>
</figure>
<p>ArrayList 实现了三个接口，继承了一个抽象类，其中 Serializable ，Cloneable 与 RandomAccess 接口都是用于标记的空接口，他的主要抽象方法来自于 List，一些实现来自于 AbstractList。</p>
<h3 id="1abstractlist-与-list">1.AbstractList 与 List</h3>
<p>ArrayList 实现了 List 接口，是 List 接口的实现类之一，他通过继承抽象类 AbstractList 获得的大部分方法的实现。</p>
<p>比较特别的是，理论上父类 AbstractList 已经实现类 AbstractList 接口，那么理论上 ArrayList 就已经可以通过父类获取 List 中的抽象方法了，不必再去实现 List 接口。</p>
<p>网上关于这个问题的答案众说纷纭，有说是为了通过共同的接口便于实现 JDK 代理，也有说是为了代码规范性与可读性的，在 Stack Overflow 上 <a href="https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete">Why does LinkedHashSet extend HashSet and implement Set</a> 一个据说问过原作者的老哥给出了一个 <code>it was a mistake</code> 的回答，但是这似乎不足以解释为什么几乎所有的容器类都有类似的行为。事实到底是怎么回事，也许只有真正的原作者知道了。</p>
<h3 id="2randomaccess">2.RandomAccess</h3>
<p>RandomAccess 是一个标记性的接口，实现了此接口的集合是允许被随机访问的。</p>
<p>根据 JavaDoc 的说法，如果一个类实现了此接口，那么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=list.size(); i &lt; n; i++)</span><br><span class="line">    list.get(i);</span><br></pre></td></tr></table></figure>
<p>要快于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator i=list.iterator(); i.hasNext(); )</span><br><span class="line">    i.next();</span><br></pre></td></tr></table></figure>
<p>随机访问其实就是根据下标访问，以 LinkedList 和 ArrayList 为例，LinkedList 底层实现是链表，随机访问需要遍历链表，复杂度为 O(n)，而 ArrayList 底层实现为数组，随机访问直接通过下标去寻址就行了，复杂度是O(1)。</p>
<p>当我们需要指定迭代的算法的时候，可以通过实现类是否实现了 RandomAccess 接口来选择对应的迭代方式。在一些方法操作集合的方法里（比如 AbstractList 中的 subList），也根据这点做了一些处理。</p>
<h3 id="3cloneable">3.Cloneable</h3>
<p>Cloneable 接口表示它的实现类是可以被拷贝的，根据 JavaDoc 的说法：</p>
<blockquote>
<p>一个类实现Cloneable接口，以表明该通过Object.clone()方法为该类的实例进行逐域复制是合法的。</p>
<p>在未实现Cloneable接口的实例上调用Object的clone方法会导致抛出CloneNotSupportedException异常。</p>
<p>按照约定，实现此接口的类应使用公共方法重写Object.clone()。</p>
</blockquote>
<p>简单的说，如果一个类想要使用<code>Object.clone()</code>方法以实现对象的拷贝，那么这个类需要实现 Cloneable 接口并且重写 <code>Object.clone()</code>方法。值得一提的是，<code>Object.clone()</code>默认提供的拷贝是浅拷贝，浅拷贝实际上没有拷贝并且创建一个新的实例，通过浅拷贝获得的对象变量其实还是指针，指向的还是原来那个内存地址。深拷贝的方法需要我们自己提供。</p>
<h3 id="4serializable">4.Serializable</h3>
<p>Serializable 接口也是一个标记性接口，他表明实现类是可以被序列化与反序列化的。</p>
<p>这里提一下序列化的概念。</p>
<blockquote>
<p>序列化是指把一个 Java 对象变成二进制内容的过程，本质上就是把对象转为一个 byte[] 数组，反序列化同理。</p>
<p>当一个 java 对象序列化以后，就可以得到的 byte[] 保存到文件中，或者把 byte[] 通过网络传输到远程，这样就相当于把 Java 对象存储到文件或者通过网络传输出去了。</p>
</blockquote>
<p>值得一提的是，针对一些不希望被存储到文件，或者以字节流的形式被传输的私密信息，java 提供了 transient 关键字，被其标记的属性不会被序列化。比如在 AbstractList 里，之前提到的并发修改检查中用于记录结构性操作次数的变量 <code>modCount</code>，还有下面要介绍到的 ArrayList 的底层数组 elementData 就是被 transient 关键字修饰的。</p>
<p>更多的内容可以参考大佬的博文：<a href="https://www.cnblogs.com/lanxuezaipiao/p/3369962.html">Java transient关键字使用小记</a></p>
<h2 id="二-成员变量">二、成员变量</h2>
<p>在 ArrayList 中，一共有四个常量，两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空实例的共享空数组实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享的空数组实例，用于默认大小的空实例。我们将此与EMPTY_ELEMENTDATA区别开来，以了解添加第一个元素时要扩容数组到多大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储ArrayList的元素的数组缓冲区。 ArrayList的容量是此数组缓冲区的长度。添加第一个元素时，任何符合</span></span><br><span class="line"><span class="comment"> * elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空ArrayList都将扩展为DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的大小（它包含的元素数）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>我们来一个一个的解释他们的作用。</p>
<h3 id="1serialversionuid">1.serialVersionUID</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br></pre></td></tr></table></figure>
<p>用于序列化检测的 UUID，我们可以简单的理解他的作用：</p>
<blockquote>
<p>当序列化以后，serialVersionUID 会被一起写入文件，当反序列化的时候，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。</p>
</blockquote>
<p>更多内容仍然可以参考大佬的博文：<a href="https://www.cnblogs.com/duanxz/p/3511695.html">java类中serialversionuid 作用 是什么?举个例子说明</a></p>
<h3 id="2default_capacity">2.DEFAULT_CAPACITY</h3>
<p>默认容量，如果实例化的时候没有在构造方法里指定初始容量大小，第一个扩容就会根据这个值扩容。</p>
<h3 id="3empty_elementdata">3.EMPTY_ELEMENTDATA</h3>
<p>一个空数组，<strong>当调用构造方法的时候指定容量为0</strong>，或者其他什么操作会导致集合内数组长度变为0的时候，就会直接把空数组赋给集合实际用于存放数据的数组 <code>elementData</code>。</p>
<h3 id="4defaultcapacity_empty_elementdata">4.DEFAULTCAPACITY_EMPTY_ELEMENTDATA</h3>
<p>也是一个空数组，不同于 <code>EMPTY_ELEMENTDATA</code> 是指定了容量为0的时候会被赋给elementData，而<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>是在不指定容量的时候才会被赋给 <code>elementData</code>，而且添加第一个元素的时候就会被扩容。</p>
<p><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和 <code>EMPTY_ELEMENTDATA</code>都不影响实际后续往里头添加元素，两者主要表示一个逻辑上的区别：前者表示集合目前为空，但是以后可能会添加元素，而后者表示这个集合一开始就没打算存任何东西，是个容量为0的空集合。</p>
<h3 id="5elementdata">5.elementData</h3>
<p>实际存放数据的数组，当扩容或者其他什么操作的时候，会先把数据拷贝到新数组，然后让这个变量指向新数组。</p>
<h3 id="6size">6.size</h3>
<p>集合中的元素数量（注意不是数组长度）。</p>
<h3 id="7max_array_size">7.MAX_ARRAY_SIZE</h3>
<p>允许的最大数组长度，之所以等于 <code>Integer.MAX_VALUE - 8</code>，是为了防止在一些虚拟机中数组头会被用于保持一些其他信息。</p>
<h2 id="三-构造方法">三、构造方法</h2>
<p>ArrayList 中提供了三个构造方法：</p>
<ul>
<li><code>ArrayList()</code></li>
<li><code>ArrayList(int initialCapacity)</code></li>
<li><code>ArrayList(Collection&lt;? extends E&gt; c)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.构造一个空集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.构造一个具有指定初始容量的空集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断指定的初始容量是否大于0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若大于0，则直接指定elementData数组的长度</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 若等于0，将EMPTY_ELEMENTDATA赋给elementData</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小于0，抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.构造一个包含指定集合所有元素的集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">// 判断传入的集合是否为空集合</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 确认转为的集合底层实现是否也是Objcet数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是空集合，将EMPTY_ELEMENTDATA赋给elementData</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一般使用比较多的是第一种，有时候会用第三种，实际上，如果我们可以估计到实际会添加多少元素，就可以使用第二种构造器指定容量，避免扩容带来的消耗。</p>
<h2 id="四-扩容缩容">四、扩容缩容</h2>
<p>ArrayList 的可扩展性是它最重要的特性之一，在开始了解其他方法前，我们需要先了解一下 ArrayList 是如何实现扩容和缩容的。</p>
<h3 id="0systemarraycopy">0.System.arraycopy()</h3>
<p>在这之前，我们需要理解一下扩容缩容所依赖的核心方法 <code>System.arraycopy()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从一个源数组复制元素到另一个数组，如果该数组指定位置已经有元素，就使用复制过来的元素替换它</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 要复制的源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos 要从源数组哪个下标开始复制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 要被移入元素的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos  要从被移入元素数组哪个下标开始替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 复制元素的个数</span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line">arraycopy(Object src,  <span class="keyword">int</span>  srcPos,</span><br><span class="line">          Object dest, <span class="keyword">int</span> destPos,</span><br><span class="line">          <span class="keyword">int</span> length)</span><br></pre></td></tr></table></figure>
<p>我们举个例子，假如我们现在有 <code>arr1 = &#123;1,2,3,4,5&#125;</code>和 <code>arr2 = &#123;6,7,8,9,10&#125;</code>，现在我们使用 <code>arraycopy(arr1, 0, arr2, 0, 2)</code>，则意为：</p>
<p>使用从 arr1 索引为 0 的元素开始，复制 2 个元素，然后把这两个元素从 arr2 数组中索引为 0 的地方开始替换原本的元素，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">System.arraycopy(arr1, <span class="number">0</span>, arr2, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// arr2 = &#123;1，2，8，9，10&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="1扩容">1.扩容</h3>
<p>虽然在 AbstractCollection 抽象类中已经有了简单的扩容方法 <code>finishToArray()</code>，但是 ArrayList 没有继续使用它，而是自己重新实现了扩容的过程。ArrayList 的扩容过程一般发生在新增元素上。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201201194637410.png" alt="会引起ArrayList扩容的方法"><figcaption aria-hidden="true">会引起ArrayList扩容的方法</figcaption>
</figure>
<p>我们以 <code>add()</code> 方法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断新元素加入后，集合是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（1）检查是否初次扩容</strong></p>
<p>我们知道，在使用构造函数构建集合的时候，如果未指定初始容量，则内部数组 <code>elementData</code> 会被赋上默认空数组 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。</p>
<p>因此，当我们调用 <code>add()</code>时，会先调用 <code>ensureCapacityInternal()</code>方法判断<code>elementData</code> 是否还是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，<strong>如果是，说明创建的时候没有指定初始容量，而且没有被扩容过</strong>，因此要保证集合被扩容到10或者更大的容量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否还是初始状态</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 扩容到默认容量（10）或更大</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（2）检查是否需要扩容</strong></p>
<p>当决定好了第一次扩容的大小，或者<code>elementData</code>被扩容过最少一次以后，就会进入到扩容的准备过程<code>ensureExplicitCapacity()</code>，在这个方法中，<strong>将会增加操作计数器<code>modCount</code>，并且保证新容量要比当前数组长度大</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩容也是结构性操作，modCount+1</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断最小所需容量是否大于当前底层数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）扩容</strong></p>
<p>最后进入真正的扩容方法 <code>grow()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 旧容量为数组当前长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新容量小于最小所需容量（size + 1），就以最小所需容量作为新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量大于允许的最大容量，就再判断能否再继续扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩容完毕，将旧数组的数据拷贝到新数组上</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可能有人会有疑问，为什么<code>oldCapacity</code>要等于<code>elementData.length</code>而不可以是 <code>size()</code>呢？</p>
<p>因为在 ArrayList，既有需要彻底移除元素并新建数组的真删除，也有只是对应下标元素设置为 null 的假删除，<strong><code>size()</code>实际计算的是有元素个数</strong>，因此这里需要使用<code>elementData.length</code>来了解数组的真实长度。</p>
<p>回到扩容，由于 <code>MAX_ARRAY_SIZE</code>已经是理论上允许的最大扩容大小了，如果新容量比<code>MAX_ARRAY_SIZE</code>还大，那么就涉及到一个临界扩容大小的问题，<code>hugeCapacity()</code>方法被用于决定<strong>最终允许的容量大小</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否发生溢出</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError</span><br><span class="line">        (<span class="string">&quot;Required array size too large&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断最终大小是MAX_ARRAY_SIZE还是Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 的 <code>hugeCapacity()</code>与 <code>AbstractCollection</code>抽象类中的 <code>hugeCapacity()</code>是完全一样的，当 <code>minCapacity &gt; MAX_ARRAY_SIZE</code>的情况成立的时候，说明现在的当前元素个数<code>size</code>容量已经等于 <code>MAX_ARRAY_SIZE</code>，数组已经极大了，这个时候再进行拷贝操作会非常消耗性能，因此最后一次扩容会直接扩到 <code>Integer.MAX_VALUE</code>，如果再大就只能溢出了。</p>
<p>以下是扩容的流程图：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201202203515729.png" alt="ArrayList 的扩容流程"><figcaption aria-hidden="true">ArrayList 的扩容流程</figcaption>
</figure>
<h3 id="2缩容">2.缩容</h3>
<p>除了扩容，ArrayList 还提供了缩容的方法 <code>trimToSize()</code>，但是这个方法不被任何其他内部方法调用，只能由程序猿自己去调用，主动让 ArrayList 瘦身，因此在日常使用中并不是很常见。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结构性操作，modCount+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 判断当前元素个数是否小于当前底层数组的长度</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        <span class="comment">// 如果长度为0，就变为EMPTY_ELEMENTDATA空数组</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            <span class="comment">// 否则就把容量缩小为当前的元素个数</span></span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3测试">3.测试</h3>
<p>我们可以借助反射，来看看 ArrayList 的扩容和缩容过程：</p>
<p>先写一个通过反射获取 elementData 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getEleSize</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        Field ele = list.getClass().getDeclaredField(<span class="string">&quot;elementData&quot;</span>);</span><br><span class="line">        ele.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object[] arr = (Object[]) ele.get(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前elementData数组的长度：&quot;</span> + arr.length);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实验看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次扩容</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getEleSize(list); <span class="comment">// 当前elementData数组的长度：0</span></span><br><span class="line">    list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    getEleSize(list); <span class="comment">// 当前elementData数组的长度：10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定初始容量为0的集合，进行第一次扩容</span></span><br><span class="line">    ArrayList&lt;String&gt; emptyList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">    getEleSize(emptyList); <span class="comment">// 当前elementData数组的长度：0</span></span><br><span class="line">    emptyList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    getEleSize(emptyList); <span class="comment">// 当前elementData数组的长度：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容1.5倍</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getEleSize(list); <span class="comment">// 当前elementData数组的长度：15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩容</span></span><br><span class="line">    list.trimToSize();</span><br><span class="line">    getEleSize(list);<span class="comment">// 当前elementData数组的长度：11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-添加-获取">五、添加 / 获取</h2>
<h3 id="1add">1.add</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果需要就先扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 添加到当前位置的下一位</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若 index &gt; size || index &lt; 0 则抛 IndexOutOfBoundsException 异常</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 如果需要就先扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 把原本 index 下标以后的元素集体后移一位,为新插入的数组腾位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加的原理比较简单，实际上就是如果不指定下标就插到数组尾部，否则就先创建一个新数组，然后把旧数组的数据移动到新数组，并且在这个过程中提前在新数组上留好要插入的元素的空位，最后再把元素插入数组。后面的增删操作基本都是这个原理。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201202134807874.png" alt="ArrayList 的新增"><figcaption aria-hidden="true">ArrayList 的新增</figcaption>
</figure>
<h3 id="2addall">2.addAll</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将新集合的数组取出</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 如有必要就扩容</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);</span><br><span class="line">    <span class="comment">// 将新数组拼接到原数组的尾部</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">// 先扩容</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要移动原数组</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 则将原本 index 下标以后的元素移到 index + numNew 的位置</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3get">3.get</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据下标从数组中取值，被使用在get(),set(),remove()等方法中</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-删除-修改">六、删除 / 修改</h2>
<h3 id="1remove">1.remove</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若 index &gt;= size 会抛出 IndexOutOfBoundsException 异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断是否需要移动数组</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 把元素尾部位置设置为null，便于下一次插入</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果要删除的元素是null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="comment">// 移除第一位为null的元素</span></span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果要删除的元素不为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有用到一个<code>fastRemove()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast 的地方在于：跳过边界检查，并且不返回删除的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较有趣的地方在于，<code>remove()</code>的时候检查的是<code>index &gt;= size</code>，而 <code>add()</code>的时候检查的是 <code>index &gt; size || index &lt; 0</code>，可见添加的时候还要看看 index 是否小于0。</p>
<p>原因在于 <code>add()</code>在校验完以后，立刻就会调用<code>System.arraycopy()</code>，由于这是个 native 方法，所以出错不会抛异常；而 <code>remve()</code> 调用完后，会先使用 <code>elementData(index)</code>取值，这时如果 <code>index&lt;0</code> 会直接抛异常。</p>
<h3 id="2clear">2.clear</h3>
<p>比较需要注意的是，相比起<code>remove()</code>方法，<code>clear()</code>只是把数组的每一位都设置为null，<code>elementData</code>的长度是没有改变的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">	<span class="comment">// 把数组每一位都设置为null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3removeall-retainall">3.removeAll / retainAll</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法都依赖于 <code>batchRemove()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.遍历本集合</span></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="comment">// 如果新增集合存在与本集合存在相同的元素，有两种情况</span></span><br><span class="line">            <span class="comment">// 1.removeAll，complement=false：直接跳过该元素</span></span><br><span class="line">            <span class="comment">// 2.retainAll，complement=true：把新元素插入原集合头部</span></span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 2.如果上述操作中发生异常，则判断是否已经完成本集合的遍历</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// 3.将数组剩下的位置都改为null</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述这三个过程可能有点难一点理解，我们假设这是 <code>retailAll()</code>，因此 <code>complement=true</code>，执行流程是这样的：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201202154625429.png" alt="batchRemove 的执行逻辑"><figcaption aria-hidden="true">batchRemove 的执行逻辑</figcaption>
</figure>
<p>同理，如果是<code>removeAll()</code>，那么 w 就会始终为0，最后就会把 elementData 的所有位置都设置为 null。</p>
<p>也就是说，在遍历过程中如果不发生异常，就会跳过第二步，直接进入第三步。</p>
<p>当然，这是没有发生异常的情况，因此遍历完成后 <code>r = size</code>，那么如果遍历到 <code>r = 2</code>，也就是进入 if 分支后，程序发生了异常，尚未完成遍历就进入了 finallly 块，就会先进入第二步，也就是下面的流程：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201202202927612.png" alt="batchRemove 发生异常时的执行逻辑"><figcaption aria-hidden="true">batchRemove 发生异常时的执行逻辑</figcaption>
</figure>
<p>最终数组会变为 {C，C，D，null} ，只有最后一个 D 被删除。</p>
<h3 id="4removeif">4.removeIf</h3>
<p>这个是 JDK8 以后的新增方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="comment">// 遍历集合，同时做并发修改检查</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">        <span class="comment">// 使用 lambda 表达式传入的匿名方法校验元素</span></span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 并发修改检测</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有有需要删除的元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="comment">// 新容量为旧容量-删除元素数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">        <span class="comment">// 把被删除的元素留下的空位“补齐”</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将删除的位置设置为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5set">5.set</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6replaceall">6.replaceAll</h3>
<p>这也是一个 JDK8 新增的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="comment">// 遍历，并使用lambda表达式传入的匿名函数处理每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七-迭代">七、迭代</h2>
<h3 id="1iterator-listiterator">1.iterator / listIterator</h3>
<p>ArrayList 重新实现了自己的迭代器，而不是继续使用 AbstractList 提供的迭代器。</p>
<p>和 AbstracList 一样，ArrayList 实现的迭代器内部类仍然是基础迭代器 Itr 和加强的迭代器 ListItr，他和 AbstractList 中的两个同名内部类基本一样，但是针对 ArrayList 的特性对方法做了一些调整：比如一些地方取消了对内部方法的调用，直接对 elementData 下标进行操作等。</p>
<p>这一块可以参考上篇文章，或者看看源码，这里就不赘述了。</p>
<h3 id="2foreach">2.forEach</h3>
<p>这是一个针对 Collection 的父接口 Iterable 接口中 forEach 方法的重写。在 ArrayList 的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="comment">// 获取 modCount</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历元素并调用lambda表达式处理元素</span></span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历结束后才进行并发修改检测</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3迭代删除存在的问题">3.迭代删除存在的问题</h3>
<p>到目前为止，我们知道有三种迭代方式：</p>
<ul>
<li>使用 <code>iterator()</code>或<code>listIterator()</code>获取迭代器；</li>
<li><code>forEach()</code>；</li>
<li>for 循环。</li>
</ul>
<p>如果我们在循环中删除集合的节点，只有迭代器的方式可以正常删除，其他都会出问题。</p>
<p>或者更准确点说，只要会引起 <code>modCount++</code>的操作，不通过迭代器进行都会出现一些问题。</p>
<p><strong>forEach</strong></p>
<p>我们先试试使用 <code>forEach()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>));</span><br><span class="line">arrayList1.forEach(arrayList1::remove); <span class="comment">// java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>
<p>可见会抛出 <code>ConcurrentModificationException</code>异常，我们回到 <code>forEach()</code>的代码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 modCount</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// 每次循环都要检查并发修改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 遍历结束后才进行并发修改检测</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在方法执行的开始就令 <code>expectedModCount= modCount</code>，遍历过程中每次都要检查 <code>modCount == expectedModCount</code>，这样如果我们<strong>在匿名函数中对元素做了一些结构性操作，导致 <code>modCount</code>增加</strong>，就会在下一次循环判断的时候跳出循环，由于此时<code>modCount != expectedModCount</code>，所以会直接进入 if 分支抛出 <code>ConcurrentModificationException</code>异常。</p>
<p>我们可以验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    list.forEach(s -&gt; &#123;</span><br><span class="line">        list.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">    System.out.println(list); <span class="comment">// [A, B, C, D]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for循环</strong></p>
<p>由于 for 循环过程不像 <code>forEach()</code>那样在循环的结构中进行并发修改检测，因此结构性操作不会出现<code>ConcurrentModificationException</code>，但是<code>remove()</code>会漏删一下元素。我们来验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList1.size(); i++) &#123;</span><br><span class="line">    arrayList1.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(arrayList1); <span class="comment">// [B, D]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，B 和 C 的删除被跳过了。实际上，这个问题和 AbstractList 的迭代器 Itr 中 <code>remove()</code> 方法遇到的问题有点像：</p>
<p>在 AbstractList 的 Itr 中，每次删除都会导致数组的“缩短”，在被删除元素的前一个元素会在 <code>remove()</code>后“补空”，落到被删除元素下标所对应的位置上，也就是说，<strong>假如有 a，b 两个元素，删除了下标为0的元素 a 以后，b 就会落到下标为0的位置</strong>。AbstractList 的 Itr 的解决方案是每次删除都把指向下一个的指针前移，那么 ArrayList 呢？</p>
<p>上文提到 ArrayList 的 <code>remove()</code> 调用了 <code>fastRemove()</code>方法，我们可以看看他是否就是罪魁祸首：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// 如果不是在数组末尾删除</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 数组被缩短了</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见<strong>数组“缩短”确实是导致的元素下标错位就是问题的根源</strong>，实际上，如果不是<code>i &lt; arrayList1.size()</code>在每次循环都会重新获取长度，那么早就抛异常了。</p>
<p>换句话说，如果不调用 <code>System.arraycopy()</code>方法，数组就不会“缩短”，理论上就不会引起这个问题，所以我们不妨试试反向删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>));</span><br><span class="line"><span class="comment">// 反向删除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arrayList1.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    arrayList1.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(arrayList1); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>可见反向删除是没有问题的。</p>
<h2 id="八-其他">八、其他</h2>
<h3 id="1indexof-lastindexof-contains">1.indexOf / lastIndexOf / contains</h3>
<p>相比起 AbstractList ，ArrayList 不再使用迭代器，而是改写成了根据下标进行for循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// indexOf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lastIndexOf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 <code>contains()</code> 方法，由于已经实现了 <code>indexOf()</code>，自然不必继续使用 AbstractCollection 提供的迭代查找了，而是改成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2sublist">2.subList</h3>
<p><code>subList()</code> 和 <code>iterator()</code>一样，也是返回一个特殊的内部类 SubList，在 AbstractList 中也已经有相同的实现，只不过在 ArrayList 里面进行了一些改进，大体逻辑和 AbstractList 中是相似的，这部分内容在前文已经有提到过，这里就不再多费笔墨。</p>
<h3 id="3sort">3.sort</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java 中集合排序要么元素类实现 Comparable 接口，要么自己写一个 Comparator 比较器。这个函数的参数指明了类型是比较器，因此只能传递自定义的比较器，在 JDK8 以后，Comparator 类提供的了一些默认实现，我们可以以类似 <code>Comparator.reverseOrder()</code> 的方式去调用，或者直接用 lambda 表达式传入一个匿名方法。</p>
<h3 id="4toarray">4.toArray</h3>
<p><code>toArray()</code> 方法在 AbstractList 的父类 AbstractCollection 中已经有过基本的实现，ArrayList 根据自己的情况重写了该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">// 直接返回 elementData 的拷贝</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的素组比本集合的元素数量少</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// 直接返回elementData的拷贝</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    <span class="comment">// 把elementData的0到size的元素覆盖到传入数组</span></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="comment">// 如果传入数组元素比本集合的元素多</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        <span class="comment">// 让传入数组size位置变为null</span></span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5clone">5.clone</h3>
<p>ArrayList 实现了 Cloneable 接口，因此他理当有自己的 <code>clone()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Object.clone()拷贝ArrayList</span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 拷贝</span></span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是， <code>Object.clone()</code>是浅拷贝， <code>Arrays.copyOf()</code>也是浅拷贝，因此我们拷贝出来的 ArrayList 不同，内部的 elementData 不同，但是 elementData 中的数据，也就是容器中的数据还是相同的。我们举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;MyBean&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="keyword">new</span> MyBean()));</span><br><span class="line">    ArrayList&lt;MyBean&gt; arrayList2 = (ArrayList&lt;MyBean&gt;) arrayList1.clone();</span><br><span class="line">    System.out.println(arrayList1); <span class="comment">// [$MyBean@782830e]</span></span><br><span class="line">    System.out.println(arrayList2); <span class="comment">// [$MyBean@782830e]</span></span><br><span class="line">    System.out.println(arrayList1 == arrayList2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    arrayList1.add(<span class="keyword">new</span> MyBean());</span><br><span class="line">    System.out.println(arrayList1); <span class="comment">// [MyBean@782830e, $MyBean@470e2030]</span></span><br><span class="line">    arrayList2.add(<span class="keyword">new</span> MyBean());</span><br><span class="line">    System.out.println(arrayList2); <span class="comment">// [$MyBean@782830e, $MyBean@3fb4f649]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6isempty">6.isEmpty</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九-总结">九、总结</h2>
<p><strong>数据结构</strong></p>
<p>ArrayList 底层是 Object[] 数组，被 RandomAccess 接口标记，具有根据下标高速随机访问的功能；</p>
<p><strong>扩容缩容</strong></p>
<p>ArrayList 扩容是扩大1.5倍，只有构造方法指定初始容量为0时，才会在第一次扩容出现小于10的容量，否则第一次扩容后的容量必然大于等于10；</p>
<p>ArrayList 有缩容方法<code>trimToSize()</code>，但是自身不会主动调用。当调用后，容量会缩回实际元素数量，最小会缩容至默认容量10；</p>
<p>ArrayList 的添加可能会因为扩容导致数组“膨胀”，同理，不是所有的删除都会引起数组“缩水”：当删除的元素是队尾元素，或者<code>clear()</code>方法都只会把下标对应的地方设置为null，而不会真正的删除数组这个位置；</p>
<p><strong>迭代中的操作</strong></p>
<p>ArrayList 在循环中删除——准确的讲，是任何会引起 <code>modCount</code>变化的结构性操作——可能会引起意外：</p>
<ul>
<li><p>在 <code>forEach()</code>删除元素会抛<code>ConcurrentModificationException</code>异常，因为 <code>forEach()</code>在循环开始前就获取了 <code>modCount</code>，每次循环都会比较旧 <code>modCount</code>和最新的 <code>modCount</code>，如果循环进行了会使<code>modCount</code>变动的操作，就会在下一次循环开始前抛异常；</p></li>
<li><p>在 for 循环里删除实际上是以步长为2对节点进行删除，因为删除时数组“缩水”导致原本要删除的下一下标对应的节点，却落到了当前被删除的节点对应的下标位置，导致被跳过。</p>
<p>如果从队尾反向删除，就不会引起数组“缩水”，因此是正常的。</p></li>
</ul>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合源码分析（六）：HashMap</title>
    <url>/2020/12/16/java/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AHashMap/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>HashMap 是 Map 接口下一个线程不安全的，基于哈希表的实现类。由于他解决哈希冲突的方式是分离链表法，也就是拉链法，因此他的数据结构是数组+链表，在 JDK8 以后，当哈希冲突严重时，HashMap 的链表会在一定条件下转为红黑树以优化查询性能，因此在 JDK8 以后，他的数据结构是数组+链表+红黑树。</p>
<p>对于 HashMap ，作为集合容器，我们需要关注其数据的存储结构，迭代方式，能否存放空值；作为使用了数组作为底层结构的集合，我们还需要关注其扩容的实现；同时，针对哈希表的特性，我们还需要关注它如何通过哈希算法取模快速定位下标。</p>
<blockquote>
<p>这是关于 java 集合类源码的第六篇文章。往期文章：</p>
<ol type="1">
<li><a href="https://blog.xiajibagao.top/2020/11/25/java/集合类源码分析/java集合源码分析（一）：Collection与AbstractCollection/">java集合源码分析（一）：Collection 与 AbstractCollection</a><br>
</li>
<li><a href="https://blog.xiajibagao.top/2020/11/27/java/集合类源码分析/java集合源码分析（二）：List与AbstractList/">java集合源码分析（二）：List与AbstractList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/02/java/集合类源码分析/java集合源码分析（三）：ArrayList/">java集合源码分析（三）：ArrayList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/03/java/集合类源码分析/java集合源码分析（四）：LinkedList/">java集合源码分析（四）：LinkedList</a></li>
<li><a href="https://blog.xiajibagao.top/2020/12/07/java/集合类源码分析/java集合源码分析（五）：Map与AbstractMap/">java集合源码分析（五）：Map与AbstractMap</a></li>
</ol>
</blockquote>
<h2 id="一-hashmap-的数据结构">一、HashMap 的数据结构</h2>
<p><img src="http://img.xiajibagao.top/image-20201208205304527.png" alt="HashMap的数据结构" style="zoom:67%;"></p>
<p><strong>在 JDK8 之前，HashMap 的数据结构是数组+链表。在 JDK8 以后是数组 + 链表 + 红黑树</strong>。</p>
<p>在 HashMap 中，每一个 value 都被存储在一个 Node 或 TreeNode 实例中，容器中有一个 <code>Node[] table</code> 数组成员变量，数组中的每一格称为一个“桶”。当添加元素时，根据元素的 key 通过哈希值计算得到对应下标，将 Node 类的形式存入“桶”中。如果 table 容量不足时，就会发生扩容，同时对容器内部的元素进行重哈希。</p>
<p>当发生哈希冲突，也就是不同元素计算得到了相同的下标时，会将节点接到“桶”的中的第一个元素后，后续操作亦同，最后就会形成链表。</p>
<p>在 JDK8 以后，由于考虑到<strong>哈希冲突严重时，“桶”中的链表会影响查询效率，因此在一定条件下，链表元素多到一定程度，Node 就会转为 TreeNode，也就是把链表转为红黑树</strong>。</p>
<p>对于红黑树，可以简单理解为不要求严格平衡的平衡二叉树，他保证了查找效率的同时，又保持了较低的的旋转次数。通过这种数据结构，保证了哈希冲突严重的情况下的查找效率。</p>
<h2 id="二-hashmap的成员变量">二、HashMap的成员变量</h2>
<p>由于 HashMap 本身继承了 AbstractMap 抽象类的成员变量，再加上自身的成员变量，以及由于扩容时的重哈希需要的参数，因此 HashMap 的成员变量比较复杂。按照来源以及用途，我们将他的成员变量分为三类：</p>
<h3 id="1来自父类的变量">1.来自父类的变量</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.存放key的Set集合视图，通过 keySet()方法获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.存放value的Collection集合视图，通过values()方法获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>
<h3 id="2自己的变量">2.自己的变量</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.结构更改次数。用于实现并发修改情况下的fast-fail机制，同AbstractList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.集合中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.存放集合中键值对对象Entry的Set集合视图，通过entrySet()获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4.集合中的桶数组。桶即是当链表或者红黑树的容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<h3 id="3扩容相关的变量和常量">3.扩容相关的变量和常量</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.默认初始容量。必须为2的幂，默认为16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.最大容量。不能超过1073741824，即Integer.MAX_VALUE的一半</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.扩容阈值。负载系数与容量的乘积，当元素个数超过该值则扩容。默认为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4.负载系数。当容器内元素数量/容器容量大于等于该值时发生扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5.默认负载系数。未在构造函数中指定则默认为0.75</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6.容器中桶的最小树化阈值。当容器中元素个数大于等于该值时，桶才会发生树化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7.桶的树化阈值。当容器元素个数大于等于MIN_TREEIFY_CAPACITY，并且桶中元素个数大于等于该值以后，将链表转为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8.桶的链化阈值。当桶中元素个数，或者说链表长度小于等于该值以后，将红黑树转为链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<h2 id="三-构造方法">三、构造方法</h2>
<p>HashMap 一共提供了四个构造方法：</p>
<h3 id="1指定容量和负载系数">1.指定容量和负载系数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定初始容量是否小于0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">// 若指定初始容量大于最大容量，则初始容量为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 初始容量是否为小于0或未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 指定初始容量</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 下一扩容大小为loadFactor或最接近的2的幂</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到一个取值的方法 <code>tableSizeFor()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的用于得到指定容量最接近的2的幂，比如传入1会得到2，传入7会得到8。</p>
<h3 id="2只指定容量">2.只指定容量</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用默认负载系数0.75</span></span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3不指定任何系数">3.不指定任何系数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下一扩容大小为默认大小16，其负载系数默认为0.75，初始容量默认为16</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4根据指定map集合构建">4.根据指定Map集合构建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到一个将合并集合的方法 <code>putMapEntries()</code>，<code>putAll()</code>方法也是基于这个方法实现的。由于添加还涉及到扩容以及其他方法，这里暂不介绍，等下面再详细的了解。</p>
<h2 id="四-hashmap的内部类">四、HashMap的内部类</h2>
<p>基于前文<a href="https://blog.xiajibagao.top/2020/12/07/java/集合类源码分析/java集合源码分析（五）：Map与AbstractMap/">java集合源码分析（五）：Map与AbstractMap</a>中第五部分 “AbstractMap 的视图”里对 AbstractMap 的分析，我们知道，HashMap 作为继承了 AbstractMap 的子类，因此它内部会拥有三个集合视图</p>
<ul>
<li>存放 key 的 Set 集合：<code>Set&lt;K&gt; keySet</code></li>
<li>存放 value 的 Collection 集合：<code>Collection&lt;V&gt; valuse</code></li>
<li>存放 Entry 对象的 Set 集合：<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet</code></li>
</ul>
<p>同时还需要一个实现了 Entry 接口的内部类作为 entrySet 的元素使用。</p>
<p>因此 HashMap 作为 AbstractMap 的子类，他最少需要 <code>3种集合视图 + 3种结合视图的迭代器 + Entry 实现类</code> 7种内部类。</p>
<p>实际上，由于 JDK8 以后红黑树和并行迭代的需求，他还需要新增 <code>1种Entry红黑树节点实现 + 3种视图容器对应的并行迭代器</code>2种内部类。</p>
<p>由于针对迭代器和并行迭代器又各提取了一个抽象类，所以 HashMap 中一共会有 ：</p>
<p><code>3种视图容器 + 1种迭代器抽象类 + 3种视图容器的迭代器 + 1种并行迭代器抽象类 + 3种视图容器对应的并行迭代器 + 1种Entry实现类 + 1种Entry的红黑树节点实现类</code></p>
<p>总计 13 种内部类</p>
<h3 id="1-node-treenode">1. Node / TreeNode</h3>
<p><img src="http://img.xiajibagao.top/image-20201208205304527.png" alt="HashMap的数据结构" style="zoom: 50%;"></p>
<p>Node 是 HashMap 中的节点类，在 JDK8 之前对应的是 Entry 类。他是 Map 接口中 Entry 的实现类。</p>
<p>在 HashMap 中数组的每一个位置都是一个“桶”，而“桶”中存放的就是带有数据的节点对象 Node。当哈希冲突时，多个 Node 会在同一个“桶”中形成链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 节点的hashcode</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// key</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// value</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JDK8，当容器中元素数量大于等于64，并且桶中节点大于等于8的时候，会在扩容前触发红黑树化，Node 类会被转变为 TreeNode ，链表会变成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;</span><br><span class="line">    <span class="comment">// 是否为红色节点</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，TreeNode 继承了 LinkedHashMap.Entry 类，但是 LinkedHashMap.Entry 类又继承了 HashMap.Node，因此，实际上 TreeNode 也是 Node 类的子类，这是 Node 转变为 TreeNode 的结构基础。</p>
<p>另外，TreeNode 尽管是树，但是他仍然通过 prev 维持了隐式的链表结构，理论上每一个节点都可以获取他上一次插入的节点，这仍然可以理解为单向链表。</p>
<h3 id="2-keyset-keyiterator">2. KeySet / KeyIterator</h3>
<p><code>Set&lt;K&gt; keySet</code> 是在 AbstractMap 中已经定义好了变量，它是一个存放 key 的集合，HashMap 的哈希算法保证了 key 的唯一性，这恰好也符合 Set 集合的特征。在 HashMap 中，<strong>为其提供了实现类 KeySet</strong> 。</p>
<p>KeySet 继承了 AbstractSet 抽象类，并且直接使用 HashMap 中的方法去实现了抽象类中的大多数抽象方法。值得一提的是，他实现的 <code>iterator()</code><strong>返回的也是 HashMap 的一个内部类 KeyIterator</strong>。</p>
<h3 id="3-values-valueiterator">3. Values / ValueIterator</h3>
<p>和 KeySet 类一样，<strong>Values 也是给 AbstractMap 中的 <code>Collection&lt;V&gt; values</code> 提供的实现类</strong>，他继承了 AbstractCollection 抽象类，并且使用 HashMap 的方法实现了大部分抽象方法。</p>
<p>同样的，它的<code>iterator()</code>返回的也是 HashMap 的一个<strong>内部类 ValueIterator</strong>。</p>
<h3 id="4-entryset-entryiterator">4. EntrySet / EntryIterator</h3>
<p>A<strong>bstractMap 中有一个留给子类去实现的核心抽象方法 <code>entrySet()</code>，而 EntrySet 就是为了实现该方法而创建的类</strong>。它继承了 <code>AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</code>，<strong>表示的是容器中的一对键值对对象</strong>。在注释中，作者将其称为视图。</p>
<p>通过 EntrySet 类，我们就可以<strong>像 Collection 的 toArray 一样，将 Map 以 Set 集合视图的形式表现出来</strong>。</p>
<p>同样的，作为一个 AbstractSet 的实现类，HashMap 也专门为其实现了一个<strong>内部迭代器类 EntryIterator</strong> 。EntrySet 的<code>iterator()</code>方法返回的就是该类。</p>
<h3 id="5-hashiterator">5. HashIterator</h3>
<p>HashIterator 类是一个用于迭代 Node 节点的迭代器抽象类，他也是上述 KeyIterator，ValueIterator，EntryIterator <strong>三种内部迭代器类的父类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然它叫 HashIterator ，但是它并没有实现 <code>Iterator</code>接口，而是让他的子类自己去实现接口。并且只值提供迭代和删除两种功能的三个方法。</p>
<p>此外，他的子类 KeyIterator，ValueIterator，EntryIterator 也非常朴素，只在它的基础上重写包装了一下 <code>nextNode()</code>作为自己的 <code>next()</code>方法，这里不妨也看成适配器的一种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-spliterator">6. Spliterator</h3>
<p>跟 Iterator 一样，HashMap 也提供了 HashMapSpliterator，KeySpliterator，ValueSpliterator，EntrySpliterator 四种并行迭代器。后面三者都是 HashMapSpliterator 的子类。</p>
<h2 id="五-hashmap-获取插入下标">五、HashMap 获取插入下标</h2>
<p>HashMap 是基于哈希表实现的，因此添加元素和扩容时通过哈希算法获取 key 对应的数组下标是整整个类进行添加操作的基础。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-计算哈希值">1. 计算哈希值</h3>
<p>这里涉及到两个方法，一个是计算哈希值的 <code>hash()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是来自知乎大佬一个非常详细的回答：<a href="https://www.zhihu.com/question/20733617/answer/32513376">JDK 源码中 HashMap 的 hash 方法原理是什么？ - 知乎</a>；</p>
<p>这里我简单的概括一下：</p>
<p>该方法实际上是一个“扰动函数”，作用是对<code>Object.hashCode()</code>获取到的 hash 值进行<strong>高低位混淆</strong>。</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201209140746276.png" alt="HashMap的哈希算法"><figcaption aria-hidden="true">HashMap的哈希算法</figcaption>
</figure>
<p>我们可以看到，<strong>符号右移16位后，新二进制数的前16位都为0，后16位就是原始 hashcode 的高16位</strong>。</p>
<p><strong>将原始 hashcode 与 位运算得到的二进制数再进行异或运算以后，我们就得到的 hash 前16全部都为1，后16位则同时混淆了高16位和低16位的特征，进一步增加了随机性。</strong></p>
<p>现在我们得到了 key 的 hashcode，这是计算下标的基础。</p>
<h3 id="2-计算下标">2. 计算下标</h3>
<p>接下来进入<code>putVal()</code>方法，实际上包括 <code>putAll()</code>在内，所有添加/替换元素的方法，都依赖于 <code>putVal()</code>实现。<code>putVal()</code>需要传入 key 的 hash 作为参数，它将根据 hash 值和 key 进行进一步的计算，获取实际 value 要插入的下标。</p>
<p>我们先忽略计算下标以外的其他方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// n 即为当前数组长度</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据 n 与 hash 计算插入下标</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，当通过扰动函数<code>hash()</code>获取到了已经混淆高低位的 key 的 hashcode 以后， <strong>会将其与数组长度-1进行与运算</strong>：<code>(n - 1) &amp; hash</code>。</p>
<p>以默认是容量16为例，它转换为二进制数是 10000，而 （16-1）转换为二进制数就是 1111，补零以后它与 <code>hash()</code> 计算得到的 hashcode 进行与运算过程如下：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201209142455463.png" alt="与运算取模"><figcaption aria-hidden="true">与运算取模</figcaption>
</figure>
<p>在这个过程，之前留下的两个问题就得到了解答：</p>
<h4 id="为什么容量需要是2的幂">为什么容量需要是2的幂？</h4>
<p>我们可以看到，按位的与运算只有 1&amp;1 = 1，<strong>由于数组长度转为二进制只有4位，所有高于4位的位数都为0，因此运算结果高于4位的位置也都会是0，这里巧妙的实现了取模的效果，数组长度起到了低位掩码的作用。这也整是为什么 HashMap 的容量要是2的幂的原因。</strong></p>
<h4 id="为什么要hash要混淆高低位">为什么要<code>hash()</code>要混淆高低位？</h4>
<p>再回头看看 <code>hash()</code>函数，他混合了原始 hashcode 的高位和低位的特征，我们说他增加了随机性，在点要怎么理解呢？</p>
<p>我们举个例子：</p>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>hashCode</th>
<th>不混淆取后四位</th>
<th>混淆后取后四位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>808321199</td>
<td>110000001011100000000010101111</td>
<td>1111</td>
<td>0001</td>
</tr>
<tr class="even">
<td>7015199</td>
<td>11010110000101100011111</td>
<td>1111</td>
<td>0100</td>
</tr>
<tr class="odd">
<td>9999</td>
<td>10011100001111</td>
<td>1111</td>
<td>1111</td>
</tr>
</tbody>
</table>
<p>实际上，由于取模运算最终只看数组长度转成的二进制数的有效位数，也就是说，数组有效位是4位，那么 key 的 hash 就只看4位，如果是18位，那么 hash 就只看18位。</p>
<p>在这种情况下，如果数组够长，那么 hash 有效位够多，散列度就会很好；<strong>但是如果有效位非常短，比如只有4位，那么对于区分度在高位数字的值来说就无法区分开</strong>，比如表格所示的 808321199，7015199，461539999 三个低位相同的数字，最后取模的时候都会被看成 1111，而混合高低位以后就是 0001，0100，1111，这就可以区分开来了。</p>
<h2 id="六-hashmap-添加元素">六、HashMap 添加元素</h2>
<p>在之前获取下标的例子中，我们知道 <code>put()</code>方法依赖于 <code>putVal()</code>方法，事实上，包括 <code>putAll()</code>在内，所有添加元素的方法都需要依赖于 <code>putVal()</code>。</p>
<p>由于添加元素涉及到整个结构的改变，因而 <code>putVal()</code>中除了需要计算下标，还包含扩容，链表的树化与树的链表化在内的多个过程。</p>
<h3 id="1-putval">1. putVal</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前table数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="comment">// 当前数组长度，当前要插入数组位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 若集合未扩容，则进行第一次扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取key对应要插入的下标（即桶）</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 若是桶中没有元素，则添加第一个</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若已经桶中已经存在元素</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 1.插入元素与第一个元素是否有相同key</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key ||</span><br><span class="line">                               (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 2.桶中的链表是否已经转换为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 3.遍历链表，添加到尾端</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 将节点添加到队尾</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 是否需要转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 是否遇到了key相同的节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果key已经存在对应的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 是否要覆盖value</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 空方法，用于LinkedHashMap插入后的回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 空方法，用于LinkedHashMap插入后的回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2链表的树化">2.链表的树化</h3>
<p>在上述过程，涉及到了判断桶中是否已经转为红黑树的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    <span class="comment">// 将Node转为TreeNode，并且添加到红黑树</span></span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br></pre></td></tr></table></figure>
<p>以及将链表转为红黑树的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>
<p>其中，<code>putTreeVal()</code>是添加节点到红黑树的方法，而 <code>treeifyBin()</code>是一个将链表转为红黑树的方法。我们暂且只看看 HashMap 链表是如何转为红黑树的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// table是否小于最小树化阈值64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">// 如果不到64就直接扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 否则看看桶中是否存在元素</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将桶中链表的所有节点Node转为TreeNode</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  如果桶中不为空，就将链表转为红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面过程实现了将链表的节点 Node 转为 TreeNode 的过程，接下来 <code>TreeNode.treeify()</code>方法会真正将链表转为红黑树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">// 获取下一节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 队首元素为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不是队首元素，则构建子节点</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">// 向右</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 向左</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 使用比较器进行比较</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构建子节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 再平衡</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再平衡，保证链表头节点是树的根节点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上是链表树化的过程，虽然实现过程不简单，但是流程很简单：</p>
<ul>
<li>判断是否链表是否大于8；</li>
<li>判断元素总数量是否大于最小树化阈值64；</li>
<li>将原本链表的Node节点转为TreeNode节点；</li>
<li>构建树，添加每一个子节点的时候判断是否需要再平衡;</li>
<li>构建完后，若原本链表的头结点不是树的根节点，则再平衡确保头节点变为根节点</li>
</ul>
<h4 id="链表转为红黑树的条件">链表转为红黑树的条件</h4>
<p>这里我们也理清楚了链表树化的条件：<strong>一个是链表添加完元素后是否大于8，并且当前总元素数量大于64</strong>。</p>
<p>当不满足这个条件的时候，再添加元素就会直接扩容，利用扩容过程中的重哈希来缓解哈希冲突，而不是转为红黑树。</p>
<h3 id="3为什么key可以为null">3.为什么key可以为null</h3>
<p>我们回顾一下 <code>hash()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，这里对 <code>key == null</code>的情况做了处理，当 key 是 null 的时候，哈希值会直接被作为 hash 为 0 的元素看待，在 <code>putVal()</code>中添加元素的时候还会判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key ||</span><br><span class="line">                       (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure>
<p>由于除了比较 hash 值，还会比较内存地址并调用 equals 比较，所以 null 会被筛出来，作为有且仅有一个的 key 使用。</p>
<h2 id="七-hashmap-的扩容">七、HashMap 的扩容</h2>
<p>现在我们知道了 HashMap 是如何计算下标的，也明白了 HashMap 是如何添加元素的，现在我们该了解添加元素过程中，扩容方法 <code>resize()</code>的原理了。</p>
<h3 id="1-resize">1. resize</h3>
<p><code>resize()</code>是 HashMap 的扩容方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 当前容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 上一次的扩容阈值（在上一次扩容时指定）</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新容量，下一次扩容目标容量</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//======一、计算并获取扩容目标大小======</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.若当前容量大于0（即已经扩容过了）</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否大于理论允许最大值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 扩容阈值设置为Integer.MAX_VALUE，本次以后不会再触发扩容</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未达到理论允许最大值，并且：</span></span><br><span class="line">        <span class="comment">// (1)本次扩容目标容量的两边小于理论允许最大值</span></span><br><span class="line">        <span class="comment">// (2)当前容量大于默认初始容量16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 新扩容阈值为当前扩容阈值的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.若本次扩容容量大于0（即还是初始状态，指定了容量，但是是第一次扩容）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 新容量为上一次指定的扩容阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 3.若当前容量和上一次的扩容阈值都为0（即还是初始状态，未指定容量而且也没扩容过）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//======二、根据指定大小扩容======</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据负载系数检验新容量是否可用</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 如果乘上负载系数大于理论允许最大容量，则直接扩容到Integer.MAX_VALUE</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组（桶）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 若桶中不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 重新计算节点在新HashMap桶数组的下标</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果是红黑树,判断是否需要链化</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 判断扩容后是否需要移动位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述过程代码一大串，其实就是确定容量和扩容两个步骤。</p>
<h3 id="2确认扩容大小">2.确认扩容大小</h3>
<h4 id="扩容的时机">扩容的时机</h4>
<p>在了解 HashMap 如何确认扩容大小之前，我们需要明白 HashMap 是什么时候会认为需要扩容。</p>
<p>我们在前面知道了，<strong>value 的下标由 key 的高低位混合后与数组长度-1进行与运算获得</strong>，也就是说，如果数组长度不够大——或者说<strong>容量不够大，就会导致与运算后得到的随机值范围受限，因此更可能造成哈希冲突</strong>。</p>
<p>为此，HashMap 引入负载系数 <code>loadFactor</code>，当不指定时默认为0.75，则有扩容阈值 <code>threshold = 容量*负载系数</code>，<strong>达到扩容阈值——而不是容量大小——的时候就会进行扩容</strong>。</p>
<p>假如我们都使用初始值，即默认容量16，默认负载系数0.75，则第一次扩容后，当元素个数达到 <code>0.75*16=12</code> 时，就会进行一次扩容变为原来的两倍，也就是32，并且将 <code>threshold</code>更新为<code>32*0.75=24</code>。如此反复。</p>
<h4 id="扩容的大小">扩容的大小</h4>
<p>扩容的时候，分为两种情况：已经扩容过，还未扩容过。</p>
<p>我们仅针对获取新容量 <code>newCap</code> 与新扩容阈值 <code>newThr</code> 这段代码逻辑，画出大致流程图：</p>
<p><img src="http://img.xiajibagao.top/未命名文件.jpg" alt="未命名文件" style="zoom:50%;"></p>
<p>这里比较需要注意的是，<strong>当 oldCap 已经大于等于理论最大值的时候，会在设置 <code>newThr=Integer.MAX_VALUE</code>后直接返回，不会执行后序扩容过程</strong>。</p>
<p>另外，当新扩容阈值被设置为 <code>Integer.MAX_VALUE</code>以后，<strong>由于该值已经是最大的整数值了，所以设置为该值以后 HashMap 就不会再触发扩容了</strong>。</p>
<h3 id="3重哈希过程">3.重哈希过程</h3>
<p>我们知道，如果桶数组扩容了，那么数组长度也就变了，那么根据长度与哈希值进行与运算的时候计算出来的下标就不一样。在 JDK7 中 HashMap 扩容移动旧容器的数据的时候，会直接进行重哈希获得新索引，并且打乱所有元素的排布。<strong>而在JDK8进行了优化，只移动部分元素</strong>。</p>
<p>我们可以回去看看扩容部分的代码，其中有这两处判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断扩容后是否需要移动位置</span></span><br><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//... ...</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">        hiHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hiTail.next = e;</span><br><span class="line">    hiTail = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容后移动位置</span></span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面有提到 HashMap 取下标，是通过将 key 的哈希值与长度做与运算，也就是 <code>(n-1) &amp; hash</code>，而这里通过计算 <code>n &amp; hash</code>是否为 0 判断是否需要位移。</p>
<p>他的思路是这样的：</p>
<p>假如从16扩容到32，扩容前通过<code>(n-1) &amp; hash</code> 取模是取后4位，而扩容后取后5位，因为01111和1111没区别，<strong>所以如果多出来这一位是0，那么最后用新长度去与运算得到的坐标是不变的，那么就不用移动</strong>。否则，多出来这一位相当于多了10000，<strong>转为十进制就是在原基础上加16，也就是加上了原桶数组的长度，那么直接在原基础上移动原桶数组长度就行了</strong>。</p>
<p>以初始容量 <code>oldCap = 16,newCap = 32</code> 为例，我们先看看他的换算过程：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>十进制 Cap</th>
<th>二进制 Cap</th>
<th>二进制 Cap-1</th>
<th>十进制 Cap-1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>oldCap</strong></td>
<td>16</td>
<td>10000</td>
<td>1111</td>
<td>15</td>
</tr>
<tr class="even">
<td><strong>newCap</strong></td>
<td>32</td>
<td>100000</td>
<td>11111</td>
<td>31</td>
</tr>
</tbody>
</table>
<p>以上述数据为基础，我们模拟下面三个 key 在扩容过程中的计算：</p>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>hash</th>
<th>(oldCap-1) &amp; hash</th>
<th>oldCap &amp; hash</th>
<th>(newCap-1) &amp; hash</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>808321199</td>
<td>110000001011100000000010101111</td>
<td>1111（15）</td>
<td>0</td>
<td>01111（15）</td>
</tr>
<tr class="even">
<td>7015199</td>
<td>11010110000101100011111</td>
<td>1111（15）</td>
<td>10000</td>
<td>11111（31）</td>
</tr>
<tr class="odd">
<td>9999</td>
<td>10011100001111</td>
<td>1111（15）</td>
<td>0</td>
<td>01111（15）</td>
</tr>
</tbody>
</table>
<p>不难看出，<strong>只有当 <code>oldCap &amp; hash &gt; 0</code>的时候元素才需要移动</strong>，而由于容量必然是2的冥，每次扩容新容量都是旧容量的两倍，换成二进制，相同的 hash 值与运算算出来的坐标总是多1，因此相当于每次需要移动的距离都是旧容量。</p>
<p><strong>也就是说，如果 <code>oldCap &amp; hash &gt; 0</code>，那么就有 <code>新坐标=原下标+oldCap</code></strong>，这个逻辑对应的代码就是 <code>newTab[j + oldCap] = hiHead;</code>这一行。</p>
<p>这样做的好处显而易见，<strong>少移动一些元素可以减少扩容的性能消耗，同时同一桶中的元素也有可能在重哈希之后被移动，使得哈希冲突得以在扩容后减缓，元素散列更均匀。</strong></p>
<h2 id="八-hashmap-获取元素">八、HashMap 获取元素</h2>
<p>和<code>put()</code>方法和 <code>putVal()</code>的关系一样，<code>get()</code>方法以及其他获取元素的方法最终都依赖于 <code>getNode()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-getnode">1. getNode</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 如果桶数组不为空，并且桶中不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果桶中第一个元素的key与要查找的key相同，返回第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果存在后续元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已经转为红黑树，则使用红黑树进行查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 否则遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2为什么元素要同时重写equals和hashcode">2.为什么元素要同时重写equals和hashcode？</h3>
<p>首先，不被原本的的hashCode和equals是这样的</p>
<ul>
<li><code>hashCode()</code>是根据内存地址换算出来的一个值</li>
<li><code>equals()</code> 方法是判断两个对象内存地址是否相等</li>
</ul>
<p>我们回顾一下上文，可以看到无论<code>put()</code>还是<code>get()</code>都会有类似这样的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// putVal</span></span><br><span class="line">p.hash == hash &amp;&amp; ((k = p.key) == key ||</span><br><span class="line">                   (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)));</span><br><span class="line"><span class="comment">// getNode</span></span><br><span class="line">p.hash == hash &amp;&amp; (key != <span class="keyword">null</span> &amp;&amp; key.equals(k));</span><br></pre></td></tr></table></figure>
<p>因为可能存在哈希冲突，或者为 null 的 key，因此所以光判断哈希值是不够的，事实上，当我们试图添加或者找到一个 key 的时候，方法会根据三方面来确定一个唯一的 key：</p>
<ul>
<li>比较 <code>hashCode()</code>是否相等：代码是比较内部 <code>hash()</code>方法算出来的值 hash 是否相等，但是由于该方法内部还是调用 <code>hashCode()</code>，所以实际上是比较的仍然是<code>hashCode()</code>算出来的值；</li>
<li>比较 <code>equlas()</code>是否相等：<code>Object.equlas()</code>方法在不重写的时候，默认比较的是内存地址；</li>
<li>比较 key 是否为 null；</li>
</ul>
<p><strong>为什么要重写equals和hashcode方法？</strong></p>
<p>当我们使用 HashMap 提供的默认的流程时，这三处校验已经足以保证 key 是唯一的。但是这也带来了一些问题，当我们使用一些未重写了 <code>Object.hashCode()</code>或者 <code>Object.equlas()</code>方法的类的实例作为 key 的时候，由于 Object 类中的方法默认比较的都是内存地址，因此必须持有当初作为 key 的实例才能拿到 value。</p>
<p>我们举个例子：</p>
<p>假设我们有一个 Student 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们使用 Student 的实例作为 key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">&quot;xx&quot;</span>,<span class="number">16</span>), <span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">&quot;xx&quot;</span>,<span class="number">16</span>), <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Object, Object&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.print(entry.getValue());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// aa</span></span><br></pre></td></tr></table></figure>
<p>因此，如果我们希望使用对象作为 key，那么大多数时候都需要重写<code>equals()</code>和<code>hashcode()</code>的。</p>
<p><strong>为什么要同时重写两个方法？</strong></p>
<p>这个也很好理解，判断 key 需要把 <code>equals()</code>和<code>hashcode()</code>两个的返回值都判断一遍，<strong>如果只重写其中一个，那么最后还是不会被认为是同一个 key</strong>。</p>
<p>当我们为 Student 重写 <code>equals()</code>和<code>hashcode()</code>以后，结果运行以后输出就是只有一个 a 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.hashCode() + age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> Student &amp;&amp;</span><br><span class="line">        <span class="keyword">this</span>.name.equals(((Student) obj).name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九-hashmap-删除元素">九、HashMap 删除元素</h2>
<p>在 HashMap 中，get，put 和 remove 行为各自都有一个统一的底层方法。在 <code>remove()</code> 中，这个方法就是 <code>removeNode()</code>，所有的删除行为最终都要通过调用它来实现。</p>
<h3 id="1-removenode">1. removeNode</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 若集合不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 若桶中第一个就是目标元素</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 否则遍历链表/树删除节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若找到目标元素，并且确定要删除，就删除节点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 若要删除为红黑树节点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                <span class="comment">// 若要删除节点为链表头结点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2红黑树在删除过程的链化">2.红黑树在删除过程的链化</h3>
<p>在扩容部分我们了解了链表是如何转为红黑树的，事实上红黑树也可以在必要的时候转化为链表。在 <code>removeNode()</code>方法中，可以看到调用了 <code>removeTreeNode()</code>以删除红黑树节点，实际上在这个过程中会发生红黑树的链化。</p>
<p>我们暂且只关注链化的判断条件，也就是在 <code>removeTreeNode()</code>中的这一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根节点为null，根节点的左或右子节点为null，根节点左子节点的左子节点为null</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">    (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果可能存在的最小红黑树如下：</p>
<figure>
<img src="http://img.xiajibagao.top/image-20201217204231973.png" alt="删除中可能存在的最小红黑树"><figcaption aria-hidden="true">删除中可能存在的最小红黑树</figcaption>
</figure>
<p>可以看到，此时树共有四个及节点，需要再删除一个节点才会导致链化，也就是说，在 remove 中，触发链化的最小树可能只有3个节点，而最大树需要考虑到变色和平衡，是十个（待考证）。</p>
<p>也就是说，和网上所说的小于6就链化不同，<strong>在删除中，链化触发值是一个范围，在 [3,10] 之间</strong>。</p>
<h3 id="3红黑树在扩容过程的链化">3.红黑树在扩容过程的链化</h3>
<p>我们知道，扩容经过重哈希有可能会拆分链表，树也一样。在扩容时， <code>split()</code>方法会对红黑树进行拆分，以便重哈希后变更位置，在里头有这么一段逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左头结点不为空，并且长度小于链化阈值 6</span></span><br><span class="line"><span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">    <span class="comment">// 将红黑树转为链表</span></span><br><span class="line">    tab[index] = loHead.untreeify(map);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    tab[index] = loHead;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">        loHead.treeify(tab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在扩容时，是否链化的标准就是<strong>树中元素个数是否小于链化阈值6</strong>。</p>
<h3 id="4为什么会存在两套链化逻辑">4.为什么会存在两套链化逻辑？</h3>
<p>关于为什么要选择不同的链化标准，网上也没有比较确定的答案，这里说说个人的猜测。</p>
<p>首先，不管是树化还是链化都比较消耗性能，应该需要尽量避免的，这个是前提条件。</p>
<p>链表的树化条件决定了当红黑树存在时，容器必然是比较大的，而容量越大，下一次扩容要达到扩容阈值就越难，换句话说，触发扩容的概率就越小。因而扩容本身就是一个低频操作，要在扩容的时候恰好因为重哈希导致树被拆分的概率就更小了，此时链化的判定条件就可以严格点，因此只要小于6就链化。</p>
<p>而删除是一个比较频繁的，而且带有主观意向的操作，很可能你一次删除的多个节点在哈希值刚好是连续的，也就是说，多次删除恰好删除的是同一颗树上的节点的概率是比较大的，因此，判断条件就应该尽可能不那么严格，避免频繁的触发链化。</p>
<h2 id="十-hashmap-的迭代">十、HashMap 的迭代</h2>
<p>由于 Map 集合本质上表示的是一组键值对之间的映射关系，并且 HashMap 的数据结构是数组+链表/树，因此 HashMap 集合并无法直接像 Collection 接口的实现类那样直接迭代。</p>
<p>而在本文的第四部分，我们了解了 HashMap 中的几个主要内部类，其中四大视图类就是其中三个集合视图的 KeySet，Values，EntrySet，与一个键值对视图 Entry。当我们要迭代 HashMap 的时候，就需要通过迭代三个集合视图来实现，并且通过 key，value 或者 Entry 对象来接受迭代得到的对象。</p>
<p>值得一提的是，<strong>和 ArrayList 一样，HashMap 也实现了 fast-fail 机制，因此最好不要在迭代的时候进行结构性操作。</strong></p>
<h3 id="1迭代器迭代">1.迭代器迭代</h3>
<p><strong>所有集合都可以通过迭代器迭代器</strong>（集合的增强 for 循环在编译以后也是迭代器跌迭代）。</p>
<p>所以，在 HashMap 中，三种视图集合都可以通过迭代器或增强 for 循环迭代器，但是 <strong>HashMap 本身虽然有迭代器，但是由于没有 <code>iterator()</code>方法，所以无法通过迭代器或者增强 for 直接迭代，必须通过三种视图集合来实现迭代。</strong></p>
<p>以 EntrySet 视图为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Object, Object&gt; entry = iterator.next();</span><br><span class="line">    System.out.print(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强for迭代，等价于迭代器迭代</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Object, Object&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.print(entry.getValue());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach迭代</span></span><br><span class="line">map.entrySet().forEach(s -&gt; &#123;</span><br><span class="line">    System.out.println(s.getValue());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>KeySet</code> 视图和 <code>values</code>同理，但是 values 是 Collection 集合，所以写法会稍微有点区别。</p>
<h3 id="2视图集合中的数据从何处来">2.视图集合中的数据从何处来</h3>
<p>我们虽然通过 <code>entrySet()</code>，<code>values()</code>和 <code>keySet()</code>三个方法获取了视图集合并且迭代成功了，但是回头看源码，却发现源码中返回的只是一个空集合，里面并没有任何装填数据的操作，但是当我们直接拿到视图集合的时候，却能直接遍历，原因在于他们的迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 获取迭代器返回的node的key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 获取迭代器返回的node的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 获取迭代器返回的node</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>nextNode()</code>方法来自于他们的父类<code>HashIterator</code>，这里需要连着它的构造方法一起看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    Node&lt;K,V&gt;[] t = table;</span><br><span class="line">    current = next = <span class="keyword">null</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取第一个不为空的桶中的第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextNode</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    Node&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="comment">// 接着构造方法获取到的第一个非空桶中的节点，遍历以该节点为头结点的链表</span></span><br><span class="line">    <span class="comment">// 当遍历完，接着查看下一个桶中的节点</span></span><br><span class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个 <strong>HashIterator 就是 HashMap 真正意义上的迭代器</strong>，<strong>它会从桶数组中第一个非空桶的第一个节点开始，迭代完全部桶数组中的每一个节点</strong>。但是它并不直接使用，而是作为而三个视图集合的迭代器的父类。</p>
<p>三个视图集合自己的迭代器通过把<code>HashIterator</code>的<code>nextNode()</code>方法的基础重新适配为 <code>next()</code>，分别把它从返回 Node 节点类变为了返回节点、节点的 key、节点的 value，这就是<strong>集合视图迭代的原理</strong>。</p>
<p>由于 Node 本身就携带了 key，value和 hash，因此删除或者添加就可以直接通过 HashMap 类的方法去操作，<strong>这就是迭代器增删改的原理</strong>。</p>
<h3 id="3-foreach迭代">3. forEach迭代</h3>
<p>HashMap 重写了 forEach() 方法，三个视图集合也自己重写了各自的 <code>forEach()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 若集合不为空</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="comment">// 遍历桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forEach()</code>逻辑与迭代器类似，但是写法更直白，就是遍历桶数组然后遍历桶数组中的链表。三个视图集合的 <code>forEach()</code>写法与 HashMap 的基本一样，这里就不再赘述了。</p>
<h2 id="十一-总结">十一、总结</h2>
<p><strong>结构与扩容</strong></p>
<p>HashMap 底层结构是数组+链表/红黑树。</p>
<p>HashMap 在不指定初始容量和负载系数的时候，默认容量为16，默认负载系数为0.75，扩容阈值为当前容量*负载系数，当容器中的元素数量大于等于扩容阈值的时候就会扩容为原来的两倍。</p>
<p><strong>树化与链化</strong></p>
<p>红黑树的树化一般发生在添加元素的时候。由于扩容本身就可以缓解哈希冲突，因此要让 HashMap 选择树化而不是优先扩容，需要同时满足两个条件：</p>
<ul>
<li>当容器中总元素的数量大于等于64；</li>
<li>添加元素后桶中链表长度大于等于8。</li>
</ul>
<p>此时会将链表转为红黑树。</p>
<p>而红黑树的链化既发生在扩容过程，也发生在删除过程，扩容过程中的链化触发条件是树的节点数量小于链化阈值6，而删除过程中的链化触发条件要求是左子节点、左子节点的左子节点或右子节点为null。由于可能存在的最小树或者最大树，因此在删除时链化触发值的范围处于 [3,10] 之间。</p>
<p><strong>哈希算法</strong></p>
<p>HashMap 获取下标的过程分两步：</p>
<ul>
<li>位运算混淆 hashCode 的高低位：<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，作用是保证取模后的随机性；</li>
<li>与运算计算下标：<code>(n - 1) &amp; hash</code>，作用是取模获取下标。</li>
</ul>
<p>其中，长度之所以是2的冥，就是为了在此处将长度作为哈希值的低位掩码，巧妙实现取模效果。</p>
<p><strong>扩容重哈希</strong></p>
<p>假如从16扩容到32，扩容前通过<code>(n-1) &amp; hash</code> 取模是取后4位，而扩容后取后5位，因为01111和1111没区别，<strong>所以如果多出来这一位是0，那么最后用新长度去与运算得到的坐标是不变的，那么就不用移动</strong>。否则，多出来这一位相当于多了10000，<strong>转为十进制就是在原基础上加16，也就是加上了原桶数组的长度，那么直接在原基础上移动原桶数组长度就行了</strong>。</p>
<p>也就是说，一个桶中的链表，在扩容后可能会被拆成两条分散在两个桶中。</p>
<p><strong>迭代</strong></p>
<p>HashMap 本身有迭代器 <code>HashIterator</code>，但是没有 <code>iterator()</code>方法，所以无法直接通过增强 for 循环或者获取迭代器进行迭代，只能借助三个视图集合的迭代器或增强 for 来迭代器。但是视图迭代器本身也是 <code>HashIterator</code>子类，因此视图本身只是空集合，它的迭代能力来自于它们自己的迭代器的父类<code>HashIterator</code>。</p>
<p>HashMap 和他的三个集合视图都重写了 <code>forEach()</code>方法，所以可以通过 <code>forEach()</code>迭代器。</p>
<p>HashMap 也实现了 fast-fail 机制，因此最好不要在迭代的时候进行结构性操作。</p>
<p><strong>equals和hashCode方法</strong></p>
<p>HashMap 在<code>get()</code>和<code>set()</code>的时候都会通过 <code>Object.equals()</code> 和 <code>Object.hashCode()</code> 方法来确定唯一 key。由于默认使用的 Object 的实现比较是内存地址，因此使用自建对象作为 key 会很不方便，因此需要重写两个方法。但是由于校验唯一性的时候两个方法都会用到，因此若要重写<code>equals()</code>和<code>hashCode()</code>必须同时重写两个方法，不能重写其中一个。</p>
]]></content>
      <categories>
        <category>java集合容器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java集合容器</tag>
      </tags>
  </entry>
</search>
