<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/%E5%8D%9A%E5%AE%A2.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%8D%9A%E5%AE%A2.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%8D%9A%E5%AE%A2.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Spring,源码分析," />





  <link rel="alternate" href="/atom.xml" title="Createsequence's Blog" type="application/atom+xml" />






<meta name="description" content="前言 众所周知，spring 从 2.5 版本以后开始支持使用注解代替繁琐的 xml 配置，到了 springboot 更是全面拥抱了注解式配置。平时在使用的时候，点开一些常见的等注解，会发现往往在一个注解上总会出现一些其他的注解，比如 @Service： 12345678@Target(&amp;#123;ElementType.TYPE&amp;#125;)@Retention(RetentionPoli">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Spring注解机制（二）：元注解解析与属性映射">
<meta property="og:url" content="http://blog.xiajibagao.top/2022/08/10/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%83%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84/index.html">
<meta property="og:site_name" content="Createsequence&#39;s Blog">
<meta property="og:description" content="前言 众所周知，spring 从 2.5 版本以后开始支持使用注解代替繁琐的 xml 配置，到了 springboot 更是全面拥抱了注解式配置。平时在使用的时候，点开一些常见的等注解，会发现往往在一个注解上总会出现一些其他的注解，比如 @Service： 12345678@Target(&amp;#123;ElementType.TYPE&amp;#125;)@Retention(RetentionPoli">
<meta property="og:locale">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220813133938406.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220813133630338.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220813142108900.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220813145531624.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220813154058053.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220813163208346.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220813163633311.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220617104800021.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220618155125929.png">
<meta property="og:image" content="https://img.xiajibagao.top/image-20220813174709782.png">
<meta property="article:published_time" content="2022-08-09T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-15T14:22:48.533Z">
<meta property="article:author" content="Createsequence">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.xiajibagao.top/image-20220813133938406.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.xiajibagao.top/2022/08/10/spring/深入理解Spring注解机制（二）：元注解解析与属性映射/"/>





  <title>深入理解Spring注解机制（二）：元注解解析与属性映射 | Createsequence's Blog</title>
  








<meta name="generator" content="Hexo 5.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Createsequence's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个努力前进的程序猿</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.xiajibagao.top/2022/08/10/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%85%83%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/Createsequence.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Createsequence's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Spring注解机制（二）：元注解解析与属性映射</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-08-10T00:00:00+08:00">
                2022-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言">前言</h2>
<p>众所周知，<code>spring</code> 从 2.5 版本以后开始支持使用注解代替繁琐的 xml 配置，到了 <code>springboot</code> 更是全面拥抱了注解式配置。平时在使用的时候，点开一些常见的等注解，会发现往往在一个注解上总会出现一些其他的注解，比如 <code>@Service</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// @Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分情况下，我们可以将 <code>@Service</code> 注解等同于 <code>@Component</code> 注解使用，则是因为 spring 基于其 JDK 对<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">元注解的机制</a>进行了扩展。</p>
<p>在 java 中，元注解是指可以注解在其他注解上的注解，spring 中通过对这个机制进行了扩展，实现了一些原生 JDK 不支持的功能，比如允许在注解中让两个属性互为别名，或者将一个带有元注解的子注解直接作为元注解看待，或者在这个基础上，通过 <code>@AliasFor</code> 或者同名策略让子注解的值覆盖元注解的值。</p>
<p>本文将基于 spring 源码 <code>5.2.x</code> 分支，解析 spring 如何实现这套功能的。</p>
<p>这是系列的第二篇文章，将详细介绍 Spring 是如何解析 <code>@AliasFor</code>，实现各种别名功能。</p>
<p>相关文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Createsequence/p/16585516.html">深入理解Spring注解机制（一）：注解的搜索与处理机制</a>；</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Createsequence/p/16585518.html">深入理解Spring注解机制（二）：元注解解析与属性映射</a>；</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Createsequence/p/16585519.html">深入理解Spring注解机制（三）：合并注解的合成</a>；</li>
</ul>
<h2 id="一-创建合并注解聚合">一、创建合并注解聚合</h2>
<h3 id="1-入口">1、入口</h3>
<p>在 <code>AnnotatedElementUtils</code> 这个工具类中，所有带有 <code>Merged</code> 关键字的方法皆用于提供合并注解支持。</p>
<p>所谓合并注解，其实就是以前文提到 <code>MergedAnnotation</code> 为基础实现的一系列功能，包括：</p>
<ul>
<li>对基于 <code>@AliasFor</code> 注解属性别名机制的支持；</li>
<li>对注解及元注解的合成支持；</li>
</ul>
<p>我们可以点开 <code>AnnotatedElementUtils</code> 工具类中的常用方法 <code>findMergedAnnotation</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">findMergedAnnotation</span><span class="params">(AnnotatedElement element, Class&lt;A&gt; annotationType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、下述任意情况下直接获取元素上声明的注解：</span></span><br><span class="line">    <span class="comment">// a.查找的注解属于java、javax或者org.springframework.lang包</span></span><br><span class="line">    <span class="comment">// b.被处理的元素属于java包，或被java包中的对象声明，或者就是Ordered.class</span></span><br><span class="line">    <span class="keyword">if</span> (AnnotationFilter.PLAIN.matches(annotationType) ||</span><br><span class="line">        AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.getDeclaredAnnotation(annotationType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将元素上的全部注解合成MergedAnnotation</span></span><br><span class="line">    <span class="keyword">return</span> findAnnotations(element)</span><br><span class="line">        <span class="comment">// 3、从MergedAnnotation获取与该类型对应的MergedAnnotations</span></span><br><span class="line">        .get(annotationType, <span class="keyword">null</span>, MergedAnnotationSelectors.firstDirectlyDeclared())</span><br><span class="line">        <span class="comment">// 4、根据MergedAnnotation通过动态代理生成一个注解实例</span></span><br><span class="line">        .synthesize(MergedAnnotation::isPresent).orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体过程分三步：</p>
<ul>
<li>通过 <code>findAnnotations</code> 获得合并注解聚合 <code>MergedAnnotations</code>，该对象表示与指定 <code>AnnotatedElement</code> 关联的全部注解的聚合体；</li>
<li>从 <code>MergedAnnotations</code> 通过 <code>get</code> 方法获取符合条件的合并注解 <code>MergedAnnotation</code>，该过程将从<code>AnnotatedElement</code> 关联的全部注解中选出所需的注解类型，然后解析其各种映射关系，并变为一个合并注解；</li>
<li>然后将该合并注解通过 <code>synthesize</code> 方法合成为一个符合条件的普通注解，该过程将基于处理后的合并注解，使用 JDK 动态代理生成一个指定注解类型的代理对象；</li>
</ul>
<p>这里我们重点关注 <code>findMergedAnnotation</code> 方法，以及调用 <code>MergedAnnotations.get</code> 方法后，合并注解聚合是如何在获得层级结构中的注解后，对其元注解和相关属性的解析的。</p>
<h3 id="2-typemappedannotations">2、TypeMappedAnnotations</h3>
<p><code>AnnotatedElementUtils.findAnnotations</code> 获取了一个 <code>MergedAnnotations</code> 对象，该方法经过一系列的跳转，最终会得到一个 <code>TypeMappedAnnotations</code> 实现类实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> MergedAnnotations <span class="title">from</span><span class="params">(AnnotatedElement element, SearchStrategy searchStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该元素若符合下述任一情况，则直接返回空注解：</span></span><br><span class="line">    <span class="comment">// a.被处理的元素属于java包、被java包中的对象声明，或者就是Ordered.class</span></span><br><span class="line">    <span class="comment">// b.只查找元素直接声明的注解，但是元素本身没有声明任何注解</span></span><br><span class="line">    <span class="comment">// c.查找元素的层级结构，但是元素本身没有任何层级结构</span></span><br><span class="line">    <span class="comment">// d.元素是桥接方法</span></span><br><span class="line">    <span class="keyword">if</span> (AnnotationsScanner.isKnownEmpty(element, searchStrategy)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5、返回一个具体的实现类实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TypeMappedAnnotations(element, searchStrategy, repeatableContainers, annotationFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前文我们知道，<code>TypeMappedAnnotations</code> 是 <code>MergedAnnotations</code> 接口的默认实现，他表示由 <code>AnnotationScanner</code> 从同一个 <code>AnnotatedElement</code> 上扫描出来的注解们转为的一批合并注解 <code>MergedAnnotation</code>。</p>
<p>举个例子，假如现有 <code>AnnotatedElement</code> 对象 <code>Foo.class</code>，他上面有一些注解，则理论上转为 <code>MergedAnnotations</code> 的过程如下：</p>
<figure>
<img src="https://img.xiajibagao.top/image-20220813133938406.png" alt="image-20220813133938406"><figcaption aria-hidden="true">image-20220813133938406</figcaption>
</figure>
<p>不过当 <code>TypeMappedAnnotations</code> 创建以后，内部的 <code>MergedAnnotation</code> 并没有真正的被创建，而是需要等到调用 <code>TypeMappedAnnotations</code> 才会完成注解的搜索、解析与合并过程，因此在这个阶段，一个 <code>TypeMappedAnnotations</code> 只能表示一组来直接或间接自于同一个 <code>AnnotatedElement</code> 的注解之间的映射关系。</p>
<h2 id="二-元注解的解析">二、元注解的解析</h2>
<p><code>TypeMappedAnnotations</code> 创建后需要等到调用时才会初始化，当调用 <code>MergedAnnotations.get</code> 方法时，会创建一个 <code>MergedAnnotationFinder</code> 用于获取符合条件的 <code>MergedAnnotation</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">MergedAnnotation&lt;A&gt; <span class="title">get</span><span class="params">(Class&lt;A&gt; annotationType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="meta">@Nullable</span> Predicate&lt;? <span class="keyword">super</span> MergedAnnotation&lt;A&gt;&gt; predicate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="meta">@Nullable</span> MergedAnnotationSelector&lt;A&gt; selector)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.annotationFilter.matches(annotationType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MergedAnnotation.missing();</span><br><span class="line">    &#125;</span><br><span class="line">    MergedAnnotation&lt;A&gt; result = scan(annotationType,</span><br><span class="line">                                      <span class="keyword">new</span> MergedAnnotationFinder&lt;&gt;(annotationType, predicate, selector));</span><br><span class="line">    <span class="keyword">return</span> (result != <span class="keyword">null</span> ? result : MergedAnnotation.missing());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>AnnotationScanner</code> 是如何使用 <code>MergedAnnotationFinder</code> 的过程在上文已经详细介绍了，这里就不再赘述，我们直接跳到 <code>MergedAnnotationFinder.process</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MergedAnnotation&lt;A&gt; <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object type, <span class="keyword">int</span> aggregateIndex, <span class="meta">@Nullable</span> Object source, Annotation annotation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取这个注解的元注解，并将自己及这些元注解都转为类型映射AnnotationTypeMappings</span></span><br><span class="line">    AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(</span><br><span class="line">        annotation.annotationType(), repeatableContainers, annotationFilter);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings.size(); i++) &#123;</span><br><span class="line">        AnnotationTypeMapping mapping = mappings.get(i);</span><br><span class="line">        <span class="keyword">if</span> (isMappingForType(mapping, annotationFilter, <span class="keyword">this</span>.requiredType)) &#123;</span><br><span class="line">            <span class="comment">// 根据符合条件的类型映射对象，创建聚合注解</span></span><br><span class="line">            MergedAnnotation&lt;A&gt; candidate = TypeMappedAnnotation.createIfPossible(</span><br><span class="line">                mapping, source, annotation, aggregateIndex, IntrospectionFailureLogger.INFO);</span><br><span class="line">            <span class="comment">// ... ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要重点关注 <code>AnnotationTypeMappings</code> 和 <code>AnnotationTypeMapping</code> 的创建，这两者才是真正用于解析与维护原始注解对象信息的主题。</p>
<h3 id="1-创建元注解聚合体">1、创建元注解聚合体</h3>
<p>首先先给出定义，<code>AnnotationTypeMappings</code> 用于表示某一个注解类上全部元注解，对应的还有一个 <code>AnnotationTypeMapping</code> ，它表示一个具体的元注解对象。</p>
<p><code>AnnotationTypeMappings</code> 与 <code>MergedAnnotations</code> 的设计思路一样，它表示一组 <code>AnnotationTypeMapping</code> 对象的聚合状态，同时用于提供对 <code>AnnotationTypeMapping</code> 的创建和搜索等功能。</p>
<p>某种程度上来说，<code>AnnotationTypeMappings</code> 其实就是一个注解类的元注解结合体。</p>
<p>我们看 <code>AnnotationTypeMappings.forAnnotationType</code> 静态方法，该方法用于根据一个注解类型创建 <code>AnnotationTypeMappings</code> 对象实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AnnotationTypeMappings <span class="title">forAnnotationType</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对可重复注解的容器缓存</span></span><br><span class="line">    <span class="keyword">if</span> (repeatableContainers == RepeatableContainers.standardRepeatables()) &#123;</span><br><span class="line">        <span class="keyword">return</span> standardRepeatablesCache.computeIfAbsent(annotationFilter,</span><br><span class="line">                                                        key -&gt; <span class="keyword">new</span> Cache(repeatableContainers, key)).get(annotationType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对不可重复注解的容器缓存</span></span><br><span class="line">    <span class="keyword">if</span> (repeatableContainers == RepeatableContainers.none()) &#123;</span><br><span class="line">        <span class="keyword">return</span> noRepeatablesCache.computeIfAbsent(annotationFilter,</span><br><span class="line">                                                  key -&gt; <span class="keyword">new</span> Cache(repeatableContainers, key)).get(annotationType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个AnnotationTypeMappings实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnnotationTypeMappings(repeatableContainers, annotationFilter, annotationType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而一切的秘密都在 <code>AnnotationTypeMappings</code> 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AnnotationTypeMappings</span><span class="params">(RepeatableContainers repeatableContainers,</span></span></span><br><span class="line"><span class="function"><span class="params">                               AnnotationFilter filter, Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.repeatableContainers = repeatableContainers; <span class="comment">// 可重复注解的容器</span></span><br><span class="line">    <span class="keyword">this</span>.filter = filter; <span class="comment">// 过滤</span></span><br><span class="line">    <span class="keyword">this</span>.mappings = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 映射关系</span></span><br><span class="line">    addAllMappings(annotationType); <span class="comment">// 解析当前类以及其元注解的层次结构中涉及到的全部映射关系</span></span><br><span class="line">    <span class="keyword">this</span>.mappings.forEach(AnnotationTypeMapping::afterAllMappingsSet); <span class="comment">// 映射关系解析完后对别名的一些校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重点分为两步：</p>
<ul>
<li>调用 <code>AnnotationTypeMappings.addAllMappings</code> 方法，解析入参注解类型的全部元注解，将其转为 <code>AnnotationTypeMapping</code> 对象；</li>
<li>调用全部已解析好的 <code>AnnotationTypeMapping</code> 对象的 <code>afterAllMappingsSet</code> 方法，做一些基本的校验；</li>
</ul>
<h3 id="2-收集元注解">2、收集元注解</h3>
<p>在 <code>AnnotationTypeMappings</code> 创建时需要重点关注 <code>AnnotationTypeMappings.addAllMappings</code> 方法，该方法实际上就是元注解解析的主体，用于根据广度优先，把一个注解类上的全部元注解都转为 <code>AnnotationTypeMapping</code> 并加入 <code>AnnotationTypeMappings</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAllMappings</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 广度优先遍历注解和元注解</span></span><br><span class="line">    Deque&lt;AnnotationTypeMapping&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    addIfPossible(queue, <span class="keyword">null</span>, annotationType, <span class="keyword">null</span>); <span class="comment">// 1.1 添加待解析的元注解</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        AnnotationTypeMapping mapping = queue.removeFirst();</span><br><span class="line">        <span class="keyword">this</span>.mappings.add(mapping);</span><br><span class="line">        <span class="comment">// 继续解析下一层</span></span><br><span class="line">        addMetaAnnotationsToQueue(queue, mapping);  <span class="comment">// 1.2 解析的元注解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1 添加待解析的元注解</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addIfPossible</span><span class="params">(Deque&lt;AnnotationTypeMapping&gt; queue, <span class="meta">@Nullable</span> AnnotationTypeMapping source,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Class&lt;? extends Annotation&gt; annotationType, <span class="meta">@Nullable</span> Annotation ann)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将数据源、元注解类型和元注解实例封装为一个AnnotationTypeMapping，作为下一次处理的数据源</span></span><br><span class="line">        queue.addLast(<span class="keyword">new</span> AnnotationTypeMapping(source, annotationType, ann));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        AnnotationUtils.rethrowAnnotationConfigurationException(ex);</span><br><span class="line">        <span class="keyword">if</span> (failureLogger.isEnabled()) &#123;</span><br><span class="line">            failureLogger.log(<span class="string">&quot;Failed to introspect meta-annotation &quot;</span> + annotationType.getName(),</span><br><span class="line">                              (source != <span class="keyword">null</span> ? source.getAnnotationType() : <span class="keyword">null</span>), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2 解析的元注解</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addMetaAnnotationsToQueue</span><span class="params">(Deque&lt;AnnotationTypeMapping&gt; queue, AnnotationTypeMapping source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前注解上直接声明的元注解</span></span><br><span class="line">    Annotation[] metaAnnotations = AnnotationsScanner.getDeclaredAnnotations(source.getAnnotationType(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (Annotation metaAnnotation : metaAnnotations) &#123;</span><br><span class="line">        <span class="comment">// 若已经解析过了则跳过，避免“循环引用”</span></span><br><span class="line">        <span class="keyword">if</span> (!isMappable(source, metaAnnotation)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// a.若当前正在解析的注解是容器注解，则将内部的可重复注解取出解析</span></span><br><span class="line">        Annotation[] repeatedAnnotations = <span class="keyword">this</span>.repeatableContainers.findRepeatedAnnotations(metaAnnotation);</span><br><span class="line">        <span class="keyword">if</span> (repeatedAnnotations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Annotation repeatedAnnotation : repeatedAnnotations) &#123;</span><br><span class="line">                <span class="comment">// 1.2.1 判断是否已经完成映射</span></span><br><span class="line">                <span class="keyword">if</span> (!isMappable(source, repeatedAnnotation)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                addIfPossible(queue, source, repeatedAnnotation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b.若当前正在解析的注解不是容器注解，则将直接解析</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            addIfPossible(queue, source, metaAnnotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2.1 判断是否已经完成映射</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMappable</span><span class="params">(AnnotationTypeMapping source, <span class="meta">@Nullable</span> Annotation metaAnnotation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (metaAnnotation != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.filter.matches(metaAnnotation) &amp;&amp;</span><br><span class="line">            !AnnotationFilter.PLAIN.matches(source.getAnnotationType()) &amp;&amp;</span><br><span class="line">            !isAlreadyMapped(source, metaAnnotation));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAlreadyMapped</span><span class="params">(AnnotationTypeMapping source, Annotation metaAnnotation)</span> </span>&#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType = metaAnnotation.annotationType();</span><br><span class="line">    <span class="comment">// 递归映射表，确定这个注解类型是否在映射表的树结构中存在</span></span><br><span class="line">    <span class="comment">// 这个做法相当于在循环引用中去重</span></span><br><span class="line">    AnnotationTypeMapping mapping = source;</span><br><span class="line">    <span class="keyword">while</span> (mapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapping.getAnnotationType() == annotationType) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mapping = mapping.getSource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析后的 <code>AnnotationTypeMappings</code> 大概可以参考下图：</p>
<figure>
<img src="https://img.xiajibagao.top/image-20220813133630338.png" alt="image-20220813133630338"><figcaption aria-hidden="true">image-20220813133630338</figcaption>
</figure>
<p>不过这个图仍然不够准确，因为 <code>AnnotationTypeMapping</code> 之间还会维持一个彼此间的引用关系，从而保证 <code>AnnotationTypeMapping</code> 彼此之间也能够区分父子关系。</p>
<h3 id="3-解析元注解">3、解析元注解</h3>
<p><code>AnnotationTypeMapping</code> 直译叫做注解类型映射，之所以叫映射，是因为一个类型映射对象总是跟一个元注解一一对应，它持有原始注解的引用，此外还会记录注解属性以及其源注解的一些信息。</p>
<p>实际上，<code>@AliasFor</code> 以及其他注解属性的映射也在这里完成，不过本节先重点关注其本身的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AnnotationTypeMapping(<span class="meta">@Nullable</span> AnnotationTypeMapping source,</span><br><span class="line">                      Class&lt;? extends Annotation&gt; annotationType, <span class="meta">@Nullable</span> Annotation annotation) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.source = source; <span class="comment">// 声明当前元注解的源注解映射对象</span></span><br><span class="line">    <span class="keyword">this</span>.root = (source != <span class="keyword">null</span> ? source.getRoot() : <span class="keyword">this</span>); <span class="comment">// 当前元注解所在树根节点对应的元注解映射对象</span></span><br><span class="line">    <span class="keyword">this</span>.distance = (source == <span class="keyword">null</span> ? <span class="number">0</span> : source.getDistance() + <span class="number">1</span>); <span class="comment">// 与树根节点对应的元注解映射对象的距离</span></span><br><span class="line">    <span class="keyword">this</span>.annotationType = annotationType; <span class="comment">// 当前元注解的类型</span></span><br><span class="line">    <span class="keyword">this</span>.metaTypes = merge( <span class="comment">// 记录全部子元注解类型</span></span><br><span class="line">        source != <span class="keyword">null</span> ? source.getMetaTypes() : <span class="keyword">null</span>,</span><br><span class="line">        annotationType);</span><br><span class="line">    <span class="keyword">this</span>.annotation = annotation; <span class="comment">// 记录对原始元注解的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些属性解析和处理......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">merge</span><span class="params">(<span class="meta">@Nullable</span> List&lt;T&gt; existing, T element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(element);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; merged = <span class="keyword">new</span> ArrayList&lt;&gt;(existing.size() + <span class="number">1</span>);</span><br><span class="line">    merged.addAll(existing);</span><br><span class="line">    merged.add(element);</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(merged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，通过构造函数不难看出，<code>AnnotationTypeMapping</code> 之间其实会形成一个类似单向链表的结构，我们根据此调整上一节末尾给出的图例：</p>
<figure>
<img src="https://img.xiajibagao.top/image-20220813142108900.png" alt="image-20220813142108900"><figcaption aria-hidden="true">image-20220813142108900</figcaption>
</figure>
<p>至此，通过 <code>AnnotationTypeMappings</code> 可以直接管理所有的 <code>AnnotationTypeMapping</code>，而通过独立的 <code>AnnotationTypeMapping</code>，又可以追溯元注解之间的父子关系。</p>
<h2 id="三-属性解析">三、属性解析</h2>
<p>通过上文，我们分析完元注解的解析问题，通过 <code>AnnotationTypeMappings</code> 或 <code>AnnotationTypeMapping</code> 都可以完成的元注解树结构的访问，不过仍然还没说清楚Spring 支持的 <code>@AliasFor</code> 以及基于元注解的各种属性映射机制是怎么实现的。</p>
<p>这些涉及注解属性的映射，都是在 <code>AnnotationTypeMapping</code> 创建时，在构造方法里通过解析注解属性，以及判断元注解之间关联关系完成的。</p>
<p>继续看 <code>AnnotationTypeMapping</code> 的构造函数中属性解析解析部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">AnnotationTypeMapping(<span class="meta">@Nullable</span> AnnotationTypeMapping source,</span><br><span class="line">                      Class&lt;? extends Annotation&gt; annotationType, <span class="meta">@Nullable</span> Annotation annotation) &#123;</span><br><span class="line">	<span class="comment">// ================ 元注解解析相关的属性 ================</span></span><br><span class="line">    <span class="keyword">this</span>.source = source;</span><br><span class="line">    <span class="keyword">this</span>.root = (source != <span class="keyword">null</span> ? source.getRoot() : <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.distance = (source == <span class="keyword">null</span> ? <span class="number">0</span> : source.getDistance() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.metaTypes = merge(</span><br><span class="line">        source != <span class="keyword">null</span> ? source.getMetaTypes() : <span class="keyword">null</span>,</span><br><span class="line">        annotationType);</span><br><span class="line">    <span class="keyword">this</span>.annotationType = annotationType;</span><br><span class="line">    <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ================ 属性解析 ================</span></span><br><span class="line">    <span class="comment">// 将当前元注解的属性解析为AttributeMethods</span></span><br><span class="line">    <span class="keyword">this</span>.attributes = AttributeMethods.forAnnotationType(annotationType);</span><br><span class="line">    <span class="comment">// 属性别名与相关的值缓存</span></span><br><span class="line">    <span class="keyword">this</span>.mirrorSets = <span class="keyword">new</span> MirrorSets();</span><br><span class="line">    <span class="keyword">this</span>.aliasMappings = filledIntArray(<span class="keyword">this</span>.attributes.size());</span><br><span class="line">    <span class="keyword">this</span>.conventionMappings = filledIntArray(<span class="keyword">this</span>.attributes.size());</span><br><span class="line">    <span class="keyword">this</span>.annotationValueMappings = filledIntArray(<span class="keyword">this</span>.attributes.size());</span><br><span class="line">    <span class="keyword">this</span>.annotationValueSource = <span class="keyword">new</span> AnnotationTypeMapping[<span class="keyword">this</span>.attributes.size()];</span><br><span class="line">    <span class="keyword">this</span>.aliasedBy = resolveAliasedForTargets();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化别名属性，为所有存在别名的属性建立MirrorSet</span></span><br><span class="line">    processAliases();</span><br><span class="line">    <span class="comment">// 为当前注解内互为并名的属性建立属性映射</span></span><br><span class="line">    addConventionMappings();</span><br><span class="line">    <span class="comment">// 为跨注解互为别名的属性建立属性映射</span></span><br><span class="line">    addConventionAnnotationValues();</span><br><span class="line">    <span class="keyword">this</span>.synthesizable = computeSynthesizableFlag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于属性解析部分，大概分为五部分内容：</p>
<ol type="1">
<li>解析注解属性；解析注解的属性，将其转为 <code>AttributeMethods</code> 对象；</li>
<li>解析<code>@AliasFor</code>注解：基于 <code>AttributeMethods</code> 对象，解析注解带有 <code>@AliasFor</code> 注解的属性；</li>
<li>映射互为别名的属性：为该注解内通过 <code>@AliasFor</code> 形成互为别名关系的属性设置对应的 <code>MirrorSet</code>；</li>
<li>映射子注解对元注解属性的别名关系：将子注解中通过 <code>@AliasFor</code> 指向父注解的属性的属性值，覆盖到父注解的对应属性上；</li>
<li>令子注解覆盖父注解的同名属性：将子注解中与父注解同名的属性的属性值，覆盖到父注解的对应属性上；</li>
</ol>
<h3 id="1-解析无别名注解属性">1、解析无别名注解属性</h3>
<p>属性解析的第一步，在 <code>AnnotationTypeMapping</code> 中，注解的属性会被解析为 <code>AttributeMethods</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AttributeMethods <span class="title">forAnnotationType</span><span class="params">(<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (annotationType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache.computeIfAbsent(annotationType, AttributeMethods::compute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AttributeMethods <span class="title">compute</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line">    Method[] methods = annotationType.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">int</span> size = methods.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAttributeMethod(methods[i])) &#123;</span><br><span class="line">            methods[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(methods, methodComparator);</span><br><span class="line">    Method[] attributeMethods = Arrays.copyOf(methods, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AttributeMethods(annotationType, attributeMethods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAttributeMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (method.getParameterCount() == <span class="number">0</span> &amp;&amp; method.getReturnType() != <span class="keyword">void</span>.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类本质上就是通过 <code>Class.getDeclaredMethods</code> 获取到的注解属性的 <code>Method</code> 数组，在 <code>AnnotationTypeMapping</code> 中，所有的属性都通过它在 <code>AttributeMethods</code> 中的数组下标访问和调用。</p>
<figure>
<img src="https://img.xiajibagao.top/image-20220813145531624.png" alt="image-20220813145531624"><figcaption aria-hidden="true">image-20220813145531624</figcaption>
</figure>
<p>在构造函数中，我们也能看到提前声明了好几个数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.aliasMappings = filledIntArray(<span class="keyword">this</span>.attributes.size());</span><br><span class="line"><span class="keyword">this</span>.conventionMappings = filledIntArray(<span class="keyword">this</span>.attributes.size());</span><br><span class="line"><span class="keyword">this</span>.annotationValueMappings = filledIntArray(<span class="keyword">this</span>.attributes.size());</span><br><span class="line"><span class="keyword">this</span>.annotationValueSource = <span class="keyword">new</span> AnnotationTypeMapping[<span class="keyword">this</span>.attributes.size()];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] filledIntArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    Arrays.fill(array, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些数组都与属性映射有关，任何一个属性的相关映射信息，都可以通过其在 <code>AttributeMethods</code> 中对应的数组下标，从这些关联的数组对应位置获得。</p>
<h3 id="2-解析带aliasfor的别名属性">2、解析带@AliasFor的别名属性</h3>
<p>属性解析的第二步，在 <code>AnnotationTypeMapping.resolveAliasedForTargets</code> 方法中，<code>AnnotationTypeMapping</code> 会将所有带有 <code>@AliasFor</code> 注解，或者被子注解直接/间接通过 <code>@AliasFor</code> 指向的属性都解析到一个名为 <code>aliasedBy</code> 的类型为 <code>Map&lt;Method, List&lt;Method&gt;&gt;</code> 的成员变量中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Method, List&lt;Method&gt;&gt; resolveAliasedForTargets() &#123;</span><br><span class="line">    Map&lt;Method, List&lt;Method&gt;&gt; aliasedBy = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.attributes.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历当前注解的属性方法，并获取其中的带有@AliasFor的方法</span></span><br><span class="line">        Method attribute = <span class="keyword">this</span>.attributes.get(i);</span><br><span class="line">        AliasFor aliasFor = AnnotationsScanner.getDeclaredAnnotation(attribute, AliasFor.class);</span><br><span class="line">        <span class="keyword">if</span> (aliasFor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取别名指定的注解类中的方法，并建立别名属性 -&gt; [属性1]的映射集合</span></span><br><span class="line">            Method target = resolveAliasTarget(attribute, aliasFor);</span><br><span class="line">            aliasedBy.computeIfAbsent(target, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;()).add(attribute);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableMap(aliasedBy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Method <span class="title">resolveAliasTarget</span><span class="params">(Method attribute, AliasFor aliasFor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resolveAliasTarget(attribute, aliasFor, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>resolveAliasTarget</code> 最终将获得<code>@AliasFor</code>注解所指定的别名方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Method <span class="title">resolveAliasTarget</span><span class="params">(Method attribute, AliasFor aliasFor, <span class="keyword">boolean</span> checkAliasPair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(aliasFor.value()) &amp;&amp; StringUtils.hasText(aliasFor.attribute())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationConfigurationException(String.format(</span><br><span class="line">            <span class="string">&quot;In @AliasFor declared on %s, attribute &#x27;attribute&#x27; and its alias &#x27;value&#x27; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;are present with values of &#x27;%s&#x27; and &#x27;%s&#x27;, but only one is permitted.&quot;</span>,</span><br><span class="line">            AttributeMethods.describe(attribute), aliasFor.attribute(),</span><br><span class="line">            aliasFor.value()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、若Annotation指定的是Annotation，则认为目标就是当前注解类</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; targetAnnotation = aliasFor.annotation();</span><br><span class="line">    <span class="keyword">if</span> (targetAnnotation == Annotation.class) &#123;</span><br><span class="line">        targetAnnotation = <span class="keyword">this</span>.annotationType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、获取aliasFrom#attribute，若为空则再获取aliasFrom#value</span></span><br><span class="line">    String targetAttributeName = aliasFor.attribute();</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(targetAttributeName)) &#123;</span><br><span class="line">        targetAttributeName = aliasFor.value();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(targetAttributeName)) &#123;</span><br><span class="line">        targetAttributeName = attribute.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、从指定类中获得别名指定指定的注解属性对应的方法</span></span><br><span class="line">    Method target = AttributeMethods.forAnnotationType(targetAnnotation).get(targetAttributeName);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// a.校验是否能找到别名方法</span></span><br><span class="line">        <span class="keyword">if</span> (targetAnnotation == <span class="keyword">this</span>.annotationType) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationConfigurationException(String.format(</span><br><span class="line">                <span class="string">&quot;@AliasFor declaration on %s declares an alias for &#x27;%s&#x27; which is not present.&quot;</span>,</span><br><span class="line">                AttributeMethods.describe(attribute), targetAttributeName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationConfigurationException(String.format(</span><br><span class="line">            <span class="string">&quot;%s is declared as an @AliasFor nonexistent %s.&quot;</span>,</span><br><span class="line">            StringUtils.capitalize(AttributeMethods.describe(attribute)),</span><br><span class="line">            AttributeMethods.describe(targetAnnotation, targetAttributeName)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b.校验别名与原属性对应的方法是否不为一个方法</span></span><br><span class="line">    <span class="keyword">if</span> (target.equals(attribute)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationConfigurationException(String.format(</span><br><span class="line">            <span class="string">&quot;@AliasFor declaration on %s points to itself. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Specify &#x27;annotation&#x27; to point to a same-named attribute on a meta-annotation.&quot;</span>,</span><br><span class="line">            AttributeMethods.describe(attribute)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c.校验别名与原属性对应的方法返回值是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (!isCompatibleReturnType(attribute.getReturnType(), target.getReturnType())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationConfigurationException(String.format(</span><br><span class="line">            <span class="string">&quot;Misconfigured aliases: %s and %s must declare the same return type.&quot;</span>,</span><br><span class="line">            AttributeMethods.describe(attribute),</span><br><span class="line">            AttributeMethods.describe(target)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// d.若有必要，则再校验声明别名方法的注解是@AliasFor指定的注解类型</span></span><br><span class="line">    <span class="keyword">if</span> (isAliasPair(target) &amp;&amp; checkAliasPair) &#123;</span><br><span class="line">        AliasFor targetAliasFor = target.getAnnotation(AliasFor.class);</span><br><span class="line">        <span class="keyword">if</span> (targetAliasFor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Method mirror = resolveAliasTarget(target, targetAliasFor, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mirror.equals(attribute)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationConfigurationException(String.format(</span><br><span class="line">                    <span class="string">&quot;%s must be declared as an @AliasFor %s, not %s.&quot;</span>,</span><br><span class="line">                    StringUtils.capitalize(AttributeMethods.describe(target)),</span><br><span class="line">                    AttributeMethods.describe(attribute), AttributeMethods.describe(mirror)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一步，他做了以下逻辑处理：</p>
<ol type="1">
<li>确定别名属性所在的注解类：若 <code>@AliasFor.annotation</code> 属性保持默认值 <code>Annotation.class</code>，则认为别名属性所在的注解就是当前解析的注解；</li>
<li>确定别名属性对应的方法名：优先获取 <code>@aliasFrom.attribute</code> 同名属性，若 <code>@AliasFrom.attribute</code> 为空则获取 <code>@AliasFrom.value</code> 指定的属性名；</li>
<li>从指定的注解类获取方法名对应的属性；</li>
<li>校验该别名方法对应方法是否不是当前注解属性的方法；</li>
<li>校验别名方法返回值类型与当前注解属性的方法返回值类型是否一致；</li>
<li>校验声明该方法的类就是注解指定的注解类；</li>
</ol>
<p>最终，完成这一步后，将构建出以别名方法作为 <code>key</code>，当前注解中对应的原始属性的方法作为 <code>value</code>的别名属性-原始属性映射表 <code>aliasedBy</code>。</p>
<p>这里有个比较有意思的地方，<code>@AliasFor</code> 注解中， <code>value</code> 和 <code>attribute</code> 属性同样存在 <code>@AliasFor</code> 注解，但是实际上这个注解是不生效的，因为在 Spring 在这边的实现实际上并没有让 <code>@AliasFor</code> 支持类似自举的机制。</p>
<p>另外，更有意思是，根据这些条件，你可以看出来，<code>@AliasFor</code> 不是一定要成对使用的，实际只要有一个 <code>@AliasFor</code> 出现，镜像关系就可以构建，如果你愿意，在不违背上述条件的情况下甚至可以同时有多个关联的别名字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> AttributeMetaMeta &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="meta">@AliasFor(attribute = &quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">alias1</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="meta">@AliasFor(attribute = &quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">alias2</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对任意一个字段赋值等同于给所有字段赋值。</p>
<h2 id="四-映射属性别名">四、映射属性别名</h2>
<p>Spring 中，支持令同一注解中的两个属性——不过在上文证明其实也支持多个——形成别名，即只要任意两个属性中的至少一个使用 <code>@AliasFor</code> 指向对方，则对其中一个属性的赋值，另一个属性也会得到。</p>
<p>而这些别名属性的映射关系，都会在 <code>processAliases</code> 完成解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAliases</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Method&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历当前注解中的属性，处理属性与其相关的别名</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.attributes.size(); i++) &#123;</span><br><span class="line">        aliases.clear(); <span class="comment">// 复用集合避免重复创建</span></span><br><span class="line">        aliases.add(<span class="keyword">this</span>.attributes.get(i));</span><br><span class="line">        <span class="comment">// 1.收集注解</span></span><br><span class="line">        collectAliases(aliases); </span><br><span class="line">        <span class="keyword">if</span> (aliases.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.处理注解</span></span><br><span class="line">            processAliases(i, aliases);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>AnnotationTypeMapping</code> 会遍历 <code>AnnotationAttributes</code> ，然后一次处理每一个注解属性，而这里分为对别名属性的收集和处理过程：</p>
<ul>
<li>收集关联属性：从当前元注解的根注解，也就是 <code>root</code> 开始，一层一层的向上找，将所有直接或间接与当前注解属性相关的，当前以及其他注解的属性；</li>
<li>处理关联属性：根据搜集到的属性上的 <code>@AliasFor</code> 注解，如果它们在同一注解中形成了别名关系，则为它们创建 <code>MirrorSet</code> 集合，构建彼此间的映射关系；</li>
</ul>
<p>接下来我们来详细的分析这两个过程。</p>
<h3 id="1-收集关联的别名属性">1、收集关联的别名属性</h3>
<p>收集注解这一步，将以当前注解的某个属性为根属性，根据链表结构向子注解递归，从子注解中获取全部与该属性相关的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectAliases</span><span class="params">(List&lt;Method&gt; aliases)</span> </span>&#123;</span><br><span class="line">    AnnotationTypeMapping mapping = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> (mapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = aliases.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            List&lt;Method&gt; additional = mapping.aliasedBy.get(aliases.get(j)); <span class="comment">// 获取以该属性作为别名的子类属性</span></span><br><span class="line">            <span class="keyword">if</span> (additional != <span class="keyword">null</span>) &#123;</span><br><span class="line">                aliases.addAll(additional);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mapping = mapping.source; <span class="comment">// 继续向声明当前元注解的子注解递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，假如我们现在有如下结构：</p>
<figure>
<img src="https://img.xiajibagao.top/image-20220813154058053.png" alt="image-20220813154058053"><figcaption aria-hidden="true">image-20220813154058053</figcaption>
</figure>
<p>现在在 <code>Annotation1</code> 的 <code>AnnotationTypeMapping</code> 中，对它的 <code>name</code> 属性进行收集的时候，则最终将一路收集得到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[name, value, value2, value3]</span><br></pre></td></tr></table></figure>
<p>可见该方法会将全部关联注解对象中，在同一条别名链上的注解属性全部找出来。</p>
<h3 id="2-处理别名属性">2、处理别名属性</h3>
<p>处理关联属性这做了三件事：</p>
<ul>
<li>如果属性关联的这一组别名中，有一个别名属性是来自于 root 的，则直接无条件使用来自 root 的别名属性覆盖当前属性；</li>
<li>使用 <code>MirrorSet</code> 解析并记录彼此之间具有关系的属性，然后根据一些规则从中选出唯一一个有效的属性作为它们的代表；</li>
<li>使用通过 <code>MirrorSet</code> 获得的代表属性替换所有关联属性，并记录该属性从哪一个注解的哪一个属性中取值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAliases</span><span class="params">(<span class="keyword">int</span> attributeIndex, List&lt;Method&gt; aliases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确认别名链上，是否有别名字段来自于root</span></span><br><span class="line">    <span class="keyword">int</span> rootAttributeIndex = getFirstRootAttributeIndex(aliases);</span><br><span class="line">    AnnotationTypeMapping mapping = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 从当前注解向root递归</span></span><br><span class="line">    <span class="keyword">while</span> (mapping != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若有当前正在处理的注解中：</span></span><br><span class="line">        <span class="comment">// 1.有别名字段来自于root；</span></span><br><span class="line">        <span class="comment">// 2.别名链中有一个别名来自于该注解；</span></span><br><span class="line">        <span class="comment">// 则在当前处理的注解的aliasMappings上，记录这个来自于root的别名属性，表示它存在一个来自root的别名</span></span><br><span class="line">        <span class="keyword">if</span> (rootAttributeIndex != -<span class="number">1</span> &amp;&amp; mapping != <span class="keyword">this</span>.root) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapping.attributes.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aliases.contains(mapping.attributes.get(i))) &#123;</span><br><span class="line">                    mapping.aliasMappings[i] = rootAttributeIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建MirrorSet，解析别名链上的属性构建映射关系</span></span><br><span class="line">        mapping.mirrorSets.updateFrom(aliases);</span><br><span class="line">        mapping.claimedAliases.addAll(aliases);</span><br><span class="line">        <span class="keyword">if</span> (mapping.annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据MirrorSet，从别名链中选择出唯一生效的属性作为它们的最终实际属性</span></span><br><span class="line">            <span class="keyword">int</span>[] resolvedMirrors = mapping.mirrorSets.resolve(<span class="keyword">null</span>, mapping.annotation, ReflectionUtils::invokeMethod);</span><br><span class="line">            <span class="comment">// 遍历当前正在处理的注解的全部属性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapping.attributes.size(); i++) &#123;</span><br><span class="line">                <span class="comment">// 若该属性在别名链中存在</span></span><br><span class="line">                <span class="keyword">if</span> (aliases.contains(mapping.attributes.get(i))) &#123;</span><br><span class="line">                    <span class="comment">// 在分别记录该属性的一些信息：</span></span><br><span class="line">                    <span class="comment">// 1.记录该属性应当从哪个注解中取值</span></span><br><span class="line">                    <span class="keyword">this</span>.annotationValueSource[attributeIndex] = mapping;</span><br><span class="line">                    <span class="comment">// 2.记录该属性应当从那个注解的那个属性中取值</span></span><br><span class="line">                    <span class="keyword">this</span>.annotationValueMappings[attributeIndex] = resolvedMirrors[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mapping = mapping.source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，关于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] resolvedMirrors = mapping.mirrorSets.resolve(<span class="keyword">null</span>, mapping.annotation, ReflectionUtils::invokeMethod)</span><br></pre></td></tr></table></figure>
<p>我们会在后续分析，这里我们举个例子说明一下上述过程：</p>
<p>一切开始前，我们从 <code>Annotation1</code> 向 <code>Annotation3</code> 遍历，此时我们处理 <code>Annotation1</code> 的属性 <code>value1</code> ：</p>
<figure>
<img src="https://img.xiajibagao.top/image-20220813163208346.png" alt="image-20220813163208346"><figcaption aria-hidden="true">image-20220813163208346</figcaption>
</figure>
<p>当调用 <code>processAliases</code> 后：</p>
<ul>
<li>由于别名链上非根属性在根注解 <code>Annotation3</code> 中都不存在，别名不动，此时三个注解的 <code>aliasMappings</code> 都不变；</li>
<li>别名链上的三个属性 <code>value1</code>、<code>value2</code> 和 <code>value3</code> 经过 <code>MirrorSet</code> 处理后，发现 <code>value3</code> 是优先级最高的，因而把它们的 <code>annotationValueSource</code>、<code>annotationValueMappings</code> 都分别更新为 <code>Annotation3</code> 和 <code>Annotation3.value3</code> 的下标；</li>
</ul>
<figure>
<img src="https://img.xiajibagao.top/image-20220813163633311.png" alt="image-20220813163633311"><figcaption aria-hidden="true">image-20220813163633311</figcaption>
</figure>
<p>这样处理后，当调用 <code>Annotation1.value1</code> 方法时：</p>
<ul>
<li>先从 <code>AnnotationAttributes</code> 中获得 <code>value1</code> 的下标 <code>0</code>；</li>
<li>确认 <code>annotationValueMapping[0]</code> 对应位置是否为 <code>-1</code> ，不是则说明有映射关系；</li>
<li>最后从 <code>annotationValueSource[0]</code> 位置取出 <code>Annotation1</code> 对应的 <code>AnnotationTypeMapping</code>，再从 <code>annotationValueMappings[0]</code> 的位置取出 <code>0</code>；</li>
<li>从 <code>Annotation1</code> 对应的 <code>AnnotationTypeMapping</code> 中找到下标 <code>0</code> 对应的方法 <code>value3</code>，然后调用并返回值；</li>
</ul>
<p>这样就是完成了映射过程。</p>
<h3 id="3-别名属性关系的构建">3、别名属性关系的构建</h3>
<p>现在我们回头看 <code>AnnotationTypeMapping.processAliases</code> 方法中的两个关于 <code>MirrorSet</code> 的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAliases</span><span class="params">(<span class="keyword">int</span> attributeIndex, List&lt;Method&gt; aliases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确认别名链上，是否有别名字段来自于root</span></span><br><span class="line">    <span class="keyword">int</span> rootAttributeIndex = getFirstRootAttributeIndex(aliases);</span><br><span class="line">    AnnotationTypeMapping mapping = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 从当前注解向root递归</span></span><br><span class="line">    <span class="keyword">while</span> (mapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建MirrorSet，解析别名链上的属性构建映射关系</span></span><br><span class="line">        mapping.mirrorSets.updateFrom(aliases);</span><br><span class="line">        <span class="keyword">if</span> (mapping.annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据MirrorSet，从别名链中选择出唯一生效的属性作为它们的最终实际属性</span></span><br><span class="line">            <span class="keyword">int</span>[] resolvedMirrors = mapping.mirrorSets.resolve(<span class="keyword">null</span>, mapping.annotation, ReflectionUtils::invokeMethod);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ... ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mapping = mapping.source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上文我们可知，<code>MirrorSet</code> 用于从一组存在直接或间接别名关系的不同注解属性中，确认唯一有效的属性。关于这个唯一有效属性，举个例子，比如现在有 A、B、C 多个属性互为别名，则最终取值的时候，只能有一个属性的值是有效值，这个值将被同步到所有的别名属性中，如果 A 是唯一有效属性，则通过 A、B、C 取到的值都会来自 A。</p>
<p>在这之前，需要先简单了解一下 <code>MirrorSets</code> ，和 <code>AnnotationTypeMappings</code> 以及 <code>MergedAnnotations</code> 的设计一样，Spring 同样以 <code>MirrorSets</code> 作为 <code>MirrorSet</code> 的聚合对象。</p>
<p>先简单看看 <code>MirrorSet</code> 的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MirrorSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MirrorSet[] mirrorSets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MirrorSet[] assigned;</span><br><span class="line">    MirrorSets() &#123;</span><br><span class="line">        <span class="keyword">this</span>.assigned = <span class="keyword">new</span> MirrorSet[attributes.size()];</span><br><span class="line">        <span class="keyword">this</span>.mirrorSets = EMPTY_MIRROR_SETS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MirrorSets</code> 在内部维护了两个数组，分别是用于存放在不同属性间共享的 <code>MirrorSet</code> 实例的 <code>mirrorSets</code>，以及与 <code>AnnotationAttributes</code> 中属性一一对应的，用于存放该属性对应的 <code>MirrorSet</code> 实例，前者用于遍历，后者用于根据属性的索引下标查询关联属性。</p>
<p>当调用 <code>MirrorSets.updateFrom</code> 方法时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateFrom</span><span class="params">(Collection&lt;Method&gt; aliases)</span> </span>&#123;</span><br><span class="line">    MirrorSet mirrorSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历当前注解的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.size(); i++) &#123;</span><br><span class="line">        Method attribute = attributes.get(i);</span><br><span class="line">        <span class="comment">// 若有属性在传入的这一组别名中出现</span></span><br><span class="line">        <span class="keyword">if</span> (aliases.contains(attribute)) &#123;</span><br><span class="line">            size++; <span class="comment">// 计数+1</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">1</span>) &#123; <span class="comment">// 仅有一个别名的时候不创建MirrorSet实例</span></span><br><span class="line">                <span class="keyword">if</span> (mirrorSet == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mirrorSet = <span class="keyword">new</span> MirrorSet();</span><br><span class="line">                    <span class="keyword">this</span>.assigned[last] = mirrorSet; <span class="comment">// 当发现第二次在别名组中出现的属性时，为上一次发现的别名属性建立MirrorSet实例</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.assigned[i] = mirrorSet;</span><br><span class="line">            &#125;</span><br><span class="line">            last = i; <span class="comment">// 记录最后出现那个别名数组下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mirrorSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mirrorSet.update();</span><br><span class="line">        Set&lt;MirrorSet&gt; unique = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(<span class="keyword">this</span>.assigned));</span><br><span class="line">        unique.remove(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.mirrorSets = unique.toArray(EMPTY_MIRROR_SETS); <span class="comment">// 更新mirrorSets数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们再看看 <code>MirrorSet.update</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MirrorSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] indexes = <span class="keyword">new</span> <span class="keyword">int</span>[attributes.size()];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(<span class="keyword">this</span>.indexes, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MirrorSets.<span class="keyword">this</span>.assigned.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (MirrorSets.<span class="keyword">this</span>.assigned[i] == <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.indexes[<span class="keyword">this</span>.size] = i;</span><br><span class="line">                <span class="keyword">this</span>.size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的来说，就是遍历 <code>MirrorSets.assigned</code> 数组，看看哪些属性是共享当前 <code>MirrorSet</code> 实例的，然后把注解属性的下标给记录到 <code>indexes</code> 中。</p>
<p>举个例子，我们现在有一个注解，他的两个属性构成了互为别名的关系，现在对其中一个进行处理，则有如下情况：</p>
<figure>
<img src="https://img.xiajibagao.top/image-20220617104800021.png" alt="image-20220617104800021"><figcaption aria-hidden="true">image-20220617104800021</figcaption>
</figure>
<ul>
<li><code>value</code> 和 <code>alias</code> 属性在 <code>AnnotationAttributes</code> 中对应的下标分别是 <code>0</code> 和 <code>1</code>；</li>
<li>处理时，由于 <code>value</code> 和 <code>alias</code> 处于同一条别名链，因此 <code>MirrorSets.updateFrom</code> 调用时会同时传入这两者；</li>
<li>由于 <code>value</code> 和 <code>alias</code> 都在 <code>ValueAttributeMeta</code> 这注解中存在，因此 <code>MirrorSets</code> 会分别为它们在 <code>assigned</code> 数组中对应的下标位置放入 <code>MirrorSet</code> 实例；</li>
<li>接着，调用 <code>MirrorSet.update</code> 时，发现 <code>assigned[0]</code> 与 <code>assigned[1]</code> 共享一个 <code>MirrorSet</code> 实例，说明两者是有联系的，然后就在该 <code>MirrorSet</code> 实例中的 <code>indexes</code> 数组记录这两个位置 <code>0</code> 和 <code>1</code>；</li>
</ul>
<h3 id="4-别名属性唯一值的确认">4、别名属性唯一值的确认</h3>
<p>接上文，当 <code>MirrorSets.updateFrom</code> 调用完毕后，同一注解内的不同属性该关联的实际上都关联上了，接着会调用 <code>MirrorSets.resolve</code> 为这些关联的属性都找到唯一确认的最终属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] resolve(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> Object annotation, ValueExtractor valueExtractor) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[attributes.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 默认情况下，每个属性都调用他本身</span></span><br><span class="line">        result[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">        MirrorSet mirrorSet = get(i);</span><br><span class="line">        <span class="comment">// 如果有MirrorSet，则调用resolve方法获得这一组关联属性中的唯一有效属性的下标</span></span><br><span class="line">        <span class="keyword">int</span> resolved = mirrorSet.resolve(source, annotation, valueExtractor);</span><br><span class="line">        <span class="comment">// 将该下标强制覆盖全部关联的属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mirrorSet.size; j++) &#123;</span><br><span class="line">            result[mirrorSet.indexes[j]] = resolved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>MirrorSet.resolve</code> 则是根据一些条件确认一组关联属性中的唯一有效属性的下标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt; <span class="function"><span class="keyword">int</span> <span class="title">resolve</span><span class="params">(<span class="meta">@Nullable</span> Object source, <span class="meta">@Nullable</span> A annotation, ValueExtractor valueExtractor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">    Object lastValue = <span class="keyword">null</span>; <span class="comment">// 最近一个的有效属性值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历与当前注解属性属性互为别名的全部属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取属性值</span></span><br><span class="line">        Method attribute = attributes.get(<span class="keyword">this</span>.indexes[i]);</span><br><span class="line">        Object value = valueExtractor.extract(attribute, annotation);</span><br><span class="line">        <span class="keyword">boolean</span> isDefaultValue = (value == <span class="keyword">null</span> ||</span><br><span class="line">                                  isEquivalentToDefaultValue(attribute, value, valueExtractor));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果属性值是默认值，或者与最后有效值相同，则记录该属性下标后返回</span></span><br><span class="line">        <span class="comment">// 以此类推，如果一组互为别名的属性全部都是默认值，则前面的属性——即离根注解最近的——的默认值会作为最终有效值</span></span><br><span class="line">        <span class="keyword">if</span> (isDefaultValue || ObjectUtils.nullSafeEquals(lastValue, value)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.indexes[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果属性值不是默认值，并且与最近一个的有效属性值不同, 则抛出异常</span></span><br><span class="line">        <span class="comment">// 这里实际要求一组互为别名的属性中，只允许一个属性的值是非默认值</span></span><br><span class="line">        <span class="keyword">if</span> (lastValue != <span class="keyword">null</span> &amp;&amp; !ObjectUtils.nullSafeEquals(lastValue, value)) &#123;</span><br><span class="line">            String on = (source != <span class="keyword">null</span>) ? <span class="string">&quot; declared on &quot;</span> + source : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationConfigurationException(String.format(</span><br><span class="line">                <span class="string">&quot;Different @AliasFor mirror values for annotation [%s]%s; attribute &#x27;%s&#x27; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;and its alias &#x27;%s&#x27; are declared with values of [%s] and [%s].&quot;</span>,</span><br><span class="line">                getAnnotationType().getName(), on,</span><br><span class="line">                attributes.get(result).getName(),</span><br><span class="line">                attribute.getName(),</span><br><span class="line">                ObjectUtils.nullSafeToString(lastValue),</span><br><span class="line">                ObjectUtils.nullSafeToString(value)));</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">this</span>.indexes[i];</span><br><span class="line">        lastValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑应该是比较清晰的，首先，如果同一个注解内存在多个互为别名的属性，则需要有一个唯一有效的最终属性，所有互为别名的属性应当以这个最终属性的值为准。</p>
<p>对应到代码中，则就是通过遍历 <code>MirrorSet</code> 中互为别名的字段，然后根据下述规则找到最终属性：</p>
<ul>
<li>如果所有属性都只有默认值，则离根注解最近的属性最为最终属性；</li>
<li>如果所有属性中存在属性有非默认值，则该属性就作为默认属性，若出现多个有非默认值的属性，则直接报错；</li>
</ul>
<p>然后返回这个最终属性的下标。</p>
<p>我们举个例子，假如现在有 A，B，C，D，E 五个属性，其中 A 和 B、C 和 D 互为别名，则经过 <code>MirrorSets#resolve</code> 方法最终得到的 <code>resolvedMirrors</code> 如下图：</p>
<p><img src="https://img.xiajibagao.top/image-20220618155125929.png" alt="image-20220618155125929" style="zoom:67%;"></p>
<p>把<code>resolvedMirrors</code>翻译一下，就是 A 和 B 取值时都取 A 的值，C 和 D 取值时都取 C 的值，而 E 取值照样取 E 的值。</p>
<h3 id="4-多级别名">4、多级别名</h3>
<p>看到这里，我们对别名机制大概有个轮廓了，任何关联的注解中，只要通过 <code>@AliasFor</code> 能直接或者间接联系上，那它们就能构成别名。</p>
<p>因此，哪怕存在这样的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Annotation1 &#123;</span><br><span class="line">    <span class="function">String <span class="title">alias1</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="meta">@AliasFor(attribute = &quot;alias1&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">alias2</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Annotation1</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Annotation2 &#123;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = Annotation1.class, attribute = &quot;alias1&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value1</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = Annotation1.class, attribute = &quot;alias2&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value2</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用 <code>@Annotation2</code> 时，只要对 <code>value1</code> 或者 <code>value2</code> 进行赋值，最终都能从两个注解的各两个属性中拿到一样的值：</p>
<figure>
<img src="https://img.xiajibagao.top/image-20220813174709782.png" alt="image-20220813174709782"><figcaption aria-hidden="true">image-20220813174709782</figcaption>
</figure>
<h2 id="五-映射属性覆盖">五、映射属性覆盖</h2>
<p>现在，通过 <code>annotationValueMappings</code>，<code>annotationValueSource</code>以及 <code>AttributeMethods</code>这三个成员变量，任何一个使用<code>@AliasFor</code> 注解配置了别名的属性都可以找到真正对应的值。</p>
<p>不过在 Spring 中，还支持一种默认的属性覆盖机制，即当父子注解都存在一个名称与类型皆相同的属性时，子注解的属性值将会覆盖父注解的属性值。</p>
<p>在 <code>AnnotationTypeMapping</code> 的构造函数中，实现该功能的代码共分为两步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为元注解与根注解同名的属性强制设置别名</span></span><br><span class="line">addConventionMappings();</span><br><span class="line"><span class="comment">// 为元注解与非根注解的子注解的同名的属性设置别名</span></span><br><span class="line">addConventionAnnotationValues();</span><br></pre></td></tr></table></figure>
<h3 id="1-根注解覆盖元注解">1、根注解覆盖元注解</h3>
<p><code>addConventionMappings</code> 用于实现根注解覆盖所有其元注解中同名同类型属性的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addConventionMappings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.distance == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AttributeMethods rootAttributes = <span class="keyword">this</span>.root.getAttributes();</span><br><span class="line">    <span class="keyword">int</span>[] mappings = <span class="keyword">this</span>.conventionMappings;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历当前注解的属性，判断是否在根注解存在</span></span><br><span class="line">        String name = <span class="keyword">this</span>.attributes.get(i).getName();</span><br><span class="line">        <span class="keyword">int</span> mapped = rootAttributes.indexOf(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若存在，并且该属性不为“value”</span></span><br><span class="line">        MirrorSet mirrors = getMirrorSets().getAssigned(i);</span><br><span class="line">        <span class="keyword">if</span> (!MergedAnnotation.VALUE.equals(name) &amp;&amp; mapped != -<span class="number">1</span>) &#123;</span><br><span class="line">            mappings[i] = mapped;</span><br><span class="line">            <span class="comment">// 若该属性还有别名，则让该属性和全部别名属性都从根注解取值</span></span><br><span class="line">            <span class="keyword">if</span> (mirrors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mirrors.size(); j++) &#123;</span><br><span class="line">                    mappings[mirrors.getAttributeIndex(j)] = mapped;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步将遍历当前注解中的属性，然后判断是否在根注解中存在同名属性，若存则直接将 <code>conventionMappings</code> 中对应下标的位置设置为根注解对应属性的下标。</p>
<h3 id="2-子注解覆盖父注解">2、子注解覆盖父注解</h3>
<p><code>addConventionAnnotationValues</code> 用于实现子注解覆盖父注解中同名同类型属性的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addConventionAnnotationValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历当前注解的全部属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.attributes.size(); i++) &#123;</span><br><span class="line">        Method attribute = <span class="keyword">this</span>.attributes.get(i);</span><br><span class="line">        <span class="keyword">boolean</span> isValueAttribute = MergedAnnotation.VALUE.equals(attribute.getName());</span><br><span class="line">        AnnotationTypeMapping mapping = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 从当前注解向非根注解的子注解递归</span></span><br><span class="line">        <span class="keyword">while</span> (mapping != <span class="keyword">null</span> &amp;&amp; mapping.distance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若当前方法在子注解中存在，则将annotationValueMappings和annotationValueSource替换为该子注解和子注解的属性</span></span><br><span class="line">            <span class="comment">// 由于替换前会比较annotationValueSource中注解距离根注解的距离，</span></span><br><span class="line">            <span class="comment">// 所以之前设置的根注解属性不受影响，因为跟注解距离为0，优先级总是最高的</span></span><br><span class="line">            <span class="keyword">int</span> mapped = mapping.getAttributes().indexOf(attribute.getName());</span><br><span class="line">            <span class="keyword">if</span> (mapped != -<span class="number">1</span> &amp;&amp; isBetterConventionAnnotationValue(i, isValueAttribute, mapping)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.annotationValueMappings[i] = mapped;</span><br><span class="line">                <span class="keyword">this</span>.annotationValueSource[i] = mapping;</span><br><span class="line">            &#125;</span><br><span class="line">            mapping = mapping.source;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBetterConventionAnnotationValue</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> isValueAttribute,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  AnnotationTypeMapping mapping)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.annotationValueMappings[index] == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> existingDistance = <span class="keyword">this</span>.annotationValueSource[index].distance;</span><br><span class="line">    <span class="keyword">return</span> !isValueAttribute &amp;&amp; existingDistance &gt; mapping.distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它大概干了这些事：</p>
<ul>
<li>若自注解中存在非 <code>value</code> 同名字段，则将与当前属性对应位置的 <code>annotationValueSource</code> 和<code>annotationValueMappings</code> 设置为该子注解和该注解中同名属性的方法下标；</li>
<li>若子注解的子注解中仍然存在同名注解，则选择一个离根注解最近的子注解，重复上述过程；</li>
<li>重复上述两步直到全部子注解递归完毕；</li>
</ul>
<h2 id="总结">总结</h2>
<p>回滚整个流程，我们了解了 Spring 中元注解的解析过程，与注解的属性覆盖与别名机制的实现。</p>
<p>当我们通过 <code>MergedAnnotations</code> 去从 <code>AnnotatedElement</code> 获取注解的时候，会有专门的 <code>AnnotationProcessor</code> ——比如 <code>MergedAnnotationFinder</code>——去把指定类型的注解上的全部元注解解析为 <code>AnnotationTypeMapping</code>，然后 <code>AnnotationTypeMapping</code> 在把一个一个的元注解对象转为 <code>AnnotationTypeMapping</code>，让他们形成类似链表的结构，从而维持父子注解间层次关系。</p>
<p>而当 <code>AnnotationTypeMapping</code> 在创建时，会递归解析 <code>AnnotationTypeMapping</code> 链表结构上的全部节点，然后解析他们的属性，让通过 <code>@AliasFor</code> 构成别名关系的属性在各个注解中以 <code>MirrorSet</code> 的形式存在，从实现别名机制。</p>
<p>并且，在完成别名映射后，<code>AnnotationTypeMapping</code> 还会再次递归解析<code>AnnotationTypeMapping</code> 链表结构上的全部节点的属性，让子注解中与父注解具有相同名称、类型的非 <code>"value"</code> 属性覆盖父注解中的属性。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
            <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/08/06/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" rel="next" title="深入理解Spring注解机制（一）：注解的搜索与处理机制">
                <i class="fa fa-chevron-left"></i> 深入理解Spring注解机制（一）：注解的搜索与处理机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/08/14/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%88%E5%B9%B6%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%88%E6%88%90/" rel="prev" title="深入理解Spring注解机制（三）：合并注解的合成">
                深入理解Spring注解机制（三）：合并注解的合成 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/Createsequence.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <!-- <a href="/archives/%7C%7Carchive"> -->
                <a href="/">
              
                  <span class="site-state-item-count">99</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E5%88%9B%E5%BB%BA%E5%90%88%E5%B9%B6%E6%B3%A8%E8%A7%A3%E8%81%9A%E5%90%88"><span class="nav-text">一、创建合并注解聚合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%A5%E5%8F%A3"><span class="nav-text">1、入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-typemappedannotations"><span class="nav-text">2、TypeMappedAnnotations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E5%85%83%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="nav-text">二、元注解的解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E5%85%83%E6%B3%A8%E8%A7%A3%E8%81%9A%E5%90%88%E4%BD%93"><span class="nav-text">1、创建元注解聚合体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%94%B6%E9%9B%86%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">2、收集元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%A7%A3%E6%9E%90%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">3、解析元注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90"><span class="nav-text">三、属性解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%A7%A3%E6%9E%90%E6%97%A0%E5%88%AB%E5%90%8D%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7"><span class="nav-text">1、解析无别名注解属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%A3%E6%9E%90%E5%B8%A6aliasfor%E7%9A%84%E5%88%AB%E5%90%8D%E5%B1%9E%E6%80%A7"><span class="nav-text">2、解析带@AliasFor的别名属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E6%98%A0%E5%B0%84%E5%B1%9E%E6%80%A7%E5%88%AB%E5%90%8D"><span class="nav-text">四、映射属性别名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%94%B6%E9%9B%86%E5%85%B3%E8%81%94%E7%9A%84%E5%88%AB%E5%90%8D%E5%B1%9E%E6%80%A7"><span class="nav-text">1、收集关联的别名属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A4%84%E7%90%86%E5%88%AB%E5%90%8D%E5%B1%9E%E6%80%A7"><span class="nav-text">2、处理别名属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%AB%E5%90%8D%E5%B1%9E%E6%80%A7%E5%85%B3%E7%B3%BB%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="nav-text">3、别名属性关系的构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%AB%E5%90%8D%E5%B1%9E%E6%80%A7%E5%94%AF%E4%B8%80%E5%80%BC%E7%9A%84%E7%A1%AE%E8%AE%A4"><span class="nav-text">4、别名属性唯一值的确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A4%9A%E7%BA%A7%E5%88%AB%E5%90%8D"><span class="nav-text">4、多级别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%98%A0%E5%B0%84%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96"><span class="nav-text">五、映射属性覆盖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B9%E6%B3%A8%E8%A7%A3%E8%A6%86%E7%9B%96%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">1、根注解覆盖元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%90%E6%B3%A8%E8%A7%A3%E8%A6%86%E7%9B%96%E7%88%B6%E6%B3%A8%E8%A7%A3"><span class="nav-text">2、子注解覆盖父注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Createsequence</span>

  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <!-- 引入目录截取js -->
  <script type="text/javascript" src="/js/src/custom/custom.js"></script>
</body>
</html>
