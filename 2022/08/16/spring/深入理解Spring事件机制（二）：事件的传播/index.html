<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"createsequence.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言Spring 从 3.x 开始支持事件机制。在 Spring 的事件机制中，我们可以令一个事件类继承 ApplicationEvent 类，然后将实现了 ApplicationListener 的 Bean 注册到 spring 容器，最后向 ApplicationEventPublisher 推送事件对象即可令所有订阅者收到事件。在 4.2 以后，甚至不需要实现 ApplicationLis">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Spring事件机制（二）：事件的传播">
<meta property="og:url" content="https://createsequence.github.io/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD/index.html">
<meta property="og:site_name" content="Createsequence&#39;s Blog">
<meta property="og:description" content="前言Spring 从 3.x 开始支持事件机制。在 Spring 的事件机制中，我们可以令一个事件类继承 ApplicationEvent 类，然后将实现了 ApplicationListener 的 Bean 注册到 spring 容器，最后向 ApplicationEventPublisher 推送事件对象即可令所有订阅者收到事件。在 4.2 以后，甚至不需要实现 ApplicationLis">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-15T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-16T15:11:58.000Z">
<meta property="article:author" content="Createsequence">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="SpringBoot">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://createsequence.github.io/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://createsequence.github.io/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD/","path":"2022/08/16/spring/深入理解Spring事件机制（二）：事件的传播/","title":"深入理解Spring事件机制（二）：事件的传播"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>深入理解Spring事件机制（二）：事件的传播 | Createsequence's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <!-- 引入目录截取js -->
  <script type="text/javascript" src="/js/custom.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Createsequence's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8E%A8%E9%80%81"><span class="nav-text">一、事件的推送</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%B0%86%E4%BA%8B%E4%BB%B6%E6%8E%A8%E9%80%81%E5%88%B0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">1、将事件推送到上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%B0%86%E4%BA%8B%E4%BB%B6%E6%8E%A8%E9%80%81%E5%88%B0%E5%B9%BF%E6%92%AD%E5%99%A8"><span class="nav-text">2、将事件推送到广播器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E6%A3%80%E7%B4%A2"><span class="nav-text">二、监听器的检索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8%E6%A3%80%E7%B4%A2%E5%99%A8"><span class="nav-text">1、监听器检索器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%8E%B7%E5%8F%96%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">2、获取监听器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-text">三、监听器的执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%B9%BF%E6%92%AD%E5%99%A8%E7%9A%84%E5%B9%BF%E6%92%AD"><span class="nav-text">1、广播器的广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%99%AE%E9%80%9A%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-text">2、普通监听器的执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E6%94%AF%E6%8C%81"><span class="nav-text">3、返回值支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81"><span class="nav-text">4、事务支持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Createsequence"
      src="/images/Createsequence.jpg">
  <p class="site-author-name" itemprop="name">Createsequence</p>
  <div class="site-description" itemprop="description">一个努力前进的程序猿</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Createsequence" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Createsequence" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://createsequence.github.io/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Createsequence.jpg">
      <meta itemprop="name" content="Createsequence">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Createsequence's Blog">
      <meta itemprop="description" content="一个努力前进的程序猿">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="深入理解Spring事件机制（二）：事件的传播 | Createsequence's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解Spring事件机制（二）：事件的传播
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-08-16 00:00:00 / 修改时间：23:11:58" itemprop="dateCreated datePublished" datetime="2022-08-16T00:00:00+08:00">2022-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring 从 <code>3.x</code> 开始支持事件机制。在 Spring 的事件机制中，我们可以令一个事件类继承 <code>ApplicationEvent</code> 类，然后将实现了 <code>ApplicationListener</code> 的 <code>Bean</code> 注册到 spring 容器，最后向 <code>ApplicationEventPublisher</code> 推送事件对象即可令所有订阅者收到事件。在 <code>4.2</code> 以后，甚至不需要实现 <code>ApplicationListener</code> 接口，仅需在 <code>Bean</code> 中方法标记 <code>@EventListener</code> 注解即可。</p>
<p>笔者将基于 Spring 源码的 <code>5.2.x</code> 分支，分析该功能是如何实现的。</p>
<p>本文是其中的第二篇文章，将分析事件是如何通过广播器推送，并被监听器接收并处理的。</p>
<p>在开始前，推荐先阅读前文了解一点 Spring 的注解机制或者事务机制，这将更有利于流程与一些代码的理解。</p>
<p>相关文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Createsequence/p/16591407.html">深入理解Spring事件机制（一）：广播器与监听器的初始化</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Createsequence/p/16591418.html">深入理解Spring事件机制（二）：事件的推送</a></li>
</ul>
<h2 id="一、事件的推送"><a href="#一、事件的推送" class="headerlink" title="一、事件的推送"></a>一、事件的推送</h2><h3 id="1、将事件推送到上下文"><a href="#1、将事件推送到上下文" class="headerlink" title="1、将事件推送到上下文"></a>1、将事件推送到上下文</h3><p>当我们借助 Spring 发送一个事件对象的时候，一般都通过 <code>ApplicationEventPublisher</code> 完成，在默认情况下，通过容器获得的 <code>ApplicationEventPublisher</code> 单例实际上就是 <code>ApplicationContext</code> 本身。</p>
<p><code>ApplicationEventPublisher</code> 提供了两个 <code>publishEvent</code> 方法，一个用于发布 <code>ApplicationEvent</code> 事件，另一个用于发布其他事件，在 <code>AbstractApplicationContext</code> 中，它们都通过同一个私有方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推送ApplicationEvent事件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    publishEvent(event, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推送非ApplicationEvent事件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    publishEvent(event, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事件对象没继承ApplicationEvent，就包装为PayloadApplicationEvent</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>&lt;&gt;(<span class="built_in">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得事件对象的实际类型</span></span><br><span class="line">            eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上下文中早期事件列表的事件没清空，说明还在上下文初始化过程，还没有可用的广播器</span></span><br><span class="line">    <span class="comment">// 因此此时不直接广播事件，而是加入早期事件列表，等到广播器完成初始化后再推送</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接推送事件</span></span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父上下文，则也向父上下文推送事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步方法总共做了这些事：</p>
<ul>
<li>如果事件对象没有继承 <code>ApplicationEvent</code>，则将其包装为 <code>PayloadApplicationEvent</code>；</li>
<li>若早期事件列表为空，说明还在上下文已有可用的广播器，直接通过广播器推送事件，否则就先把事件加入早期事件列表，等到广播器初始化完成后再推送；</li>
<li>如果上下文存在父上下文，则向父上下文也推送事件；</li>
</ul>
<p>针对早期事件列表，在容器调用 <code>AbstractApplicationContext.refresh</code> 方法进行初始化的过程中，早期事件列表在整个容器启动的第一个步骤 <code>prepareRefresh</code> 中被创建，而在非常靠后的 <code>registerListeners</code> 步骤中才被清空。</p>
<p>也就是说，当 <code>registerListeners</code> 还没执行前，任何向上下文推送的事件实际上都不会立刻执行，而是延迟到 <code>registerListeners</code> 这一步才会推送，在这一步后，向上下文推送的事件都会立刻被推送。</p>
<h3 id="2、将事件推送到广播器"><a href="#2、将事件推送到广播器" class="headerlink" title="2、将事件推送到广播器"></a>2、将事件推送到广播器</h3><p>当上下文将事件推送到广播器时，需要调用 <code>ApplicationEventMulticaster.multicastEvent</code> 方法，我们以默认的实现类 <code>SimpleApplicationEventMulticaster</code> 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取事件的实际类型</span></span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="comment">// 获取任务执行器，</span></span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">    <span class="comment">// 获取已经注册的监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过执行器执行广播调用过程</span></span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步共干了四件事：</p>
<ul>
<li>获取事件的实际类型；</li>
<li>获取广播器中配置的任务执行器；</li>
<li>通过事件的实际类型获取对应的监听器；</li>
<li>遍历监听器，在执行器中调用监听器；</li>
</ul>
<p>更简单的概况，就是：找到事件对应的监听器，然后依次放到执行器执行。</p>
<p>下面我们将详细分析监听器查询与执行的过程。</p>
<h2 id="二、监听器的检索"><a href="#二、监听器的检索" class="headerlink" title="二、监听器的检索"></a>二、监听器的检索</h2><p>在广播器广播事件时，会调用 <code>getApplicationListeners</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(</span><br><span class="line">    ApplicationEvent event, ResolvableType eventType) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取事件的实际类型</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">source</span> <span class="operator">=</span> event.getSource();</span><br><span class="line">    Class&lt;?&gt; sourceType = (source != <span class="literal">null</span> ? source.getClass() : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 生成监听器与事件类型的缓存key</span></span><br><span class="line">    <span class="type">ListenerCacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenerCacheKey</span>(eventType, sourceType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中获取事件对应的监听器检索器，若不存在则新建并加入缓存</span></span><br><span class="line">    <span class="type">CachedListenerRetriever</span> <span class="variable">newRetriever</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">CachedListenerRetriever</span> <span class="variable">existingRetriever</span> <span class="operator">=</span> <span class="built_in">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (existingRetriever == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Caching a new ListenerRetriever if possible</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.beanClassLoader == <span class="literal">null</span> ||</span><br><span class="line">            (ClassUtils.isCacheSafe(event.getClass(), <span class="built_in">this</span>.beanClassLoader) &amp;&amp;</span><br><span class="line">             (sourceType == <span class="literal">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="built_in">this</span>.beanClassLoader)))) &#123;</span><br><span class="line">            newRetriever = <span class="keyword">new</span> <span class="title class_">CachedListenerRetriever</span>();</span><br><span class="line">            existingRetriever = <span class="built_in">this</span>.retrieverCache.putIfAbsent(cacheKey, newRetriever);</span><br><span class="line">            <span class="keyword">if</span> (existingRetriever != <span class="literal">null</span>) &#123;</span><br><span class="line">                newRetriever = <span class="literal">null</span>;  <span class="comment">// no need to populate it in retrieveApplicationListeners</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若存在，则从检索器中获取全部监听器</span></span><br><span class="line">    <span class="keyword">if</span> (existingRetriever != <span class="literal">null</span>) &#123;</span><br><span class="line">        Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners();</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If result is null, the existing retriever is not fully populated yet by another thread.</span></span><br><span class="line">        <span class="comment">// Proceed like caching wasn&#x27;t possible for this current local attempt.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从检索器中获取所需的监听器</span></span><br><span class="line">    <span class="keyword">return</span> retrieveApplicationListeners(eventType, sourceType, newRetriever);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、监听器检索器"><a href="#1、监听器检索器" class="headerlink" title="1、监听器检索器"></a>1、监听器检索器</h3><p>默认的广播器 <code>SimpleApplicationEventMulticaster</code> 中维护了两个检索器内部类，用于管理注册到广播器的监听器，它们有不同的用途：</p>
<ul>
<li><code>DefaultListenerRetriever</code> ：用于支持监听器的注册功能；</li>
<li><code>CachedListenerRetriever</code>：用于提供基于事件类型快速查询对应监听器的缓存功能；</li>
</ul>
<p><strong>DefaultListenerRetriever</strong></p>
<p><code>DefaultListenerRetriever</code> 主要用于支持监听器的注册，他唯一的作用就是提供 <code>getApplicationListeners</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DefaultListenerRetriever</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听器实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听器Bean名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Set&lt;String&gt; applicationListenerBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;</span><br><span class="line">        <span class="comment">// 先获得Bean实例</span></span><br><span class="line">        List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            <span class="built_in">this</span>.applicationListeners.size() + <span class="built_in">this</span>.applicationListenerBeans.size());</span><br><span class="line">        allListeners.addAll(<span class="built_in">this</span>.applicationListeners);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再根据BeanName从BeanFactory中获取监听器Bean</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.applicationListenerBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">            <span class="keyword">for</span> (String listenerBeanName : <span class="built_in">this</span>.applicationListenerBeans) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ApplicationListener&lt;?&gt; listener =</span><br><span class="line">                        beanFactory.getBean(listenerBeanName, ApplicationListener.class);</span><br><span class="line">                    <span class="keyword">if</span> (!allListeners.contains(listener)) &#123;</span><br><span class="line">                        allListeners.add(listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                    <span class="comment">// Singleton listener instance (without backing bean definition) disappeared -</span></span><br><span class="line">                    <span class="comment">// probably in the middle of the destruction phase</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对监听器排序</span></span><br><span class="line">        AnnotationAwareOrderComparator.sort(allListeners);</span><br><span class="line">        <span class="keyword">return</span> allListeners;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该检索器支持直接注册 <code>Bean</code> 实例，或者只注册 <code>BeanName</code>，当调用 <code>getApplicationListeners</code> 将会全量的获得已注册的监听器实例。</p>
<p><strong>CachedListenerRetriever</strong></p>
<p><code>CachedListenerRetriever</code> 用于提供基于事件类型快速查询对应监听器的缓存功能，它总是在 <code>DefaultListenerRetriever</code> 创建后，向广播器推送事件的时候才会被创建，而当向广播器注册监听器时，如果已有该缓存检索器，则它们全部都会被销毁，等待下一次推送时间时再被创建，从而实现刷新缓存的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CachedListenerRetriever</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> Set&lt;String&gt; applicationListenerBeans;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners() &#123;</span><br><span class="line">        Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners = <span class="built_in">this</span>.applicationListeners;</span><br><span class="line">        Set&lt;String&gt; applicationListenerBeans = <span class="built_in">this</span>.applicationListenerBeans;</span><br><span class="line">        <span class="keyword">if</span> (applicationListeners == <span class="literal">null</span> || applicationListenerBeans == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Not fully populated yet</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            applicationListeners.size() + applicationListenerBeans.size());</span><br><span class="line">        allListeners.addAll(applicationListeners);</span><br><span class="line">        <span class="keyword">if</span> (!applicationListenerBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">            <span class="keyword">for</span> (String listenerBeanName : applicationListenerBeans) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    allListeners.add(beanFactory.getBean(listenerBeanName, ApplicationListener.class));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                    <span class="comment">// Singleton listener instance (without backing bean definition) disappeared -</span></span><br><span class="line">                    <span class="comment">// probably in the middle of the destruction phase</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!applicationListenerBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 对监听器排序</span></span><br><span class="line">            AnnotationAwareOrderComparator.sort(allListeners);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allListeners;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而每一个 <code>CachedListenerRetriever</code> 都会有一个对应的 <code>ListenerCacheKey</code>，这个类重写了 <code>hashCode</code> 与 <code>equals</code> 方法，用来在 Map 集合中根据事件类型与事件 source 作为 key： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ListenerCacheKey</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;ListenerCacheKey&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResolvableType eventType;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、获取监听器"><a href="#2、获取监听器" class="headerlink" title="2、获取监听器"></a>2、获取监听器</h3><p>在 <code>getApplicationListeners</code> 方法中，主要用于创建一个 <code>ListenerCacheKey</code> 对应的 <code>CachedListenerRetriever</code> 缓存实例，不过实际上此时 <code>CachedListenerRetriever</code> 仍然还是空的，需要在最后通过 <code>retrieveApplicationListeners</code> 方法从 <code>DefaultListenerRetriever</code> 中找到对应的监听器，然后将他们都刷进缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(</span><br><span class="line">    ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, <span class="meta">@Nullable</span> CachedListenerRetriever retriever) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Set&lt;ApplicationListener&lt;?&gt;&gt; filteredListeners = (retriever != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;() : <span class="literal">null</span>);</span><br><span class="line">    Set&lt;String&gt; filteredListenerBeans = (retriever != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br><span class="line">    Set&lt;String&gt; listenerBeans;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.defaultRetriever) &#123;</span><br><span class="line">        listeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListeners);</span><br><span class="line">        listenerBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListenerBeans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历监听器实例，如果支持处理该事件</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : listeners) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supportsEvent(listener, eventType, sourceType)) &#123;</span><br><span class="line">            <span class="comment">// 有检索器缓存</span></span><br><span class="line">            <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">                filteredListeners.add(listener);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无检索器缓存</span></span><br><span class="line">            allListeners.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历仅注册了BeanName的监听器，并将其中支持处理该事件的监听器BeanFactory中取出</span></span><br><span class="line">    <span class="keyword">if</span> (!listenerBeans.isEmpty()) &#123;</span><br><span class="line">        <span class="type">ConfigurableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">        <span class="keyword">for</span> (String listenerBeanName : listenerBeans) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (supportsEvent(beanFactory, listenerBeanName, eventType)) &#123;</span><br><span class="line">                    ApplicationListener&lt;?&gt; listener =</span><br><span class="line">                        beanFactory.getBean(listenerBeanName, ApplicationListener.class);</span><br><span class="line">                    <span class="keyword">if</span> (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果是单例Bean，可以直接取出备用</span></span><br><span class="line">                            <span class="keyword">if</span> (beanFactory.isSingleton(listenerBeanName)) &#123;</span><br><span class="line">                                filteredListeners.add(listener);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果不是单例Bean，则不保证后续会不会再调整，因此只记录BeanName，等要用的时候再获取</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                filteredListenerBeans.add(listenerBeanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        allListeners.add(listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 移除不匹配该事件的监听器</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">listener</span> <span class="operator">=</span> beanFactory.getSingleton(listenerBeanName);</span><br><span class="line">                    <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">                        filteredListeners.remove(listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                    allListeners.remove(listener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                <span class="comment">// Singleton listener instance (without backing bean definition) disappeared -</span></span><br><span class="line">                <span class="comment">// probably in the middle of the destruction phase</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对监听器排序</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(allListeners);</span><br><span class="line">    <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredListenerBeans.isEmpty()) &#123;</span><br><span class="line">            retriever.applicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(allListeners);</span><br><span class="line">            retriever.applicationListenerBeans = filteredListenerBeans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            retriever.applicationListeners = filteredListeners;</span><br><span class="line">            retriever.applicationListenerBeans = filteredListenerBeans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allListeners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这里多次调用的 <code>support</code> 方法按顺序依次则有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supportsEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">    ApplicationListener&lt;?&gt; listener, ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">GenericApplicationListener</span> <span class="variable">smartListener</span> <span class="operator">=</span> (listener <span class="keyword">instanceof</span> GenericApplicationListener ?</span><br><span class="line">                                                (GenericApplicationListener) listener : <span class="keyword">new</span> <span class="title class_">GenericApplicationListenerAdapter</span>(listener));</span><br><span class="line">    <span class="keyword">return</span> (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">supportsEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableBeanFactory beanFactory, String listenerBeanName, ResolvableType eventType)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取监听器类型，并判断监听器是否支持处理该事件：</span></span><br><span class="line">    Class&lt;?&gt; listenerType = beanFactory.getType(listenerBeanName);</span><br><span class="line">    <span class="comment">// 1.GenericApplicationListener与SmartApplicationListener默认支持所有ApplicationEvent,</span></span><br><span class="line">    <span class="comment">// 因此如果监听器是上述任意一种，直接返回ture</span></span><br><span class="line">    <span class="keyword">if</span> (listenerType == <span class="literal">null</span> || GenericApplicationListener.class.isAssignableFrom(listenerType) ||</span><br><span class="line">        SmartApplicationListener.class.isAssignableFrom(listenerType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.获取监听器ApplicationListener的类泛型，判断是否为该类事件，不是就直击返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!supportsEvent(listenerType, eventType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3.如果还不行，尝试直接从BeanFactory获取BeanDefinition信息，然后转为ApplicationListener后再获取它在类泛型上声明的事件类型</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> beanFactory.getMergedBeanDefinition(listenerBeanName);</span><br><span class="line">        <span class="type">ResolvableType</span> <span class="variable">genericEventType</span> <span class="operator">=</span> bd.getResolvableType().as(ApplicationListener.class).getGeneric();</span><br><span class="line">        <span class="comment">// 如果能获得事件类型就判断，不能说明实际上支持所有类型，都返回ture</span></span><br><span class="line">        <span class="keyword">return</span> (genericEventType == ResolvableType.NONE || genericEventType.isAssignableFrom(eventType));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="comment">// Ignore - no need to check resolvable type for manually registered singleton</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supportsEvent</span><span class="params">(Class&lt;?&gt; listenerType, ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取在监听器泛型声明的事件类型，确认这个事件类型是否与当前事件为一类事件</span></span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">declaredEventType</span> <span class="operator">=</span> GenericApplicationListenerAdapter.resolveDeclaredEventType(listenerType);</span><br><span class="line">    <span class="keyword">return</span> (declaredEventType == <span class="literal">null</span> || declaredEventType.isAssignableFrom(eventType));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ResolvableType <span class="title function_">resolveDeclaredEventType</span><span class="params">(Class&lt;?&gt; listenerType)</span> &#123;</span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">eventType</span> <span class="operator">=</span> eventTypeCache.get(listenerType);</span><br><span class="line">    <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将监听器转为ApplicationListener，获取其类泛型声明的事件类型</span></span><br><span class="line">        eventType = ResolvableType.forClass(listenerType).as(ApplicationListener.class).getGeneric();</span><br><span class="line">        eventTypeCache.put(listenerType, eventType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (eventType != ResolvableType.NONE ? eventType : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑有点长，不过主要目标还是很清晰的：</p>
<ul>
<li>先根据事件的类型和 <code>source</code> 获取 <code>CachedListenerRetriever</code> 缓存，如果没缓存就先创建；</li>
<li>从 <code>DefaultListenerRetriever</code> 获取全部监听器：<ol>
<li>如果能获取实例，就直接获得实例；</li>
<li>不能获得实例，就通过 <code>BeanName</code> 从 <code>BeanFactory</code> 里取；</li>
</ol>
</li>
<li>判断这些监听器支不支持处理当前推送的事件：<ol>
<li>如果能拿到实例，并且如果实现了 <code>GenericApplicationListener</code>，就直接调用 <code>supportsEventType</code> 和 <code>supportsSourceType</code> 方法判断；</li>
<li>如果不能拿到实例，那就尝试拿到实际的类型，并且通过泛型确认是否支持当前推送的事件；</li>
</ol>
</li>
<li>获得全部支持该事件的监听器后，再将其刷入 <code>CachedListenerRetriever</code> 缓存，下次再来就直接从缓存里头取；</li>
</ul>
<h2 id="三、监听器的执行"><a href="#三、监听器的执行" class="headerlink" title="三、监听器的执行"></a>三、监听器的执行</h2><p>监听器的执行分为两步，第一步是在广播器中调用监听器的 <code>onApplicationEvent</code>，第二步是在 <code>onApplicationEvent</code> 调用真正的处理逻辑，这里根据监听器类型的不同而具有不同的实现，这里我们重点关注注解式监听器。</p>
<h3 id="1、广播器的广播"><a href="#1、广播器的广播" class="headerlink" title="1、广播器的广播"></a>1、广播器的广播</h3><p>监听器的执行对应 <code>multicastEvent</code> 中的这一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取任务执行器，</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line"><span class="comment">// 获取已经注册的监听器</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过执行器异步执行广播调用过程</span></span><br><span class="line">        executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果通过当前线程执行广播调用过程</span></span><br><span class="line">        invokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="type">ErrorHandler</span> <span class="variable">errorHandler</span> <span class="operator">=</span> getErrorHandler();</span><br><span class="line">    <span class="keyword">if</span> (errorHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发生异常时调用</span></span><br><span class="line">            doInvokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            errorHandler.handleError(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        doInvokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 onApplicationEvent 方法</span></span><br><span class="line">        listener.onApplicationEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</span><br><span class="line">            <span class="comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span></span><br><span class="line">            <span class="comment">// -&gt; let&#x27;s suppress the exception and just log a debug message.</span></span><br><span class="line">            <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑非常简单：</p>
<ul>
<li>获取全部支持处理该事件的监听器，然后依次调用 <code>ApplicationListener.onApplicationEvent</code> 方法；</li>
<li>如果广播器有设置线程池，则调用监听器的时候就在线程池里调用，否则在当前线程里调用；</li>
<li>当调用发生异常时，就调用广播器中注册的异常处理器 <code>ErrorHandler</code>；</li>
</ul>
<h3 id="2、普通监听器的执行"><a href="#2、普通监听器的执行" class="headerlink" title="2、普通监听器的执行"></a>2、普通监听器的执行</h3><p>我们以最基本的注解式监听器 <code>ApplicationListenerMethodAdapter</code> 为例，当调用它的 <code>onApplicationEvent</code> 方法时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    processEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    Object[] args = resolveArguments(event);</span><br><span class="line">    <span class="keyword">if</span> (shouldHandle(event, args)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> doInvoke(args);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            handleResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No result object given - no result to handle&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>条件判断</strong></p>
<p>此过程平平无奇，其中 <code>shouldHandle</code> 方法用于根据在 <code>@EventListener</code> 中的 <code>condition</code> 属性指定的 <code>SpEL</code> 表达式确定是否需要真正调用注解方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">shouldHandle</span><span class="params">(ApplicationEvent event, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">condition</span> <span class="operator">=</span> getCondition();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(condition)) &#123;</span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.evaluator, <span class="string">&quot;EventExpressionEvaluator must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.evaluator.condition(</span><br><span class="line">            condition, event, <span class="built_in">this</span>.targetMethod, <span class="built_in">this</span>.methodKey, args, <span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于 <code>evaluator</code> 则是 Spring 基于 <code>SpEL</code> 表达式封装的一个用于事件的工具类 <code>EventExpressionEvaluator</code>，关于这个可以单独了解 <code>SpelExpressionParser</code>、<code>StandardEvaluationContext</code> 、 <code>Expression</code> 这三个类，或者直接了解 Spring 的 <code>SpEL</code> 表达式相关功能。</p>
<h3 id="3、返回值支持"><a href="#3、返回值支持" class="headerlink" title="3、返回值支持"></a>3、返回值支持</h3><p>相比于普通的编程式监听器，注解式监听器还会多处一步对返回值的处理。我们以 <code>ApplicationListenerMethodAdapter</code> 为例，当 <code>doInvoke</code> 以后，若注解方法返回值不为null，则会尝试通过 <code>handleResult</code> 对返回值进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reactiveStreamsPresent &amp;&amp; <span class="keyword">new</span> <span class="title class_">ReactiveResultHandler</span>().subscribeToPublisher(result)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Adapted to reactive result: &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、返回值是CompletionStage</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> CompletionStage) &#123;</span><br><span class="line">        ((CompletionStage&lt;?&gt;) result).whenComplete((event, ex) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 发生异常</span></span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">                handleAsyncError(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当完成后若有返回值，则继续尝试处理返回值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (event != <span class="literal">null</span>) &#123;</span><br><span class="line">                publishEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、返回值是ListenableFuture</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ListenableFuture) &#123;</span><br><span class="line">        ((ListenableFuture&lt;?&gt;) result).addCallback(<span class="built_in">this</span>::publishEvents, <span class="built_in">this</span>::handleAsyncError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、返回值是普通对象、数组或者集合</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        publishEvents(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当监听器方法有返回值的时候，这里有三种处理：</p>
<ul>
<li>返回值是 <code>CompletionStage</code>，继续完成下一步异步调用；</li>
<li>返回值是 <code>ListenableFuture</code>，调用回调方法；</li>
<li>返回值返回值是对象、数组或集合，尝试作为将其作为事件对象发送；</li>
</ul>
<p><strong>返回值是CompletionStage</strong></p>
<p>当看到了 <code>CompletionStage</code> 的时候，很容易联想到基于它实现的 <code>CompletableFuture</code>。它表示一个待完成的异步任务，在 <code>ApplicationListenerMethodAdapter</code> 中，监听器会通过如下代码，为其追加任务完成后的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当这一步完成后，获取执行结构</span></span><br><span class="line">((CompletionStage&lt;?&gt;) result).whenComplete((event, ex) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果发生异常</span></span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleAsyncError(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当完成后若有返回值，则继续尝试处理返回值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event != <span class="literal">null</span>) &#123;</span><br><span class="line">        publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>返回值是ListenableFuture</strong></p>
<p><code>ListenableFuture</code> 也是一个异步任务回调接口，它的用法与 Guava 中的 <code>ListenableFuture</code> 几乎完全一致，处理的逻辑与上文的返回值是 <code>CompletionStage</code> 的情况也完全一致，就是追加任务完成后的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ListenableFuture&lt;?&gt;) result).addCallback(<span class="built_in">this</span>::publishEvents, <span class="built_in">this</span>::handleAsyncError);</span><br></pre></td></tr></table></figure>

<p>当任务的返回值不为 null 的时候，就尝试处理它的返回值。</p>
<p><strong>返回值是普通对象、数组或集合</strong></p>
<p>当对象是普通对象的时候，监听器会尝试将返回值也作为一个事件推送。而如果是数组或者集合，会先将其摊平，然后把其中的每一个元素都取出尝试作为事件推送：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">publishEvents</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是数组，就将数组取出然后依次作为事件发送</span></span><br><span class="line">    <span class="keyword">if</span> (result.getClass().isArray()) &#123;</span><br><span class="line">        Object[] events = ObjectUtils.toObjectArray(result);</span><br><span class="line">        <span class="keyword">for</span> (Object event : events) &#123;</span><br><span class="line">            publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是集合，也平铺后依次将其中元素作为事件发送</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Collection&lt;?&gt;) &#123;</span><br><span class="line">        Collection&lt;?&gt; events = (Collection&lt;?&gt;) result;</span><br><span class="line">        <span class="keyword">for</span> (Object event : events) &#123;</span><br><span class="line">            publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接将返回值作为事件发送</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        publishEvent(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(<span class="meta">@Nullable</span> Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event != <span class="literal">null</span>) &#123;</span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.applicationContext, <span class="string">&quot;ApplicationContext must not be null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.applicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、事务支持"><a href="#4、事务支持" class="headerlink" title="4、事务支持"></a>4、事务支持</h3><p>由于编程式监听器天生就是支持事务的，因此 Spring 只单纯为注解式监听器专门准备的事务监听器方法适配器 <code>ApplicationListenerMethodTransactionalAdapter</code>，它由监听器工厂 <code>TransactionalEventListenerFactory</code> 生产，与一个 <code>@TransactionalEventListener</code> 注解对应。</p>
<p><strong>@TransactionalEventListener</strong></p>
<p>而 <code>@TransactionalEventListener</code> 是一个基于 Spring 元注解机制扩展的注解，它在 <code>@EventListener</code> 的基础上扩展了一些事务相关的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalEventListener &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当当前事务进行到哪个阶段时，调用该监听器，若fallbackExecution为true时无意义</span></span><br><span class="line">    TransactionPhase <span class="title function_">phase</span><span class="params">()</span> <span class="keyword">default</span> TransactionPhase.AFTER_COMMIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前没有事务的时候，是否调用该监听器</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">fallbackExecution</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听的事件类型</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = EventListener.class, attribute = &quot;classes&quot;)</span></span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于判断是否处理事件的SpEL表达式</span></span><br><span class="line">    String <span class="title function_">condition</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ApplicationListenerMethodTransactionalAdapter</strong></p>
<p>事务监听器方法适配器 <code>ApplicationListenerMethodTransactionalAdapter</code> 继承了非事务的适配器 <code>ApplicationListenerMethodAdapter</code>，但是基于 <code>TransactionSynchronization</code> 在监听器的 <code>onApplicationEvent</code> 方法做了一些事务的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationListenerMethodTransactionalAdapter</span> <span class="keyword">extends</span> <span class="title class_">ApplicationListenerMethodAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionalEventListener annotation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApplicationListenerMethodTransactionalAdapter</span><span class="params">(String beanName, Class&lt;?&gt; targetClass, Method method)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(beanName, targetClass, method);</span><br><span class="line">        <span class="type">TransactionalEventListener</span> <span class="variable">ann</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(method, TransactionalEventListener.class);</span><br><span class="line">        <span class="keyword">if</span> (ann == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No TransactionalEventListener annotation found on method: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.annotation = ann;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果全局事务管理器可以用，则创建一个TransactionSynchronizationEventAdapter同步事务，</span></span><br><span class="line">        <span class="comment">// 并注册到全局事务管理器</span></span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp;</span><br><span class="line">            TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">            <span class="type">TransactionSynchronization</span> <span class="variable">transactionSynchronization</span> <span class="operator">=</span> createTransactionSynchronization(event);</span><br><span class="line">            TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果全局事务管理器不可用，并且在注解中配置了fallbackExecution为true，即没有事务也调用监听器</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.annotation.fallbackExecution()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Processing &quot;</span> + event + <span class="string">&quot; as a fallback execution on AFTER_ROLLBACK phase&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理器事件</span></span><br><span class="line">            processEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No transactional event execution at all</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;No transaction is active - skipping &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TransactionSynchronization <span class="title function_">createTransactionSynchronization</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionSynchronizationEventAdapter</span>(<span class="built_in">this</span>, event, <span class="built_in">this</span>.annotation.phase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TransactionSynchronizationEventAdapter</span> <span class="keyword">extends</span> <span class="title class_">TransactionSynchronizationAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ApplicationListenerMethodAdapter listener;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEvent event;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TransactionPhase phase;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TransactionSynchronizationEventAdapter</span><span class="params">(ApplicationListenerMethodAdapter listener,</span></span><br><span class="line"><span class="params">                                                      ApplicationEvent event, TransactionPhase phase)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.listener = listener;</span><br><span class="line">            <span class="built_in">this</span>.event = event;</span><br><span class="line">            <span class="built_in">this</span>.phase = phase;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.listener.getOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeCommit</span><span class="params">(<span class="type">boolean</span> readOnly)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果注解中配置了调用阶段为TransactionPhase.BEFORE_COMMIT，则事务提交前调用</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.phase == TransactionPhase.BEFORE_COMMIT) &#123;</span><br><span class="line">                processEvent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">            <span class="comment">// 事务提交时调用</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.phase == TransactionPhase.AFTER_COMMIT &amp;&amp; status == STATUS_COMMITTED) &#123;</span><br><span class="line">                processEvent();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 事务回滚时调用</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.phase == TransactionPhase.AFTER_ROLLBACK &amp;&amp; status == STATUS_ROLLED_BACK) &#123;</span><br><span class="line">                processEvent();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 事务提交完毕后调用</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.phase == TransactionPhase.AFTER_COMPLETION) &#123;</span><br><span class="line">                processEvent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processEvent</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.listener.processEvent(<span class="built_in">this</span>.event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑也很直白：</p>
<ul>
<li>当调用方法时 <code>onApplicationEvent</code> 方法时，判断事务是否可用；</li>
<li>事务不可用，并且 <code>@TransactionalEventListener</code> 的 <code>fallbackExecution</code> 属性为 <code>true</code>，则直接调用注解放方法；</li>
<li>若事务可用，则创建一个实现了 <code>TransactionSynchronization</code> 接口的事务同步操作 <code>TransactionSynchronizationEventAdapter</code> ，并将其注册到 <code>TransactionSynchronizationManager</code>；</li>
<li><code>TransactionSynchronizationManager</code> 在事务进行到指定阶段后，会调用 <code>TransactionSynchronizationEventAdapter</code> 的对应回调方法；</li>
<li><code>TransactionSynchronizationEventAdapter</code> 在回调方法中，再确认当前事务阶段与在 <code>@TransactionalEventListener</code> 中 <code>phase</code> 属性指定的阶段是否一致，若一致则调用注解方法；</li>
</ul>
<p>因此此处也不难理解为什么广播器进行广播的时候，若指定了线程池则事务会失效了，因为具体到监听器适配器调用时，通过 <code>TransactionSynchronizationManager</code> 注册的事务是当前线程池中的工作线程的事务，而调用广播器的主线程的事务与其不是一个事务，因此监听器中事务回滚不会令主线程的事务一并回滚。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们向 <code>ApplicationContext</code> 推送事件时：</p>
<ul>
<li><p><code>ApplicationContext</code> 会将事件推送至内部持有的广播器实例 <code>SimpleApplicationEventMulticaster</code>；</p>
</li>
<li><p><code>SimpleApplicationEventMulticaster</code> 在内部维护了两个检索器，分别是 <code>DefaultListenerRetriever</code> 与 <code>CachedListenerRetriever</code>，</p>
<p>前者用于提供监听器注册和全量查询功能，后者用于提供基于事件类型与事件源类型对监听器进行快速查询的缓存，</p>
<p>当推送事件时，会先通过 <code>DefaultListenerRetriever</code> 全量查询，然后将其加入 <code>CachedListenerRetriever</code> 缓存，下次查询时直接从缓存中获取订阅了事件的监听器；</p>
</li>
<li><p>当获得订阅了事件的监听器后，会尝试调用监听器的 <code>onApplicationEvent</code> 方法：</p>
<ol>
<li>若广播器中注册了线程池，则会直接把操作提交到线程池中执行；</li>
<li>若广播器中没有注册线程，则会直接在当前线程执行；</li>
</ol>
</li>
<li><p>监听器被调用的时候，处理基本内的事件处理，而注解时监听器还额外支持一些功能，比如：</p>
<ol>
<li>如果使用了 <code>@TransactionalEventListener</code> 注解会生成支持事务的监听器 <code>ApplicationListenerMethodTransactionalAdapter</code> ，该监听器会在调用前向事务管理器注册同步事务，从而获得事务支持；</li>
<li>默认的注解式监听器生成 <code>ApplicationListenerMethodAdapter</code> 这种类型的监听器，该类监听器在绑定的注解方法有返回值时，会尝试将返回值也作为一个事件发送，而如果是集合或者数组，则会摊平后尝试将每一个元素都作为事件发生；</li>
</ol>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
              <a href="/tags/SpringBoot/" rel="tag"># SpringBoot</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/14/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%90%88%E5%B9%B6%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%88%E6%88%90/" rel="prev" title="深入理解Spring注解机制（三）：合并注解的合成">
                  <i class="fa fa-angle-left"></i> 深入理解Spring注解机制（三）：合并注解的合成
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/16/spring/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B9%BF%E6%92%AD%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="next" title="深入理解Spring事件机制（一）：广播器与监听器的初始化">
                  深入理解Spring事件机制（一）：广播器与监听器的初始化 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Createsequence</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">261k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:47</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
