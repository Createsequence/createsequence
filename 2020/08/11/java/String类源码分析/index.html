<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"createsequence.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="概述java 的 String 类可以说是日常中使用的最多的类，但是大多数时候都只是简单的拼接或者调用 API，只知其然不知其所以然。为了改变这个情况，我决定结合网上的资料，参考源码，深入一点去了解 String 这个熟悉的陌生人。 要第一时间了解一个类，没有什么比官方的文档更直观的了：">
<meta property="og:type" content="article">
<meta property="og:title" content="String类源码分析">
<meta property="og:url" content="https://createsequence.github.io/2020/08/11/java/String%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Createsequence&#39;s Blog">
<meta property="og:description" content="概述java 的 String 类可以说是日常中使用的最多的类，但是大多数时候都只是简单的拼接或者调用 API，只知其然不知其所以然。为了改变这个情况，我决定结合网上的资料，参考源码，深入一点去了解 String 这个熟悉的陌生人。 要第一时间了解一个类，没有什么比官方的文档更直观的了：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.xiajibagao.top/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BAString.png">
<meta property="og:image" content="http://img.xiajibagao.top/new%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%9B%E5%BB%BAString.png">
<meta property="og:image" content="http://img.xiajibagao.top/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%E5%A0%86%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84String%E5%AF%B9%E8%B1%A1.png">
<meta property="article:published_time" content="2020-08-10T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-16T09:42:37.000Z">
<meta property="article:author" content="Createsequence">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.xiajibagao.top/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BAString.png">


<link rel="canonical" href="https://createsequence.github.io/2020/08/11/java/String%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://createsequence.github.io/2020/08/11/java/String%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","path":"2020/08/11/java/String类源码分析/","title":"String类源码分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>String类源码分析 | Createsequence's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <!-- 引入目录截取js -->
  <script type="text/javascript" src="/js/custom.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Createsequence's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81String%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-text">一、String对象的不可变性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-text">1.String为什么是不可变的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-String%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-text">2.String不可变的必要性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">二、字符串常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="nav-text">1.作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%85%A5%E6%B1%A0%E6%96%B9%E6%B3%95intern"><span class="nav-text">2.入池方法intern()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81String%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-text">三、String对象的创建方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E5%80%BC%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BA"><span class="nav-text">1.使用字面值形式创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%9B%E5%BB%BA"><span class="nav-text">2.使用new关键字创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="nav-text">3.小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81String%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="nav-text">四、String的拼接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-StringBuilder"><span class="nav-text">1.StringBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8A%A0%E5%8F%B7%E6%8B%BC%E6%8E%A5%E4%B8%8Eappend%E6%96%B9%E6%B3%95%E6%8B%BC%E6%8E%A5"><span class="nav-text">2.加号拼接与append方法拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-StringBuffer"><span class="nav-text">3.StringBuffer</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Createsequence"
      src="/images/Createsequence.jpg">
  <p class="site-author-name" itemprop="name">Createsequence</p>
  <div class="site-description" itemprop="description">一个努力前进的程序猿</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Createsequence" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Createsequence" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://createsequence.github.io/2020/08/11/java/String%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Createsequence.jpg">
      <meta itemprop="name" content="Createsequence">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Createsequence's Blog">
      <meta itemprop="description" content="一个努力前进的程序猿">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="String类源码分析 | Createsequence's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          String类源码分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-11T00:00:00+08:00">2020-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-02-16 17:42:37" itemprop="dateModified" datetime="2021-02-16T17:42:37+08:00">2021-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>java 的 String 类可以说是日常中使用的最多的类，但是大多数时候都只是简单的拼接或者调用 API，只知其然不知其所以然。为了改变这个情况，我决定结合网上的资料，参考源码，深入一点去了解 String 这个熟悉的陌生人。</p>
<p>要第一时间了解一个类，没有什么比官方的文档更直观的了：</p>
<blockquote>
<p>String类表示字符串。Java程序中的所有字符串文本（如“abc”）都作为此类的实例实现。</p>
<p><strong>字符串是常量；它们的值在创建后不能更改</strong>。字符串缓冲区支持可变字符串。<strong>因为字符串对象是不可变的，所以可以共享它们</strong>。</p>
<p><strong>Java语言提供了对字符串连接运算符（+）以及将其他对象转换为字符串的特殊支持。字符串连接是通过<code>StringBuilder</code>（或<code>StringBuffer</code>）类及其<code>append</code>方法实现的。字符串转换是通过<code>toString</code>方法实现的</strong></p>
<p>… …</p>
</blockquote>
<p>根据文档，对于String类，我们关注三个问题：</p>
<ul>
<li>String对象的不可变性（为什么是不可变的，这么设计的必要性）</li>
<li>String对象的创建方式（两种创建方式，字符串常量池）</li>
<li>String对象的拼接（StringBuffer，StringBuilder，加号拼接的本质）</li>
</ul>
<h2 id="一、String对象的不可变性"><a href="#一、String对象的不可变性" class="headerlink" title="一、String对象的不可变性"></a>一、String对象的不可变性</h2><h3 id="1-String为什么是不可变的"><a href="#1-String为什么是不可变的" class="headerlink" title="1.String为什么是不可变的"></a>1.String为什么是不可变的</h3><p>文档中提到：</p>
<blockquote>
<p>字符串是常量；它们的值在创建后不能更改。</p>
</blockquote>
<p>对于这段话我们结合源码来看;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，String类字符其实就是char数组对象的二次封装，存储变量<code>value[]</code>是被final修饰的，所以一个String对象创建以后是无法被改变值的，这点跟包装类是一样的。</p>
<p>我们常见的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;BBB&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>实际上创建了两个String对象，我们使用 &#x3D; 只是把s指从AAA的内存地址指向了BBB的内存地址。</p>
<p>我们再看看熟悉的<code>substring()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="built_in">this</span></span><br><span class="line">        : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在最后也是返回了一个新的String对象，同理，<code>toLowerCase()</code>,<code>trim()</code>等返回字符串的方法也都是在最后返回了一个新对象。</p>
<h3 id="2-String不可变的必要性"><a href="#2-String不可变的必要性" class="headerlink" title="2.String不可变的必要性"></a>2.String不可变的必要性</h3><p>String之所以被设计为不可变的，目的是为了<strong>效率和安全性</strong>：</p>
<ul>
<li>效率：<ol>
<li>String不可变是字符串常量池实现的必要条件，通过常量池可以避免了过多的创建String对象，节省堆空间。</li>
<li>String的包含了自身的HashCode，不可变保证了对象HashCode的唯一性，避免了反复计算。</li>
</ol>
</li>
<li>安全性：<ol>
<li>String被许多Java类用来当参数，如果字符串可变，那么会引起各种严重错误和安全漏洞。</li>
<li>再者String作为核心类，很多的内部方法的实现都是本地调用的，即调用操作系统本地API，其和操作系统交流频繁，假如这个类被继承重写的话，难免会是操作系统造成巨大的隐患。</li>
<li>最后字符串的不可变性使得同一字符串实例被多个线程共享，所以保障了多线程的安全性。而且类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。</li>
</ol>
</li>
</ul>
<h2 id="二、字符串常量池"><a href="#二、字符串常量池" class="headerlink" title="二、字符串常量池"></a>二、字符串常量池</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>文档中有提到：</p>
<blockquote>
<p>因为字符串对象是不可变的，所以可以共享它们</p>
</blockquote>
<p>字符串常量池是一块用于记录字符串常量的特殊区域（具体可以参考我在关于<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Createsequence/p/13447923.html">jvm内存结构的文章</a>），JDK8之前字符串常量池在方法区的运行时常量池中，JDK8之后分离到了堆中。“共享”操作就依赖于字符串常量池。</p>
<p>我们知道String是一个对象，而<code>value[]</code>是一个不可变值，所以当我们日常中使用String的时候就会频繁的创建新的String对象。JVM为了提高性能减少内存开销，在通过类似<code>String S = “aaa”</code>这样的操作的时候，<strong>JVM会先检查常量池是否是存在相同的字符串，如果已存在就直接返回字符串实例地址，否则就会先实例一个String对象放到池中，再返回地址</strong>。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>; </span><br><span class="line">System.out.print(s1 == s2);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们知道“&#x3D;&#x3D;”比较对象的时候比较的是内存地址是否相等，当s1创建的时候，一个“aaa”String对象被创建并放入池中，s1指向的是该对象地址；当第二个s2赋值的时候，JVM从常量池中找到了值为“aaa”的字符串对象，于是跳过了创建过程，直接将s1指向的对象地址也赋给了s2.</p>
<h3 id="2-入池方法intern"><a href="#2-入池方法intern" class="headerlink" title="2.入池方法intern()"></a>2.入池方法<code>intern()</code></h3><p>这里要提一下String对象的手动入池方法 <code>intern()</code>。</p>
<p>这个方法的注释是这样的：</p>
<blockquote>
<p>最初为空的字符串池由String类私有维护。</p>
<p>调用intern方法时，如果池已经包含等于<code>equal()</code>方法确定的此String对象的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。</p>
</blockquote>
<p>举个例子说明作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;aabb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aabb&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>最开始s1创建了“aabb”对象A，并且加入了字符串常量池，接着s2创建了新的”aabb”对象B，这个对象在堆中并且独立于常量池，此时s1指向常量池中的A，s2指向常量池外的B，所以&#x3D;&#x3D;返回是false。</p>
<p>我们使用<code>intern()</code>方法手动入池，字符串常量池中已经有了值等于“aabb”的对象A，于是直接返回了对象A的地址，此时s1和s2指向的都是内存中的对象A，所以&#x3D;&#x3D;返回了true。</p>
<h2 id="三、String对象的创建方式"><a href="#三、String对象的创建方式" class="headerlink" title="三、String对象的创建方式"></a>三、String对象的创建方式</h2><p>从上文我们知道String对象的创建和字符串常量池是密切相关的，而创建一个新String对象有两种方式：</p>
<ul>
<li>使用字面值形式创建。类似 <code>String s = &quot;aaa&quot;</code></li>
<li>使用new关键字创建。类似 <code>String s = new String(&quot;aaa&quot;)</code></li>
</ul>
<h3 id="1-使用字面值形式创建"><a href="#1-使用字面值形式创建" class="headerlink" title="1.使用字面值形式创建"></a>1.使用字面值形式创建</h3><p><img src="http://img.xiajibagao.top/%E5%AD%97%E9%9D%A2%E9%87%8F%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BAString.png" alt="字面值形式创建String"></p>
<p><strong>当使用字面值创建String对象的时候，会根据该字符串是否已存在于字符串常量池里来决定是否创建新的String对象。</strong></p>
<p>当我们使用类似<code>String s = &quot;a&quot;</code>这样的代码创建字符串常量的时候，JVM会先检查“a”这个字符串是否在常量池中：</p>
<ul>
<li><p><strong>如果存在，就直接将此String对象地址赋给引用s（引用s是个成员变量，它在虚拟机栈中）</strong>；</p>
</li>
<li><p><strong>如果不存在，就会先在堆中创建一个String对象，然后将对象移入字符串常量池，最后将地址赋给s</strong>。</p>
</li>
</ul>
<h3 id="2-使用new关键字创建"><a href="#2-使用new关键字创建" class="headerlink" title="2.使用new关键字创建"></a>2.使用new关键字创建</h3><p><img src="http://img.xiajibagao.top/new%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%9B%E5%BB%BAString.png" alt="new关键字创建String"></p>
<p><strong>当使用String关键字创建String对象的时候，无论字符串常量池中是否有同值对象，都会创建一个新实例。</strong></p>
<p>看看new调用的的构造函数的注释：</p>
<blockquote>
<p>初始化新创建的字符串对象，使其表示与参数相同的字符序列；换句话说，<strong>新创建的字符串是参数字符串的副本</strong>。除非需要original的显式副本，否则没有必要使用此构造函数，因为字符串是不可变的。</p>
</blockquote>
<p>当我们使用new关键字创建String对象时，和字面值形式创建一样，JVM会检查字符串常量池是否存在同值对象：</p>
<ul>
<li><strong>如果存在，则就在堆中创建一个对象，然后返回该堆中对象的地址</strong>；</li>
<li><strong>否则就先在字符串常量池中创建一个String对象，然后再在堆中创建一个一模一样的对象，然后返回堆中对象的地址</strong>。</li>
</ul>
<p>也就是说，使用字面值创建后产生的对象只会有一个，但是用new创建对象后产生的对象可能会有两个（只有堆中一个，或者堆中一个和常量池中一个）。</p>
<p>我们举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;aabb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aabb&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aa&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s4); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，四个String对象是都是相互独立的。</p>
<p>实际上，执行完以后对象在内存中的情况是这样的：</p>
<p><img src="http://img.xiajibagao.top/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%E5%A0%86%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84String%E5%AF%B9%E8%B1%A1.png" alt="代码执行后堆和常量池中的String对象"></p>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h3><ul>
<li>使用new或者字面值形式创建String时都会根据常量池是否存在同值对象而决定是否在常量池中创建对象</li>
<li>使用字面值创建的String，引用直接指向常量池中的对象</li>
<li>使用new创建的String，还会在堆中常量池外再创建一个对象，引用指向常量池外的对象</li>
</ul>
<h2 id="四、String的拼接"><a href="#四、String的拼接" class="headerlink" title="四、String的拼接"></a>四、String的拼接</h2><p>我们知道，String经常会用拼接操作，而这依赖于StringBuilder类。实际上，<strong>字符串类不止有String，还有StringBuilder和StringBuffer</strong>。</p>
<p>简单的来说，StringBuilder和StringBuffer与String的主要区别在于后两者是<strong>可变的字符序列</strong>，每次改变都是针对对象本身，而不是像String那样直接创建新的对象，然后再改变引用。</p>
<h3 id="1-StringBuilder"><a href="#1-StringBuilder" class="headerlink" title="1.StringBuilder"></a>1.StringBuilder</h3><p>我们先看看它的注释是怎么介绍的：</p>
<blockquote>
<p><strong>可变的字符序列</strong>。</p>
<p><strong>此类提供与StringBuffer兼容的API，但不保证同步</strong>。</p>
<p>此类设计为在单线程正在使用StringBuilder的地方来代替StringBuffer。在可能的情况下，建议优先使用此类而不是StringBuffer，因为在大多数实现中它会更快。 </p>
<p>StringBuilder上的主要操作是<code>append()</code>和<code>insert()</code>方法，它们会被重载以接受任何类型的数据。每个有效地将给定的基准转换为字符串，然后将该字符串的字符追加或插入到字符串生成器中。 a<strong>ppend方法始终将这些字符添加到生成器的末尾。 insert方法在指定点添加字符</strong>。</p>
<p>例如:</p>
<p>如果z指向当前内容为“ start”的字符串生成器对象，则方法调用z.append（“ le”）会使字符串生成器包含“ startle”，而z.insert（4，“ le”）将更改字符串生成器以包含“ starlet”。</p>
<p>通常，如果sb引用StringBuilder的实例，则sb.append（x）与sb.insert（sb.length（），x）具有相同的效果。每个字符串生成器都有能力。只要字符串构建器中包含的字符序列的长度不超过容量，就不必分配新的内部缓冲区。如果内部缓冲区溢出，则会自动变大。</p>
<p> StringBuilder实例不能安全地用于多个线程。如果需要这样的同步，则建议使用StringBuffer。除非另有说明，否则将null参数传递给此类中的构造函数或方法将导致引发NullPointerException。</p>
</blockquote>
<p>我们知道这个类的主要作用在于能够动态的扩展（<code>append()</code>）和改变字符串对象（<code>insert()</code>）的值。</p>
<p>我们对比一下String和StringBuilder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，两者的区别在于String实现了Comparable接口而StringBulier继承了抽象类AbstractStringBuilder。后者的扩展性就来自于AbstractStringBuilder。</p>
<p>AbstractStringBuilder中和String一样采用一个<strong>char数组</strong>来保存字符串值，但是这个char数组是未经final修饰，是可变的。</p>
<p>char数组有一个初始大小，跟集合容器类似，当append的字符串长度超过当前char数组容量时，则对char数组进行动态扩展，即重新申请一段更大的内存空间，然后将当前char数组拷贝到新的位置；反之就会适当缩容。</p>
<p>一般是新数组长度默认为：<code>(旧数组长度+新增字符长度) * 2 + 2</code>。(不太准确，想要了解更多的同学可以参考AbstractStringBuilder类源码中的<code>newCapacity()</code>方法)</p>
<h3 id="2-加号拼接与append方法拼接"><a href="#2-加号拼接与append方法拼接" class="headerlink" title="2.加号拼接与append方法拼接"></a>2.加号拼接与append方法拼接</h3><p>我们平时一般都直接对String使用加号拼接，实际上这仍然还是依赖于StringBuilder的<code>append()</code>方法。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这写法实际上编译以后会变成类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s = (<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(s))).append(<span class="string">&quot;a&quot;</span>).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看见<strong>每一次循环都会生成一个新的StringBuilder对象，这样无疑是很低效的</strong>，也是为什么网上很多文章会说循环中拼接字符串不要使用String而是StringBuilder的原因。因为如果我们自己写就可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显比编译器转换后的写法要高效。</p>
<p>理解了加号拼接的原理，我们也就知道了为什么字符串对象使用加号凭借&#x3D;&#x3D;返回的是false：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span> + s3;</span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s5); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>分析一下上面的过程，<strong>无论 <code>s1 + s2</code>还是 <code>&quot;ab&quot; + s3</code>实际上都调用了StringBuilder在字符串常量池外创建了一个新的对象</strong>，所以&#x3D;&#x3D;判断返回了false。</p>
<p>值得一提的是，如果我们遇到了“常量+字面值”的组合，是可以看成单纯的字面值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span> + s3;</span><br><span class="line">System.out.println(s1 == s5); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>总结一下就是：</p>
<ul>
<li><strong>对于“常量+字面值”的组合，可以等价于纯字面值创建对象</strong></li>
<li><strong>对于包含字符串对象引用的写法，由于会调用StringBuilder类的toString方法生成新对象，所以等价于new的方式创建对象</strong></li>
</ul>
<h3 id="3-StringBuffer"><a href="#3-StringBuffer" class="headerlink" title="3.StringBuffer"></a>3.StringBuffer</h3><p>同样看看它的javaDoc，与StringBuilder基本相同的内容我们跳过：</p>
<blockquote>
<p><strong>线程安全的可变字符序列</strong>。StringBuffer类似于字符串，但是可以修改。</p>
<p>对于**。字符串缓冲区可安全用于多个线程。这些方法在必要时进行同步，以使任何特定实例上的所有操作都表现为好像以某种串行顺序发生，该顺序与所涉及的每个单独线程进行的方法调用的顺序一致。 </p>
<p>… …</p>
<p>请注意，虽然StringBuffer被设计为可以安全地从多个线程中并发使用，但是如果将构造函数或append或insert操作传递给在线程之间共享的源序列，则调用代码必须确保该操作具有一致且不变的视图操作期间源序列的长度。这可以通过调用方在操作调用期间保持锁定，使用不可变的源序列或不跨线程共享源序列来满足。</p>
<p>… …</p>
<p><strong>从JDK 5版本开始，该类已经添加了一个等效类StringBuilder，该类旨在供单线程使用。</strong>通常应优先使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步，因此它比所有此类都优先使用。</p>
</blockquote>
<p>可以知道，StringBuilder是与JDK5之后添加的StringBuffer是“等效类”，两个类功能基本一致，唯一的区别在于<strong>StringBuffer是线程安全的</strong>。</p>
<p>我们查看源码，可以看到<strong>StringBuffer实现线程安全的方式是为成员方法添加<code>synchronized</code>关键字进行修饰</strong>，比如<code>append()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，StringBuffer几乎所有的方法都加了<code>synchronized</code>。这也就不难理解为什么一般情况下StringBuffer效率不如StringBuilder了，因为StringBuffer的所有方法都加了锁。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/10/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" rel="prev" title="JVM初探（二）：垃圾回收机制">
                  <i class="fa fa-angle-left"></i> JVM初探（二）：垃圾回收机制
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/11/jvm/JVM%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="next" title="JVM初探（三）：类加载机制">
                  JVM初探（三）：类加载机制 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Createsequence</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">261k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:47</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
